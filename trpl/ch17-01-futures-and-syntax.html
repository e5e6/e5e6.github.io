<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures and the Async Syntax Future 与异步语法 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="futures-and-the-async-syntax-future-与异步语法"><a class="header" href="#futures-and-the-async-syntax-future-与异步语法">Futures and the Async Syntax Future 与异步语法</a></h2>
<p>The key elements of asynchronous programming in Rust are <em>futures</em> and Rust’s
<code>async</code> and <code>await</code> keywords.</p>
<p>Rust 异步编程的核心要素是 <strong>Future</strong> 及 <code>async</code>/<code>await</code> 关键字。</p>
<p>A <em>future</em> is a value that may not be ready now but will become ready at some
point in the future. (This same concept shows up in many languages, sometimes
under other names such as <em>task</em> or <em>promise</em>.) Rust provides a <code>Future</code> trait
as a building block so that different async operations can be implemented with
different data structures but with a common interface. In Rust, futures are
types that implement the <code>Future</code> trait. Each future holds its own information
about the progress that has been made and what “ready” means.</p>
<p><strong>Future</strong> 是可能尚未就绪但将在未来某时刻就绪的值（其他语言中可能称为<strong>任务</strong>或<strong>承诺</strong>）。<span class="highlight">[note]Rust 提供 <code>Future</code> trait 作为基础构建块</span>，使不同异步操作可通过不同数据结构实现统一接口。在 Rust 中，Future 是实现 <code>Future</code> trait 的类型。<span class="highlight">[note]每个 Future 持有自身进展信息及“就绪“的含义</span>。</p>
<p>You can apply the <code>async</code> keyword to blocks and functions to specify that they
can be interrupted and resumed. Within an async block or async function, you can
use the <code>await</code> keyword to <em>await a future</em> (that is, wait for it to become
ready). Any point where you await a future within an async block or function is
a potential spot for that async block or function to pause and resume. The
process of checking with a future to see if its value is available yet is called
<em>polling</em>.</p>
<p><span class="highlight">[note]<code>async</code> 关键字可应用于代码块和函数，表示它们可被中断和恢复。在异步块或函数内，可用 <code>await</code> 关键字<strong>等待 Future</strong>（即等待其就绪）。异步块/函数内任何等待 Future 的点都是潜在的暂停/恢复点。检查 Future 值是否就绪的过程称为<strong>轮询</strong>。</span></p>
<p>Some other languages, such as C# and JavaScript, also use <code>async</code> and <code>await</code>
keywords for async programming. If you’re familiar with those languages, you may
notice some significant differences in how Rust does things, including how it
handles the syntax. That’s for good reason, as we’ll see!</p>
<p>C# 和 JavaScript 等语言也用 <code>async</code>/<code>await</code> 处理异步编程。若熟悉这些语言，可能会注意到 Rust 的显著差异（包括语法处理方式）。这是有意为之，我们稍后会看到！</p>
<p>When writing async Rust, we use the <code>async</code> and <code>await</code> keywords most of the
time. Rust compiles them into equivalent code using the <code>Future</code> trait, much as
it compiles <code>for</code> loops into equivalent code using the <code>Iterator</code> trait. Because
Rust provides the <code>Future</code> trait, though, you can also implement it for your own
data types when you need to. Many of the functions we’ll see throughout this
chapter return types with their own implementations of <code>Future</code>. We’ll return to
the definition of the trait at the end of the chapter and dig into more of how
it works, but this is enough detail to keep us moving forward.</p>
<p>编写异步 Rust 时，我们主要<span class="highlight">[note]使用 <code>async</code>/<code>await</code>。Rust 将其编译为基于 <code>Future</code> trait 的等效代码</span>，类似将 <code>for</code> 循环编译为基于 <code>Iterator</code> trait 的代码。由于 Rust 提供了 <code>Future</code> trait，你也可在需要时为自定义类型实现它。本章多数函数返回实现 <code>Future</code> 的自定义类型。我们将在章末回顾该 trait 定义并深入其工作原理，目前这些细节已足够推进。</p>
<p>This may all feel a bit abstract, so let’s write our first async program: a
little web scraper. We’ll pass in two URLs from the command line, fetch both of
them concurrently, and return the result of whichever one finishes first. This
example will have a fair bit of new syntax, but don’t worry—we’ll explain
everything you need to know as we go.</p>
<p>这些概念可能较抽象，因此我们编写第一个异步程序：简易网页抓取工具。通过命令行传入两个 URL，并发获取两者，并返回先完成的结果。此例会有新语法，但请放心——我们将逐步解释。</p>
<h2 id="our-first-async-program-首个异步程序"><a class="header" href="#our-first-async-program-首个异步程序">Our First Async Program 首个异步程序</a></h2>
<p>To keep the focus of this chapter on learning async rather than juggling parts
of the ecosystem, we’ve created the <code>trpl</code> crate (<code>trpl</code> is short for “The Rust
Programming Language”). It re-exports all the types, traits, and functions
you’ll need, primarily from the <code>futures</code> and
<code>tokio</code> crates. The <code>futures</code> crate is an official home
for Rust experimentation for async code, and it’s actually where the <code>Future</code>
trait was originally designed. Tokio is the most widely used async runtime in
Rust today, especially for web applications. There are other great runtimes out
there, and they may be more suitable for your purposes. We use the <code>tokio</code> crate
under the hood for <code>trpl</code> because it’s well tested and widely used.</p>
<p>为聚焦异步学习而非生态库细节，我们创建了 <code>trpl</code> crate（“The Rust Programming Language“缩写）。它重新导出了所需类型、trait 和函数（主要来自 <code>futures</code> 和 <code>tokio</code> crate）。<span class="highlight">[note]<code>futures</code> crate 是 Rust 异步代码的官方实验基地</span>，<code>Future</code> trait 最初在此设计。Tokio 是当前 Rust 最广泛使用的异步运行时（尤其适用于 Web 应用）。还有其他优秀运行时可能更适合你的需求。我们底层使用 <code>tokio</code> 是因为它经过充分测试且应用广泛。</p>
<p>In some cases, <code>trpl</code> also renames or wraps the original APIs to keep you
focused on the details relevant to this chapter. If you want to understand what
the crate does, we encourage you to check out its source
code. You’ll be able to see what crate each
re-export comes from, and we’ve left extensive comments explaining what the
crate does.</p>
<p>有时 <code>trpl</code> 会重命名或包装原始 API 以聚焦本章相关细节。若想了解该 crate 的功能，建议查看其<a href="https://github.com/rust-lang/book/tree/main/packages/trpl">源代码</a>。你可查看每个重导出项的来源，且我们留有详细注释说明功能。</p>
<p>Create a new binary project named <code>hello-async</code> and add the <code>trpl</code> crate as a
dependency:</p>
<p>创建名为 <code>hello-async</code> 的二进制项目并添加 <code>trpl</code> 依赖：</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Now we can use the various pieces provided by <code>trpl</code> to write our first async
program. We’ll build a little command line tool that fetches two web pages,
pulls the <code>&lt;title&gt;</code> element from each, and prints out the title of whichever
page finishes that whole process first.</p>
<p>现在可用 <code>trpl</code> 提供的组件编写首个异步程序。我们将构建命令行工具：获取两个网页，提取各自的 <code>&lt;title&gt;</code> 元素，并打印先完成整个过程的页面标题。</p>
<h3 id="defining-the-page_title-function-定义-page_title-函数"><a class="header" href="#defining-the-page_title-function-定义-page_title-函数">Defining the page_title Function 定义 page_title 函数</a></h3>
<p>Let’s start by writing a function that takes one page URL as a parameter, makes
a request to it, and returns the text of the title element (see Listing 17-1).</p>
<p>首先编写函数：接收页面 URL 参数，发起请求，返回标题元素文本（见示例17-1）。</p>
<figure class="listing" id="listing-17-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre></pre>
<figcaption><a href="#listing-17-1">Listing 17-1</a>: Defining an async function to get the title element from an HTML page 定义异步函数从HTML页面获取标题元素</figcaption>
</figure>
<p>First, we define a function named <code>page_title</code> and mark it with the <code>async</code>
keyword. Then we use the <code>trpl::get</code> function to fetch whatever URL is passed in
and add the <code>await</code> keyword to await the response. To get the text of the
response, we call its <code>text</code> method, and once again await it with the <code>await</code>
keyword. Both of these steps are asynchronous. For the <code>get</code> function, we have
to wait for the server to send back the first part of its response, which will
include HTTP headers, cookies, and so on, and can be delivered separately from
the response body. Especially if the body is very large, it can take some time
for it all to arrive. Because we have to wait for the <em>entirety</em> of the response
to arrive, the <code>text</code> method is also async.</p>
<p>首先用 <code>async</code> 关键字定义 <code>page_title</code> 函数。然后用 <code>trpl::get</code> 获取传入的 URL，并用 <code>await</code> 等待响应。为获取响应文本，调用其 <code>text</code> 方法并再次用 <code>await</code> 等待。这两步都是异步的：<code>get</code> 需等待服务器返回响应第一部分（含 HTTP 头、Cookie 等），可能与响应体分开发送；若响应体很大，完全到达可能耗时。因需等待<strong>整个</strong>响应到达，<code>text</code> 方法也是异步的。</p>
<p>We have to explicitly await both of these futures, because futures in Rust are
<em>lazy</em>: they don’t do anything until you ask them to with the <code>await</code> keyword.
(In fact, Rust will show a compiler warning if you don’t use a future.) This
might remind you of Chapter 13’s discussion of iterators in the section
Processing a Series of Items With Iterators.
Iterators do nothing unless you call their <code>next</code> method—whether directly or by
using <code>for</code> loops or methods such as <code>map</code> that use <code>next</code> under the hood.
Likewise, futures do nothing unless you explicitly ask them to. This laziness
allows Rust to avoid running async code until it’s actually needed.</p>
<p>必须显式等待这两个 Future，因为 Rust 的 Future 是<strong>惰性</strong>的：<span class="highlight">[note]除非用 <code>await</code> 显式请求，否则不执行任何操作</span>（实际上，未使用的 Future 会触发编译器警告）。这类似于第13章迭代器的处理方式：除非调用 <code>next</code> 方法（直接或通过 <code>for</code> 循环/<code>map</code> 等方法），否则迭代器不工作。同理，Future 除非显式请求否则不执行。这种惰性让 Rust 避免在真正需要前运行异步代码。</p>
<section class="note" aria-role="note">
<p>Note: This is different from the behavior we saw in the previous chapter when
using <code>thread::spawn</code> in Creating a New Thread with
spawn, where the closure we passed to another
thread started running immediately. It’s also different from how many other
languages approach async. But it’s important for Rust to be able to provide
its performance guarantees, just as it is with iterators.</p>
<p>注意：这与第16章使用 <code>thread::spawn</code> 的行为不同（线程闭包立即运行），也不同于许多其他语言的异步处理方式。但对 Rust 提供性能保证至关重要（与迭代器类似）。</p>
</section>
<p>Once we have <code>response_text</code>, we can parse it into an instance of the <code>Html</code>
type using <code>Html::parse</code>. Instead of a raw string, we now have a data type we
can use to work with the HTML as a richer data structure. In particular, we can
use the <code>select_first</code> method to find the first instance of a given CSS
selector. By passing the string <code>"title"</code>, we’ll get the first <code>&lt;title&gt;</code> element
in the document, if there is one. Because there may not be any matching element,
<code>select_first</code> returns an <code>Option&lt;ElementRef&gt;</code>. Finally, we use the
<code>Option::map</code> method, which lets us work with the item in the <code>Option</code> if it’s
present, and do nothing if it isn’t. (We could also use a <code>match</code> expression
here, but <code>map</code> is more idiomatic.) In the body of the function we supply to
<code>map</code>, we call <code>inner_html</code> on the <code>title</code> to get its content, which is
a <code>String</code>. When all is said and done, we have an <code>Option&lt;String&gt;</code>.</p>
<p>获得 <code>response_text</code> 后，用 <code>Html::parse</code> 解析为 <code>Html</code> 类型实例。现在有了可操作 HTML 的丰富数据结构。特别是可用 <code>select_first</code> 方法查找给定 CSS 选择器的首个实例。传入字符串 <code>"title"</code> 将获取文档中首个 <code>&lt;title&gt;</code> 元素（若存在）。因可能无匹配元素，<code>select_first</code> 返回 <code>Option&lt;ElementRef&gt;</code>。最后用 <code>Option::map</code> 处理 <code>Option</code> 中的元素（若存在），否则无操作（此处也可用 <code>match</code>，但 <code>map</code> 更符合习惯）。在传给 <code>map</code> 的函数中，对 <code>title</code> 调用 <code>inner_html</code> 获取其内容（即 <code>String</code>）。最终得到 <code>Option&lt;String&gt;</code>。</p>
<p>Notice that Rust’s <code>await</code> keyword goes <em>after</em> the expression you’re awaiting,
not before it. That is, it’s a <em>postfix</em> keyword. This may differ from what
you’re used to if you’ve used <code>async</code> in other languages, but in Rust it makes
chains of methods much nicer to work with. As a result, we can change the body
of <code>page_title</code> to chain the <code>trpl::get</code> and <code>text</code> function calls together
with <code>await</code> between them, as shown in Listing 17-2.</p>
<p>注意 Rust 的 <code>await</code> 关键字位于表达式<strong>之后</strong>而非之前，是<strong>后缀</strong>关键字。若熟悉其他语言的异步，这可能有别，但在 Rust 中它使方法链更清晰。因此可将 <code>page_title</code> 函数体改为链式调用 <code>trpl::get</code> 和 <code>text</code> 方法，中间用 <code>await</code> 连接（见示例17-2）。</p>
<figure class="listing" id="listing-17-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-2">Listing 17-2</a>: Chaining with the <code>await</code> keyword 使用 <code>await</code> 关键字进行链式调用</figcaption>
</figure>
<p>With that, we have successfully written our first async function! Before we add
some code in <code>main</code> to call it, let’s talk a little more about what we’ve
written and what it means.</p>
<p>至此我们成功编写了第一个异步函数！在 <code>main</code> 中添加调用代码前，再讨论已写内容及其含义。</p>
<p>When Rust sees a block marked with the <code>async</code> keyword, it compiles it into a
unique, anonymous data type that implements the <code>Future</code> trait. When Rust sees a
function marked with <code>async</code>, it compiles it into a non-async function whose
body is an async block. An async function’s return type is the type of the
anonymous data type the compiler creates for that async block.</p>
<p><span class="highlight">[note]Rust 遇到 <code>async</code> 标记的代码块时，会将其编译为实现 <code>Future</code> trait 的唯一匿名数据类型。遇到 <code>async</code> 标记的函数时，会将其编译为返回异步块的非异步函数。异步函数的返回类型是编译器为该异步块创建的匿名数据类型。</span></p>
<p>Thus, writing <code>async fn</code> is equivalent to writing a function that returns a
<em>future</em> of the return type. To the compiler, a function definition such as the
<code>async fn page_title</code> in Listing 17-1 is equivalent to a non-async function
defined like this:</p>
<p>因此，编写 <code>async fn</code> 等效于返回该返回类型的 <strong>Future</strong> 的函数。对编译器而言，示例17-1中的 <code>async fn page_title</code> 定义等效于如下非异步函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let’s walk through each part of the transformed version:</p>
<p>逐步解析转换版本：</p>
<ul>
<li>It uses the <code>impl Trait</code> syntax we discussed back in Chapter 10 in the
“Traits as Parameters” section.</li>
<li>使用第10章“将 trait 作为参数“所述的 <code>impl Trait</code> 语法</li>
<li>The returned trait is a <code>Future</code> with an associated type of <code>Output</code>. Notice
that the <code>Output</code> type is <code>Option&lt;String&gt;</code>, which is the same as the original
return type from the <code>async fn</code> version of <code>page_title</code>.</li>
<li>返回的 trait 是 <code>Future</code>，关联类型为 <code>Output</code>（注意 <code>Output</code> 类型是 <code>Option&lt;String&gt;</code>，与原 <code>async fn</code> 版本的返回类型相同）</li>
<li>All of the code called in the body of the original function is wrapped in an
<code>async move</code> block. Remember that blocks are expressions. This whole block is
the expression returned from the function.</li>
<li>原函数体内所有代码被包装在 <code>async move</code> 块中（块是表达式，整个块是函数的返回表达式）</li>
<li>This async block produces a value with the type <code>Option&lt;String&gt;</code>, as just
described. That value matches the <code>Output</code> type in the return type. This
is just like other blocks you have seen.</li>
<li>该异步块生成 <code>Option&lt;String&gt;</code> 类型的值，匹配返回类型中的 <code>Output</code></li>
<li>The new function body is an <code>async move</code> block because of how it uses the
<code>url</code> parameter. (We’ll talk much more about <code>async</code> versus <code>async move</code> later
in the chapter.)</li>
<li>新函数体是 <code>async move</code> 块，因其使用了 <code>url</code> 参数（本章稍后将详述 <code>async</code> 与 <code>async move</code>）</li>
</ul>
<p>Now we can call <code>page_title</code> in <code>main</code>.</p>
<p>现在可在 <code>main</code> 中调用 <code>page_title</code>。</p>
<h2 id="determining-a-single-pages-title-获取单个页面标题"><a class="header" href="#determining-a-single-pages-title-获取单个页面标题">Determining a Single Page’s Title 获取单个页面标题</a></h2>
<p>To start, we’ll just get the title for a single page. In Listing 17-3, we follow
the same pattern we used in Chapter 12 to get command line arguments in the
Accepting Command Line Arguments section. Then we
pass the first URL <code>page_title</code> and await the result. Because the value
produced by the future is an <code>Option&lt;String&gt;</code>, we use a <code>match</code> expression to
print different messages to account for whether the page had a <code>&lt;title&gt;</code>.</p>
<p>首先仅获取单个页面标题。示例17-3沿用第12章获取命令行参数的模式，将第一个 URL 传给 <code>page_title</code> 并等待结果。因 Future 产生 <code>Option&lt;String&gt;</code>，用 <code>match</code> 表达式根据页面是否有 <code>&lt;title&gt;</code> 打印不同信息。</p>
<figure class="listing" id="listing-17-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-3">Listing 17-3</a>: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument 从 <code>main</code> 调用 <code>page_title</code> 函数（用户提供参数）</figcaption>
</figure>
<p>Unfortunately, this code doesn’t compile. The only place we can use the <code>await</code>
keyword is in async functions or blocks, and Rust won’t let us mark the
special <code>main</code> function as <code>async</code>.</p>
<p>但此代码无法编译：<code>await</code> 关键字只能在异步函数或块中使用，而 Rust 不允许将特殊的 <code>main</code> 函数标记为 <code>async</code>。</p>
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>The reason <code>main</code> can’t be marked <code>async</code> is that async code needs a <em>runtime</em>:
a Rust crate that manages the details of executing asynchronous code. A
program’s <code>main</code> function can <em>initialize</em> a runtime, but it’s not a runtime
<em>itself</em>. (We’ll see more about why this is the case in a bit.) Every Rust
program that executes async code has at least one place where it sets up a
runtime and executes the futures.</p>
<p><code>main</code> 不能标记 <code>async</code> 的原因是异步代码需要<strong>运行时</strong>（管理异步代码执行细节的 Rust crate）。程序的 <code>main</code> 函数可<strong>初始化</strong>运行时，但其本身不是运行时（稍后详述原因）。每个执行异步代码的 Rust 程序至少有一个设置运行时并执行 Future 的位置。</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead,
there are many different async runtimes available, each of which makes different
tradeoffs suitable to the use case it targets. For example, a high-throughput
web server with many CPU cores and a large amount of RAM has very different
needs than a microcontroller with a single core, a small amount of RAM, and no
heap allocation ability. The crates that provide those runtimes also often
supply async versions of common functionality such as file or network I/O.</p>
<p>多数支持异步的语言捆绑运行时，但 Rust 没有。相反，有许多异步运行时可用，各自针对目标用例做出不同权衡。例如，具有多 CPU 核心和大内存的高吞吐量 Web 服务器，与单核、小内存且无堆分配能力的微控制器需求迥异。<span class="highlight">[note]提供这些运行时的 crate 通常也包含常见功能（如文件/网络 I/O）的异步版本。</span></p>
<p>Here, and throughout the rest of this chapter, we’ll use the <code>run</code> function from
the <code>trpl</code> crate, which takes a future as an argument and runs it to completion.
Behind the scenes, calling <code>run</code> sets up a runtime that’s used to run the future
passed in. Once the future completes, <code>run</code> returns whatever value the future
produced.</p>
<p>本章将使用 <code>trpl</code> crate 的 <code>run</code> 函数：接收 Future 参数并运行至完成。调用 <code>run</code> 会设置运行时以运行传入的 Future。Future 完成后，<code>run</code> 返回其产生的值。</p>
<p>We could pass the future returned by <code>page_title</code> directly to <code>run</code>, and once it
completed, we could match on the resulting <code>Option&lt;String&gt;</code>, as
we tried to do in Listing 17-3. However, for most of the examples in the chapter
(and most async code in the real world), we’ll be doing more than just one
async function call, so instead we’ll pass an <code>async</code> block and explicitly
await the result of the <code>page_title</code> call, as in Listing 17-4.</p>
<p>可将 <code>page_title</code> 返回的 Future 直接传给 <code>run</code>，完成后对结果 <code>Option&lt;String&gt;</code> 进行匹配（如示例17-3尝试）。但本章多数示例（及现实中的异步代码）不只有单个异步调用，因此我们将传递 <code>async</code> 块并显式等待 <code>page_title</code> 调用的结果（见示例17-4）。</p>
<figure class="listing" id="listing-17-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-4">Listing 17-4</a>: Awaiting an async block with <code>trpl::run</code> 用 <code>trpl::run</code> 等待异步块</figcaption>
</figure>
<p>When we run this code, we get the behavior we expected initially:</p>
<p>运行此代码将获得预期行为：</p>
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Phew—we finally have some working async code! But before we add the code to race
the two sites against each other, let’s briefly turn our attention back to how
futures work.</p>
<p>终于有了可工作的异步代码！但在添加竞速两个站点的代码前，先简要回顾 Future 的工作原理。</p>
<p>Each <em>await point</em>—that is, every place where the code uses the <code>await</code>
keyword—represents a place where control is handed back to the runtime. To
make that work, Rust needs to keep track of the state involved in the async
block so that the runtime can kick off some other work and then come back when
it’s ready to try advancing the first one again. This is an invisible state machine,
as if you’d written an enum like this to save the current state at each await
point:</p>
<p><span class="highlight">[note]每个<strong>等待点</strong>（即使用 <code>await</code> 关键字的位置）代表将控制权交回运行时的位置。</span>为此，Rust 需跟踪异步块涉及的状态，以便运行时暂停某活动并切换到其他活动，最终再切回推进第一个活动。这是<strong>隐形状态机</strong>，如同手动编写枚举保存每个等待点的当前状态：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>Writing the code to transition between each state by hand would be tedious and
error-prone, however, especially when you need to add more functionality and
more states to the code later. Fortunately, the Rust compiler creates and
manages the state machine data structures for async code automatically. The
normal borrowing and ownership rules around data structures all still apply, and
happily, the compiler also handles checking those for us and provides useful
error messages. We’ll work through a few of those later in the chapter.</p>
<p>手动编写状态间转换代码冗长易错（尤其需添加功能和状态时）。幸运的是，Rust 编译器自动为异步代码创建和管理状态机数据结构。围绕数据结构的常规借用和所有权规则仍适用，编译器也处理这些检查并提供有用错误信息（本章稍后将涉及）。</p>
<p>Ultimately, something has to execute this state machine, and that something is a
runtime. (This is why you may come across references to <em>executors</em>
when looking into runtimes: an executor is the part of a runtime responsible for
executing the async code.)</p>
<p>最终需有执行此状态机的实体，即<strong>运行时</strong>（因此研究运行时时可能遇到<strong>执行器</strong>的提法：执行器是运行时中负责执行异步代码的部分）。</p>
<p>Now you can see why the compiler stopped us from making <code>main</code> itself an async
function back in Listing 17-3. If <code>main</code> were an async function, something else
would need to manage the state machine for whatever future <code>main</code> returned, but
<code>main</code> is the starting point for the program! Instead, we called the <code>trpl::run</code>
function in <code>main</code> to set up a runtime and run the future returned by the
<code>async</code> block until it is done.</p>
<p>现在明白为何编译器在示例17-3中阻止我们将 <code>main</code> 设为异步函数：若 <code>main</code> 是异步函数，需有其他实体管理其返回的 Future 状态机，但 <code>main</code> 是程序的起点！我们在 <code>main</code> 中调用 <code>trpl::run</code> 来设置运行时并运行 <code>async</code> 块返回的 Future 直至完成。</p>
<section class="note" aria-role="note">
<p>Note: Some runtimes provide macros so you <em>can</em> write an async <code>main</code>
function. Those macros rewrite <code>async fn main() { ... }</code> to be a normal <code>fn  main</code>, which does the same thing we did by hand in Listing 17-4: call a
function that runs a future to completion the way <code>trpl::run</code> does.</p>
<p>注意：某些运行时提供宏支持编写异步 <code>main</code> 函数。这些宏将 <code>async fn main() { ... }</code> 重写为普通 <code>fn main</code>，其功能与示例17-4手动操作相同：调用运行 Future 至完成的函数（类似 <code>trpl::run</code>）。</p>
</section>
<p>Now let’s put these pieces together and see how we can write concurrent code.</p>
<p>现在整合这些部分，看看如何编写并发代码。</p>
<h3 id="racing-our-two-urls-against-each-other-竞速两个-url"><a class="header" href="#racing-our-two-urls-against-each-other-竞速两个-url">Racing Our Two URLs Against Each Other 竞速两个 URL</a></h3>
<p>In Listing 17-5, we call <code>page_title</code> with two different URLs passed in from the
command line and race them.</p>
<p>示例17-5用命令行传入的两个不同 URL 调用 <code>page_title</code> 并竞速它们。</p>
<figure class="listing" id="listing-17-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title was: '{title}'"),
            None =&gt; println!("It had no title."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption><a href="#listing-17-5">Listing 17-5</a>: </figcaption>
</figure>
<p>We begin by calling <code>page_title</code> for each of the user-supplied URLs. We save the
resulting futures as <code>title_fut_1</code> and <code>title_fut_2</code>. Remember, these don’t do
anything yet, because futures are lazy and we haven’t yet awaited them. Then we
pass the futures to <code>trpl::race</code>, which returns a value to indicate which of the
futures passed to it finishes first.</p>
<p>首先为每个用户提供的 URL 调用 <code>page_title</code>，将结果 Future 保存为 <code>title_fut_1</code> 和 <code>title_fut_2</code>。记住：这些调用尚未执行任何操作（因 Future 是惰性的且尚未等待）。然后将 Future 传给 <code>trpl::race</code>（返回指示哪个 Future 先完成的值）。</p>
<section class="note" aria-role="note">
<p>Note: Under the hood, <code>race</code> is built on a more general function, <code>select</code>,
which you will encounter more often in real-world Rust code. A <code>select</code>
function can do a lot of things that the <code>trpl::race</code> function can’t, but it
also has some additional complexity that we can skip over for now.</p>
<p>注意：底层 <code>race</code> <span class="highlight">[note]基于更通用的 <code>select</code> 函数构建</span>（实际 Rust 代码中更常见）。<code>select</code> 函数能完成 <code>trpl::race</code> 无法实现的许多功能，但也带来额外复杂性（目前可跳过）。</p>
<p><span class="highlight">[note]注：<code>use futures::future::select;</code></span></p>
</section>
<p>Either future can legitimately “win,” so it doesn’t make sense to return a
<code>Result</code>. Instead, <code>race</code> returns a type we haven’t seen before,
<code>trpl::Either</code>. The <code>Either</code> type is somewhat similar to a <code>Result</code> in that it
has two cases. Unlike <code>Result</code>, though, there is no notion of success or
failure baked into <code>Either</code>. Instead, it uses <code>Left</code> and <code>Right</code> to indicate
“one or the other”:</p>
<p>任一 Future 都可能“获胜“，因此返回 <code>Result</code> 不合理。<code>race</code> 返回新类型 <code>trpl::Either</code>。<code>Either</code> 类型类似于 <code>Result</code>（有两种情况），但不内建成功/失败概念，而是用 <code>Left</code> 和 <code>Right</code> 表示“二者之一“：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>race</code> function returns <code>Left</code> with the output from the first future
argument it finishes first, or <code>Right</code> with the output of the second future
argument if that one finishes first. This matches the order the arguments appear
in when calling the function: the first argument is to the left of the second
argument.</p>
<p><code>race</code> 函数返回 <code>Left</code>（含第一个参数的输出，若其先完成）或 <code>Right</code>（含第二个参数的输出，若其先完成）。这匹配参数顺序：第一个参数在左，第二个在右。</p>
<p>We also update <code>page_title</code> to return the same URL passed in. That way, if
the page that returns first does not have a <code>&lt;title&gt;</code> we can resolve, we can
still print a meaningful message. With that information available, we wrap up by
updating our <code>println!</code> output to indicate both which URL finished first and
what, if any, the <code>&lt;title&gt;</code> is for the web page at that URL.</p>
<p>我们还更新 <code>page_title</code> 以返回传入的 URL。这样即使先返回的页面无 <code>&lt;title&gt;</code>，仍能打印有意义的消息。利用这些信息更新 <code>println!</code> 输出，指示哪个 URL 先完成及其网页标题（若有）。</p>
<p>You have built a small working web scraper now! Pick a couple URLs and run the
command line tool. You may discover that some sites are consistently faster than
others, while in other cases the faster site varies from run to run. More
importantly, you’ve learned the basics of working with futures, so now we can
dig deeper into what we can do with async.</p>
<p>现在你已构建了简易网页抓取工具！选择几个 URL 运行命令行工具，可能会发现某些站点始终更快，而其他情况下较快的站点因运行而异。更重要的是，你已掌握使用 Future 的基础知识，现在可深入探索异步的更多功能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
