<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shared-State Concurrency 共享状态并发 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="shared-state-concurrency-共享状态并发"><a class="header" href="#shared-state-concurrency-共享状态并发">Shared-State Concurrency 共享状态并发</a></h2>
<p>Message passing is a fine way to handle concurrency, but it’s not the only way.
Another method would be for multiple threads to access the same shared data.
Consider this part of the slogan from the Go language documentation again: “Do
not communicate by sharing memory.”</p>
<p>消息传递是处理并发的良方，但非唯一方法。另一种方法是多线程访问同一共享数据。再思考 Go 文档的口号：“不要通过共享内存来通信。”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts caution not to use memory sharing?</p>
<p>共享内存通信是何种形式？为何消息传递倡导者警告勿用共享内存？</p>
<p>In a way, channels in any programming language are similar to single ownership
because once you transfer a value down a channel, you should no longer use that
value. Shared-memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.</p>
<p>某种程度上，任何语言的通道都类似单一所有权，因值传输后不应再使用。共享内存并发类似多所有权：多线程可同时访问同一内存位置。如第 15 章所述，智能指针使多所有权成为可能，但管理不同所有者会增加复杂性。Rust 的类型系统和所有权规则极大助力此管理的正确性。以互斥锁为例，这是共享内存的常见并发原语。</p>
<h3 id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time-使用互斥锁确保线程独占访问数据"><a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time-使用互斥锁确保线程独占访问数据">Using Mutexes to Allow Access to Data from One Thread at a Time 使用互斥锁确保线程独占访问数据</a></h3>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s lock. The <em>lock</em> is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p><strong>互斥锁</strong>（Mutex）是“相互排斥”的缩写，因其一次仅允许一个线程访问数据。要访问互斥锁数据，线程需先请求获取锁来发出访问信号。<strong>锁</strong>是互斥锁的数据结构，跟踪当前谁独占访问数据。因此，互斥锁通过锁定系统<strong>守护</strong>其数据。</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<p>互斥锁因难用而闻名，因需记住两条规则：</p>
<ol>
<li>
<p>You must attempt to acquire the lock before using the data.</p>
</li>
<li>
<p>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</p>
</li>
<li>
<p>使用数据前必须尝试获取锁</p>
</li>
<li>
<p>使用完互斥锁守护的数据后必须解锁，以便其他线程获取锁</p>
</li>
</ol>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!</p>
<p>互斥锁的现实隐喻：会议小组讨论仅有一个麦克风。发言前需请求使用麦克风。获得后发言时长不限，结束后传递给下一位请求发言者。若发言后未传递麦克风，其他人将无法发言。共享麦克风管理出错将导致讨论混乱！</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.</p>
<p>互斥锁管理可能极其复杂，因此许多人热衷通道。但得益于 Rust 的类型系统和所有权规则，锁定和解锁不会出错。</p>
<h4 id="the-api-of-mutext-mutext-的-api"><a class="header" href="#the-api-of-mutext-mutext-的-api">The API of <code>Mutex&lt;T&gt;</code> <code>Mutex&lt;T&gt;</code> 的 API</a></h4>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12.</p>
<p>以单线程上下文使用互斥锁为例，如示例 16-12。</p>
<figure class="listing" id="listing-16-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<figcaption><a href="#listing-16-12">Listing 16-12</a>: Exploring the API of <code>Mutex&lt;T&gt;</code> in a single-threaded context for simplicity 在单线程中探索 <code>Mutex&lt;T&gt;</code> API</figcaption>
</figure>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>与许多类型相同，我们用<span class="highlight">[note]关联函数 <code>new</code> 创建 <code>Mutex&lt;T&gt;</code>。要访问互斥锁内部数据，需用 <code>lock</code> 方法获取锁。此调用阻塞当前线程直到轮到我们持有锁。</span></p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p><span class="highlight">[note]若持有锁的线程 panic，<code>lock</code> 调用会失败。</span>此时无人能获取锁，故选择 <code>unwrap</code> 让此线程 panic。</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>. The type of <code>m</code> is
<code>Mutex&lt;i32&gt;</code>, not <code>i32</code>, so we <em>must</em> call <code>lock</code> to be able to use the <code>i32</code>
value. We can’t forget; the type system won’t let us access the inner <code>i32</code>
otherwise.</p>
<p><span class="highlight">[note]获取锁后，可将返回值（此处为 <code>num</code>）视为内部数据的可变引用。</span>类型系统确保使用数据前先获取锁。<code>m</code> 类型为 <code>Mutex&lt;i32&gt;</code> 而非 <code>i32</code>，故<strong>必须</strong>调用 <code>lock</code> 才能使用 <code>i32</code> 值。类型系统防止我们以其他方式访问内部 <code>i32</code>。</p>
<p>The call to <code>lock</code> returns a type called <code>MutexGuard</code>, wrapped in a
<code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> type
implements <code>Deref</code> to point at our inner data; the type also has a <code>Drop</code>
implementation that releases the lock automatically when a <code>MutexGuard</code> goes
out of scope, which happens at the end of the inner scope. As a result, we
don’t risk forgetting to release the lock and blocking the mutex from being
used by other threads because the lock release happens automatically.</p>
<p><span class="highlight">[note]<code>lock</code> 调用返回名为 <code>MutexGuard</code> 的类型，包装在 <code>LockResult</code> 中（通过 <code>unwrap</code> 处理）。<code>MutexGuard</code> 实现 <code>Deref</code> 指向内部数据；其还有 <code>Drop</code> 实现，在 <code>MutexGuard</code> 离开作用域时自动释放锁。</span>因此，我们不会忘记释放锁导致互斥锁被其他线程阻塞。</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to <code>6</code>.</p>
<p>释放锁后，可打印互斥锁值，可见内部 <code>i32</code> 成功改为 <code>6</code>。</p>
<h4 id="sharing-a-mutext-between-multiple-threads-多线程间共享-mutext"><a class="header" href="#sharing-a-mutext-between-multiple-threads-多线程间共享-mutext">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads 多线程间共享 <code>Mutex&lt;T&gt;</code></a></h4>
<p>Now let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>. We’ll
spin up 10 threads and have them each increment a counter value by 1, so the
counter goes from 0 to 10. The example in Listing 16-13 will have a compiler
error, and we’ll use that error to learn more about using <code>Mutex&lt;T&gt;</code> and how
Rust helps us use it correctly.</p>
<p>现尝试用 <code>Mutex&lt;T&gt;</code> 在线程间共享值。启动 10 个线程，每个将计数器值增加 1，使计数器从 0 到 10。示例 16-13 将产生编译错误，我们将借此学习 <code>Mutex&lt;T&gt;</code> 的使用及 Rust 如何助其正确使用。</p>
<figure class="listing" id="listing-16-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="#listing-16-13">Listing 16-13</a>: Ten threads, each incrementing a counter guarded by a <code>Mutex&lt;T&gt;</code> 十个线程，每个递增 <code>Mutex&lt;T&gt;</code> 守护的计数器</figcaption>
</figure>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we did
in Listing 16-12. Next, we create 10 threads by iterating over a range of
numbers. We use <code>thread::spawn</code> and give all the threads the same closure: one
that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by
calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>创建 <code>counter</code> 变量持有 <code>Mutex&lt;T&gt;</code> 内的 <code>i32</code>（同示例 16-12）。接着通过数字范围迭代创建 10 个线程。使用 <code>thread::spawn</code> 并传递相同闭包：移动 <code>counter</code> 到线程，调用 <code>lock</code> 方法获取 <code>Mutex&lt;T&gt;</code> 的锁，然后将互斥锁值加 1。线程运行完闭包后，<code>num</code> 离开作用域并释放锁，其他线程可获取。</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call <code>join</code> on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.</p>
<p>主线程收集所有连接句柄。然后同示例 16-2，在每个句柄调用 <code>join</code> 确保所有线程完成。此时主线程获取锁并打印结果。</p>
<p>We hinted that this example wouldn’t compile. Now let’s find out why!</p>
<p>此例无法编译。现在找出原因！</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>The error message states that the <code>counter</code> value was moved in the previous
iteration of the loop. Rust is telling us that we can’t move the ownership of
lock <code>counter</code> into multiple threads. Let’s fix the compiler error with the
multiple-ownership method we discussed in Chapter 15.</p>
<p>错误信息表明 <code>counter</code> 值在上次循环迭代中被移动。Rust 提示无法将锁 <code>counter</code> 的所有权移入多个线程。用第 15 章的多所有权方法修复此错误。</p>
<h4 id="multiple-ownership-with-multiple-threads-多线程的多所有权"><a class="header" href="#multiple-ownership-with-multiple-threads-多线程的多所有权">Multiple Ownership with Multiple Threads 多线程的多所有权</a></h4>
<p>In Chapter 15, we gave a value to multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread.</p>
<p>第 15 章用智能指针 <code>Rc&lt;T&gt;</code> 创建引用计数值实现多所有权。现尝试相同方法，如示例 16-14 所示。</p>
<figure class="listing" id="listing-16-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="#listing-16-14">Listing 16-14</a>: Attempting to use <code>Rc&lt;T&gt;</code> to allow multiple threads to own the <code>Mutex&lt;T&gt;</code> 尝试用 <code>Rc&lt;T&gt;</code> 允许多线程拥有 <code>Mutex&lt;T&gt;</code></figcaption>
</figure>
<p>Once again, we compile and get… different errors! The compiler is teaching us a
lot.</p>
<p>再次编译后…出现不同错误！编译器教会我们许多。</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:728:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Wow, that error message is very wordy! Here’s the important part to focus on:
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The compiler is
also telling us the reason why: <code>the trait `Send` is not implemented for  `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. We’ll talk about <code>Send</code> in the next section: it’s one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.</p>
<p>重点在于：<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。编译器也给出原因：<code>the trait `Send` is not implemented for  `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>。下节讨论 <code>Send</code>：它是确保类型用于并发场景的特征之一。</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type that is exactly like <code>Rc&lt;T&gt;</code>, but that makes
changes to the reference count in a thread-safe way.</p>
<p>不幸的是，<span class="highlight">[note]<code>Rc&lt;T&gt;</code> 不能安全跨线程共享。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，<code>clone</code> 调用增加计数，<code>drop</code> 调用减少计数。但未使用任何并发原语确保计数更改不被其他线程中断。</span>这可能导致计数错误（进而导致内存泄漏或值提前丢弃）。我们需要类似 <code>Rc&lt;T&gt;</code> 但线程安全更改引用计数的类型。</p>
<h4 id="atomic-reference-counting-with-arct-原子引用计数-arct"><a class="header" href="#atomic-reference-counting-with-arct-原子引用计数-arct">Atomic Reference Counting with <code>Arc&lt;T&gt;</code> 原子引用计数 <code>Arc&lt;T&gt;</code></a></h4>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically
reference-counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <code>std::sync::atomic</code> for more
details. At this point, you just need to know that atomics work like primitive
types but are safe to share across threads.</p>
<p>幸运的是，<span class="highlight">[note]<code>Arc&lt;T&gt;</code> 正是类似 <code>Rc&lt;T&gt;</code> 但线程安全的类型。<strong>a</strong> 代表<strong>原子性</strong>（atomic），即<strong>原子引用计数</strong>类型。</span>原子是另一种并发原语（此处不赘述），详见标准库文档 <a href="https://doc.rust-lang.org/std/sync/atomic/"><code>std::sync::atomic</code></a>。目前只需知原子类型类似原始类型但可安全跨线程共享。</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>你可能好奇为何所有原始类型非原子，以及标准库类型为何不默认用 <code>Arc&lt;T&gt;</code>。原因是<span class="highlight">[note]线程安全需性能代价，仅当真正需要时才应支付</span>。若仅在单线程操作值，不强制原子保证可使代码更快。</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run.</p>
<p>回到示例：<code>Arc&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> API 相同，故修改 <code>use</code> 行、<code>new</code> 和 <code>clone</code> 调用即可。示例 16-15 最终可编译运行。</p>
<figure class="listing" id="listing-16-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<figcaption><a href="#listing-16-15">Listing 16-15</a>: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code> to be able to share ownership across multiple threads 使用 <code>Arc&lt;T&gt;</code> 包装 <code>Mutex&lt;T&gt;</code> 以跨线程共享所有权</figcaption>
</figure>
<p>This code will print the following:</p>
<p>代码将打印：</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<p>成功了！从 0 计数到 10 可能不惊人，但教会我们许多 <code>Mutex&lt;T&gt;</code> 和线程安全知识。你也可用此程序结构执行比递增计数器更复杂的操作。使用此策略，可将计算拆分为独立部分，分配到不同线程，然后用 <code>Mutex&lt;T&gt;</code> 让每个线程更新其部分的最终结果。</p>
<p>Note that if you are doing simple numerical operations, there are types simpler
than <code>Mutex&lt;T&gt;</code> types provided by the <code>std::sync::atomic</code> module of the
standard library. These types provide safe, concurrent,
atomic access to primitive types. We chose to use <code>Mutex&lt;T&gt;</code> with a primitive
type for this example so we could concentrate on how <code>Mutex&lt;T&gt;</code> works.</p>
<p>注意：<span class="highlight">[note]若进行简单数值操作，标准库的 <code>std::sync::atomic</code> 模块提供比 <code>Mutex&lt;T&gt;</code> 更简单的类型。</span>这些类型提供对原始类型的安全并发原子访问。此例选择对原始类型用 <code>Mutex&lt;T&gt;</code> 是为专注于 <code>Mutex&lt;T&gt;</code> 工作原理。</p>
<h3 id="similarities-between-refcelltrct-and-mutextarct-refcelltrct-与-mutextarct-的相似性"><a class="header" href="#similarities-between-refcelltrct-and-mutextarct-refcelltrct-与-mutextarct-的相似性">Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 的相似性</a></h3>
<p>You might have noticed that <code>counter</code> is immutable but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in
Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code>
to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>你可能注意到 <code>counter</code> 不可变但能获取内部值的可变引用；这意味着 <code>Mutex&lt;T&gt;</code> 提供<strong>内部可变性</strong>（同 <code>Cell</code> 系列）。类似第 15 章用 <code>RefCell&lt;T&gt;</code> 在 <code>Rc&lt;T&gt;</code> 内部可变内容，我们用 <code>Mutex&lt;T&gt;</code> 在 <code>Arc&lt;T&gt;</code> 内部可变内容。</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall from Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>另需注意：使用 <code>Mutex&lt;T&gt;</code> 时，Rust 无法防止所有逻辑错误。回顾第 15 章，<span class="highlight">[note]使用 <code>Rc&lt;T&gt;</code> 有创建引用循环的风险（两个 <code>Rc&lt;T&gt;</code> 相互引用导致内存泄漏）。类似地，<code>Mutex&lt;T&gt;</code> 有创建<strong>死锁</strong>的风险。</span>死锁发生在操作需锁两个资源，而两线程各持有一个锁时，导致彼此永久等待。若对死锁感兴趣，可尝试用 Rust 编写死锁程序，研究任意语言的互斥锁死锁缓解策略并在 Rust 中实现。<code>Mutex&lt;T&gt;</code> 和 <code>MutexGuard</code> 的标准库 API 文档提供了有用信息。</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
<p>最后讨论 <code>Send</code> 和 <code>Sync</code> 特征及其在自定义类型中的应用。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
