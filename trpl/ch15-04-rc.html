<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rc&lt;T&gt;, the Reference Counted Smart Pointer Rc&lt;T&gt;，引用计数智能指针 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="rct-the-reference-counted-smart-pointer-rct引用计数智能指针"><a class="header" href="#rct-the-reference-counted-smart-pointer-rct引用计数智能指针"><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer <code>Rc&lt;T&gt;</code>，引用计数智能指针</a></h2>
<p>In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it and so has no owners.</p>
<p>在大多数情况下，所有权是明确的：你确切知道哪个变量拥有给定值。然而，有时单个值可能有多个所有者。例如在图数据结构中，多条边可能指向同一个节点，从概念上讲，该节点由指向它的所有边共同拥有。节点不应被清理，除非没有任何边指向它，即没有所有者。</p>
<p>You have to enable multiple ownership explicitly by using the Rust type
<code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type
keeps track of the number of references to a value to determine whether or not
the value is still in use. If there are zero references to a value, the value
can be cleaned up without any references becoming invalid.</p>
<p>你必须<span class="highlight">[note]使用 Rust 类型 <code>Rc&lt;T&gt;</code> 显式启用多重所有权，它是<strong>引用计数</strong>（reference counting）的缩写。</span><code>Rc&lt;T&gt;</code> 类型跟踪对值的引用数量，以确定该值是否仍在使用中。如果对值的引用为零，则可以在不使任何引用无效的情况下清理该值。</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
an uproar from the remaining TV watchers!</p>
<p>想象 <code>Rc&lt;T&gt;</code> 是家庭房间中的电视。当一个人进来看电视时，他们会打开它。其他人可以进入房间看电视。当最后一个人离开房间时，他们会关闭电视，因为它不再被使用。如果有人在其他人还在看电视时关闭电视，其他观看者会表示不满！</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.</p>
<p>当我们在堆上分配数据供程序的多个部分读取，并且无法在编译时确定哪部分最后使用数据时，我们会使用 <code>Rc&lt;T&gt;</code> 类型。如果知道哪部分最后完成，我们可以直接将该部分作为数据的所有者，并在编译时强制执行常规所有权规则。</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.</p>
<p>注意 <code>Rc&lt;T&gt;</code> 仅适用于单线程场景。在第 16 章讨论并发时，我们将介绍如何在多线程程序中进行引用计数。</p>
<h3 id="using-rct-to-share-data-使用-rct-共享数据"><a class="header" href="#using-rct-to-share-data-使用-rct-共享数据">Using <code>Rc&lt;T&gt;</code> to Share Data 使用 <code>Rc&lt;T&gt;</code> 共享数据</a></h3>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3.</p>
<p>让我们回到代码清单 15-5 中的 cons 列表示例。回想一下，我们使用 <code>Box&lt;T&gt;</code> 定义了它。这次，我们将创建两个列表，它们共同拥有第三个列表的所有权。从概念上讲，这类似于图 15-3。</p>
<img alt="" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code> 两个列表 <code>b</code> 和 <code>c</code> 共享对第三个列表 <code>a</code> 的所有权</span></p>
<p>We’ll create list <code>a</code> that contains <code>5</code> and then <code>10</code>. Then we’ll make two more
lists: <code>b</code> that starts with <code>3</code> and <code>c</code> that starts with <code>4</code>. Both <code>b</code> and <code>c</code>
lists will then continue on to the first <code>a</code> list containing <code>5</code> and <code>10</code>. In
other words, both lists will share the first list containing <code>5</code> and <code>10</code>.</p>
<p>我们将创建一个包含 <code>5</code> 和 <code>10</code> 的列表 <code>a</code>。然后创建另外两个列表：以 <code>3</code> 开头的 <code>b</code> 和以 <code>4</code> 开头的 <code>c</code>。然后 <code>b</code> 和 <code>c</code> 列表都将延续到包含 <code>5</code> 和 <code>10</code> 的第一个 <code>a</code> 列表。换句话说，两个列表将共享包含 <code>5</code> 和 <code>10</code> 的第一个列表。</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17.</p>
<p>尝试使用带 <code>Box&lt;T&gt;</code> 的 <code>List</code> 定义实现此场景是行不通的，如代码清单 15-17 所示。</p>
<figure class="listing" id="listing-15-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<figcaption><a href="#listing-15-17">Listing 15-17</a>: Demonstrating that we’re not allowed to have two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list 演示不允许两个使用 <code>Box&lt;T&gt;</code> 的列表尝试共享对第三个列表的所有权</figcaption>
</figure>
<p>When we compile this code, we get this error:</p>
<p>编译此代码时，我们得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p><code>Cons</code> 变体拥有它们持有的数据，因此当我们创建 <code>b</code> 列表时，<code>a</code> 被移动到 <code>b</code> 中，<code>b</code> 拥有 <code>a</code>。然后，当我们在创建 <code>c</code> 时尝试再次使用 <code>a</code>，这是不允许的，因为 <code>a</code> 已被移动。</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. This is the case for the elements and lists
in Listing 15-17, but not in every scenario.</p>
<p>我们可以将 <code>Cons</code> 的定义更改为持有引用，但这样就必须指定生命周期参数。通过指定生命周期参数，我们要求列表中的每个元素至少与整个列表一样长。这在代码清单 15-17 的元素和列表中成立，但并非所有场景都如此。</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby
increasing the number of references from one to two and letting <code>a</code> and <code>b</code>
share ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when
creating <code>c</code>, increasing the number of references from two to three. Every time
we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it.</p>
<p>相反，我们将 <code>List</code> 的定义更改为使用 <code>Rc&lt;T&gt;</code> 替代 <code>Box&lt;T&gt;</code>，如代码清单 15-18 所示。每个 <code>Cons</code> 变体现将持有一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。创建 <code>b</code> 时，我们不取得 <code>a</code> 的所有权，而是克隆 <code>a</code> 持有的 <code>Rc&lt;List&gt;</code>，从而将引用计数从 1 增加到 2，让 <code>a</code> 和 <code>b</code> 共享该 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也克隆 <code>a</code>，将引用计数从 2 增加到 3。<span class="highlight">[note]每次调用 <code>Rc::clone</code> 时，<code>Rc&lt;List&gt;</code> 内部数据的引用计数会增加</span>，除非引用计数为零，否则数据不会被清理。</p>
<figure class="listing" id="listing-15-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<figcaption><a href="#listing-15-18">Listing 15-18</a>: A definition of <code>List</code> that uses <code>Rc&lt;T&gt;</code> 使用 <code>Rc&lt;T&gt;</code> 的 <code>List</code> 定义</figcaption>
</figure>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding <code>5</code> and <code>10</code> and store it
in a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then, when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>我们需要添加 <code>use</code> 语句将 <code>Rc&lt;T&gt;</code> 引入作用域，因为它不在预导入中。在 <code>main</code> 中，我们创建包含 <code>5</code> 和 <code>10</code> 的列表，并将其存储在 <code>a</code> 中的新 <code>Rc&lt;List&gt;</code> 中。然后，创建 <code>b</code> 和 <code>c</code> 时，我们调用 <code>Rc::clone</code> 函数并将 <code>a</code> 中的 <code>Rc&lt;List&gt;</code> 引用作为参数传递。</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<p><span class="highlight">[note]我们本可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，但 Rust 的惯例是在这种情况下使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的实现不像大多数类型的 <code>clone</code> 实现那样深度复制所有数据。</span>调用 <code>Rc::clone</code> 仅增加引用计数，这不需要太多时间。数据的深度复制可能非常耗时。通过使用 <code>Rc::clone</code> 进行引用计数，我们可以直观区分深度复制的克隆和增加引用计数的克隆。在代码中查找性能问题时，我们只需考虑深度复制的克隆，而忽略对 <code>Rc::clone</code> 的调用。</p>
<h3 id="cloning-an-rct-increases-the-reference-count-克隆-rct-会增加引用计数"><a class="header" href="#cloning-an-rct-increases-the-reference-count-克隆-rct-会增加引用计数">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count 克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</a></h3>
<p>Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>让我们修改代码清单 15-18 中的工作示例，以便在创建和丢弃对 <code>a</code> 中 <code>Rc&lt;List&gt;</code> 的引用时观察引用计数的变化。</p>
<p>In Listing 15-19, we’ll change <code>main</code> so it has an inner scope around list <code>c</code>;
then we can see how the reference count changes when <code>c</code> goes out of scope.</p>
<p>在代码清单 15-19 中，我们将修改 <code>main</code>，使其包含围绕列表 <code>c</code> 的内部作用域；这样我们可以看到当 <code>c</code> 离开作用域时引用计数如何变化。</p>
<figure class="listing" id="listing-15-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>// --snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<figcaption><a href="#listing-15-19">Listing 15-19</a>: Printing the reference count 打印引用计数</figcaption>
</figure>
<p>At each point in the program where the reference count changes, we print the
reference count, which we get by calling the <code>Rc::strong_count</code> function. This
function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code> type
also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in “Preventing
Reference Cycles Using <code>Weak&lt;T&gt;</code>”.</p>
<p>在引用计数发生变化的程序每个位置，我们打印<span class="highlight">[note]通过调用 <code>Rc::strong_count</code> 函数获得的引用计数。此函数名为 <code>strong_count</code> 而不是 <code>count</code>，因为 <code>Rc&lt;T&gt;</code> 类型还有一个 <code>weak_count</code></span>；我们将在“使用 <code>Weak&lt;T&gt;</code> 防止引用循环”中看到 <code>weak_count</code> 的用途。</p>
<p>This code prints the following:</p>
<p>此代码打印以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1; then
each time we call <code>clone</code>, the count goes up by 1. When <code>c</code> goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call <code>Rc::clone</code> to increase the reference
count: the implementation of the <code>Drop</code> trait decreases the reference count
automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>我们可以看到 <code>a</code> 中的 <code>Rc&lt;List&gt;</code> 初始引用计数为 1；然后每次调用 <code>clone</code>，计数增加 1。当 <code>c</code> 离开作用域时，计数减少 1。我们无需像调用 <code>Rc::clone</code> 增加引用计数那样调用函数来减少引用计数：<code>Drop</code> trait 的实现会在 <code>Rc&lt;T&gt;</code> 值离开作用域时自动减少引用计数。</p>
<p>What we can’t see in this example is that when <code>b</code> and then <code>a</code> go out of scope
at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up
completely. Using <code>Rc&lt;T&gt;</code> allows a single value to have multiple owners, and
the count ensures that the value remains valid as long as any of the owners
still exist.</p>
<p>在此示例中看不到的是，当 <code>b</code> 和 <code>a</code> 在 <code>main</code> 结束时离开作用域，计数变为 0，<code>Rc&lt;List&gt;</code> 被完全清理。使用 <code>Rc&lt;T&gt;</code> 允许单个值拥有多个所有者，计数确保只要任何所有者仍然存在，该值就保持有效。</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple
parts of your program for reading only. If <code>Rc&lt;T&gt;</code> allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code>
type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this
immutability restriction.</p>
<p>通过不可变引用，<code>Rc&lt;T&gt;</code> 允许你在程序的多个部分之间共享数据仅供读取。如果 <code>Rc&lt;T&gt;</code> 也允许你拥有多个可变引用，你可能会违反第 4 章讨论的借用规则之一：对同一位置的多个可变借用可能导致数据竞争和不一致。但能够改变数据非常有用！在下一节中，我们将讨论内部可变性模式以及可以与 <code>Rc&lt;T&gt;</code> 结合使用的 <code>RefCell&lt;T&gt;</code> 类型来处理这种不可变性限制。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-03-drop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-03-drop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
