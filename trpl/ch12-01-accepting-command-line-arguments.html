<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Accepting Command Line Arguments 接受命令行参数 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="accepting-command-line-arguments-接受命令行参数"><a class="header" href="#accepting-command-line-arguments-接受命令行参数">Accepting Command Line Arguments 接受命令行参数</a></h2>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<p>让我们使用 <code>cargo new</code> 创建一个新项目（一如既往）。我们将项目命名为 <code>minigrep</code>，以便与系统中可能已存在的 <code>grep</code> 工具区分开。</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
file path and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, two hyphens to indicate the following arguments are
for our program rather than for <code>cargo</code>, a string to search for, and a path to
a file to search in, like so:</p>
<p>首要任务是让 <code>minigrep</code> 接受两个命令行参数：文件路径和要搜索的字符串。也就是说，我们希望能够使用 <code>cargo run</code> 运行程序，两个连字符表示后续参数是传递给我们的程序而非 <code>cargo</code> 的，包括要搜索的字符串和要搜索的文件路径，如下所示：</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. Some existing libraries on <a href="https://crates.io/">crates.io</a> can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.</p>
<p>目前，由 <code>cargo new</code> 生成的程序无法处理我们提供的参数。<a href="https://crates.io/">crates.io</a> 上的一些现有库可以帮助编写接受命令行参数的程序，但既然你正在学习这个概念，我们就自己实现这个功能。</p>
<h3 id="reading-the-argument-values-读取参数值"><a class="header" href="#reading-the-argument-values-读取参数值">Reading the Argument Values 读取参数值</a></h3>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to
it, we’ll need the <code>std::env::args</code> function provided in Rust’s standard
library. This function returns an iterator of the command line arguments passed
to <code>minigrep</code>. We’ll cover iterators fully in Chapter 13. For now, you only need to know two details about iterators: iterators
produce a series of values, and we can call the <code>collect</code> method on an iterator
to turn it into a collection, such as a vector, that contains all the elements
the iterator produces.</p>
<p>为了让 <code>minigrep</code> 能够读取传递给它的命令行参数值，我们需要使用 Rust 标准库提供的 <code>std::env::args</code> 函数。该函数返回传递给 <code>minigrep</code> 的命令行参数的迭代器。我们将在第 13 章全面介绍迭代器。现在你只需了解关于迭代器的两个细节：迭代器会产生一系列值，我们可以在迭代器上调用 <code>collect</code> 方法将其转换为集合（如向量），其中包含迭代器生成的所有元素。</p>
<p>The code in Listing 12-1 allows your <code>minigrep</code> program to read any command
line arguments passed to it, and then collect the values into a vector.</p>
<p>清单 12-1 中的代码允许你的 <code>minigrep</code> 程序读取传递给它的任何命令行参数，然后将值收集到向量中。</p>
<figure class="listing" id="listing-12-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<figcaption><a href="#listing-12-1">Listing 12-1</a>: Collecting the command line arguments into a vector and printing them 将命令行参数收集到向量中并打印它们</figcaption>
</figure>
<p>First we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in Chapter
7, in cases where the desired function is
nested in more than one module, we’ve chosen to bring the parent module into
scope rather than the function. By doing so, we can easily use other functions
from <code>std::env</code>. It’s also less ambiguous than adding <code>use std::env::args</code> and
then calling the function with just <code>args</code>, because <code>args</code> might easily be
mistaken for a function that’s defined in the current module.</p>
<p>首先我们通过 <code>use</code> 语句将 <code>std::env</code> 模块引入作用域，以便使用其 <code>args</code> 函数。注意 <code>std::env::args</code> 函数嵌套在两层模块中。如第 7 章所述，当所需函数嵌套在多个模块中时，我们选择将父模块而非函数引入作用域。这样，我们可以轻松使用 <code>std::env</code> 中的其他函数。这比添加 <code>use std::env::args</code> 然后仅用 <code>args</code> 调用函数更清晰，因为 <code>args</code> 很容易被误认为是当前模块中定义的函数。</p>
<section class="note" aria-role="note">
<h3 id="the-args-function-and-invalid-unicode-args-函数与无效-unicode"><a class="header" href="#the-args-function-and-invalid-unicode-args-函数与无效-unicode">The <code>args</code> Function and Invalid Unicode <code>args</code> 函数与无效 Unicode</a></h3>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator
that produces <code>OsString</code> values instead of <code>String</code> values. We’ve chosen to
use <code>std::env::args</code> here for simplicity because <code>OsString</code> values differ per
platform and are more complex to work with than <code>String</code> values.</p>
<p>注意：<span class="highlight">[note]如果任何参数包含无效 Unicode，<code>std::env::args</code> 将会 panic。如果你的程序需要接受包含无效 Unicode 的参数，请改用 <code>std::env::args_os</code>。</span>该函数返回生成 <code>OsString</code> 值而非 <code>String</code> 值的迭代器。为简化起见，我们在此选择使用 <code>std::env::args</code>，因为 <code>OsString</code> 值因平台而异，且比 <code>String</code> 值更复杂。</p>
</section>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use
<code>collect</code> to turn the iterator into a vector containing all the values produced
by the iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although you very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>在 <code>main</code> 的第一行，我们调用 <code>env::args</code>，并立即使用 <code>collect</code> 将迭代器转换为包含迭代器生成的所有值的向量。我们可以使用 <code>collect</code> 函数创建多种集合，因此显式注解 <code>args</code> 的类型以指定我们需要字符串向量。虽然在 Rust 中很少需要注解类型，但 <code>collect</code> 是你经常需要注解的函数之一，因为 Rust 无法推断你想要的集合类型。</p>
<p>Finally, we print the vector using the debug macro. Let’s try running the code
first with no arguments and then with two arguments:</p>
<p>最后，我们使用调试宏打印向量。让我们先尝试不带参数运行代码，然后带两个参数运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>Notice that the first value in the vector is <code>"target/debug/minigrep"</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change the behavior of the program based on what
command line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<p>注意向量中的第一个值是 <code>"target/debug/minigrep"</code>，这是我们的二进制文件名称。这与 C 语言中的参数列表行为一致，允许程序在执行时使用调用它们的名称。能够访问程序名称通常很方便，例如在消息中打印它，或根据调用程序时使用的命令行别名更改程序行为。但就本章而言，我们将忽略它，仅保存我们需要的两个参数。</p>
<h3 id="saving-the-argument-values-in-variables-将参数值保存到变量中"><a class="header" href="#saving-the-argument-values-in-variables-将参数值保存到变量中">Saving the Argument Values in Variables 将参数值保存到变量中</a></h3>
<p>The program is currently able to access the values specified as command line
arguments. Now we need to save the values of the two arguments in variables so
we can use the values throughout the rest of the program. We do that in Listing
12-2.</p>
<p>程序现在能够访问指定为命令行参数的值。接下来我们需要将两个参数的值保存到变量中，以便在程序其余部分使用这些值。我们在清单 12-2 中实现这一点。</p>
<figure class="listing" id="listing-12-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
<figcaption><a href="#listing-12-2">Listing 12-2</a>: Creating variables to hold the query argument and file path argument 创建变量保存查询参数和文件路径参数</figcaption>
</figure>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting arguments at index 1. The
first argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the file path, so we put a reference to the second argument in the
variable <code>file_path</code>.</p>
<p>如我们打印向量时所看到的，程序名称占据向量中的第一个值 <code>args[0]</code>，因此我们从索引 1 开始获取参数。<code>minigrep</code> 接受的第一个参数是我们要搜索的字符串，因此我们将第一个参数的引用放入变量 <code>query</code> 中。第二个参数是文件路径，因此我们将第二个参数的引用放入变量 <code>file_path</code> 中。</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<p>我们暂时打印这些变量的值以证明代码按预期工作。让我们再次使用参数 <code>test</code> 和 <code>sample.txt</code> 运行此程序：</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.</p>
<p>很好，程序运行正常！我们所需的参数值已保存到正确的变量中。稍后我们将添加一些错误处理来应对某些可能的错误情况（例如用户未提供任何参数）；现在，我们将忽略这种情况，转而添加文件读取功能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-00-an-io-project.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-00-an-io-project.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-02-reading-a-file.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
