<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Refactoring to Improve Modularity and Error Handling 重构以提升模块化与错误处理能力 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refactoring-to-improve-modularity-and-error-handling-重构以提升模块化与错误处理能力"><a class="header" href="#refactoring-to-improve-modularity-and-error-handling-重构以提升模块化与错误处理能力">Refactoring to Improve Modularity and Error Handling 重构以提升模块化与错误处理能力</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors. First, our <code>main</code>
function now performs two tasks: it parses arguments and reads files. As our
program grows, the number of separate tasks the <code>main</code> function handles will
increase. As a function gains responsibilities, it becomes more difficult to
reason about, harder to test, and harder to change without breaking one of its
parts. It’s best to separate functionality so each function is responsible for
one task.</p>
<p>为了改进程序，我们将修复四个涉及程序结构及其处理潜在错误方式的问题。首先，当前的 <code>main</code> 函数承担了两项任务：解析参数和读取文件。随着程序增长，<code>main</code> 函数处理的独立任务数量会增加。当函数职责增多时，其逻辑会变得更难理解、更难测试，且更难在不破坏部分功能的情况下修改。最好将功能分离，使每个函数只负责单一任务。</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>file_path</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>此问题也关联到第二个问题：尽管 <code>query</code> 和 <code>file_path</code> 是程序的配置变量，但像 <code>contents</code> 这样的变量用于执行程序逻辑。<code>main</code> 函数越长，需要引入作用域的变量就越多；作用域中的变量越多，跟踪每个变量的用途就越困难。最好将配置变量分组到一个结构中，以明确其目的。</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints <code>Should have been  able to read the file</code>. Reading a file can fail in a number of ways: for
example, the file could be missing, or we might not have permission to open it.
Right now, regardless of the situation, we’d print the same error message for
everything, which wouldn’t give the user any information!</p>
<p>第三个问题是：读取文件失败时我们使用 <code>expect</code> 打印错误消息，但消息仅显示 <code>Should have been  able to read the file</code>。文件读取可能因多种原因失败：例如文件不存在或没有打开权限。当前无论何种情况，我们都打印相同的错误消息，这无法向用户提供有效信息！</p>
<p>Fourth, we use <code>expect</code> to handle an error, and if the user runs our program
without specifying enough arguments, they’ll get an <code>index out of bounds</code> error
from Rust that doesn’t clearly explain the problem. It would be best if all the
error-handling code were in one place so future maintainers had only one place
to consult the code if the error-handling logic needed to change. Having all the
error-handling code in one place will also ensure that we’re printing messages
that will be meaningful to our end users.</p>
<p>第四个问题是我们用 <code>expect</code> 处理错误，若用户运行时未提供足够参数，将收到 Rust 的 <code>index out of bounds</code> 错误，但该错误未清晰说明问题。最好将所有错误处理代码集中在一处，这样未来维护者在需要修改错误处理逻辑时只需查看一个位置。集中错误处理代码还能确保打印对最终用户有意义的提示信息。</p>
<p>Let’s address these four problems by refactoring our project.</p>
<p>让我们通过重构项目来解决这四个问题。</p>
<h3 id="separation-of-concerns-for-binary-projects-二进制项目的职责分离"><a class="header" href="#separation-of-concerns-for-binary-projects-二进制项目的职责分离">Separation of Concerns for Binary Projects 二进制项目的职责分离</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, many Rust
programmers find it useful to split up the separate concerns of a binary
program when the <code>main</code> function starts getting large. This process has the
following steps:</p>
<p>将多个任务分配给 <code>main</code> 函数的组织问题是许多二进制项目的通病。因此，当 <code>main</code> 函数变得庞大时，许多 Rust 开发者发现拆分二进制程序的独立关注点很有用。此过程包含以下步骤：</p>
<ul>
<li>Split your program into a <em>main.rs</em> file and a <em>lib.rs</em> file and move your
program’s logic to <em>lib.rs</em>.</li>
<li>将程序拆分为 <em>main.rs</em> 和 <em>lib.rs</em> 文件，并将程序逻辑移至 <em>lib.rs</em></li>
<li>As long as your command line parsing logic is small, it can remain in
the <code>main</code> function.</li>
<li>只要命令行解析逻辑简单，可保留在 <code>main</code> 函数中</li>
<li>When the command line parsing logic starts getting complicated, extract it
from the <code>main</code> function into other functions or types.</li>
<li>当命令行解析逻辑变复杂时，将其从 <code>main</code> 函数提取到其他函数或类型中</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<p>此过程后保留在 <code>main</code> 函数中的职责应限于：</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>使用参数值调用命令行解析逻辑</li>
<li>Setting up any other configuration</li>
<li>设置其他配置</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>调用 <em>lib.rs</em> 中的 <code>run</code> 函数</li>
<li>Handling the error if <code>run</code> returns an error</li>
<li>若 <code>run</code> 返回错误则处理该错误</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it out of the <code>main</code> function. The code that
remains in the <code>main</code> function will be small enough to verify its correctness
by reading it. Let’s rework our program by following this process.</p>
<p>此模式的核心是分离关注点：<em>main.rs</em> 负责运行程序，而 <em>lib.rs</em> 处理所有实际任务逻辑。由于无法直接测试 <code>main</code> 函数，此结构允许你将所有程序逻辑移出 <code>main</code> 函数进行测试。保留在 <code>main</code> 中的代码量足够小，可通过阅读验证正确性。让我们按此流程改造程序。</p>
<h4 id="extracting-the-argument-parser-提取参数解析器"><a class="header" href="#extracting-the-argument-parser-提取参数解析器">Extracting the Argument Parser 提取参数解析器</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call. Listing 12-5 shows the new start of the <code>main</code> function that
calls a new function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em>.</p>
<p>我们将参数解析功能提取到 <code>main</code> 调用的函数中。清单 12-5 展示了新的 <code>main</code> 函数起始部分，它调用新定义的 <code>parse_config</code> 函数（在 <em>src/main.rs</em> 中）。</p>
<figure class="listing" id="listing-12-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption><a href="#listing-12-5">Listing 12-5</a>: Extracting a <code>parse_config</code> function from <code>main</code> 从 <code>main</code> 中提取 <code>parse_config</code> 函数</figcaption>
</figure>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable <code>query</code> and the
argument value at index 2 to the variable <code>file_path</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>file_path</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>我们仍将命令行参数收集到向量中，但不再在 <code>main</code> 函数中将索引 1 的值赋给 <code>query</code>、索引 2 的值赋给 <code>file_path</code>，而是将整个向量传递给 <code>parse_config</code> 函数。<code>parse_config</code> 函数包含确定参数与变量对应关系的逻辑，并将值传回 <code>main</code>。我们仍在 <code>main</code> 中创建 <code>query</code> 和 <code>file_path</code> 变量，但 <code>main</code> 不再负责确定命令行参数与变量的对应关系。</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<p>对小程序来说这种改造可能显得过度，但我们正以小步增量方式进行重构。修改后请再次运行程序以验证参数解析仍正常工作。经常检查进展有助于快速定位问题根源。</p>
<h4 id="grouping-configuration-values-分组配置值"><a class="header" href="#grouping-configuration-values-分组配置值">Grouping Configuration Values 分组配置值</a></h4>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>我们可以进一步改进 <code>parse_config</code> 函数。当前返回元组后立即将其拆分为独立部分，这表明当前的抽象可能不够合理。</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we’ll instead put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<p>另一个可改进的迹象是 <code>parse_config</code> 中的 <code>config</code> 部分，暗示返回的两个值相关且同属一个配置值。当前仅通过元组分组来传递这种关联性，我们将把这两个值放入结构体，并为每个字段赋予有意义的名称。这样做将使未来代码维护者更容易理解不同值间的关联及其用途。</p>
<p>Listing 12-6 shows the improvements to the <code>parse_config</code> function.</p>
<p>清单 12-6 展示了对 <code>parse_config</code> 函数的改进。</p>
<figure class="listing" id="listing-12-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption><a href="#listing-12-6">Listing 12-6</a>: Refactoring <code>parse_config</code> to return an instance of a <code>Config</code> struct 重构 <code>parse_config</code> 返回 <code>Config</code> 结构体实例</figcaption>
</figure>
<p>We’ve added a struct named <code>Config</code> defined to have fields named <code>query</code> and
<code>file_path</code>. The signature of <code>parse_config</code> now indicates that it returns a
<code>Config</code> value. In the body of <code>parse_config</code>, where we used to return
string slices that reference <code>String</code> values in <code>args</code>, we now define <code>Config</code>
to contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of
the argument values and is only letting the <code>parse_config</code> function borrow
them, which means we’d violate Rust’s borrowing rules if <code>Config</code> tried to take
ownership of the values in <code>args</code>.</p>
<p>我们添加了包含 <code>query</code> 和 <code>file_path</code> 字段的 <code>Config</code> 结构体。<code>parse_config</code> 的签名现表明它返回 <code>Config</code> 值。在函数体中，过去返回引用 <code>args</code> 中 <code>String</code> 值的字符串切片，现在改为定义 <code>Config</code> 包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者，仅借给 <code>parse_config</code> 使用，这意味着若 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权，将违反 Rust 的借用规则。</p>
<p>There are a number of ways we could manage the <code>String</code> data; the easiest,
though somewhat inefficient, route is to call the <code>clone</code> method on the values.
This will make a full copy of the data for the <code>Config</code> instance to own, which
takes more time and memory than storing a reference to the string data.
However, cloning the data also makes our code very straightforward because we
don’t have to manage the lifetimes of the references; in this circumstance,
giving up a little performance to gain simplicity is a worthwhile trade-off.</p>
<p>有多种方式管理 <code>String</code> 数据；最简单（但效率较低）的方法是调用值的 <code>clone</code> 方法。这会为 <code>Config</code> 实例创建数据的完整副本，比存储字符串数据的引用更耗时间和内存。但克隆数据也使代码更简洁，因为我们无需管理引用的生命周期；在此情况下，牺牲少量性能换取简单性是值得的。</p>
<section class="note" aria-role="note">
<h3 id="the-trade-offs-of-using-clone-使用-clone-的权衡"><a class="header" href="#the-trade-offs-of-using-clone-使用-clone-的权衡">The Trade-Offs of Using <code>clone</code> 使用 <code>clone</code> 的权衡</a></h3>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In
Chapter 13, you’ll learn how to use more efficient
methods in this type of situation. But for now, it’s okay to copy a few
strings to continue making progress because you’ll make these copies only
once and your file path and query string are very small. It’s better to have
a working program that’s a bit inefficient than to try to hyperoptimize code
on your first pass. As you become more experienced with Rust, it’ll be
easier to start with the most efficient solution, but for now, it’s
perfectly acceptable to call <code>clone</code>.</p>
<p>许多 Rust 开发者倾向于避免用 <code>clone</code> 解决所有权问题，因其有运行时开销。在第 13 章，你将学习在此类情况下使用更高效的方法。但当前复制少量字符串以继续推进是可以接受的，因为这些复制仅发生一次，且文件路径和查询字符串非常小。拥有稍低效但可工作的程序，比首次尝试就过度优化更好。随着 Rust 经验增长，你会更易从高效方案起步，但目前调用 <code>clone</code> 完全可接受。</p>
</section>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>file_path</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>我们更新了 <code>main</code>，将 <code>parse_config</code> 返回的 <code>Config</code> 实例存入变量 <code>config</code>，并将之前使用独立变量 <code>query</code> 和 <code>file_path</code> 的代码改为使用 <code>Config</code> 结构体的字段。</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>file_path</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<p>现在代码更清晰地表明 <code>query</code> 和 <code>file_path</code> 相关，其目的是配置程序工作方式。使用这些值的代码只需在 <code>config</code> 实例的对应字段中查找即可。</p>
<h4 id="creating-a-constructor-for-config-为-config-创建构造函数"><a class="header" href="#creating-a-constructor-for-config-为-config-创建构造函数">Creating a Constructor for <code>Config</code> 为 <code>Config</code> 创建构造函数</a></h4>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us see that the <code>query</code> and <code>file_path</code> values were related, and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>file_path</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>至此，我们已将参数解析逻辑从 <code>main</code> 提取到 <code>parse_config</code> 函数。这让我们看到 <code>query</code> 和 <code>file_path</code> 的关联性应体现在代码中。接着添加 <code>Config</code> 结构体命名其关联目的，并从 <code>parse_config</code> 返回字段名。</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make.</p>
<p>既然 <code>parse_config</code> 的目的是创建 <code>Config</code> 实例，可将其从普通函数改为与 <code>Config</code> 结构体关联的 <code>new</code> 函数。此变更使代码更符合 Rust 惯例。创建标准库类型（如 <code>String</code>）的实例可调用 <code>String::new</code>。类似地，将 <code>parse_config</code> 改为 <code>Config</code> 的关联函数 <code>new</code> 后，可通过 <code>Config::new</code> 创建实例。清单 12-7 展示了需要做的更改。</p>
<figure class="listing" id="listing-12-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption><a href="#listing-12-7">Listing 12-7</a>: Changing <code>parse_config</code> into <code>Config::new</code> 将 <code>parse_config</code> 改为 <code>Config::new</code></figcaption>
</figure>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<p>我们将 <code>main</code> 中调用 <code>parse_config</code> 的地方改为调用 <code>Config::new</code>。把 <code>parse_config</code> 重命名为 <code>new</code> 并移至 <code>impl</code> 块内，使 <code>new</code> 函数与 <code>Config</code> 关联。请再次编译此代码确保其工作。</p>
<h3 id="fixing-the-error-handling-修复错误处理"><a class="header" href="#fixing-the-error-handling-修复错误处理">Fixing the Error Handling 修复错误处理</a></h3>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:</p>
<p>现在我们来修复错误处理。回想一下，若向量包含少于三项时访问索引 1 或 2 会导致程序 panic。尝试不带参数运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
they should do instead. Let’s fix that now.</p>
<p><code>index out of bounds: the len is 1 but the index is 1</code> 这条面向程序员的消息对终端用户无帮助。现在修复它。</p>
<h4 id="improving-the-error-message-改进错误消息"><a class="header" href="#improving-the-error-message-改进错误消息">Improving the Error Message 改进错误消息</a></h4>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index 1 and index 2. If the slice isn’t
long enough, the program panics and displays a better error message.</p>
<p>在清单 12-8 中，我们在 <code>new</code> 函数添加检查，确保在访问索引 1 和 2 前切片足够长。若长度不足，程序 panic 并显示更好的错误消息。</p>
<figure class="listing" id="listing-12-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-8">Listing 12-8</a>: Adding a check for the number of arguments 添加参数数量检查</figcaption>
</figure>
<p>This code is similar to the <code>Guess::new</code> function we wrote in Listing
9-13, where we called <code>panic!</code> when the
<code>value</code> argument was out of the range of valid values. Instead of checking for
a range of values here, we’re checking that the length of <code>args</code> is at least
<code>3</code> and the rest of the function can operate under the assumption that this
condition has been met. If <code>args</code> has fewer than three items, this condition
will be <code>true</code>, and we call the <code>panic!</code> macro to end the program immediately.</p>
<p>此代码类似清单 9-13 的 <code>Guess::new</code> 函数（当 <code>value</code> 参数超出有效范围时调用 <code>panic!</code>）。这里不检查值范围，而检查 <code>args</code> 长度是否至少为 3，函数其余部分可基于此条件运行。若 <code>args</code> 少于三项，此条件为真，调用 <code>panic!</code> 宏立即终止程序。</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<p>在 <code>new</code> 中添加这几行后，再次不带参数运行程序查看错误信息：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps the
technique we used in Listing 9-13 isn’t the best one to use here: a call to
<code>panic!</code> is more appropriate for a programming problem than a usage problem,
as discussed in Chapter 9. Instead,
we’ll use the other technique you learned about in Chapter 9—returning a
<code>Result</code> that indicates either success or an error.</p>
<p>此输出更合理，但仍有冗余信息。清单 9-13 的技术可能不适用：如第 9 章所述，<code>panic!</code> 更适合编程问题而非用法问题。我们将改用第 9 章的另一技术——返回表示成功或错误的 <code>Result</code>。</p>
<h4 id="returning-a-result-instead-of-calling-panic-返回-result-而非调用-panic"><a class="header" href="#returning-a-result-instead-of-calling-panic-返回-result-而非调用-panic">Returning a <code>Result</code> Instead of Calling <code>panic!</code> 返回 <code>Result</code> 而非调用 <code>panic!</code></a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. We’re also
going to change the function name from <code>new</code> to <code>build</code> because many
programmers expect <code>new</code> functions to never fail. When <code>Config::build</code> is
communicating to <code>main</code>, we can use the <code>Result</code> type to signal there was a
problem. Then we can change <code>main</code> to convert an <code>Err</code> variant into a more
practical error for our users without the surrounding text about <code>thread  'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>我们改为返回 <code>Result</code>，成功时包含 <code>Config</code> 实例，错误时描述问题。同时将函数名从 <code>new</code> 改为 <code>build</code>，因为<span class="highlight">[note]许多开发者期望 <code>new</code> 函数永不失败</span>。当 <code>Config::build</code> 与 <code>main</code> 通信时，可用 <code>Result</code> 类型表示问题。接着修改 <code>main</code>，将 <code>Err</code> 变体转换为对用户更友好的错误，避免 <code>panic!</code> 引起的 <code>thread 'main'</code> 和 <code>RUST_BACKTRACE</code> 等文本。</p>
<p>Listing 12-9 shows the changes we need to make to the return value of the
function we’re now calling <code>Config::build</code> and the body of the function needed
to return a <code>Result</code>. Note that this won’t compile until we update <code>main</code> as
well, which we’ll do in the next listing.</p>
<p>清单 12-9 展示了需对 <code>Config::build</code> 返回值和函数体做的更改（返回 <code>Result</code>）。注意在更新 <code>main</code>（下个清单）前此代码无法编译。</p>
<figure class="listing" id="listing-12-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption><a href="#listing-12-9">Listing 12-9</a>: Returning a <code>Result</code> from <code>Config::build</code> 从 <code>Config::build</code> 返回 <code>Result</code></figcaption>
</figure>
<p>Our <code>build</code> function returns a <code>Result</code> with a <code>Config</code> instance in the success
case and a string literal in the error case. Our error values will always be
string literals that have the <code>'static</code> lifetime.</p>
<p><code>build</code> 函数返回 <code>Result</code>，成功时包含 <code>Config</code> 实例，错误时为字符串字面量（具有 <code>'static</code> 生命周期）。</p>
<p>We’ve made two changes in the body of the function: instead of calling <code>panic!</code>
when the user doesn’t pass enough arguments, we now return an <code>Err</code> value, and
we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes make the
function conform to its new type signature.</p>
<p>函数体内有两处改动：用户未提供足够参数时不再调用 <code>panic!</code> 而是返回 <code>Err</code> 值，并将 <code>Config</code> 返回值包装在 <code>Ok</code> 中。这些变更使函数符合新签名。</p>
<p>Returning an <code>Err</code> value from <code>Config::build</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>build</code> function and exit the
process more cleanly in the error case.</p>
<p>从 <code>Config::build</code> 返回 <code>Err</code> 允许 <code>main</code> 处理返回的 <code>Result</code>，并在错误时更清晰地退出进程。</p>
<h4 id="calling-configbuild-and-handling-errors-调用-configbuild-并处理错误"><a class="header" href="#calling-configbuild-and-handling-errors-调用-configbuild-并处理错误">Calling <code>Config::build</code> and Handling Errors 调用 <code>Config::build</code> 并处理错误</a></h4>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::build</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code away from <code>panic!</code> and instead implement it by
hand. A nonzero exit status is a convention to signal to the process that
called our program that the program exited with an error state.</p>
<p>为处理错误并打印用户友好消息，需更新 <code>main</code> 处理 <code>Config::build</code> 返回的 <code>Result</code>，如清单 12-10 所示。我们还将手动实现以非零错误码退出的逻辑（而非依赖 <code>panic!</code>）。非零退出状态是向调用进程表明程序以错误状态终止的约定。</p>
<figure class="listing" id="listing-12-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-10">Listing 12-10</a>: Exiting with an error code if building a <code>Config</code> fails 构建 <code>Config</code> 失败时带错误码退出</figcaption>
</figure>
<p>In this listing, we’ve used a method we haven’t covered in detail yet:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value that <code>Ok</code> is wrapping. However, if the
value is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is
an anonymous function we define and pass as an argument to <code>unwrap_or_else</code>.
We’ll cover closures in more detail in Chapter 13. For
now, you just need to know that <code>unwrap_or_else</code> will pass the inner value of
the <code>Err</code>, which in this case is the static string <code>"not enough arguments"</code>
that we added in Listing 12-9, to our closure in the argument <code>err</code> that
appears between the vertical pipes. The code in the closure can then use the
<code>err</code> value when it runs.</p>
<p>此清单使用了标准库为 <code>Result&lt;T, E&gt;</code> 定义的 <code>unwrap_or_else</code> 方法（尚未详细讲解）。该方法允许自定义非 <code>panic!</code> 的错误处理：若 <code>Result</code> 是 <code>Ok</code> 值，其行为类似 <code>unwrap</code>——返回 <code>Ok</code> 包装的内部值；若是 <code>Err</code> 值，则调用闭包（作为参数传递的匿名函数）中的代码。第 13 章将深入讲解闭包。现在只需知道：<code>unwrap_or_else</code> 会将 <code>Err</code> 的内部值（此处为清单 12-9 添加的 <code>"not enough arguments"</code> 静态字符串）传递给闭包参数 <code>err</code>（竖线间）。闭包代码运行时可使用 <code>err</code> 值。</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the <code>err</code> value and then call <code>process::exit</code>. The
<code>process::exit</code> function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
<code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:</p>
<p>我们添加了 <code>use</code> 行将标准库的 <code>process</code> 引入作用域。错误情况下的闭包代码仅两行：打印 <code>err</code> 值并<span class="highlight">[note]调用 <code>process::exit</code></span>。该函数会立即停止程序并返回传入的退出状态码。这类似清单 12-8 基于 <code>panic!</code> 的处理，但不再有额外输出。尝试运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<p>输出对用户友好多了！</p>
<h3 id="extracting-logic-from-the-main-function-从-main-提取逻辑"><a class="header" href="#extracting-logic-from-the-main-function-从-main-提取逻辑">Extracting Logic from the <code>main</code> Function 从 <code>main</code> 提取逻辑</a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll
extract a function named <code>run</code> that will hold all the logic currently in the
<code>main</code> function that isn’t involved with setting up configuration or handling
errors. When we’re done, the <code>main</code> function will be concise and easy to verify
by inspection, and we’ll be able to write tests for all the other logic.</p>
<p>完成配置解析的重构后，现在处理程序逻辑。如“二进制项目的职责分离”所述，我们将提取名为 <code>run</code> 的函数，包含当前 <code>main</code> 中与配置设置或错误处理无关的所有逻辑。完成后，<code>main</code> 函数将简洁易验证，其他逻辑均可测试。</p>
<p>Listing 12-11 shows the small, incremental improvement of extracting a <code>run</code>
function.</p>
<p>清单 12-11 展示了提取 <code>run</code> 函数的渐进改进。</p>
<figure class="listing" id="listing-12-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-11">Listing 12-11</a>: Extracting a <code>run</code> function containing the rest of the program logic 提取包含剩余程序逻辑的 <code>run</code> 函数</figcaption>
</figure>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<p><code>run</code> 函数现在包含从文件读取开始的 <code>main</code> 所有剩余逻辑，并以 <code>Config</code> 实例为参数。</p>
<h4 id="returning-errors-from-the-run-function-从-run-函数返回错误"><a class="header" href="#returning-errors-from-the-run-function-从-run-函数返回错误">Returning Errors from the <code>run</code> Function 从 <code>run</code> 函数返回错误</a></h4>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::build</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate the logic around handling errors into <code>main</code> in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>.</p>
<p>将剩余逻辑分离到 <code>run</code> 函数后，可改进错误处理（类似清单 12-9 对 <code>Config::build</code> 的改进）。不再通过 <code>expect</code> 调用引发 panic，而是让 <code>run</code> 在出错时返回 <code>Result&lt;T, E&gt;</code>。这让我们能将错误处理逻辑集中到 <code>main</code>，以更友好的方式处理。清单 12-12 展示了需对 <code>run</code> 签名和函数体做的更改。</p>
<figure class="listing" id="listing-12-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-12">Listing 12-12</a>: Changing the <code>run</code> function to return <code>Result</code> 修改 <code>run</code> 函数返回 <code>Result</code></figcaption>
</figure>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>我们在这里做了三处重要的修改。首先，我们将 <code>run</code> 函数的返回类型更改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。这个函数之前返回的是单位类型 <code>()</code>，我们保留了在 <code>Ok</code> 情况下返回的值。</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we’ve
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We’ll cover trait objects in Chapter 18. For now, just
know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that
implements the <code>Error</code> trait, but we don’t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The <code>dyn</code> keyword is short
for <em>dynamic</em>.</p>
<p>对于错误类型，我们使用了 <em>特征对象</em> <code>Box&lt;dyn Error&gt;</code>（并且我们在顶部通过 <code>use</code> 语句引入了 <code>std::error::Error</code>）。我们将在第18章讨论特征对象。现在，只需要知道 <code>Box&lt;dyn Error&gt;</code> 表示函数将返回一个实现了 <code>Error</code> 特征的类型，但我们不需要指定返回值的具体类型。这让我们可以灵活地返回不同错误情况可能出现的不同类型的错误值。<code>dyn</code> 关键字是 <em>动态</em> 的缩写。</p>
<p>Second, we’ve removed the call to <code>expect</code> in favor of the <code>?</code> operator, as we
talked about in Chapter 9. Rather than
<code>panic!</code> on an error, <code>?</code> will return the error value from the current function
for the caller to handle.</p>
<p>第二，我们删除了对 <code>expect</code> 的调用，改用了 <code>?</code> 运算符，正如我们在第9章讨论的那样。与其在出错时调用 <code>panic!</code>，<code>?</code> 会将错误值从当前函数返回，供调用者处理。</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case.
We’ve declared the <code>run</code> function’s success type as <code>()</code> in the signature,
which means we need to wrap the unit type value in the <code>Ok</code> value. This
<code>Ok(())</code> syntax might look a bit strange at first, but using <code>()</code> like this is
the idiomatic way to indicate that we’re calling <code>run</code> for its side effects
only; it doesn’t return a value we need.</p>
<p>第三，<code>run</code> 函数现在在成功的情况下返回一个 <code>Ok</code> 值。我们在函数签名中将 <code>run</code> 函数的成功类型声明为 <code>()</code>，这意味着我们需要将单位类型值包裹在 <code>Ok</code> 中。这个 <code>Ok(())</code> 语法起初可能看起来有点奇怪，但像这样使用 <code>()</code> 是表示我们仅仅是为了副作用调用 <code>run</code> 的惯用方式；它并没有返回我们需要的值。</p>
<p>When you run this code, it will compile but will display a warning:</p>
<p>运行此代码时会产生警告：</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.</p>
<p>Rust 告诉我们我们的代码忽略了 <code>Result</code> 值，而 <code>Result</code> 值可能表明发生了错误。但我们没有检查是否发生了错误，编译器提醒我们可能在这里漏掉了错误处理代码！让我们现在来解决这个问题。</p>
<h4 id="handling-errors-returned-from-run-in-main-在-main-中处理-run-返回的错误"><a class="header" href="#handling-errors-returned-from-run-in-main-在-main-中处理-run-返回的错误">Handling Errors Returned from <code>run</code> in <code>main</code> 在 <code>main</code> 中处理 <code>run</code> 返回的错误</a></h4>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::build</code> in Listing 12-10, but with a slight difference:</p>
<p>我们将用类似清单 12-10 处理 <code>Config::build</code> 的技术处理错误，但略有不同：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and to call <code>process::exit(1)</code> if it does. The <code>run</code> function
doesn’t return a value that we want to <code>unwrap</code> in the same way that
<code>Config::build</code> returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in
the success case, we only care about detecting an error, so we don’t need
<code>unwrap_or_else</code> to return the unwrapped value, which would only be <code>()</code>.</p>
<p>这里使用 <code>if let</code> 而非 <code>unwrap_or_else</code> 检查 <code>run</code> 是否返回 <code>Err</code>，是则调用 <code>process::exit(1)</code>。因为 <code>run</code> 成功时返回 <code>()</code>（而 <code>Config::build</code> 返回 <code>Config</code> 实例），我们只关心是否出错，无需像 <code>unwrap_or_else</code> 那样解包值（解包结果只会是 <code>()</code>）。</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<p><code>if let</code> 和 <code>unwrap_or_else</code> 的函数体相同：打印错误并退出。</p>
<h3 id="splitting-code-into-a-library-crate-将代码拆分为库-crate"><a class="header" href="#splitting-code-into-a-library-crate-将代码拆分为库-crate">Splitting Code into a Library Crate 将代码拆分为库 crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file. That way, we
can test the code and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>目前 <code>minigrep</code> 项目进展顺利！现在我们将拆分 <em>src/main.rs</em> 文件，把部分代码放入 <em>src/lib.rs</em>。这样即可测试代码，并让 <em>src/main.rs</em> 职责更少。</p>
<p>Let’s define the code responsible for searching text in <em>src/lib.rs</em> rather
than in <em>src/main.rs</em>, which will let us (or anyone else using our
<code>minigrep</code> library) call the searching function from more contexts than our
<code>minigrep</code> binary.</p>
<p>让我们在 <em>src/lib.rs</em> 中定义文本搜索逻辑（而非 <em>src/main.rs</em>），这样我们（或其他使用 <code>minigrep</code> 库的人）就能在更多上下文中调用搜索函数。</p>
<p>First, let’s define the <code>search</code> function signature in <em>src/lib.rs</em> as shown in
Listing 12-13, with a body that calls the <code>unimplemented!</code> macro. We’ll explain
the signature in more detail when we fill in the implementation.</p>
<p>首先在 <em>src/lib.rs</em> 中定义 <code>search</code> 函数签名（如清单 12-13），其函数体调用 <code>unimplemented!</code> 宏。实现时会详细解释签名。</p>
<figure class="listing" id="listing-12-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    unimplemented!();
}</code></pre>
<figcaption><a href="#listing-12-13">Listing 12-13</a>: Defining the <code>search</code> function in  <em>src/lib.rs</em> 在 <em>src/lib.rs</em> 中定义 <code>search</code> 函数</figcaption>
</figure>
<p>We’ve used the <code>pub</code> keyword on the function definition to designate <code>search</code>
as part of our library crate’s public API. We now have a library crate that we
can use from our binary crate and that we can test!</p>
<p>在函数定义中使用 <code>pub</code> 关键字将 <code>search</code> 设为库 crate 公共 API 的一部分。现在有了可从二进制 crate 使用且可测试的库 crate！</p>
<p>Now we need to bring the code defined in <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em> and call it, as shown in Listing 12-14.</p>
<p>接下来需将 <em>src/lib.rs</em> 中的代码引入二进制 crate（在 <em>src/main.rs</em> 中）并调用，如清单 12-14 所示。</p>
<figure class="listing" id="listing-12-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>// --snip--
use minigrep::search;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="#listing-12-14">Listing 12-14</a>: Using the <code>minigrep</code> library crate’s <code>search</code> function in <em>src/main.rs</em> 在 <em>src/main.rs</em> 使用 <code>minigrep</code> 库的 <code>search</code> 函数</figcaption>
</figure>
<p>We add a <code>use minigrep::search</code> line to bring the <code>search</code> function from
the library crate into the binary crate’s scope. Then, in the <code>run</code> function,
rather than printing out the contents of the file, we call the <code>search</code>
function and pass the <code>config.query</code> value and <code>contents</code> as arguments. Then
<code>run</code> will use a <code>for</code> loop to print each line returned from <code>search</code> that
matched the query. This is also a good time to remove the <code>println!</code> calls in
the <code>main</code> function that displayed the query and the file path so that our
program only prints the search results (if no errors occur).</p>
<p>添加 <code>use minigrep::search</code> 将库 crate 的 <code>search</code> 函数引入二进制 crate 作用域。接着在 <code>run</code> 函数中，不再打印文件内容，而是调用 <code>search</code> 函数（传入 <code>config.query</code> 和 <code>contents</code> 参数）。<code>run</code> 函数通过 <code>for</code> 循环打印 <code>search</code> 返回的每个匹配行。同时移除 <code>main</code> 中打印查询和文件路径的 <code>println!</code> 调用，使程序仅输出搜索结果（无错误时）。</p>
<p>Note that the search function will be collecting all the results into a vector
it returns before any printing happens. This implementation could be slow to
display results when searching large files because results aren’t printed as
they’re found; we’ll discuss a possible way to fix this using iterators in
Chapter 13.</p>
<p>注意：<code>search</code> 函数会在打印前将所有结果收集到返回的向量中。当搜索大文件时，此实现可能因无法实时打印而显慢；第 13 章将讨论用迭代器修复此问题的方法。</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>哇！虽然工作量很大，但我们为未来成功奠定了基础。现在错误处理更简单，代码也更模块化。此后几乎所有工作都将在 <em>src/lib.rs</em> 中完成。</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<p>让我们利用新获得的模块化优势做些旧代码难以实现的事：编写测试！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
