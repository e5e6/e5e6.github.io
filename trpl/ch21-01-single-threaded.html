<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building a Single-Threaded Web Server 构建单线程Web服务器 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="building-a-single-threaded-web-server-构建单线程web服务器"><a class="header" href="#building-a-single-threaded-web-server-构建单线程web服务器">Building a Single-Threaded Web Server 构建单线程Web服务器</a></h2>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>我们将从使单线程Web服务器工作开始。在开始之前，让我们快速概述构建Web服务器所涉及的协议。这些协议的细节超出了本书的范围，但简要概述将为你提供所需的信息。</p>
<p>The two main protocols involved in web servers are <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both protocols
are <em>request-response</em> protocols, meaning a <em>client</em> initiates requests and a
<em>server</em> listens to the requests and provides a response to the client. The
contents of those requests and responses are defined by the protocols.</p>
<p>Web服务器涉及的两个主要协议是超文本传输协议(HTTP)和传输控制协议(TCP)。这两种协议都是请求-响应协议，意味着客户端发起请求，服务器监听请求并向客户端提供响应。这些请求和响应的内容由协议定义。</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<p>TCP是较低级别的协议，描述了信息如何从一台服务器传递到另一台服务器的细节，但没有指定该信息是什么。HTTP建立在TCP之上，定义了请求和响应的内容。从技术上讲，可以将HTTP与其他协议一起使用，但在绝大多数情况下，HTTP通过TCP发送其数据。我们将处理TCP和HTTP请求及响应的原始字节。</p>
<h3 id="listening-to-the-tcp-connection-监听tcp连接"><a class="header" href="#listening-to-the-tcp-connection-监听tcp连接">Listening to the TCP Connection 监听TCP连接</a></h3>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<p>我们的Web服务器需要监听TCP连接，因此这是我们要处理的第一部分。标准库提供了一个<code>std::net</code>模块，让我们可以做到这一点。让我们以通常的方式创建一个新项目：</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 21-1 in <em>src/main.rs</em> to start. This code will
listen at the local address <code>127.0.0.1:7878</code> for incoming TCP streams. When it
gets an incoming stream, it will print <code>Connection established!</code>.</p>
<p>现在在 <code>src/main.rs</code> 中输入代码清单21-1中的代码。此代码将在本地地址<code>127.0.0.1:7878</code>监听传入的TCP流。当它接收到传入流时，会打印<code>Connection established!</code>。</p>
<figure class="listing" id="listing-21-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
<figcaption><a href="#listing-21-1">Listing 21-1</a>: Listening for incoming streams and printing a message when we receive a stream 监听传入流并在接收到流时打印消息</figcaption>
</figure>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP isn’t normally accepted on this port so
our server is unlikely to conflict with any other web server you might have
running on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>
<p>使用<code>TcpListener</code>，我们可以在地址<code>127.0.0.1:7878</code>监听TCP连接。在地址中，冒号前的部分代表你的计算机的IP地址（这在每台计算机上都是相同的，并不特指作者的计算机），而<code>7878</code>是端口。我们选择这个端口有两个原因：HTTP通常不接受此端口，因此我们的服务器不太可能与你计算机上可能运行的其他Web服务器冲突；并且7878在电话键盘上是rust的拼写。</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The function is called <code>bind</code>
because, in networking, connecting to a port to listen to is known as “binding
to a port.”</p>
<p>此场景中的<code>bind</code>函数类似于<code>new</code>函数，它会返回一个新的<code>TcpListener</code>实例。该函数被称为<code>bind</code>，因为在网络中，连接到端口进行监听被称为“绑定到端口“。</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that it’s
possible for binding to fail. For example, connecting to port 80 requires
administrator privileges (non-administrators can listen only on ports higher
than 1023), so if we tried to connect to port 80 without being an
administrator, binding wouldn’t work. Binding also wouldn’t work, for example,
if we ran two instances of our program and so had two programs listening to the
same port. Because we’re writing a basic server just for learning purposes, we
won’t worry about handling these kinds of errors; instead, we use <code>unwrap</code> to
stop the program if errors happen.</p>
<p><code>bind</code>函数返回一个<code>Result&lt;T, E&gt;</code>，表示绑定可能失败。例如，连接到端口80需要管理员权限（非管理员只能监听1023以上的端口），因此如果我们尝试以非管理员身份连接端口80，绑定将不起作用。绑定也可能失败，例如，如果我们运行两个程序实例，就有两个程序监听同一个端口。因为我们正在编写仅用于学习目的的简单服务器，所以不用担心处理此类错误；相反，如果发生错误，我们使用<code>unwrap</code>停止程序。</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, we will read from the <code>TcpStream</code> to see what
the client sent and then write our response to the stream to send data back to
the client. Overall, this <code>for</code> loop will process each connection in turn and
produce a series of streams for us to handle.</p>
<p><code>TcpListener</code>上的<code>incoming</code>方法返回一个迭代器，该迭代器为我们提供一系列流（更具体地说，是<code>TcpStream</code>类型的流）。单个流表示客户端和服务器之间的开放连接。连接是指客户端连接到服务器、服务器生成响应以及服务器关闭连接的完整请求和响应过程的名称。因此，我们将从<code>TcpStream</code>读取以查看客户端发送的内容，然后将响应写入流以将数据发送回客户端。总的来说，这个<code>for</code>循环将依次处理每个连接，并生成一系列供我们处理的流。</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>目前，我们对流的处理包括在流有任何错误时调用<code>unwrap</code>终止程序；如果没有错误，程序会打印一条消息。我们将在下一个代码清单中为成功情况添加更多功能。当客户端连接到服务器时，我们可能从<code>incoming</code>方法收到错误的原因是我们实际上不是在遍历连接，而是在遍历连接尝试。由于多种原因（其中许多与操作系统相关），连接可能不成功。例如，许多操作系统对其可以支持的并发打开连接数量有限制；超过该数量的新连接尝试将产生错误，直到一些打开的连接关闭。</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<p>让我们尝试运行此代码！在终端中调用<code>cargo run</code>，然后在Web浏览器中加载 <code>127.0.0.1:7878</code>。浏览器应显示类似“Connection reset“的错误消息，因为服务器当前没有返回任何数据。但是当你查看终端时，应该看到浏览器连接到服务器时打印的几条消息！</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>有时你会看到针对一个浏览器请求打印多条消息；原因可能是浏览器正在请求页面以及其他资源，例如浏览器标签中出现的 <code>favicon.ico</code> 图标。</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary.</p>
<p>也可能是因为服务器没有响应任何数据，浏览器尝试多次连接到服务器。当<code>stream</code>在循环结束时超出作用域并被丢弃时，连接作为<code>drop</code>实现的一部分被关闭。浏览器有时会通过重试来处理已关闭的连接，因为问题可能是暂时的。</p>
<p>Browsers also sometimes open multiple connections to the server without sending
any requests, so that if they <em>do</em> later send requests, they can happen faster.
When this happens, our server will see each connection, regardless of whether
there are any requests over that connection. Many versions of Chrome-based
browsers do this, for example; you can disable that optimization by using =
private browsing mode or use a different browser.</p>
<p>浏览器有时也会在不发送任何请求的情况下打开多个到服务器的连接，以便以后发送请求时可以更快。发生这种情况时，我们的服务器将看到每个连接，无论该连接上是否有任何请求。例如，许多基于Chrome的浏览器版本都会这样做；你可以通过使用隐私浏览模式或使用不同的浏览器来禁用该优化。</p>
<p>The important factor is that we’ve successfully gotten a handle to a TCP
connection!</p>
<p>重要的因素是我们已成功获取到TCP连接句柄！</p>
<p>Remember to stop the program by pressing <kbd>ctrl</kbd>-<kbd>c</kbd> when
you’re done running a particular version of the code. Then restart the program
by invoking the <code>cargo run</code> command after you’ve made each set of code changes
to make sure you’re running the newest code.</p>
<p>请记住在运行特定版本的代码后按<kbd>ctrl</kbd>-<kbd>c</kbd>停止程序。然后在每次代码更改后通过调用<code>cargo run</code>命令重新启动程序，以确保运行的是最新代码。</p>
<h3 id="reading-the-request-读取请求"><a class="header" href="#reading-the-request-读取请求">Reading the Request 读取请求</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 21-2.</p>
<p>让我们实现从浏览器读取请求的功能！为了分离首先获取连接然后对连接执行某些操作的关注点，我们将为处理连接启动一个新函数。在这个新的<code>handle_connection</code>函数中，我们将从TCP流读取数据并打印出来，以便查看浏览器发送的数据。将代码更改为代码清单21-2所示。</p>
<figure class="listing" id="listing-21-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<figcaption><a href="#listing-21-2">Listing 21-2</a>: Reading from the <code>TcpStream</code> and printing the data 从<code>TcpStream</code>读取并打印数据</figcaption>
</figure>
<p>We bring <code>std::io::prelude</code> and <code>std::io::BufReader</code> into scope to get access
to traits and types that let us read from and write to the stream. In the <code>for</code>
loop in the <code>main</code> function, instead of printing a message that says we made a
connection, we now call the new <code>handle_connection</code> function and pass the
<code>stream</code> to it.</p>
<p>我们<span class="highlight">[note]将<code>std::io::prelude</code>和<code>std::io::BufReader</code>引入作用域，以获取允许我们从流读取和写入的特征和类型</span>。在<code>main</code>函数的<code>for</code>循环中，我们现在不再打印已建立连接的消息，而是调用新的<code>handle_connection</code>函数并将<code>stream</code>传递给它。</p>
<p>In the <code>handle_connection</code> function, we create a new <code>BufReader</code> instance that
wraps a reference to the <code>stream</code>. The <code>BufReader</code> adds buffering by managing calls
to the <code>std::io::Read</code> trait methods for us.</p>
<p>在<code>handle_connection</code>函数中，我们创建一个新的<code>BufReader</code>实例，该实例包装了对<code>stream</code>的引用。<span class="highlight">[note]<code>BufReader</code>通过管理对<code>std::io::Read</code>特征方法的调用来为我们添加缓冲。</span></p>
<p>We create a variable named <code>http_request</code> to collect the lines of the request
the browser sends to our server. We indicate that we want to collect these
lines in a vector by adding the <code>Vec&lt;_&gt;</code> type annotation.</p>
<p>我们创建一个名为<code>http_request</code>的变量来收集浏览器发送给我们服务器的请求行。我们通过添加<code>Vec&lt;_&gt;</code>类型注释来表明我们希望在向量中收集这些行。</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code>
method. The <code>lines</code> method returns an iterator of <code>Result&lt;String,  std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline
byte. To get each <code>String</code>, we map and <code>unwrap</code> each <code>Result</code>. The <code>Result</code>
might be an error if the data isn’t valid UTF-8 or if there was a problem
reading from the stream. Again, a production program should handle these errors
more gracefully, but we’re choosing to stop the program in the error case for
simplicity.</p>
<p><span class="highlight">[note]<code>BufReader</code>实现了<code>std::io::BufRead</code>特征，该特征提供了<code>lines</code>方法。</span><code>lines</code>方法返回一个<code>Result&lt;String, std::io::Error&gt;</code>的迭代器，通过在每次看到换行字节时分割数据流来生成。为了获取每个<code>String</code>，我们对每个<code>Result</code>进行映射和<code>unwrap</code>。如果数据不是有效的UTF-8或者从流中读取时出现问题，则<code>Result</code>可能是一个错误。再次强调，生产程序应该更优雅地处理这些错误，但为了简单起见，我们选择在错误情况下停止程序。</p>
<p>The browser signals the end of an HTTP request by sending two newline
characters in a row, so to get one request from the stream, we take lines until
we get a line that is the empty string. Once we’ve collected the lines into the
vector, we’re printing them out using pretty debug formatting so we can take a
look at the instructions the web browser is sending to our server.</p>
<p>浏览器通过连续发送两个换行符来表示HTTP请求的结束，因此为了从流中获取一个请求，我们获取行直到得到一个空字符串。一旦将行收集到向量中，我们就使用漂亮的调试格式打印它们，以便查看Web浏览器发送给我们服务器的指令。</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<p>让我们尝试这段代码！启动程序并在Web浏览器中再次发出请求。请注意，浏览器中仍会显示错误页面，但我们终端中的程序输出现在应类似于：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>GET</code> in the first line
of the request. If the repeated connections are all requesting <em>/</em>, we know the
browser is trying to fetch <em>/</em> repeatedly because it’s not getting a response
from our program.</p>
<p>根据浏览器的不同，你可能会得到略有不同的输出。现在我们正在打印请求数据，通过查看请求第一行中<code>GET</code>之后的路径，我们可以看到为什么从一个浏览器请求获得多个连接。如果重复的连接都请求 <code>/</code>，我们知道浏览器正在尝试重复获取 <code>/</code>，因为它没有从我们的程序获得响应。</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<p>让我们分解这些请求数据以了解浏览器对我们的程序提出了什么要求。</p>
<h3 id="a-closer-look-at-an-http-request-深入了解http请求"><a class="header" href="#a-closer-look-at-an-http-request-深入了解http请求">A Closer Look at an HTTP Request 深入了解HTTP请求</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<p>HTTP是基于文本的协议，请求采用以下格式：</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request, which means it is asking for
information.</p>
<p>第一行是请求行，包含有关客户端请求内容的信息。请求行的第一部分指示使用的方法，例如<code>GET</code>或<code>POST</code>，描述了客户端如何发出此请求。我们的客户端使用了<code>GET</code>请求，这意味着它正在请求信息。</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>uniform resource
identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>uniform resource locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute <em>URL</em> for <em>URI</em> here.</p>
<p>请求行的下一部分是 <code>/</code>，表示客户端请求的统一资源标识符(URI)：URI几乎与统一资源定位符(URL)相同，但不完全相同。URI和URL之间的区别在本章中并不重要，但HTTP规范使用术语URI，因此我们可以在这里在心理上用 URL 替代 URI。</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a CRLF sequence. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
<em>CRLF sequence</em> separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>最后一部分是客户端使用的HTTP版本，然后请求行以CRLF序列结束。（CRLF代表回车和换行，这是来自打字机时代的术语！）CRLF序列也可以写成<code>\r\n</code>，其中<code>\r</code>是回车，<code>\n</code>是换行。CRLF序列将请求行与请求数据的其余部分分开。请注意，当打印CRLF时，我们看到的是新行开始而不是<code>\r\n</code>。</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>查看我们到目前为止运行程序收到的请求行数据，我们看到<code>GET</code>是方法，<code>/</code> 是请求URI，<code>HTTP/1.1</code>是版本。</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>在请求行之后，从<code>Host:</code>开始的行是头部。<code>GET</code>请求没有正文。</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>尝试从不同的浏览器发出请求或请求不同的地址，例如 <code>127.0.0.1:7878/test</code>，以查看请求数据如何变化。</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<p>现在我们知道了浏览器请求的内容，让我们发回一些数据！</p>
<h3 id="writing-a-response-编写响应"><a class="header" href="#writing-a-response-编写响应">Writing a Response 编写响应</a></h3>
<p>We’re going to implement sending data in response to a client request.
Responses have the following format:</p>
<p>我们将实现发送数据以响应客户端请求。响应具有以下格式：</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>第一行是状态行，包含响应中使用的HTTP版本、总结请求结果的数字状态码以及提供状态码文本描述的原因短语。在CRLF序列之后是任何头部、另一个CRLF序列和响应的正文。</p>
<p>Here is an example response that uses HTTP version 1.1, and has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<p>这是一个使用HTTP版本1.1、状态码200（OK原因短语）、无头部和无正文的响应示例：</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 21-3.</p>
<p>状态码200是标准的成功响应。这段文本是一个微小的成功HTTP响应。让我们将其写入流作为对成功请求的响应！从<code>handle_connection</code>函数中，删除打印请求数据的<code>println!</code>，并将其替换为代码清单21-3中的代码。</p>
<figure class="listing" id="listing-21-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-21-3">Listing 21-3</a>: Writing a tiny successful HTTP response to the stream 将微小的成功HTTP响应写入流</figcaption>
</figure>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection. Because the <code>write_all</code> operation
could fail, we use <code>unwrap</code> on any error result as before. Again, in a real
application you would add error handling here.</p>
<p>第一行定义了<code>response</code>变量，该变量保存成功消息的数据。然后我们在<code>response</code>上调用<code>as_bytes</code>将字符串数据转换为字节。<code>stream</code>上的<code>write_all</code>方法接受一个<code>&amp;[u8]</code>并将这些字节直接发送到连接。因为<code>write_all</code>操作可能失败，所以我们像以前一样对任何错误结果使用<code>unwrap</code>。再次强调，在实际应用中，你应该在此处添加错误处理。</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just handcoded receiving an HTTP
request and sending a response!</p>
<p>通过这些更改，让我们运行代码并发出请求。我们不再向终端打印任何数据，因此除了Cargo的输出外，不会看到任何输出。当你在Web浏览器中加载 <code>127.0.0.1:7878</code> 时，应该得到一个空白页面而不是错误。你刚刚手动编写了接收HTTP请求和发送响应的代码！</p>
<h3 id="returning-real-html-返回真实的html"><a class="header" href="#returning-real-html-返回真实的html">Returning Real HTML 返回真实的HTML</a></h3>
<p>Let’s implement the functionality for returning more than a blank page. Create
the new file <em>hello.html</em> in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 21-4 shows one
possibility.</p>
<p>让我们实现返回超过空白页面的功能。在你的项目目录的根目录（而不是 <code>src</code> 目录）中创建新文件 <code>hello.html</code>。你可以输入任何你想要的HTML；代码清单21-4展示了一种可能性。</p>
<figure class="listing" id="listing-21-4">
<span class="file-name">Filename: hello.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption><a href="#listing-21-4">Listing 21-4</a>: A sample HTML file to return in a response 要在响应中返回的示例HTML文件</figcaption>
</figure>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 21-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p>这是一个最小的HTML5文档，包含一个标题和一些文本。为了在收到请求时从服务器返回此内容，我们将修改<code>handle_connection</code>，如代码清单21-5所示，读取HTML文件，将其作为正文添加到响应中并发送。</p>
<figure class="listing" id="listing-21-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-21-5">Listing 21-5</a>: Sending the contents of <em>hello.html</em> as the body of the response 发送<em>hello.html</em>的内容作为响应的正文</figcaption>
</figure>
<p>We’ve added <code>fs</code> to the <code>use</code> statement to bring the standard library’s
filesystem module into scope. The code for reading the contents of a file to a
string should look familiar; we used it when we read the contents of a file for
our I/O project in Listing 12-4.</p>
<p>我们已将<code>fs</code>添加到<code>use</code>语句中，以将标准库的文件系统模块引入作用域。将文件内容读取到字符串的代码应该很熟悉；我们在列表12-4中的I/O项目中读取文件内容时使用过它。</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header
which is set to the size of our response body, in this case the size of
<code>hello.html</code>.</p>
<p>接下来，我们使用<code>format!</code>将文件的内容添加为成功响应的正文。为确保有效的HTTP响应，我们添加了<code>Content-Length</code>头部，该头部设置为响应正文的大小，即<code>hello.html</code>的大小。</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>使用<code>cargo run</code>运行此代码，并在浏览器中加载 <code>127.0.0.1:7878</code>；你应该看到HTML被渲染！</p>
<p>Currently, we’re ignoring the request data in <code>http_request</code> and just sending
back the contents of the HTML file unconditionally. That means if you try
requesting <em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get
back this same HTML response. At the moment, our server is very limited and
does not do what most web servers do. We want to customize our responses
depending on the request and only send back the HTML file for a well-formed
request to <em>/</em>.</p>
<p>目前，我们忽略了<code>http_request</code>中的请求数据，只是无条件地发送回HTML文件的内容。这意味着如果你在浏览器中尝试请求_127.0.0.1:7878/something-else_，你仍将获得相同的HTML响应。目前，我们的服务器非常有限，没有执行大多数Web服务器的操作。我们希望根据请求自定义响应，并且仅对格式正确的 <code>/</code> 请求发送回HTML文件。</p>
<h3 id="validating-the-request-and-selectively-responding-验证请求并有选择地响应"><a class="header" href="#validating-the-request-and-selectively-responding-验证请求并有选择地响应">Validating the Request and Selectively Responding 验证请求并有选择地响应</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 21-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p>目前，无论客户端请求什么，我们的Web服务器都将返回文件中的HTML。让我们添加功能来检查浏览器是否请求 <code>/</code>，然后再返回HTML文件，如果浏览器请求其他任何内容，则返回错误。为此，我们需要修改<code>handle_connection</code>，如代码清单21-6所示。这段新代码将接收到的请求内容与我们已知的 <code>/</code> 请求进行比较，并添加<code>if</code>和<code>else</code>块以区别处理请求。</p>
<figure class="listing" id="listing-21-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<figcaption><a href="#listing-21-6">Listing 21-6</a>: Handling requests to <em>/</em> differently from other requests 以不同于其他请求的方式处理对*/*的请求</figcaption>
</figure>
<p>We’re only going to be looking at the first line of the HTTP request, so rather
than reading the entire request into a vector, we’re calling <code>next</code> to get the
first item from the iterator. The first <code>unwrap</code> takes care of the <code>Option</code> and
stops the program if the iterator has no items. The second <code>unwrap</code> handles the
<code>Result</code> and has the same effect as the <code>unwrap</code> that was in the <code>map</code> added in
Listing 21-2.</p>
<p>我们只关注HTTP请求的第一行，因此不是将整个请求读入向量，而是调用<code>next</code>从迭代器获取第一项。第一个<code>unwrap</code>处理<code>Option</code>，如果迭代器没有项则停止程序。第二个<code>unwrap</code>处理<code>Result</code>，其效果与代码清单21-2中添加的<code>map</code>中的<code>unwrap</code>相同。</p>
<p>Next, we check the <code>request_line</code> to see if it equals the request line of a GET
request to the <em>/</em> path. If it does, the <code>if</code> block returns the contents of our
HTML file.</p>
<p>接下来，我们检查<code>request_line</code>是否等于对 <code>/</code> 路径的GET请求行。如果是，<code>if</code>块返回HTML文件的内容。</p>
<p>If the <code>request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it
means we’ve received some other request. We’ll add code to the <code>else</code> block in
a moment to respond to all other requests.</p>
<p>如果<code>request_line</code>不等于对 <code>/</code> 路径的GET请求，则意味着我们收到了其他请求。我们将很快在<code>else</code>块中添加代码以响应所有其他请求。</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 21-1 and Listing 21-2.</p>
<p>现在运行此代码并请求 <code>127.0.0.1:7878</code>；你应该获得 <code>hello.html</code> 中的HTML。如果你发出任何其他请求，例如 <code>127.0.0.1:7878/something-else</code>，你将得到连接错误，类似于运行代码清单21-1和21-2中的代码时看到的错误。</p>
<p>Now let’s add the code in Listing 21-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p>现在让我们将代码清单21-7中的代码添加到<code>else</code>块，以返回状态码404的响应，该状态码表示未找到请求的内容。我们还将返回一些HTML，以便在浏览器中呈现页面向最终用户指示响应。</p>
<figure class="listing" id="listing-21-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-21-7">Listing 21-7</a>: Responding with status code 404 and an error page if anything other than <em>/</em> was requested 如果请求了*/*以外的任何内容，则响应状态码404和错误页面</figcaption>
</figure>
<p>Here, our response has a status line with status code 404 and the reason phrase
<code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>.
You’ll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error
page; again feel free to use any HTML you want or use the example HTML in
Listing 21-8.</p>
<p>这里，我们的响应有一个状态行，状态码为404，原因短语为<code>NOT FOUND</code>。响应的正文将是文件<code>404.html</code> 中的HTML。你需要在 <code>hello.html</code> 旁边创建一个 <code>404.html</code> 文件作为错误页面；同样，你可以使用任何你想要的HTML，或使用代码清单21-8中的示例HTML。</p>
<figure class="listing" id="listing-21-8">
<span class="file-name">Filename: 404.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption><a href="#listing-21-8">Listing 21-8</a>: Sample content for the page to send back with any 404 response 随任何404响应发送回的页面内容示例</figcaption>
</figure>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should
return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<p>通过这些更改，再次运行你的服务器。请求 <code>127.0.0.1:7878</code> 应返回 <code>hello.html</code> 的内容，而任何其他请求（如 <code>127.0.0.1:7878/foo</code>）应返回 <code>404.html</code> 中的错误HTML。</p>
<h3 id="a-touch-of-refactoring-重构一下"><a class="header" href="#a-touch-of-refactoring-重构一下">A Touch of Refactoring 重构一下</a></h3>
<p>At the moment, the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables; we
can then use those variables unconditionally in the code to read the file and
write the response. Listing 21-9 shows the resultant code after replacing the
large <code>if</code> and <code>else</code> blocks.</p>
<p>目前，<code>if</code>和<code>else</code>块有很多重复：它们都读取文件并将文件内容写入流。唯一的区别是状态行和文件名。让我们通过将这些差异提取到单独的<code>if</code>和<code>else</code>行来使代码更简洁，这些行将状态行和文件名的值分配给变量；然后我们可以在代码中无条件地使用这些变量来读取文件和写入响应。在用较小的<code>if</code>和<code>else</code>块替换大型块后，代码清单21-9显示了结果代码。</p>
<figure class="listing" id="listing-21-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-21-9">Listing 21-9</a>: Refactoring the <code>if</code> and <code>else</code> blocks to contain only the code that differs between the two cases 重构<code>if</code>和<code>else</code>块以仅包含两种情况之间不同的代码</figcaption>
</figure>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 19.</p>
<p>现在<code>if</code>和<code>else</code>块仅返回元组中状态行和文件名的适当值；然后我们使用解构将这些值分配给<code>status_line</code>和<code>filename</code>，使用<code>let</code>语句中的模式，如第19章所述。</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 21-9 will be the same as that in
Listing 21-7.</p>
<p>以前重复的代码现在位于<code>if</code>和<code>else</code>块之外，并使用<code>status_line</code>和<code>filename</code>变量。这样可以更清楚地看到两种情况之间的差异，并且意味着如果我们想更改文件读取和响应写入的工作方式，我们只有一个地方可以更新代码。代码清单21-9中的代码行为将与代码清单21-7中的行为相同。</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>太棒了！我们现在有了一个大约40行Rust代码的简单Web服务器，它用一个内容页面响应一个请求，并用404响应所有其他请求。</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<p>目前，我们的服务器在单个线程中运行，这意味着它一次只能处理一个请求。让我们通过模拟一些慢速请求来检查这可能有什么问题。然后我们将修复它，使我们的服务器能够同时处理多个请求。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-02-multithreaded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-02-multithreaded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
