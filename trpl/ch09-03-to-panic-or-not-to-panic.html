<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>To panic! or Not to panic! 该使用 panic! 还是不该用 panic! - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="to-panic-or-not-to-panic-该使用-panic-还是不该用-panic"><a class="header" href="#to-panic-or-not-to-panic-该使用-panic-还是不该用-panic">To <code>panic!</code> or Not to <code>panic!</code> 该使用 <code>panic!</code> 还是不该用 <code>panic!</code></a></h2>
<p>So how do you decide when you should call <code>panic!</code> and when you should return
<code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code>
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision that a situation is unrecoverable on behalf of
the calling code. When you choose to return a <code>Result</code> value, you give the
calling code options. The calling code could choose to attempt to recover in a
way that’s appropriate for its situation, or it could decide that an <code>Err</code>
value in this case is unrecoverable, so it can call <code>panic!</code> and turn your
recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a
good default choice when you’re defining a function that might fail.</p>
<p>那么该如何决定何时应该调用 <code>panic!</code> 以及何时应该返回 <code>Result</code> 呢？当代码 panic 时，是没有恢复途径的。你可以在任何错误场景下调用 <code>panic!</code>，无论是否存在可能的恢复方式，但这样做就意味着你代表调用代码做出了该场景不可恢复的决定。当你选择返回 <code>Result</code> 值时，则赋予了调用代码选择权。调用代码可以根据自身情况选择尝试恢复，或者判定此处的 <code>Err</code> 值不可恢复，从而调用 <code>panic!</code> 将你的可恢复错误转为不可恢复错误。因此，在定义可能失败的函数时，返回 <code>Result</code> 是良好的默认选择。</p>
<p>In situations such as examples, prototype code, and tests, it’s more
appropriate to write code that panics instead of returning a <code>Result</code>. Let’s
explore why, then discuss situations in which the compiler can’t tell that
failure is impossible, but you as a human can. The chapter will conclude with
some general guidelines on how to decide whether to panic in library code.</p>
<p>在示例、原型代码和测试等场景中，编写 panic 的代码比返回 <code>Result</code> 更合适。我们将探讨原因，然后讨论编译器无法判断失败不可能发生、但开发者可以确认的情况。本章最后会给出在库代码中决定是否 panic 的通用指导原则。</p>
<h3 id="examples-prototype-code-and-tests-示例原型代码和测试"><a class="header" href="#examples-prototype-code-and-tests-示例原型代码和测试">Examples, Prototype Code, and Tests 示例、原型代码和测试</a></h3>
<p>When you’re writing an example to illustrate some concept, also including
robust error-handling code can make the example less clear. In examples, it’s
understood that a call to a method like <code>unwrap</code> that could panic is meant as a
placeholder for the way you’d want your application to handle errors, which can
differ based on what the rest of your code is doing.</p>
<p>当你编写示例阐述某个概念时，包含健壮的错误处理代码反而会降低示例的清晰度。在示例中，像 <code>unwrap</code> 这类可能 panic 的方法调用，应被理解为应用程序错误处理方式的占位符——具体处理方式可能因代码其他部分而异。</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.</p>
<p>类似地，在原型设计阶段，当你尚未决定如何处理错误时，<code>unwrap</code> 和 <code>expect</code> 方法非常方便。它们会在代码中留下清晰的标记，便于后续改进程序的健壮性。</p>
<p>If a method call fails in a test, you’d want the whole test to fail, even if
that method isn’t the functionality under test. Because <code>panic!</code> is how a test
is marked as a failure, calling <code>unwrap</code> or <code>expect</code> is exactly what should
happen.</p>
<p>如果测试中的方法调用失败，即使该方法并非被测功能，你也希望整个测试失败。因为 <code>panic!</code> 正是标记测试失败的方式，此时调用 <code>unwrap</code> 或 <code>expect</code> 是完全合理的。</p>
<h3 id="cases-in-which-you-have-more-information-than-the-compiler-你比编译器掌握更多信息的情况"><a class="header" href="#cases-in-which-you-have-more-information-than-the-compiler-你比编译器掌握更多信息的情况">Cases in Which You Have More Information Than the Compiler 你比编译器掌握更多信息的情况</a></h3>
<p>It would also be appropriate to call <code>expect</code> when you have some other logic
that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t
something the compiler understands. You’ll still have a <code>Result</code> value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an <code>Err</code> variant, it’s perfectly acceptable to call <code>expect</code> and document
the reason you think you’ll never have an <code>Err</code> variant in the argument text.
Here’s an example:</p>
<p>当你通过其他逻辑确保 <code>Result</code> 必定是 <code>Ok</code> 值，但该逻辑超出编译器理解范围时，调用 <code>expect</code> 也是合适的。此时你仍需处理 <code>Result</code> 值：从普遍角度看，被调用的操作仍有失败可能，尽管在你的特定场景中逻辑上不可能发生。若通过人工检查代码能确保绝不会出现 <code>Err</code> 变体，那么调用 <code>expect</code> 并在参数文本中说明原因完全可接受。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see
that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>expect</code>
here. However, having a hardcoded, valid string doesn’t change the return type
of the <code>parse</code> method: we still get a <code>Result</code> value, and the compiler will
still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility
because the compiler isn’t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore <em>did</em> have a possibility of failure,
we’d definitely want to handle the <code>Result</code> in a more robust way instead.
Mentioning the assumption that this IP address is hardcoded will prompt us to
change <code>expect</code> to better error-handling code if, in the future, we need to get
the IP address from some other source instead.</p>
<p>这里通过解析硬编码字符串创建 <code>IpAddr</code> 实例。显然 <code>127.0.0.1</code> 是有效 IP 地址，因此使用 <code>expect</code> 合理。但硬编码的有效字符串不会改变 <code>parse</code> 方法的返回类型：我们依然得到 <code>Result</code> 值，编译器仍会要求我们处理该 <code>Result</code>（仿佛可能出现 <code>Err</code> 变体），因为编译器无法智能推断此字符串永远有效。如果 IP 地址字符串来自用户输入而非硬编码（即确实可能失败），我们必然需要用更健壮的方式处理 <code>Result</code>。此处注明 IP 地址是硬编码的假设，能促使我们在未来需要从其他来源获取 IP 时，将 <code>expect</code> 升级为更好的错误处理代码。</p>
<h3 id="guidelines-for-error-handling-错误处理指导原则"><a class="header" href="#guidelines-for-error-handling-错误处理指导原则">Guidelines for Error Handling 错误处理指导原则</a></h3>
<p>It’s advisable to have your code panic when it’s possible that your code could
end up in a bad state. In this context, a <em>bad state</em> is when some assumption,
guarantee, contract, or invariant has been broken, such as when invalid values,
contradictory values, or missing values are passed to your code—plus one or
more of the following:</p>
<p>当代码可能陷入坏状态（bad state）时，建议直接 panic。此处的<strong>坏状态</strong>指某些假设、保证、契约或不变量被破坏的情况，例如向代码传入无效值、矛盾值或缺失值，且满足以下至少一个条件：</p>
<ul>
<li>The bad state is something that is unexpected, as opposed to something that
will likely happen occasionally, like a user entering data in the wrong
format.</li>
<li>该坏状态是意外事件，而非偶尔会发生的情况（如用户输入格式错误）</li>
<li>Your code after this point needs to rely on not being in this bad state,
rather than checking for the problem at every step.</li>
<li>后续代码需要依赖不处于此坏状态的前提，而非每一步都检查问题</li>
<li>There’s not a good way to encode this information in the types you use. We’ll
work through an example of what we mean in “Encoding States and Behavior as
Types” in Chapter 18.</li>
<li>无法通过类型系统有效编码此信息（第 18 章“将状态和行为编码为类型“将举例说明）</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, it’s
best to return an error if you can so the user of the library can decide what
they want to do in that case. However, in cases where continuing could be
insecure or harmful, the best choice might be to call <code>panic!</code> and alert the
person using your library to the bug in their code so they can fix it during
development. Similarly, <code>panic!</code> is often appropriate if you’re calling
external code that is out of your control and it returns an invalid state that
you have no way of fixing.</p>
<p>若用户调用代码时传入无意义的值，最佳实践是返回错误（以便库使用者决定处理方式）。但当继续执行可能导致安全隐患时，调用 <code>panic!</code> 告警并提示使用者修复代码缺陷更为合适。同样，当调用不受控的外部代码返回无效状态且无法修复时，<code>panic!</code> 也常适用。</p>
<p>However, when failure is expected, it’s more appropriate to return a <code>Result</code>
than to make a <code>panic!</code> call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a <code>Result</code> indicates that failure is an
expected possibility that the calling code must decide how to handle.</p>
<p>但预期可能失败时（如解析器收到畸形数据、HTTP 请求返回速率限制状态），返回 <code>Result</code> 比调用 <code>panic!</code> 更合适。这表明失败是预期内的可能性，需由调用代码决定处理策略。</p>
<p>When your code performs an operation that could put a user at risk if it’s
called using invalid values, your code should verify the values are valid first
and panic if the values aren’t valid. This is mostly for safety reasons:
attempting to operate on invalid data can expose your code to vulnerabilities.
This is the main reason the standard library will call <code>panic!</code> if you attempt
an out-of-bounds memory access: trying to access memory that doesn’t belong to
the current data structure is a common security problem. Functions often have
<em>contracts</em>: their behavior is only guaranteed if the inputs meet particular
requirements. Panicking when the contract is violated makes sense because a
contract violation always indicates a caller-side bug, and it’s not a kind of
error you want the calling code to have to explicitly handle. In fact, there’s
no reasonable way for calling code to recover; the calling <em>programmers</em> need
to fix the code. Contracts for a function, especially when a violation will
cause a panic, should be explained in the API documentation for the function.</p>
<p>当代码执行可能因无效值危及用户安全的操作时，应优先验证值有效性并在无效时 panic。这主要出于安全考量：无效数据操作可能导致漏洞。标准库在内存越界访问时调用 <code>panic!</code> 正源于此——访问不属于当前数据结构的内存是常见安全问题。函数通常存在<strong>契约</strong>（contract）：仅当输入满足特定要求时行为才有保证。违反契约时 panic 是合理的，因为契约破坏总是调用方 bug，且不应由调用代码显式处理。事实上，调用代码无法合理恢复；需要<strong>程序员</strong>修复代码。函数的契约（尤其是违反会导致 panic 时）应在 API 文档中说明。</p>
<p>However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking done by the compiler) to do many of the checks for you. If your
function has a particular type as a parameter, you can proceed with your code’s
logic knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an <code>Option</code>, your program expects to
have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle
two cases for the <code>Some</code> and <code>None</code> variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type such as <code>u32</code>, which ensures
the parameter is never negative.</p>
<p>然而在所有函数中大量检查错误会冗长繁琐。幸运的是，可利用 Rust 类型系统（及编译器的类型检查）自动完成多数检查。若函数参数为特定类型，可确信编译器已确保值有效。例如，使用非 <code>Option</code> 类型时，程序预期必有值而非空值。代码无需处理 <code>Some</code> 和 <code>None</code> 两种变体，只需处理确定有值的情况。尝试传入空值的代码甚至无法编译，因此函数无需在运行时检查该情况。另一个例子是使用 <code>u32</code> 等无符号整数类型可确保参数永不小于零。</p>
<h3 id="creating-custom-types-for-validation-创建自定义类型进行验证"><a class="header" href="#creating-custom-types-for-validation-创建自定义类型进行验证">Creating Custom Types for Validation 创建自定义类型进行验证</a></h3>
<p>Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when the user guesses a number that’s out of range versus when the
user types, for example, letters instead.</p>
<p>让我们进一步利用 Rust 类型系统确保值有效性，探索如何创建验证用的自定义类型。回顾第 2 章的猜数游戏：代码要求用户猜测 1 到 100 之间的数字，但在与秘密数字比较前从未验证用户猜测值是否在此范围内，仅验证了其为正数。此时后果不严重：“过高/过低“的反馈仍正确。但引导用户有效猜测，并对越界输入与字母输入等行为区别处理，会是实用增强。</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a
<code>u32</code> to allow potentially negative numbers, and then add a check for the
number being in range, like so:</p>
<p>一种实现方式是将猜测值解析为 <code>i32</code>（而非仅 <code>u32</code>）以允许负数，然后检查范围：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</figure>
<p>The <code>if</code> expression checks whether our value is out of range, tells the user
about the problem, and calls <code>continue</code> to start the next iteration of the loop
and ask for another guess. After the <code>if</code> expression, we can proceed with the
comparisons between <code>guess</code> and the secret number knowing that <code>guess</code> is
between 1 and 100.</p>
<p><code>if</code> 表达式检查值是否越界，向用户反馈问题并调用 <code>continue</code> 重启循环等待新输入。此后进行猜测值与秘密数字比较时，可确信 <code>guess</code> 必在 1 到 100 之间。</p>
<p>However, this is not an ideal solution: if it were absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).</p>
<p>但这不是理想方案：若程序必须严格操作 1 到 100 的值，且多个函数有此要求，在每个函数重复此检查将冗长乏味（并可能影响性能）。</p>
<p>Instead, we can make a new type in a dedicated module and put the validations in
a function to create an instance of the type rather than repeating the
validations everywhere. That way, it’s safe for functions to use the new type in
their signatures and confidently use the values they receive. Listing 9-13 shows
one way to define a <code>Guess</code> type that will only create an instance of <code>Guess</code> if
the <code>new</code> function receives a value between 1 and 100.</p>
<p>替代方案是在专用模块中创建新类型，并将验证逻辑放在创建类型实例的函数中（而非到处重复）。这样函数可安全地在签名中使用新类型，并放心使用接收到的值。代码清单 9-13 展示了定义 <code>Guess</code> 类型的方式：仅当 <code>new</code> 函数收到 1 到 100 的值时才创建实例。</p>
<figure class="listing" id="listing-9-13">
<span class="file-name">Filename: src/guessing_game.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-13">Listing 9-13</a>: A <code>Guess</code> type that will only continue with values between 1 and 100 仅允许值在 1 到 100 之间的 <code>Guess</code> 类型</figcaption>
</figure>
<p>Note that this code in <em>src/guessing_game.rs</em> depends on adding a module
declaration <code>mod guessing_game;</code> in <em>src/lib.rs</em> that we haven’t shown here.
Within this new module’s file, we define a struct in that module named <code>Guess</code>
that has a field named <code>value</code> that holds an <code>i32</code>. This is where the number
will be stored.</p>
<p>注意 <em>src/guessing_game.rs</em> 中的代码依赖于在 <em>src/lib.rs</em> 中添加未展示的模块声明 <code>mod guessing_game;</code>。在此新模块文件中，我们定义包含 <code>i32</code> 类型字段 <code>value</code> 的结构体 <code>Guess</code>（该字段存储数值）。</p>
<p>Then we implement an associated function named <code>new</code> on <code>Guess</code> that creates
instances of <code>Guess</code> values. The <code>new</code> function is defined to have one
parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the
body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100.
If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would
violate the contract that <code>Guess::new</code> is relying on. The conditions in which
<code>Guess::new</code> might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a <code>panic!</code> in the API documentation that you create in Chapter 14. If
<code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set
to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>随后为 <code>Guess</code> 实现关联函数 <code>new</code> 来创建实例。<code>new</code> 函数定义为：接收 <code>i32</code> 类型参数 <code>value</code>，返回 <code>Guess</code>。函数体中的代码会检验 <code>value</code> 是否在 1 到 100 之间。若未通过检验，则调用 <code>panic!</code> 提醒调用代码的开发者修复 bug——因为在此范围外创建 <code>Guess</code> 将违反 <code>Guess::new</code> 依赖的契约。<code>Guess::new</code> <span class="highlight">[note]可能 panic 的条件应在其公开 API 文档中说明</span>；第 14 章将介绍如何在 API 文档中标注 <code>panic!</code> 可能性。若通过检验，则用 <code>value</code> 参数创建新 <code>Guess</code> 并返回。</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any
other parameters, and returns an <code>i32</code>. This kind of method is sometimes called
a <em>getter</em> because its purpose is to get some data from its fields and return
it. This public method is necessary because the <code>value</code> field of the <code>Guess</code>
struct is private. It’s important that the <code>value</code> field be private so code
using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: code outside
the <code>guessing_game</code> module <em>must</em> use the <code>Guess::new</code> function to create an
instance of <code>Guess</code>, thereby ensuring there’s no way for a <code>Guess</code> to have a
<code>value</code> that hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>接着实现方法 <code>value</code>：借用 <code>self</code>，无其他参数，返回 <code>i32</code>。此类方法称为<strong>获取器</strong>（getter），因其用于从字段提取数据。由于 <code>Guess</code> 结构体的 <code>value</code> 字段是私有的，此公开方法很有必要。<code>value</code> 的私有性确保了外部代码无法直接设置该值：<code>guessing_game</code> 模块外的代码<strong>必须</strong>通过 <code>Guess::new</code> 创建实例，从而保证 <code>Guess</code> 的值必已通过 <code>Guess::new</code> 的条件检查。</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a <code>Guess</code> rather than an
<code>i32</code> and wouldn’t need to do any additional checks in its body.</p>
<p>接收或返回 1 到 100 数字的函数，可在签名中声明使用 <code>Guess</code> 类型（而非 <code>i32</code>），无需在函数体内额外检查。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>Rust’s error-handling features are designed to help you write more robust code.
The <code>panic!</code> macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
<code>Result</code> to tell code that calls your code that it needs to handle potential
success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate
situations will make your code more reliable in the face of inevitable problems.</p>
<p>Rust 的错误处理功能旨在助你编写更健壮的代码。<code>panic!</code> 宏表示程序遇到无法处理的状态，让进程停止而非用无效值继续执行。<code>Result</code> 枚举则利用类型系统表明操作可能失败（但代码可恢复）。通过 <code>Result</code> 可告知调用代码需处理潜在的成功或失败。在适当场景使用 <code>panic!</code> 和 <code>Result</code> 能使代码在面临问题时更可靠。</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with
the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you
can use them in your code.</p>
<p>既然你已见识标准库如何高效利用泛型（通过 <code>Option</code> 和 <code>Result</code> 枚举），接下来我们将探讨泛型的工作原理及如何在代码中使用它们。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
