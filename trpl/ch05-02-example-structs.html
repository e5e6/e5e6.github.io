<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>An Example Program Using Structs 使用结构体的示例程序 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="an-example-program-using-structs-使用结构体的示例程序"><a class="header" href="#an-example-program-using-structs-使用结构体的示例程序">An Example Program Using Structs 使用结构体的示例程序</a></h2>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start by using single variables, and
then refactor the program until we’re using structs instead.</p>
<p>为了理解何时使用结构体，我们将编写一个计算矩形面积的程序。首先使用单变量实现，然后逐步重构，最终用结构体替代。</p>
<p>Let’s make a new binary project with Cargo called <em>rectangles</em> that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s <em>src/main.rs</em>.</p>
<p>使用 Cargo 创建一个名为 <em>rectangles</em> 的二进制项目，它将接收以像素为单位的矩形宽度和高度，并计算矩形面积。代码清单 5-8 展示了项目 <em>src/main.rs</em> 中的实现方式：</p>
<figure class="listing" id="listing-5-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<figcaption><a href="#listing-5-8">Listing 5-8</a>: Calculating the area of a rectangle specified by separate width and height variables 通过独立的宽高变量计算矩形面积</figcaption>
</figure>
<p>Now, run this program using <code>cargo run</code>:</p>
<p>使用 <code>cargo run</code> 运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the
<code>area</code> function with each dimension, but we can do more to make this code clear
and readable.</p>
<p>此代码通过向 <code>area</code> 函数传入两个维度成功计算出面积，但我们可以优化代码使其更清晰易读。</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<p>问题体现在 <code>area</code> 的函数签名中：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters, and it’s not clear anywhere in our
program that the parameters are related. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in “The Tuple Type” section
of Chapter 3: by using tuples.</p>
<p><code>area</code> 函数本应计算单个矩形面积，但我们编写的函数有两个参数，且参数间的关联性不明确。将宽高组合在一起会更清晰易管理。第三章的[“元组类型”]章节已讨论过用元组实现的方式。</p>
<h3 id="refactoring-with-tuples--使用元组重构"><a class="header" href="#refactoring-with-tuples--使用元组重构">Refactoring with Tuples  使用元组重构</a></h3>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<p>代码清单 5-9 展示了使用元组的版本：</p>
<figure class="listing" id="listing-5-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<figcaption><a href="#listing-5-9">Listing 5-9</a>: Specifying the width and height of the rectangle with a tuple 使用元组表示矩形宽高</figcaption>
</figure>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so we have to index into the parts of
the tuple, making our calculation less obvious.</p>
<p>一方面此版本更优：元组提供了基础结构，且只需传递一个参数。但另一方面清晰度下降：元组元素未命名，需通过索引访问，降低了计算逻辑的直观性。</p>
<p>Mixing up the width and height wouldn’t matter for the area calculation, but if
we want to draw the rectangle on the screen, it would matter! We would have to
keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple
index <code>1</code>. This would be even harder for someone else to figure out and keep in
mind if they were to use our code. Because we haven’t conveyed the meaning of
our data in our code, it’s now easier to introduce errors.</p>
<p>混淆宽高虽不影响面积计算，但在屏幕绘制矩形时会产生问题！我们必须记住 <code>width</code> 对应元组索引 <code>0</code>，<code>height</code> 对应索引 <code>1</code>。这对其他使用者而言更易出错，因为我们未在代码中体现数据的含义。</p>
<h3 id="refactoring-with-structs-adding-more-meaning-使用结构体重构增强语义"><a class="header" href="#refactoring-with-structs-adding-more-meaning-使用结构体重构增强语义">Refactoring with Structs: Adding More Meaning 使用结构体重构：增强语义</a></h3>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a struct with a name for the whole as well as names for the
parts, as shown in Listing 5-10.</p>
<p>我们通过结构体为数据添加标签来明确含义。如代码清单 5-10 所示，可将元组转换为具有整体命名和字段命名的结构体：</p>
<figure class="listing" id="listing-5-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<figcaption><a href="#listing-5-10">Listing 5-10</a>: Defining a <code>Rectangle</code> struct 定义 <code>Rectangle</code> 结构体</figcaption>
</figure>
<p>Here, we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly
brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have
type <code>u32</code>. Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code>
that has a width of <code>30</code> and a height of <code>50</code>.</p>
<p>这里定义了名为 <code>Rectangle</code> 的结构体，其内部包含 <code>u32</code> 类型的 <code>width</code> 和 <code>height</code> 字段。在 <code>main</code> 中创建了宽 <code>30</code>、高 <code>50</code> 的结构体实例。</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p><code>area</code> 函数现在接收一个名为 <code>rectangle</code> 的参数，其类型是对 <code>Rectangle</code> 实例的不可变借用。如第四章所述，我们选择借用而非获取所有权，这样 <code>main</code> 函数可保留所有权并继续使用 <code>rect1</code>，这也是函数签名和使用处添加 <code>&amp;</code> 的原因。</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code>
instance (note that accessing fields of a borrowed struct instance does not
move the field values, which is why you often see borrows of structs). Our
function signature for <code>area</code> now says exactly what we mean: calculate the area
of <code>Rectangle</code>, using its <code>width</code> and <code>height</code> fields. This conveys that the
width and height are related to each other, and it gives descriptive names to
the values rather than using the tuple index values of <code>0</code> and <code>1</code>. This is a
win for clarity.</p>
<p><code>area</code> 函数访问 <code>Rectangle</code> 实例的字段（注意：访问借用结构体的字段不会移动值）。现在的函数签名精准表达了意图：利用 <code>width</code> 和 <code>height</code> 字段计算矩形面积。这明确了宽高的关联性，并提供了描述性名称而非元组索引 <code>0</code> 和 <code>1</code>，显著提升了代码清晰度。</p>
<h3 id="adding-useful-functionality-with-derived-traits-通过派生-trait-增加实用功能"><a class="header" href="#adding-useful-functionality-with-derived-traits-通过派生-trait-增加实用功能">Adding Useful Functionality with Derived Traits 通过派生 trait 增加实用功能</a></h3>
<p>It’d be useful to be able to print an instance of <code>Rectangle</code> while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the <code>println!</code> macro as we have used in
previous chapters. This won’t work, however.</p>
<p>调试时若能打印 <code>Rectangle</code> 实例及其字段值将非常有用。代码清单 5-11 尝试使用 <code>println!</code> 宏，但无法正常工作：</p>
<figure class="listing" id="listing-5-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1}");
}</code></pre>
<figcaption><a href="#listing-5-11">Listing 5-11</a>: Attempting to print a <code>Rectangle</code> instance 尝试打印 <code>Rectangle</code> 实例</figcaption>
</figure>
<p>When we compile this code, we get an error with this core message:</p>
<p>编译时将出现核心错误信息：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, the curly
brackets tell <code>println!</code> to use formatting known as <code>Display</code>: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement <code>Display</code> by default because there’s only one way you’d want to show
a <code>1</code> or any other primitive type to a user. But with structs, the way
<code>println!</code> should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn’t try to guess what we want, and structs don’t have a provided
implementation of <code>Display</code> to use with <code>println!</code> and the <code>{}</code> placeholder.</p>
<p><code>println!</code> 宏支持多种格式化，默认花括号要求使用 <code>Display</code> 格式（面向最终用户的输出）。基础类型默认实现 <code>Display</code>，但结构体存在多种显示方式（是否加逗号/花括号？显示哪些字段？），因此 Rust 不进行猜测，结构体也未提供 <code>Display</code> 实现。</p>
<p>If we continue reading the errors, we’ll find this helpful note:</p>
<p>继续阅读错误会发现提示：</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Let’s try it! The <code>println!</code> macro call will now look like <code>println!("rect1 is  {rect1:?}");</code>. Putting the specifier <code>:?</code> inside the curly brackets tells
<code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code> trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.</p>
<p>尝试修改为 <code>println!("rect1 是 {rect1:?}");</code>。在花括号内添加 <code>:?</code> 指定使用 <code>Debug</code> 输出格式，该 trait 专为开发者设计，可在调试时查看值。</p>
<p>Compile the code with this change. Drat! We still get an error:</p>
<p>但修改后仍报错：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<p>编译器再次给出提示：</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>does</em> include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the outer attribute <code>#[derive(Debug)]</code> just before the
struct definition, as shown in Listing 5-12.</p>
<p>Rust 包含调试输出功能，但需显式为结构体启用。如代码清单 5-12 所示，在结构体定义前添加 <code>#[derive(Debug)]</code> 属性：</p>
<figure class="listing" id="listing-5-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<figcaption><a href="#listing-5-12">Listing 5-12</a>: Adding the attribute to derive the <code>Debug</code> trait and printing the <code>Rectangle</code> instance using debug formatting 添加派生 <code>Debug</code> 属性并使用调试格式化输出</figcaption>
</figure>
<p>Now when we run the program, we won’t get any errors, and we’ll see the
following output:</p>
<p>运行程序将成功输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string. In
this example, using the <code>{:#?}</code> style will output the following:</p>
<p>虽然输出不够美观，但完整展示了字段值，对调试极有帮助。大型结构体可使用 <code>{:#?}</code> 替代 <code>{:?}</code> 获得更易读的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Another way to print out a value using the <code>Debug</code> format is to use the <code>dbg!</code>
macro, which takes ownership of an expression (as opposed
to <code>println!</code>, which takes a reference), prints the file and line number of
where that <code>dbg!</code> macro call occurs in your code along with the resultant value
of that expression, and returns ownership of the value.</p>
<p>另一种调试方式是使用 <code>dbg!</code> 宏。它会获取表达式所有权（而 <code>println!</code> 使用引用），输出调用位置的文件名、行号及结果值，并返回所有权。</p>
<section class="note" aria-role="note">
<p>Note: Calling the <code>dbg!</code> macro prints to the standard error console stream
(<code>stderr</code>), as opposed to <code>println!</code>, which prints to the standard output
console stream (<code>stdout</code>). We’ll talk more about <code>stderr</code> and <code>stdout</code> in the
“Writing Error Messages to Standard Error Instead of Standard Output”
section in Chapter 12.</p>
<p>注意：<code>dbg!</code> 输出到标准错误流（<code>stderr</code>），而 <code>println!</code> 输出到标准输出流（<code>stdout</code>）。第十二章[“将错误信息输出到标准错误流”]将详细讨论。</p>
</section>
<p>Here’s an example where we’re interested in the value that gets assigned to the
<code>width</code> field, as well as the value of the whole struct in <code>rect1</code>:</p>
<p>以下示例同时查看 <code>width</code> 字段和整个结构体的值：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>We can put <code>dbg!</code> around the expression <code>30 * scale</code> and, because <code>dbg!</code>
returns ownership of the expression’s value, the <code>width</code> field will get the
same value as if we didn’t have the <code>dbg!</code> call there. We don’t want <code>dbg!</code> to
take ownership of <code>rect1</code>, so we use a reference to <code>rect1</code> in the next call.
Here’s what the output of this example looks like:</p>
<p>将 <code>dbg!</code> 置于表达式 <code>30 * scale</code> 周围时，因其返回表达式值的所有权，<code>width</code> 字段仍会获得原值。后续调用中使用 <code>rect1</code> 的引用避免所有权转移。输出如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>We can see the first bit of output came from <em>src/main.rs</em> line 10 where we’re
debugging the expression <code>30 * scale</code>, and its resultant value is <code>60</code> (the
<code>Debug</code> formatting implemented for integers is to print only their value). The
<code>dbg!</code> call on line 14 of <em>src/main.rs</em> outputs the value of <code>&amp;rect1</code>, which is
the <code>Rectangle</code> struct. This output uses the pretty <code>Debug</code> formatting of the
<code>Rectangle</code> type. The <code>dbg!</code> macro can be really helpful when you’re trying to
figure out what your code is doing!</p>
<p>首行输出来自 <em>src/main.rs</em> 第 10 行对 <code>30 * scale</code> 的调试（结果为 <code>60</code>）。第 14 行输出 <code>&amp;rect1</code> 的值（即 <code>Rectangle</code> 结构体）。<code>dbg!</code> 宏在代码调试中极为实用！</p>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us
to use with the <code>derive</code> attribute that can add useful behavior to our custom
types. Those traits and their behaviors are listed in Appendix C. We’ll cover how to implement these traits with custom behavior as
well as how to create your own traits in Chapter 10. There are also many
attributes other than <code>derive</code>; for more information, see the “Attributes”
section of the Rust Reference.</p>
<p>除 <code>Debug</code> 外，Rust 还提供大量可通过 <code>derive</code> 属性派生的 trait（附录 C 列出完整列表），它们能为自定义类型添加有用行为。第十章将介绍如何实现自定义 trait 及创建新 trait。更多属性详见 Rust 参考手册的[“属性”]章节。</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code> struct
because it won’t work with any other type. Let’s look at how we can continue to
refactor this code by turning the <code>area</code> function into an <code>area</code> <em>method</em>
defined on our <code>Rectangle</code> type.</p>
<p>当前 <code>area</code> 函数仅适用于矩形。若能将此行为与 <code>Rectangle</code> 结构体更紧密绑定将更合理。接下来我们将把 <code>area</code> 函数重构为 <code>Rectangle</code> 类型的<strong>方法</strong>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-01-defining-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-03-method-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-01-defining-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-03-method-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
