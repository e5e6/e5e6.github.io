<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How to Write Tests 如何编写测试 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="how-to-write-tests-如何编写测试"><a class="header" href="#how-to-write-tests-如何编写测试">How to Write Tests 如何编写测试</a></h2>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<p>测试是用于验证非测试代码是否按预期方式运行的 Rust 函数。测试函数通常执行以下三个操作：</p>
<ul>
<li>Set up any needed data or state.</li>
<li>设置所需数据或状态</li>
<li>Run the code you want to test.</li>
<li>运行要测试的代码</li>
<li>Assert that the results are what you expect.</li>
<li>断言结果符合预期</li>
</ul>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<p>让我们看看 Rust 为这些操作提供的功能，包括 <code>test</code> 属性、几个宏和 <code>should_panic</code> 属性。</p>
<h3 id="the-anatomy-of-a-test-function-测试函数剖析"><a class="header" href="#the-anatomy-of-a-test-function-测试函数剖析">The Anatomy of a Test Function 测试函数剖析</a></h3>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the annotated functions and reports on whether each test function passes or
fails.</p>
<p>最简单的 Rust 测试是一个用 <code>test</code> 属性标注的函数。属性是 Rust 代码的元数据；例如我们在第五章为结构体使用的 <code>derive</code> 属性。<span class="highlight">[note]要将函数转为测试函数，需在 <code>fn</code> 前添加 <code>#[test]</code>。</span>当使用 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试运行程序二进制文件来执行带注解的函数，并报告每个测试函数的通过或失败情况。</p>
<p>Whenever we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module gives you a
template for writing your tests so you don’t have to look up the exact
structure and syntax every time you start a new project. You can add as many
additional test functions and as many test modules as you want!</p>
<p>当我们用 Cargo 创建新的库项目时，它会自动生成包含测试函数的测试模块。该模块为编写测试提供了模板，无需每次新建项目时都查找确切结构和语法。你可以根据需要添加任意数量的测试函数和测试模块！</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test before we actually test any code. Then we’ll write some real-world tests
that call some code that we’ve written and assert that its behavior is correct.</p>
<p>我们将通过模板测试实验测试的工作机制，然后再实际测试代码。接着会编写调用已实现代码的真实测试，并断言其行为正确。</p>
<p>Let’s create a new library project called <code>adder</code> that will add two numbers:</p>
<p>创建名为 <code>adder</code> 的新库项目来对数字求和：</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like
Listing 11-1.</p>
<p><code>adder</code> 库中 <em>src/lib.rs</em> 文件的内容应如示例 11-1 所示。</p>
<figure class="listing" id="listing-11-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-1">Listing 11-1</a>: The code generated automatically by <code>cargo new</code> <code>cargo new</code> 自动生成的代码</figcaption>
</figure>
<p>The file starts with an example <code>add</code> function, so that we have something
to test.</p>
<p>文件以示例 <code>add</code> 函数开头，以便我们有测试目标。</p>
<p>For now, let’s focus solely on the <code>it_works</code> function. Note the <code>#[test]</code>
annotation: this attribute indicates this is a test function, so the test
runner knows to treat this function as a test. We might also have non-test
functions in the <code>tests</code> module to help set up common scenarios or perform
common operations, so we always need to indicate which functions are tests.</p>
<p>现在，让我们专注于 <code>it_works</code> 函数。注意 <code>#[test]</code> 注解：该属性表示这是测试函数，测试运行器会将其视为测试。<code>tests</code> 模块中可能还有用于设置公共场景或执行公共操作的非测试函数，因此我们始终需要标注哪些函数是测试。</p>
<p>The example function body uses the <code>assert_eq!</code> macro to assert that <code>result</code>,
which contains the result of calling <code>add</code> with 2 and 2, equals 4. This
assertion serves as an example of the format for a typical test. Let’s run it
to see that this test passes.</p>
<p>示例函数体使用 <code>assert_eq!</code> 宏断言调用 <code>add(2, 2)</code> 的结果 <code>result</code> 等于 4。该断言展示了典型测试的格式。运行它可以看到测试通过。</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2.</p>
<p><code>cargo test</code> 命令运行项目中的所有测试，如示例 11-2 所示。</p>
<figure class="listing" id="listing-11-2">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<figcaption><a href="#listing-11-2">Listing 11-2</a>: The output from running the automatically generated test 运行自动生成测试的输出</figcaption>
</figure>
<p>Cargo compiled and ran the test. We see the line <code>running 1 test</code>. The next
line shows the name of the generated test function, called <code>tests::it_works</code>,
and that the result of running that test is <code>ok</code>. The overall summary <code>test  result: ok.</code> means that all the tests passed, and the portion that reads <code>1  passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>Cargo 编译并运行了测试。我们看到 <code>running 1 test</code> 行。下一行显示生成的测试函数名 <code>tests::it_works</code>，其运行结果为 <code>ok</code>。总结行 <code>test result: ok.</code> 表示所有测试通过，<code>1 passed; 0 failed</code> 部分统计了通过和失败的测试数。</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular
instance; we’ll cover that in the “Ignoring Some Tests Unless Specifically
Requested” section later in this chapter. Because we
haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an
argument to the <code>cargo test</code> command to run only tests whose name matches a
string; this is called <em>filtering</em> and we’ll cover it in the “Running a
Subset of Tests by Name” section. Here we haven’t
filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>可以将测试标记为忽略（ignored）使其在特定情况下不运行；本章稍后的“除非特别指定否则忽略某些测试”部分将介绍这一点。由于我们未使用该功能，总结显示 <code>0 ignored</code>。我们还可以向 <code>cargo test</code> 命令传递参数，仅运行名称匹配字符串的测试（称为<em>过滤</em>），这将在“按名称运行测试子集”部分介绍。这里未过滤运行的测试，因此总结末尾显示 <code>0 filtered out</code>。</p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
the documentation about benchmark tests to learn more.</p>
<p>基准测试的统计数据 <code>0 measured</code> 用于衡量性能。基准测试目前仅在 Rust 的 nightly 版本中可用。请参阅基准测试的文档以了解更多信息。</p>
<p>The next part of the test output starting at <code>Doc-tests adder</code> is for the
results of any documentation tests. We don’t have any documentation tests yet,
but Rust can compile any code examples that appear in our API documentation.
This feature helps keep your docs and your code in sync! We’ll discuss how to
write documentation tests in the “Documentation Comments as
Tests” section of Chapter 14. For now, we’ll
ignore the <code>Doc-tests</code> output.</p>
<p>测试输出中从 <code>Doc-tests adder</code> 开始的部分是文档测试的结果。我们尚无文档测试，但 Rust 可以编译 API 文档中出现的任何代码示例。此功能有助于保持文档与代码同步！我们将在第十四章的“将文档注释作为测试”部分讨论如何编写文档测试。现在暂时忽略 <code>Doc-tests</code> 输出。</p>
<p>Let’s start to customize the test to our own needs. First, change the name of
the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p>现在开始根据需求定制测试。首先将 <code>it_works</code> 函数重命名为 <code>exploration</code>：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<p>再次运行 <code>cargo test</code>，输出现在显示 <code>exploration</code> 而非 <code>it_works</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests
fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. In Chapter 9, we talked about how the simplest way to panic
is to call the <code>panic!</code> macro. Enter the new test as a function named
<code>another</code>, so your <em>src/lib.rs</em> file looks like Listing 11-3.</p>
<p>现在添加另一个测试，但这次让它失败！当测试函数中出现 panic 时测试失败。<span class="highlight">[note]每个测试在新线程中运行</span>，当主线程检测到测试线程终止时，该测试被标记为失败。第九章提到，触发 panic 最简单的方式是调用 <code>panic!</code> 宏。添加名为 <code>another</code> 的新测试，使 <em>src/lib.rs</em> 如示例 11-3 所示。</p>
<figure class="listing" id="listing-11-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
<figcaption><a href="#listing-11-3">Listing 11-3</a>: Adding a second test that will fail because we call the <code>panic!</code> macro 添加第二个会因调用 <code>panic!</code> 宏而失败的测试</figcaption>
</figure>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<p>再次运行 <code>cargo test</code>，输出应如示例 11-4 所示，表明 <code>exploration</code> 测试通过而 <code>another</code> 失败。</p>
<figure class="listing" id="listing-11-4">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<figcaption><a href="#listing-11-4">Listing 11-4</a>: Test results when one test passes and one test fails 一个测试通过、一个测试失败时的测试结果</figcaption>
</figure>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
displays the detailed reason for each test failure. In this case, we get the
details that <code>tests::another</code> failed because it panicked with the message <code>Make  this test fail</code> on line 17 in the <em>src/lib.rs</em> file. The next section lists
just the names of all the failing tests, which is useful when there are lots of
tests and lots of detailed failing test output. We can use the name of a
failing test to run just that test to more easily debug it; we’ll talk more
about ways to run tests in the “Controlling How Tests Are
Run” section.</p>
<p><code>test tests::another</code> 行显示 <code>FAILED</code> 而非 <code>ok</code>。单个结果和总结之间出现两个新部分：第一部分详细说明每个测试失败的原因。本例中，<code>tests::another</code> 在 <em>src/lib.rs</em> 文件的第 17 行因 <code>Make this test fail</code> 消息而 panic。下一部分仅列出所有失败测试的名称，这在测试众多且失败输出详细时非常有用。我们可以使用失败测试的名称单独运行它以方便调试；“控制测试的运行方式”部分将详细介绍运行测试的方法。</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We
had one test pass and one test fail.</p>
<p>总结行显示在最后：总体测试结果为 <code>FAILED</code>。我们有一个测试通过，一个测试失败。</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<p>现在你已了解不同场景下的测试结果，让我们看看除 <code>panic!</code> 外其他在测试中有用的宏。</p>
<h3 id="checking-results-with-the-assert-macro-使用-assert-宏检查结果"><a class="header" href="#checking-results-with-the-assert-macro-使用-assert-宏检查结果">Checking Results with the <code>assert!</code> Macro 使用 <code>assert!</code> 宏检查结果</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the
<code>assert!</code> macro calls <code>panic!</code> to cause the test to fail. Using the <code>assert!</code>
macro helps us check that our code is functioning in the way we intend.</p>
<p>标准库提供的 <code>assert!</code> 宏用于确保测试中的条件评估为 <code>true</code>。我们向 <code>assert!</code> 宏传递一个布尔值参数。若值为 <code>true</code>，无事发生且测试通过；若为 <code>false</code>，<code>assert!</code> 宏调用 <code>panic!</code> 导致测试失败。使用 <code>assert!</code> 宏有助于验证代码是否按预期运行。</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file, then write some tests for it using the <code>assert!</code> macro.</p>
<p>第五章的示例 5-15 使用了 <code>Rectangle</code> 结构体和 <code>can_hold</code> 方法，它们在示例 11-5 中重复出现。我们将此代码放入 <em>src/lib.rs</em> 文件，然后用 <code>assert!</code> 宏为其编写测试。</p>
<figure class="listing" id="listing-11-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<figcaption><a href="#listing-11-5">Listing 11-5</a>: The <code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter 5 来自第五章的 <code>Rectangle</code> 结构体及其 <code>can_hold</code> 方法</figcaption>
</figure>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and
a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that
has a width of 5 and a height of 1.</p>
<p><code>can_hold</code> 方法返回布尔值，是 <code>assert!</code> 宏的完美用例。在示例 11-6 中，我们通过创建宽 8 高 7 的 <code>Rectangle</code> 实例来测试 <code>can_hold</code> 方法，并断言它可以容纳宽 5 高 1 的另一个 <code>Rectangle</code> 实例。</p>
<figure class="listing" id="listing-11-6">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<figcaption><a href="#listing-11-6">Listing 11-6</a>: A test for <code>can_hold</code> that checks whether a larger rectangle can indeed hold a smaller rectangle 测试 <code>can_hold</code>：检查较大矩形是否能容纳较小矩形</figcaption>
</figure>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is
a regular module that follows the usual visibility rules we covered in Chapter
7 in the “Paths for Referring to an Item in the Module
Tree”
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here, so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>注意 <code>tests</code> 模块内的 <code>use super::*;</code> 行。<code>tests</code> 是遵循第七章“模块树中引用项的路径”部分介绍的常规可见性规则的普通模块。由于 <code>tests</code> 是内部模块，我们需要将外部模块中待测试的代码引入内部模块的作用域。这里使用全局导入（glob），因此外部模块定义的任何内容对 <code>tests</code> 模块都可用。</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<p>我们将测试命名为 <code>larger_can_hold_smaller</code>，并创建所需两个 <code>Rectangle</code> 实例。接着调用 <code>assert!</code> 宏并传入 <code>larger.can_hold(&amp;smaller)</code> 的结果。该表达式应返回 <code>true</code>，因此测试应通过。让我们验证一下！</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p>确实通过了！现在添加另一个测试，断言较小矩形无法容纳较大矩形：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<p>由于此场景中 <code>can_hold</code> 的正确结果是 <code>false</code>，我们需要在传递给 <code>assert!</code> 宏前取反该结果。因此，若 <code>can_hold</code> 返回 <code>false</code>，测试将通过：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code>
method by replacing the greater-than sign with a less-than sign when it
compares the widths:</p>
<p>两个测试均通过！现在看看在代码中引入错误时测试结果如何变化。我们将 <code>can_hold</code> 方法中比较宽度的大于号改为小于号：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running the tests now produces the following:</p>
<p>现在运行测试会产生以下结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is
<code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<p>测试捕获了错误！因为 <code>larger.width</code> 是 <code>8</code> 而 <code>smaller.width</code> 是 <code>5</code>，<code>can_hold</code> 中的宽度比较现在返回 <code>false</code>：8 不小于 5。</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros-使用-assert_eq-和-assert_ne-宏测试相等性"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros-使用-assert_eq-和-assert_ne-宏测试相等性">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros 使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏测试相等性</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could
do this by using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, without printing the values that led to the <code>false</code> value.</p>
<p>验证功能的常见方法是测试被测代码的结果与预期返回值是否相等。可以使用 <code>assert!</code> 宏传递 <code>==</code> 运算符的表达式实现。但这是如此常见的测试，以至于标准库提供了一对宏——<code>assert_eq!</code> 和 <code>assert_ne!</code>——来更便捷地执行此测试。这些宏分别比较两个参数是否相等或不相等。若断言失败，它们还会打印两个值，便于查看失败<em>原因</em>；而 <code>assert!</code> 宏仅显示 <code>==</code> 表达式得到 <code>false</code> 值，不打印导致 <code>false</code> 的值。</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter, then we test this function using the <code>assert_eq!</code> macro.</p>
<p>在示例 11-7 中，我们编写函数 <code>add_two</code> 将参数加 <code>2</code>，然后用 <code>assert_eq!</code> 宏测试该函数。</p>
<figure class="listing" id="listing-11-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-7">Listing 11-7</a>: Testing the function <code>add_two</code> using the <code>assert_eq!</code> macro 使用 <code>assert_eq!</code> 宏测试函数 <code>add_two</code></figcaption>
</figure>
<p>Let’s check that it passes!</p>
<p>运行验证是否通过：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We create a variable named <code>result</code> that holds the result of calling
<code>add_two(2)</code>. Then we pass <code>result</code> and <code>4</code> as the arguments to the
<code>assert_eq!</code> macro. The output line for this test is <code>test tests::it_adds_two  ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>我们创建变量 <code>result</code> 保存调用 <code>add_two(2)</code> 的结果，然后将 <code>result</code> 和 <code>4</code> 作为参数传递给 <code>assert_eq!</code> 宏。该测试的输出行是 <code>test tests::it_adds_two ... ok</code>，其中 <code>ok</code> 表示测试通过！</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<p>现在在代码中引入错误，将 <code>add_two</code> 函数的实现改为加 <code>3</code>：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Run the tests again:</p>
<p>再次运行测试：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our test caught the bug! The <code>tests::it_adds_two</code> test failed, and the message
tells us that the assertion that failed was <code>left == right</code> and what the <code>left</code>
and <code>right</code> values are. This message helps us start debugging: the <code>left</code>
argument, where we had the result of calling <code>add_two(2)</code>, was <code>5</code> but the
<code>right</code> argument was <code>4</code>. You can imagine that this would be especially helpful
when we have a lot of tests going on.</p>
<p>测试捕获了错误！<code>tests::it_adds_two</code> 测试失败，消息指出失败的断言是 <code>left == right</code> 并显示了 <code>left</code> 和 <code>right</code> 的值。这有助于我们开始调试：<code>left</code> 参数（即 <code>add_two(2)</code> 的调用结果）是 <code>5</code>，而 <code>right</code> 参数是 <code>4</code>。可以想象，这在测试众多时尤其有用。</p>
<p>Note that in some languages and test frameworks, the parameters to equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Rust, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value
the code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(4, result)</code>, which would result in the same failure message that
displays <code> assertion `left == right` failed</code>.</p>
<p>注意，在某些语言和测试框架中，相等断言函数的参数称为 <code>expected</code> 和 <code>actual</code>，指定参数的顺序很重要。但在 Rust 中，它们称为 <code>left</code> 和 <code>right</code>，指定期望值和代码产生值的顺序无关紧要。本测试中的断言可写为 <code>assert_eq!(4, result)</code>，失败消息同样显示 <code> assertion `left == right` failed</code>。</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but the way in which the input is changed depends on the day of
the week that we run our tests, the best thing to assert might be that the
output of the function is not equal to the input.</p>
<p><code>assert_ne!</code> 宏在给定两个值不相等时通过，相等时失败。当我们不确定值<em>将</em>是什么，但明确知道它<em>不应</em>是什么时，此宏最有用。例如，若测试一个保证会以某种方式修改输入的函数，而修改方式取决于运行测试的星期几，此时最好的断言可能是函数的输出不等于输入。</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of
the standard library types implement these traits. For structs and enums that
you define yourself, you’ll need to implement <code>PartialEq</code> to assert equality of
those types. You’ll also need to implement <code>Debug</code> to print the values when the
assertion fails. Because both traits are derivable traits, as mentioned in
Listing 5-12 in Chapter 5, this is usually as straightforward as adding the
<code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See
Appendix C, “Derivable Traits,” for more
details about these and other derivable traits.</p>
<p><span class="highlight">[note]在底层，<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏分别使用 <code>==</code> 和 <code>!=</code> 运算符。断言失败时，这些宏使用调试格式打印参数，这意味着被比较的值必须实现 <code>PartialEq</code> 和 <code>Debug</code> 特征。</span>所有基本类型和大多数标准库类型都实现了这些特征。对于自定义的结构体和枚举，需要实现 <code>PartialEq</code> 才能断言其相等性，还需实现 <code>Debug</code> 才能在断言失败时打印值。由于这两个特征都是可派生的（如第五章的示例 5-12 所述），通常只需在结构体或枚举定义中添加 <code>#[derive(PartialEq, Debug)]</code> 注解即可。更多细节见附录 C 的“可派生特征”。</p>
<h3 id="adding-custom-failure-messages-添加自定义失败消息"><a class="header" href="#adding-custom-failure-messages-添加自定义失败消息">Adding Custom Failure Messages 添加自定义失败消息</a></h3>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in “Concatenation with the <code>+</code> Operator or the
<code>format!</code> Macro” in Chapter 8), so you can pass a format string that contains <code>{}</code>
placeholders and values to go in those placeholders. Custom messages are useful
for documenting what an assertion means; when a test fails, you’ll have a better
idea of what the problem is with the code.</p>
<p>你还<span class="highlight">[note]可以向 <code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏传递可选参数作为自定义消息，随失败消息一起打印。在必需参数后指定的任何参数都会传递给 <code>format!</code> 宏</span>（第八章“使用 <code>+</code> 运算符或 <code>format!</code> 宏进行拼接”中讨论过），因此可以传递包含 <code>{}</code> 占位符的格式字符串及其填充值。自定义消息有助于记录断言的含义；测试失败时，你能更好地理解代码的问题所在。</p>
<p>For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:</p>
<p>例如，假设有函数根据名字问候他人，我们需要测试传入函数的名字是否出现在输出中：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
<code>greeting</code> function, we’ll just assert that the output contains the text of the
input parameter.</p>
<p>该程序的需求尚未确定，我们非常确定问候语开头的 <code>Hello</code> 文本会更改。为避免需求变更时更新测试，我们决定不检查 <code>greeting</code> 函数返回值的完全相等性，仅断言输出包含输入参数的文本。</p>
<p>Now let’s introduce a bug into this code by changing <code>greeting</code> to exclude
<code>name</code> to see what the default test failure looks like:</p>
<p>现在通过修改 <code>greeting</code> 函数排除 <code>name</code> 来引入错误，观察默认测试失败情况：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running this test produces the following:</p>
<p>运行此测试产生以下结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message would print the value from the
<code>greeting</code> function. Let’s add a custom failure message composed of a format
string with a placeholder filled in with the actual value we got from the
<code>greeting</code> function:</p>
<p>此结果仅表明断言失败及其所在行号。更有用的失败消息应打印 <code>greeting</code> 函数的值。让我们添加由格式字符串和实际值填充的自定义失败消息：</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<p>现在运行测试时，会得到信息更丰富的错误消息：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<p>我们可以在测试输出中看到实际获得的值，这有助于调试实际发生的情况与预期情况的差异。</p>
<h3 id="checking-for-panics-with-should_panic-使用-should_panic-检查-panic"><a class="header" href="#checking-for-panics-with-should_panic-使用-should_panic-检查-panic">Checking for Panics with <code>should_panic</code> 使用 <code>should_panic</code> 检查 panic</a></h3>
<p>In addition to checking return values, it’s important to check that our code
handles error conditions as we expect. For example, consider the <code>Guess</code> type
that we created in Chapter 9, Listing 9-13. Other code that uses <code>Guess</code>
depends on the guarantee that <code>Guess</code> instances will contain only values
between 1 and 100. We can write a test that ensures that attempting to create a
<code>Guess</code> instance with a value outside that range panics.</p>
<p>除了检查返回值，确保代码按预期处理错误条件也很重要。例如，回顾第九章示例 9-13 创建的 <code>Guess</code> 类型。使用 <code>Guess</code> 的其他代码依赖于 <code>Guess</code> 实例仅包含 1 到 100 之间值的保证。我们可以编写测试来确保尝试在此范围外创建 <code>Guess</code> 实例会触发 panic。</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The
test passes if the code inside the function panics; the test fails if the code
inside the function doesn’t panic.</p>
<p>为此，需将 <code>should_panic</code> 属性添加到测试函数。如果函数内的代码触发 panic，测试通过；如果未触发 panic，测试失败。</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect them to.</p>
<p><span class="highlight">[note]示例 11-8 展示了测试 <code>Guess::new</code> 在预期条件下触发错误的测试。</span></p>
<figure class="listing" id="listing-11-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-8">Listing 11-8</a>: Testing that a condition will cause a <code>panic!</code> 测试条件是否导致 <code>panic!</code></figcaption>
</figure>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<p>我们将 <code>#[should_panic]</code> 属性放在 <code>#[test]</code> 属性之后、测试函数之前。观察测试通过时的结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<p>运行良好！现在通过移除 <code>new</code> 函数在值大于 100 时触发 panic 的条件来引入错误：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<p>运行示例 11-8 的测试时，它将失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>此情况下我们未获得非常有用的消息，但查看测试函数可见其标注了 <code>#[should_panic]</code>。得到的失败意味着测试函数中的代码未触发 panic。</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would
pass even if the test panics for a different reason from the one we were
expecting. To make <code>should_panic</code> tests more precise, we can add an optional
<code>expected</code> parameter to the <code>should_panic</code> attribute. The test harness will
make sure that the failure message contains the provided text. For example,
consider the modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function
panics with different messages depending on whether the value is too small or
too large.</p>
<p>使用 <code>should_panic</code> 的测试可能不够精确。即使测试因非预期原因 panic，<code>should_panic</code> 测试也会通过。<span class="highlight">[note]为使 <code>should_panic</code> 测试更精确，可向 <code>should_panic</code> 属性添加可选的 <code>expected</code> 参数。</span>测试工具将确保失败消息包含提供的文本。例如，修改示例 11-9 中 <code>Guess</code> 的代码，使 <code>new</code> 函数根据值过小或过大触发不同的消息。</p>
<figure class="listing" id="listing-11-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-9">Listing 11-9</a>: Testing for a <code>panic!</code> with a panic message containing a specified substring 测试 <code>panic!</code> 消息是否包含指定子串</figcaption>
</figure>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to  100, got 200</code>. What you choose to specify depends on how much of the panic
message is unique or dynamic and how precise you want your test to be. In this
case, a substring of the panic message is enough to ensure that the code in the
test function executes the <code>else if value &gt; 100</code> case.</p>
<p>此测试将通过，因为我们在 <code>should_panic</code> 属性的 <code>expected</code> 参数中提供的文本是 <code>Guess::new</code> 函数 panic 消息的子串。我们可以指定完整的预期 panic 消息（本例中为 <code>Guess value must be less than or equal to 100, got 200</code>）。具体指定内容取决于 panic 消息的唯一性或动态性程度，以及你期望测试的精确度。本例中，panic 消息的子串足以确保测试函数执行了 <code>else if value &gt; 100</code> 分支。</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<p>为观察带 <code>expected</code> 消息的 <code>should_panic</code> 测试失败的情况，让我们再次引入错误——交换 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 块的内容：</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<p>此时运行 <code>should_panic</code> 测试将失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>less than or equal  to 100</code>. The panic message that we did get in this case was <code>Guess value must  be greater than or equal to 1, got 200.</code> Now we can start figuring out where
our bug is!</p>
<p>失败消息表明测试确实如预期 panic 了，但 panic 消息未包含预期的 <code>less than or equal to 100</code> 字符串。实际得到的 panic 消息是 <code>Guess value must be greater than or equal to 1, got 200.</code>。现在我们可以开始定位错误了！</p>
<h3 id="using-resultt-e-in-tests-在测试中使用-resultt-e"><a class="header" href="#using-resultt-e-in-tests-在测试中使用-resultt-e">Using <code>Result&lt;T, E&gt;</code> in Tests 在测试中使用 <code>Result&lt;T, E&gt;</code></a></h3>
<p>Our tests so far all panic when they fail. We can also write tests that use
<code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code>Result&lt;T,  E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<p>目前的测试在失败时都会 panic。我们也可以编写使用 <code>Result&lt;T, E&gt;</code> 的测试！下面是示例 11-1 的测试改写为使用 <code>Result&lt;T, E&gt;</code> 并在失败时返回 <code>Err</code> 而非 panic 的版本：</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>The <code>it_works</code> function now has the <code>Result&lt;(), String&gt;</code> return type. In the
body of the function, rather than calling the <code>assert_eq!</code> macro, we return
<code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test
fails.</p>
<p><code>it_works</code> 函数现在返回 <code>Result&lt;(), String&gt;</code> 类型。在函数体中，不再调用 <code>assert_eq!</code> 宏，而是在测试通过时返回 <code>Ok(())</code>，失败时返回包含 <code>String</code> 的 <code>Err</code>。</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p><span class="highlight">[note]将测试编写为返回 <code>Result&lt;T, E&gt;</code> 的形式，允许在测试体中使用问号运算符</span>，这在测试内部操作返回 <code>Err</code> 变体时应失败的情况下非常方便。</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T,  E&gt;</code>. To assert that an operation returns an <code>Err</code> variant, <em>don’t</em> use the
question mark operator on the <code>Result&lt;T, E&gt;</code> value. Instead, use
<code>assert!(value.is_err())</code>.</p>
<p><span class="highlight">[note]不能对使用 <code>Result&lt;T, E&gt;</code> 的测试使用 <code>#[should_panic]</code> 注解。</span>要断言操作返回 <code>Err</code> 变体，请<em>勿</em>对 <code>Result&lt;T, E&gt;</code> 值使用问号运算符，而应使用 <code>assert!(value.is_err())</code>。</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo  test</code>.</p>
<p>现在你已了解多种编写测试的方法，接下来让我们探索运行测试时发生的情况及 <code>cargo test</code> 的不同选项。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
