<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paths for Referring to an Item in the Module Tree 在模块树中引用项的路径 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="paths-for-referring-to-an-item-in-the-module-tree-在模块树中引用项的路径"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree-在模块树中引用项的路径">Paths for Referring to an Item in the Module Tree 在模块树中引用项的路径</a></h2>
<p>To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. To call a function, we need to
know its path.</p>
<p>为了告诉 Rust 在模块树中查找项的位置，我们使用路径的方式类似于在文件系统中导航路径。要调用函数，我们需要知道其路径。</p>
<p>A path can take two forms:</p>
<p>路径有两种形式：</p>
<ul>
<li>An <em>absolute path</em> is the full path starting from a crate root; for code
from an external crate, the absolute path begins with the crate name, and for
code from the current crate, it starts with the literal <code>crate</code>.</li>
<li><strong>绝对路径</strong>：从 crate 根开始的完整路径。对于外部 crate 的代码，绝对路径以 crate 名称开头；对于当前 crate 的代码，则以字面量 <code>crate</code> 开头。</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or
an identifier in the current module.</li>
<li><strong>相对路径</strong>：从当前模块开始，使用 <code>self</code>、<code>super</code> 或当前模块中的标识符。</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
<p>绝对路径和相对路径后都跟着一个或多个由双冒号(<code>::</code>)分隔的标识符。</p>
<p>Returning to Listing 7-1, say we want to call the <code>add_to_waitlist</code> function.
This is the same as asking: what’s the path of the <code>add_to_waitlist</code> function?
Listing 7-3 contains Listing 7-1 with some of the modules and functions
removed.</p>
<p>回顾示例 7-1，假设我们要调用 <code>add_to_waitlist</code> 函数。这等价于询问：<code>add_to_waitlist</code> 函数的路径是什么？示例 7-3 展示了简化后的模块和函数结构。</p>
<p>We’ll show two ways to call the <code>add_to_waitlist</code> function from a new function,
<code>eat_at_restaurant</code>, defined in the crate root. These paths are correct, but
there’s another problem remaining that will prevent this example from compiling
as is. We’ll explain why in a bit.</p>
<p>我们将展示从 crate 根定义的 <code>eat_at_restaurant</code> 函数中调用 <code>add_to_waitlist</code> 的两种方式。虽然路径正确，但存在另一个问题导致此示例无法编译，稍后会解释原因。</p>
<p>The <code>eat_at_restaurant</code> function is part of our library crate’s public API, so
we mark it with the <code>pub</code> keyword. In the “Exposing Paths with the <code>pub</code>
Keyword” section, we’ll go into more detail about <code>pub</code>.</p>
<p><code>eat_at_restaurant</code> 函数是库 crate 公共 API 的一部分，因此我们用 <code>pub</code> 关键字标记它。在使用 <code>pub</code> 关键字暴露路径一节中会详细讨论 <code>pub</code>。</p>
<figure class="listing" id="listing-7-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-3">Listing 7-3</a>: Calling the <code>add_to_waitlist</code> function using absolute and relative paths 使用绝对路径和相对路径调用 <code>add_to_waitlist</code> 函数</figcaption>
</figure>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>,
we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to
start an absolute path. We then include each of the successive modules until we
make our way to <code>add_to_waitlist</code>. You can imagine a filesystem with the same
structure: we’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to
run the <code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the
crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>在 <code>eat_at_restaurant</code> 中首次调用 <code>add_to_waitlist</code> 时使用了绝对路径。由于 <code>add_to_waitlist</code> 与 <code>eat_at_restaurant</code> 同属一个 crate，我们可以用 <code>crate</code> 关键字起始绝对路径，然后逐级包含模块直到 <code>add_to_waitlist</code>。类比文件系统：要执行 <code>add_to_waitlist</code> 程序需指定路径 <code>/front_of_house/hosting/add_to_waitlist</code>；使用 <code>crate</code> 从 crate 根开始类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a
relative path. The path starts with <code>front_of_house</code>, the name of the module
defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the
filesystem equivalent would be using the path
<code>front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means
that the path is relative.</p>
<p>第二次调用时使用了相对路径。路径以 <code>front_of_house</code>（与 <code>eat_at_restaurant</code> 同级的模块名）开头。文件系统中等价路径为 <code>front_of_house/hosting/add_to_waitlist</code>。以模块名起始表示路径是相对的。</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make
based on your project, and it depends on whether you’re more likely to move
item definition code separately from or together with the code that uses the
item. For example, if we moved the <code>front_of_house</code> module and the
<code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d
need to update the absolute path to <code>add_to_waitlist</code>, but the relative path
would still be valid. However, if we moved the <code>eat_at_restaurant</code> function
separately into a module named <code>dining</code>, the absolute path to the
<code>add_to_waitlist</code> call would stay the same, but the relative path would need to
be updated. Our preference in general is to specify absolute paths because it’s
more likely we’ll want to move code definitions and item calls independently of
each other.</p>
<p>选择相对路径还是绝对路径取决于项目需求，需考虑项定义代码与使用代码是否可能分离移动。若将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数移至 <code>customer_experience</code> 模块，需更新绝对路径，但相对路径仍有效。若将 <code>eat_at_restaurant</code> 单独移至 <code>dining</code> 模块，绝对路径不变，但相对路径需更新。通常我们推荐使用绝对路径，因为更可能独立移动代码定义和调用点。</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The
errors we get are shown in Listing 7-4.</p>
<p>尝试编译示例 7-3 会发现错误，如示例 7-4 所示：</p>
<figure class="listing" id="listing-7-4">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-4">Listing 7-4</a>: Compiler errors from building the code in Listing 7-3 示例 7-3 代码的编译错误</figcaption>
</figure>
<p>The error messages say that module <code>hosting</code> is private. In other words, we
have the correct paths for the <code>hosting</code> module and the <code>add_to_waitlist</code>
function, but Rust won’t let us use them because it doesn’t have access to the
private sections. In Rust, all items (functions, methods, structs, enums,
modules, and constants) are private to parent modules by default. If you want
to make an item like a function or struct private, you put it in a module.</p>
<p>错误信息指出 <code>hosting</code> 模块是私有的。虽然路径正确，但 Rust 因无法访问私有部分而拒绝使用。在 Rust 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对父模块私有。要使函数或结构体等项私有，只需将其放入模块。</p>
<p>Items in a parent module can’t use the private items inside child modules, but
items in child modules can use the items in their ancestor modules. This is
because child modules wrap and hide their implementation details, but the child
modules can see the context in which they’re defined. To continue with our
metaphor, think of the privacy rules as being like the back office of a
restaurant: what goes on in there is private to restaurant customers, but
office managers can see and do everything in the restaurant they operate.</p>
<p>父模块中的项不能使用子模块的私有项，但子模块中的项可使用祖先模块的项。这是因为子模块封装并隐藏了实现细节，但能看见定义它们的上下文。类比餐厅后台办公室：对顾客私有，但经理可查看运营的所有细节。</p>
<p>Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. However, Rust does give
you the option to expose inner parts of child modules’ code to outer ancestor
modules by using the <code>pub</code> keyword to make an item public.</p>
<p>Rust 的模块系统默认隐藏内部实现细节，这样你就知道可以修改哪些内部代码而不破坏外部代码。当然，Rust 也提供 <code>pub</code> 关键字选项来将子模块内部代码暴露给外部祖先模块。</p>
<h3 id="exposing-paths-with-the-pub-keyword-使用-pub-关键字暴露路径"><a class="header" href="#exposing-paths-with-the-pub-keyword-使用-pub-关键字暴露路径">Exposing Paths with the <code>pub</code> Keyword 使用 <code>pub</code> 关键字暴露路径</a></h3>
<p>Let’s return to the error in Listing 7-4 that told us the <code>hosting</code> module is
private. We want the <code>eat_at_restaurant</code> function in the parent module to have
access to the <code>add_to_waitlist</code> function in the child module, so we mark the
<code>hosting</code> module with the <code>pub</code> keyword, as shown in Listing 7-5.</p>
<p>回到示例 7-4 关于 <code>hosting</code> 模块私有的错误。为了让父模块的 <code>eat_at_restaurant</code> 函数访问子模块的 <code>add_to_waitlist</code> 函数，我们用 <code>pub</code> 标记 <code>hosting</code> 模块，如示例 7-5 所示：</p>
<figure class="listing" id="listing-7-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-5">Listing 7-5</a>: Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code> 将 <code>hosting</code> 模块声明为 <code>pub</code> 以便从 <code>eat_at_restaurant</code> 使用</figcaption>
</figure>
<p>Unfortunately, the code in Listing 7-5 still results in compiler errors, as
shown in Listing 7-6.</p>
<p>但示例 7-5 仍会导致编译错误，如示例 7-6 所示：</p>
<figure class="listing" id="listing-7-6">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-6">Listing 7-6</a>: Compiler errors from building the code in Listing 7-5 示例 7-5 代码的编译错误</figcaption>
</figure>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting</code> makes the
module public. With this change, if we can access <code>front_of_house</code>, we can
access <code>hosting</code>. But the <em>contents</em> of <code>hosting</code> are still private; making the
module public doesn’t make its contents public. The <code>pub</code> keyword on a module
only lets code in its ancestor modules refer to it, not access its inner code.
Because modules are containers, there’s not much we can do by only making the
module public; we need to go further and choose to make one or more of the
items within the module public as well.</p>
<p>原因何在？在 <code>mod hosting</code> 前添加 <code>pub</code> 使模块公开后，若能访问 <code>front_of_house</code> 就能访问 <code>hosting</code>，但 <code>hosting</code> 的<strong>内容</strong>仍私有。模块的 <code>pub</code> 关键字仅允许祖先模块引用它，而非访问其内部代码。由于模块是容器，仅公开模块作用有限，还需进一步选择公开模块内的一个或多个项。</p>
<p>The errors in Listing 7-6 say that the <code>add_to_waitlist</code> function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.</p>
<p>示例 7-6 的错误表明 <code>add_to_waitlist</code> 函数是私有的。隐私规则同样适用于结构体、枚举、函数、方法和模块。</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code>
keyword before its definition, as in Listing 7-7.</p>
<p>我们在 <code>add_to_waitlist</code> 函数定义前添加 <code>pub</code> 关键字使其公开，如示例 7-7 所示：</p>
<figure class="listing" id="listing-7-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-7">Listing 7-7</a>: Adding the <code>pub</code> keyword to <code>mod hosting</code> and <code>fn add_to_waitlist</code> lets us call the function from <code>eat_at_restaurant</code> 给 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字</figcaption>
</figure>
<p>Now the code will compile! To see why adding the <code>pub</code> keyword lets us use
these paths in <code>eat_at_restaurant</code> with respect to the privacy rules, let’s look
at the absolute and the relative paths.</p>
<p>现在代码可以编译了！关于为何添加 <code>pub</code> 后能在 <code>eat_at_restaurant</code> 使用这些路径，让我们从隐私规则角度分析绝对路径和相对路径：</p>
<p>In the absolute path, we start with <code>crate</code>, the root of our crate’s module
tree. The <code>front_of_house</code> module is defined in the crate root. While
<code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is
defined in the same module as <code>front_of_house</code> (that is, <code>eat_at_restaurant</code>
and <code>front_of_house</code> are siblings), we can refer to <code>front_of_house</code> from
<code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can
access the parent module of <code>hosting</code>, so we can access <code>hosting</code>. Finally, the
<code>add_to_waitlist</code> function is marked with <code>pub</code> and we can access its parent
module, so this function call works!</p>
<p><strong>绝对路径</strong>：从 <code>crate</code>（crate 模块树的根）开始。<code>front_of_house</code> 模块定义在 crate 根中。虽然 <code>front_of_house</code> 非公开，但因 <code>eat_at_restaurant</code> 与它定义在同一模块（即它们是同级），可以从 <code>eat_at_restaurant</code> 引用 <code>front_of_house</code>。接着是用 <code>pub</code> 标记的 <code>hosting</code> 模块，我们能访问其父模块，故可访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> 且我们能访问其父模块，因此函数调用成立！</p>
<p>In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
<code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module
as <code>eat_at_restaurant</code>, so the relative path starting from the module in which
<code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and
<code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this
function call is valid!</p>
<p><strong>相对路径</strong>：逻辑与绝对路径相同，仅第一步不同：路径从 <code>front_of_house</code> 而非 crate 根开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义在同一模块内，因此从 <code>eat_at_restaurant</code> 所在模块开始的相对路径有效。之后因 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径剩余部分有效，函数调用成立！</p>
<p>If you plan on sharing your library crate so other projects can use your code,
your public API is your contract with users of your crate that determines how
they can interact with your code. There are many considerations around managing
changes to your public API to make it easier for people to depend on your
crate. These considerations are beyond the scope of this book; if you’re
interested in this topic, see The Rust API Guidelines.</p>
<p>若计划共享库 crate 供其他项目使用，公共 API 就是你与 crate 用户之间的契约。管理公共 API 变更有许多考量点，这些超出了本书范围；若感兴趣可参阅《Rust API 指南》。</p>
<section class="note" aria-role="note">
<h4 id="best-practices-for-packages-with-a-binary-and-a-library-含二进制和库的包的最佳实践"><a class="header" href="#best-practices-for-packages-with-a-binary-and-a-library-含二进制和库的包的最佳实践">Best Practices for Packages with a Binary and a Library 含二进制和库的包的最佳实践</a></h4>
<p>We mentioned that a package can contain both a <em>src/main.rs</em> binary crate
root as well as a <em>src/lib.rs</em> library crate root, and both crates will have
the package name by default. Typically, packages with this pattern of
containing both a library and a binary crate will have just enough code in the
binary crate to start an executable that calls code defined in the library
crate. This lets other projects benefit from the most functionality that the
package provides because the library crate’s code can be shared.</p>
<p>我们提到包可同时包含 <em>src/main.rs</em> 二进制 crate 根和 <em>src/lib.rs</em> 库 crate 根，且两者默认使用包名。通常这类包中，二进制 crate 只包含启动执行代码并调用库 crate 定义的代码。这样其他项目可最大程度复用包的功能，因为库 crate 的代码可共享。</p>
<p>The module tree should be defined in <em>src/lib.rs</em>. Then, any public items can
be used in the binary crate by starting paths with the name of the package.
The binary crate becomes a user of the library crate just like a completely
external crate would use the library crate: it can only use the public API.
This helps you design a good API; not only are you the author, you’re also a
client!</p>
<p>模块树应在 <em>src/lib.rs</em> 中定义。然后二进制 crate 可通过以包名开头的路径使用所有公共项。二进制 crate 成为库 crate 的用户，就像完全外部 crate 那样：只能使用公共 API。这有助于设计良好 API，因为你既是作者也是客户！</p>
<p>In Chapter 12, we’ll demonstrate this organizational
practice with a command line program that will contain both a binary crate
and a library crate.</p>
<p>第 12 章将通过命令行程序演示此实践，该程序将包含二进制 crate 和库 crate。</p>
</section>
<h3 id="starting-relative-paths-with-super-使用-super-起始相对路径"><a class="header" href="#starting-relative-paths-with-super-使用-super-起始相对路径">Starting Relative Paths with <code>super</code> 使用 <code>super</code> 起始相对路径</a></h3>
<p>We can construct relative paths that begin in the parent module, rather than
the current module or the crate root, by using <code>super</code> at the start of the
path. This is like starting a filesystem path with the <code>..</code> syntax that means
to go to the parent directory. Using <code>super</code> allows us to reference an item
that we know is in the parent module, which can make rearranging the module
tree easier when the module is closely related to the parent but the parent
might be moved elsewhere in the module tree someday.</p>
<p>通过在路径开头使用 <code>super</code>，可以构建起始于父模块而非当前模块或 crate 根的相对路径。这类似于文件系统中用 <code>..</code> 表示进入父目录。使用 <code>super</code> 允许引用已知在父模块中的项，当模块与父模块紧密关联但未来可能移动时，能简化模块树重组。</p>
<p>Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function <code>fix_incorrect_order</code> defined in the <code>back_of_house</code> module calls the
function <code>deliver_order</code> defined in the parent module by specifying the path to
<code>deliver_order</code>, starting with <code>super</code>.</p>
<p>考虑示例 7-8 的代码，模拟厨师修正错误订单并亲自送给顾客的场景。定义在 <code>back_of_house</code> 模块的 <code>fix_incorrect_order</code> 函数，通过以 <code>super</code> 起始的路径调用父模块中的 <code>deliver_order</code> 函数。</p>
<figure class="listing" id="listing-7-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<figcaption><a href="#listing-7-8">Listing 7-8</a>: Calling a function using a relative path starting with <code>super</code> 使用以 <code>super</code> 开头的相对路径调用函数</figcaption>
</figure>
<p>The <code>fix_incorrect_order</code> function is in the <code>back_of_house</code> module, so we can
use <code>super</code> to go to the parent module of <code>back_of_house</code>, which in this case
is <code>crate</code>, the root. From there, we look for <code>deliver_order</code> and find it.
Success! We think the <code>back_of_house</code> module and the <code>deliver_order</code> function
are likely to stay in the same relationship to each other and get moved
together should we decide to reorganize the crate’s module tree. Therefore, we
used <code>super</code> so we’ll have fewer places to update code in the future if this
code gets moved to a different module.</p>
<p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，因此可用 <code>super</code> 访问其父模块（此处是 crate 根）。在此找到 <code>deliver_order</code> 并成功调用！我们认为 <code>back_of_house</code> 模块和 <code>deliver_order</code> 函数很可能保持相互关系，若重组模块树会一起移动。因此使用 <code>super</code> 后，未来移动这些代码时需修改的地方更少。</p>
<h3 id="making-structs-and-enums-public-公开结构体和枚举"><a class="header" href="#making-structs-and-enums-public-公开结构体和枚举">Making Structs and Enums Public 公开结构体和枚举</a></h3>
<p>We can also use <code>pub</code> to designate structs and enums as public, but there are a
few extra details to the usage of <code>pub</code> with structs and enums. If we use <code>pub</code>
before a struct definition, we make the struct public, but the struct’s fields
will still be private. We can make each field public or not on a case-by-case
basis. In Listing 7-9, we’ve defined a public <code>back_of_house::Breakfast</code> struct
with a public <code>toast</code> field but a private <code>seasonal_fruit</code> field. This models
the case in a restaurant where the customer can pick the type of bread that
comes with a meal, but the chef decides which fruit accompanies the meal based
on what’s in season and in stock. The available fruit changes quickly, so
customers can’t choose the fruit or even see which fruit they’ll get.</p>
<p>也可用 <code>pub</code> 将结构体和枚举设为公开，但有些额外细节：<code>pub</code> 使结构体公开，但字段仍私有。可逐字段选择是否公开；<code>pub</code> 使枚举公开后，其所有变体自动公开。示例 7-9 定义了公开的 <code>back_of_house::Breakfast</code> 结构体，其中 <code>toast</code> 字段公开而 <code>seasonal_fruit</code> 字段私有。这模拟了餐厅中顾客选择面包类型，但厨师根据季节和库存搭配水果的场景（水果变化快，顾客不能选择甚至看不到水果）。</p>
<figure class="listing" id="listing-7-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast.
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like.
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<figcaption><a href="#listing-7-9">Listing 7-9</a>: A struct with some public fields and some private fields 包含公开字段和私有字段的结构体</figcaption>
</figure>
<p>Because the <code>toast</code> field in the <code>back_of_house::Breakfast</code> struct is public,
in <code>eat_at_restaurant</code> we can write and read to the <code>toast</code> field using dot
notation. Notice that we can’t use the <code>seasonal_fruit</code> field in
<code>eat_at_restaurant</code>, because <code>seasonal_fruit</code> is private. Try uncommenting the
line modifying the <code>seasonal_fruit</code> field value to see what error you get!</p>
<p>因 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段公开，在 <code>eat_at_restaurant</code> 中可用点号读写该字段。注意不可使用 <code>seasonal_fruit</code> 字段（它是私有的）。尝试取消修改该字段的注释，观察错误！</p>
<p>Also, note that because <code>back_of_house::Breakfast</code> has a private field, the
struct needs to provide a public associated function that constructs an
instance of <code>Breakfast</code> (we’ve named it <code>summer</code> here). If <code>Breakfast</code> didn’t
have such a function, we couldn’t create an instance of <code>Breakfast</code> in
<code>eat_at_restaurant</code> because we couldn’t set the value of the private
<code>seasonal_fruit</code> field in <code>eat_at_restaurant</code>.</p>
<p>另外注意，由于 <code>back_of_house::Breakfast</code> 有私有字段，结构体需提供公开关联函数（此处命名为 <code>summer</code>）来构造实例。若没有此函数，在 <code>eat_at_restaurant</code> 中无法创建 <code>Breakfast</code> 实例，因为无法设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p>In contrast, if we make an enum public, all of its variants are then public. We
only need the <code>pub</code> before the <code>enum</code> keyword, as shown in Listing 7-10.</p>
<p>相反，公开枚举时其所有变体会自动公开（仅需在 <code>enum</code> 关键字前加 <code>pub</code>），如示例 7-10 所示：</p>
<figure class="listing" id="listing-7-10">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<figcaption><a href="#listing-7-10">Listing 7-10</a>: Designating an enum as public makes all its variants public. 公开枚举会使其所有变体自动公开</figcaption>
</figure>
<p>Because we made the <code>Appetizer</code> enum public, we can use the <code>Soup</code> and <code>Salad</code>
variants in <code>eat_at_restaurant</code>.</p>
<p>将 <code>Appetizer</code> 枚举设为公开后，即可在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 变体。</p>
<p>Enums aren’t very useful unless their variants are public; it would be annoying
to have to annotate all enum variants with <code>pub</code> in every case, so the default
for enum variants is to be public. Structs are often useful without their
fields being public, so struct fields follow the general rule of everything
being private by default unless annotated with <code>pub</code>.</p>
<p>枚举若变体不公开则用处不大，若每次都给所有变体标注 <code>pub</code> 会很繁琐，因此枚举变体默认公开。结构体字段默认私有则通常更有用，除非用 <code>pub</code> 标注。</p>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that is
our last module system feature: the <code>use</code> keyword. We’ll cover <code>use</code> by itself
first, and then we’ll show how to combine <code>pub</code> and <code>use</code>.</p>
<p>最后还有一种涉及 <code>pub</code> 的情形，这是我们模块系统的最后一个功能：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，再展示如何组合 <code>pub</code> 和 <code>use</code>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
