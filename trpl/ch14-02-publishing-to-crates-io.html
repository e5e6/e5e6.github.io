<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Publishing a Crate to Crates.io 发布包到 Crates.io - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="publishing-a-crate-to-cratesio-发布包到-cratesio"><a class="header" href="#publishing-a-crate-to-cratesio-发布包到-cratesio">Publishing a Crate to Crates.io 发布包到 Crates.io</a></h2>
<p>We’ve used packages from <a href="https://crates.io/">crates.io</a> as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
<a href="https://crates.io/">crates.io</a> distributes the source code of
your packages, so it primarily hosts code that is open source.</p>
<p>我们使用过 <a href="https://crates.io/">crates.io</a> 上的包作为项目的依赖项，但你也可以通过发布自己的包来与他人分享你的代码。<a href="https://crates.io/">crates.io</a> 上的包注册表会分发你包的源代码，因此它主要托管开源的代码。</p>
<p>Rust and Cargo have features that make your published package easier for people
to find and use. We’ll talk about some of these features next and then explain
how to publish a package.</p>
<p>Rust 和 Cargo 提供了一些功能，使你发布的包更容易被他人发现和使用。接下来我们将讨论其中一些功能，然后解释如何发布一个包。</p>
<h3 id="making-useful-documentation-comments-编写有用的文档注释"><a class="header" href="#making-useful-documentation-comments-编写有用的文档注释">Making Useful Documentation Comments 编写有用的文档注释</a></h3>
<p>Accurately documenting your packages will help other users know how and when to
use them, so it’s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, <code>//</code>. Rust also has
a particular kind of comment for documentation, known conveniently as a
<em>documentation comment</em>, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to <em>use</em> your crate as opposed to how
your crate is <em>implemented</em>.</p>
<p>准确为你的包编写文档有助于其他用户了解如何以及何时使用它们，因此值得投入时间编写文档。在第 3 章中，我们讨论了如何使用双斜杠 <code>//</code> 注释 Rust 代码。Rust 还有一种特定用于文档的注释，方便地称为<em>文档注释</em>，它可以生成 HTML 文档。该 HTML 会显示公共 API 项的文档注释内容，供那些希望了解如何<em>使用</em>你的包，而不是包如何<em>实现</em>的程序员阅读。</p>
<p>Documentation comments use three slashes, <code>///</code>, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting. Listing 14-1 shows documentation comments
for an <code>add_one</code> function in a crate named <code>my_crate</code>.</p>
<p><span class="highlight">[note]文档注释使用三个斜杠</span> <code>///</code> 而不是两个，并支持 Markdown 符号来格式化文本。将文档注释放在它们所记录的项之前。清单 14-1 展示了一个名为 <code>my_crate</code> 的包中 <code>add_one</code> 函数的文档注释。</p>
<figure class="listing" id="listing-14-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<figcaption><a href="#listing-14-1">Listing 14-1</a>: A documentation comment for a function 一个函数的文档注释</figcaption>
</figure>
<p>Here, we give a description of what the <code>add_one</code> function does, start a
section with the heading <code>Examples</code>, and then provide code that demonstrates
how to use the <code>add_one</code> function. We can generate the HTML documentation from
this documentation comment by running <code>cargo doc</code>. This command runs the
<code>rustdoc</code> tool distributed with Rust and puts the generated HTML documentation
in the <em>target/doc</em> directory.</p>
<p>这里，我们描述了 <code>add_one</code> 函数的功能，以一个标题为 <code>Examples</code> 的部分开始，然后提供了演示如何使用 <code>add_one</code> 函数的代码。我们可以通过运行 <code>cargo doc</code> 从这个文档注释生成 HTML 文档。这个命令运行 Rust 分发的 <code>rustdoc</code> 工具，并将生成的 HTML 文档放在 <em>target/doc</em> 目录下。</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1.</p>
<p>为了方便起见，运行 <code>cargo doc --open</code> 会为你当前包的文档（以及你包所有依赖项的文档）构建 HTML，并在 Web 浏览器中打开结果。导航到 <code>add_one</code> 函数，你将看到文档注释中的文本是如何渲染的，如图 14-1 所示。</p>
<img alt="" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code>
function. <code>add_one</code> 函数的 HTML 文档</span></p>
<h4 id="commonly-used-sections-常用部分"><a class="header" href="#commonly-used-sections-常用部分">Commonly Used Sections 常用部分</a></h4>
<p>We used the <code># Examples</code> Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Here are some other sections that crate
authors commonly use in their documentation:</p>
<p>我们在清单 14-1 中使用了 Markdown 标题 <code># Examples</code> 在 HTML 中创建了一个标题为 “Examples” 的部分。以下是包作者在文档中常用的<span class="highlight">[note]其他一些部分</span>：</p>
<ul>
<li><strong>Panics</strong>: The scenarios in which the function being documented could
panic. Callers of the function who don’t want their programs to panic should
make sure they don’t call the function in these situations.</li>
<li><strong>Panics (恐慌)</strong>: 被记录的函数可能发生恐慌的场景。不希望程序恐慌的调用者应确保不会在这些情况下调用该函数。</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of
errors that might occur and what conditions might cause those errors to be
returned can be helpful to callers so they can write code to handle the
different kinds of errors in different ways.</li>
<li><strong>Errors (错误)</strong>: 如果函数返回 <code>Result</code>，描述可能发生的错误类型以及什么条件可能导致这些错误被返回，对调用者很有帮助，这样他们可以编写代码以不同方式处理不同类型的错误。</li>
<li><strong>Safety</strong>: If the function is <code>unsafe</code> to call (we discuss unsafety in
Chapter 20), there should be a section explaining why the function is unsafe
and covering the invariants that the function expects callers to uphold.</li>
<li><strong>Safety (安全性)</strong>: 如果调用函数是 <code>unsafe</code>（我们将在第 20 章讨论不安全代码），那么应该有一个部分解释为什么该函数是不安全的，并涵盖函数期望调用者维护的不变性。</li>
</ul>
<p>Most documentation comments don’t need all of these sections, but this is a
good checklist to remind you of the aspects of your code users will be
interested in knowing about.</p>
<p>大多数文档注释不需要所有这些部分，但这是一个很好的清单，可以提醒你用户会有兴趣了解的代码方面。</p>
<h4 id="documentation-comments-as-tests-文档注释作为测试"><a class="header" href="#documentation-comments-as-tests-文档注释作为测试">Documentation Comments as Tests 文档注释作为测试</a></h4>
<p>Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running <code>cargo  test</code> will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code>
function from Listing 14-1, we will see a section in the test results that looks
like this:</p>
<p>在你的文档注释中添加示例代码块有助于演示如何使用你的库，这样做还有一个额外的好处：运行 <code>cargo test</code> 会将你文档中的代码示例作为测试运行！没有什么比带示例的文档更好的了。但也没有什么比文档写好之后代码发生了变化导致示例无法工作更糟糕的了。如果我们使用清单 14-1 中 <code>add_one</code> 函数的文档运行 <code>cargo test</code>，我们将在测试结果中看到一个类似这样的部分：</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Now, if we change either the function or the example so the <code>assert_eq!</code> in the
example panics, and run <code>cargo test</code> again, we’ll see that the doc tests catch
that the example and the code are out of sync with each other!</p>
<p>现在，如果我们更改函数或示例，使得示例中的 <code>assert_eq!</code> 宏发生恐慌，然后再次运行 <code>cargo test</code>，我们会看到文档测试捕获到了示例和代码不同步的情况！</p>
<h4 id="commenting-contained-items-注释包含的项"><a class="header" href="#commenting-contained-items-注释包含的项">Commenting Contained Items 注释包含的项</a></h4>
<p>The style of doc comment <code>//!</code> adds documentation to the item that <em>contains</em>
the comments rather than to the items <em>following</em> the comments. We typically use
these doc comments inside the crate root file (<em>src/lib.rs</em> by convention) or
inside a module to document the crate or the module as a whole.</p>
<p><span class="highlight">[note]文档注释样式 <code>//!</code> 将文档添加到<em>包含</em>这些注释的项</span>，而不是添加到<em>跟随</em>这些注释的项。我们通常在包根文件（约定为 <em>src/lib.rs</em>）内部或模块内部使用这些文档注释来记录整个包或模块。</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code>
crate that contains the <code>add_one</code> function, we add documentation comments that
start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing
14-2.</p>
<p>例如，要为包含 <code>add_one</code> 函数的 <code>my_crate</code> 包添加描述其用途的文档，我们在 <em>src/lib.rs</em> 文件的开头添加以 <code>//!</code> 开头的文档注释，如清单 14-2 所示。</p>
<figure class="listing" id="listing-14-2">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-14-2">Listing 14-2</a>: Documentation for the <code>my_crate</code> crate as a whole 整个 <code>my_crate</code> 包的文档</figcaption>
</figure>
<p>Notice there isn’t any code after the last line that begins with <code>//!</code>. Because
we started the comments with <code>//!</code> instead of <code>///</code>, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, that item is the <em>src/lib.rs</em> file, which is the crate root. These
comments describe the entire crate.</p>
<p>请注意，在以 <code>//!</code> 开头的最后一行之后没有任何代码。因为我们以 <code>//!</code> 而不是 <code>///</code> 开始注释，所以我们是在记录包含此注释的项，而不是在此注释之后的项。在这种情况下，该项是 <em>src/lib.rs</em> 文件，也就是包根。这些注释描述了整个包。</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-2.</p>
<p>当我们运行 <code>cargo doc --open</code> 时，这些注释将显示在 <code>my_crate</code> 文档的首页，位于包中公共项列表的上方，如图 14-2 所示。</p>
<img alt="" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figure 14-2: Rendered documentation for <code>my_crate</code>,
including the comment describing the crate as a whole. <code>my_crate</code> 的渲染文档，包括描述整个包的注释</span></p>
<p>Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crate’s organization.</p>
<p>容器项内部的文档注释对于描述包和模块尤其有用。使用它们来解释容器的整体目的，以帮助用户理解包的组织结构。</p>
<h3 id="exporting-a-convenient-public-api-with-pub-use-使用-pub-use-导出一个方便的公共-api"><a class="header" href="#exporting-a-convenient-public-api-with-pub-use-使用-pub-use-导出一个方便的公共-api">Exporting a Convenient Public API with <code>pub use</code> 使用 <code>pub use</code> 导出一个方便的公共 API</a></h3>
<p>The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.</p>
<p>当你发布一个包时，公共 API 的结构是一个主要的考虑因素。使用你包的人不如你熟悉其结构，如果你的包有一个庞大的模块层次结构，他们可能会难以找到他们想要使用的部分。</p>
<p>In Chapter 7, we covered how to make items public using the <code>pub</code> keyword, and
how to bring items into a scope with the <code>use</code> keyword. However, the structure
that makes sense to you while you’re developing a crate might not be very
convenient for your users. You might want to organize your structs in a
hierarchy containing multiple levels, but then people who want to use a type
you’ve defined deep in the hierarchy might have trouble finding out that type
exists. They might also be annoyed at having to enter <code>use  my_crate::some_module::another_module::UsefulType;</code> rather than <code>use  my_crate::UsefulType;</code>.</p>
<p>在第 7 章中，我们介绍了如何使用 <code>pub</code> 关键字使项变为公共的，以及如何使用 <code>use</code> 关键字将项引入作用域。然而，你在开发包时觉得合理的结构对你的用户来说可能并不方便。你可能希望将结构体组织在一个包含多层的层次结构中，但想要使用你在层次结构深处定义的类型的用户可能会难以发现该类型的存在。他们也可能对必须输入 <code>use my_crate::some_module::another_module::UsefulType;</code> 而不是 <code>use my_crate::UsefulType;</code> 感到烦恼。</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
from your private structure by using <code>pub use</code>. <em>Re-exporting</em> takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.</p>
<p>好消息是，如果这种结构<em>不</em>方便其他人在另一个库中使用，你不必重新安排你的内部组织：相反，你可以使用 <code>pub use</code> 重新导出项，以创建一个与你的私有结构不同的公共结构。<em>重新导出</em>（Re-exporting）将一个公共项从一个位置取出，使其在另一个位置也变为公共的，就好像它是在那个位置定义的一样。</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library are two modules: a <code>kinds</code> module containing two enums
named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a
function named <code>mix</code>, as shown in Listing 14-3.</p>
<p>例如，假设我们创建了一个名为 <code>art</code> 的库来模拟艺术概念。在这个库中有两个模块：一个 <code>kinds</code> 模块，包含两个枚举 <code>PrimaryColor</code> 和 <code>SecondaryColor</code>；一个 <code>utils</code> 模块，包含一个名为 <code>mix</code> 的函数，如清单 14-3 所示。</p>
<figure class="listing" id="listing-14-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<figcaption><a href="#listing-14-3">Listing 14-3</a>: An <code>art</code> library with items organized into <code>kinds</code> and <code>utils</code> modules 一个将项组织到 <code>kinds</code> 和 <code>utils</code> 模块的 <code>art</code> 库</figcaption>
</figure>
<p>Figure 14-3 shows what the front page of the documentation for this crate
generated by <code>cargo doc</code> would look like.</p>
<p>图 14-3 展示了由 <code>cargo doc</code> 生成的这个包的文档首页的样子。</p>
<img alt="" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: Front page of the documentation for <code>art</code>
that lists the <code>kinds</code> and <code>utils</code> modules. <code>art</code> 包的文档首页，列出了 <code>kinds</code> 和 <code>utils</code> 模块</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren’t listed on the
front page, nor is the <code>mix</code> function. We have to click <code>kinds</code> and <code>utils</code> to
see them.</p>
<p>请注意，<code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型没有列在首页上，<code>mix</code> 函数也没有。我们必须点击 <code>kinds</code> 和 <code>utils</code> 才能看到它们。</p>
<p>Another crate that depends on this library would need <code>use</code> statements that
bring the items from <code>art</code> into scope, specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
<code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate.</p>
<p>另一个依赖于这个库的包需要使用 <code>use</code> 语句将 <code>art</code> 中的项引入作用域，指定当前定义的模块结构。清单 14-4 展示了一个使用 <code>art</code> 包中的 <code>PrimaryColor</code> 和 <code>mix</code> 项的包示例。</p>
<figure class="listing" id="listing-14-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<figcaption><a href="#listing-14-4">Listing 14-4</a>: A crate using the <code>art</code> crate’s items with its internal structure exported 一个使用 <code>art</code> 包项（其内部结构已被导出）的包</figcaption>
</figure>
<p>The author of the code in Listing 14-4, which uses the <code>art</code> crate, had to
figure out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the
<code>utils</code> module. The module structure of the <code>art</code> crate is more relevant to
developers working on the <code>art</code> crate than to those using it. The internal
structure doesn’t contain any useful information for someone trying to
understand how to use the <code>art</code> crate, but rather causes confusion because
developers who use it have to figure out where to look, and must specify the
module names in the <code>use</code> statements.</p>
<p>清单 14-4 中使用 <code>art</code> 包的代码作者必须弄清楚 <code>PrimaryColor</code> 在 <code>kinds</code> 模块中，而 <code>mix</code> 在 <code>utils</code> 模块中。<code>art</code> 包的模块结构对开发 <code>art</code> 包的程序员更相关，而对使用它的人来说则不然。内部结构不包含任何对试图理解如何使用 <code>art</code> 包的人有用的信息，反而会引起混淆，因为使用它的开发者必须弄清楚去哪里找，并且必须在 <code>use</code> 语句中指定模块名称。</p>
<p>To remove the internal organization from the public API, we can modify the
<code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-5.</p>
<p>为了从公共 API 中移除内部组织，我们可以修改清单 14-3 中的 <code>art</code> 包代码，添加 <code>pub use</code> 语句在顶层重新导出这些项，如清单 14-5 所示。</p>
<figure class="listing" id="listing-14-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<figcaption><a href="#listing-14-5">Listing 14-5</a>: Adding <code>pub use</code> statements to re-export items 添加 <code>pub use</code> 语句重新导出项</figcaption>
</figure>
<p>The API documentation that <code>cargo doc</code> generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
<code>PrimaryColor</code> and <code>SecondaryColor</code> types and the <code>mix</code> function easier to find.</p>
<p>现在 <code>cargo doc</code> 为此包生成的 API 文档将在首页列出并链接重新导出的项，如图 14-4 所示，使得 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型以及 <code>mix</code> 函数更容易找到。</p>
<img alt="" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figure 14-4: The front page of the documentation for <code>art</code>
that lists the re-exports. <code>art</code> 包的文档首页，列出了重新导出的项</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6.</p>
<p><code>art</code> 包的用户仍然可以像清单 14-4 所示那样使用清单 14-3 的内部结构，或者他们可以使用清单 14-5 中更方便的结构，如清单 14-6 所示。</p>
<figure class="listing" id="listing-14-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<figcaption><a href="#listing-14-6">Listing 14-6</a>: A program using the re-exported items from the <code>art</code> crate 一个使用 <code>art</code> 包重新导出项的程序</figcaption>
</figure>
<p>In cases where there are many nested modules, re-exporting the types at the top
level with <code>pub use</code> can make a significant difference in the experience of
people who use the crate. Another common use of <code>pub use</code> is to re-export
definitions of a dependency in the current crate to make that crate’s
definitions part of your crate’s public API.</p>
<p>在存在许多嵌套模块的情况下，使用 <code>pub use</code> 在顶层重新导出类型可以显著改善使用你包的人的体验。<code>pub use</code> 的另一个常见用途是在当前包中重新导出依赖项的定义，使该依赖项的定义成为你包公共 API 的一部分。</p>
<p>Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing <code>pub  use</code> gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.</p>
<p>创建一个有用的公共 API 结构更像是一门艺术而非科学，你可以通过迭代找到最适合用户的 API。选择 <code>pub use</code> 使你在内部如何组织包方面具有灵活性，并将内部结构与呈现给用户的结构解耦。查看一些你已安装包的代码，看看它们的内部结构是否与公共 API 不同。</p>
<h3 id="setting-up-a-cratesio-account-设置-cratesio-账户"><a class="header" href="#setting-up-a-cratesio-account-设置-cratesio-账户">Setting Up a Crates.io Account 设置 Crates.io 账户</a></h3>
<p>Before you can publish any crates, you need to create an account on
<a href="https://crates.io/">crates.io</a> and get an API token. To do so,
visit the home page at <a href="https://crates.io/">crates.io</a> and log
in via a GitHub account. (The GitHub account is currently a requirement, but
the site might support other ways of creating an account in the future.) Once
you’re logged in, visit your account settings at
<a href="https://crates.io/me/">https://crates.io/me/</a> and retrieve your
API key. Then run the <code>cargo login</code> command and paste your API key when prompted, like this:</p>
<p>在发布任何包之前，你需要在 <a href="https://crates.io/">crates.io</a> 上创建一个账户并获取一个 API 令牌。为此，访问 <a href="https://crates.io/">crates.io</a> 主页并通过 GitHub 账户登录。（目前 GitHub 账户是必需的，但将来该网站可能会支持其他创建账户的方式。）登录后，访问你的账户设置页面 <a href="https://crates.io/me/">https://crates.io/me/</a> 并获取你的 API 密钥。然后运行 <code>cargo login</code> 命令，并在提示时粘贴你的 API 密钥，如下所示：</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials.toml</em>. Note that this token is a <em>secret</em>: do not share
it with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on <a href="https://crates.io/">crates.io</a>.</p>
<p>此命令会将你的 API 令牌告知 Cargo，并将其本地存储在 <em>~/.cargo/credentials.toml</em> 中。请注意，此令牌是<em>机密</em>：不要与其他人共享。如果因任何原因将其共享给任何人，你应该撤销它并在 <a href="https://crates.io/">crates.io</a> 上生成一个新令牌。</p>
<h3 id="adding-metadata-to-a-new-crate-向新包添加元数据"><a class="header" href="#adding-metadata-to-a-new-crate-向新包添加元数据">Adding Metadata to a New Crate 向新包添加元数据</a></h3>
<p>Let’s say you have a crate you want to publish. Before publishing, you’ll need
to add some metadata in the <code>[package]</code> section of the crate’s <em>Cargo.toml</em>
file.</p>
<p>假设你有一个想要发布的包。在发布之前，你需要在包的 <em>Cargo.toml</em> 文件的 <code>[package]</code> 部分添加一些元数据。</p>
<p>Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
<a href="https://crates.io/">crates.io</a> are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use. If the name has been used, you will need to find another name and
edit the <code>name</code> field in the <em>Cargo.toml</em> file under the <code>[package]</code> section to
use the new name for publishing, like so:</p>
<p>你的包需要一个唯一的名称。在本地处理包时，你可以随意命名包。然而，<a href="https://crates.io/">crates.io</a> 上的包名是按先到先得的原则分配的。一旦一个包名被占用，其他人就无法发布同名的包。在尝试发布包之前，请搜索你想要使用的名称。如果该名称已被使用，你将需要找到另一个名称，并编辑 <em>Cargo.toml</em> 文件中 <code>[package]</code> 部分下的 <code>name</code> 字段以使用新名称进行发布，如下所示：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Even if you’ve chosen a unique name, when you run <code>cargo publish</code> to publish
the crate at this point, you’ll get a warning and then an error:</p>
<p>即使你选择了一个唯一的名称，此时运行 <code>cargo publish</code> 发布包时，你也会收到一个警告，然后是一个错误：</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
</code></pre>
<p>This results in an error because you’re missing some crucial information: a
description and license are required so people will know what your crate does
and under what terms they can use it. In <em>Cargo.toml</em>, add a description that’s
just a sentence or two, because it will appear with your crate in search
results. For the <code>license</code> field, you need to give a <em>license identifier value</em>.
The Linux Foundation’s Software Package Data Exchange (SPDX) lists the
identifiers you can use for this value. For example, to specify that you’ve
licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<p>出现错误是因为你缺少一些关键信息：描述和许可证是必需的，以便人们知道你的包是做什么的以及在什么条款下可以使用它。在 <em>Cargo.toml</em> 中，添加一个只需一两句话的描述，因为它将出现在搜索结果中你的包旁边。对于 <code>license</code> 字段，你需要提供一个<em>许可证标识符值</em>。Linux 基金会的 Software Package Data Exchange (SPDX) 列出了你可以用于此值的标识符。例如，要指定你使用 MIT 许可证授权你的包，添加 <code>MIT</code> 标识符：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use <code>license-file</code> to specify the name of that file instead of using the
<code>license</code> key.</p>
<p>如果你想使用 SPDX 中未列出的许可证，你需要将该许可证的文本放在一个文件中，将该文件包含在你的项目中，然后使用 <code>license-file</code> 指定该文件的名称，而不是使用 <code>license</code> 键。</p>
<p>Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of <code>MIT OR Apache-2.0</code>. This practice
demonstrates that you can also specify multiple license identifiers separated
by <code>OR</code> to have multiple licenses for your project.</p>
<p>哪种许可证适合你的项目超出了本书的范围。许多 Rust 社区成员通过与 Rust 相同的方式对他们的项目进行授权，即使用 <code>MIT OR Apache-2.0</code> 双重许可证。这种做法表明你也可以通过用 <code>OR</code> 分隔多个许可证标识符来为你的项目指定多个许可证。</p>
<p>With a unique name, the version, your description, and a license added, the
<em>Cargo.toml</em> file for a project that is ready to publish might look like this:</p>
<p>添加了唯一的名称、版本、描述和许可证后，一个准备好发布的项目的 <em>Cargo.toml</em> 文件可能如下所示：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure that others can discover and use your crate
more easily.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo 的文档</a>描述了你可以指定的其他元数据，以确保其他人可以更容易地发现和使用你的包。</p>
<h3 id="publishing-to-cratesio-发布到-cratesio"><a class="header" href="#publishing-to-cratesio-发布到-cratesio">Publishing to Crates.io 发布到 Crates.io</a></h3>
<p>Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
<a href="https://crates.io/">crates.io</a> for others to use.</p>
<p>现在你已经创建了账户、保存了 API 令牌、为包选择了名称并指定了所需的元数据，你准备好发布了！发布一个包会将特定版本上传到 <a href="https://crates.io/">crates.io</a> 供他人使用。</p>
<p>Be careful, because a publish is <em>permanent</em>. The version can never be
overwritten, and the code cannot be deleted except in certain circumstances.
One major goal of Crates.io is to act as a permanent archive of code so that
builds of all projects that depend on crates from
<a href="https://crates.io/">crates.io</a> will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.</p>
<p>请小心，因为发布是<em>永久性</em>的。版本永远不能被覆盖，代码也不能被删除，除非在特定情况下。Crates.io 的一个主要目标是充当代码的永久存档，以便所有依赖来自 <a href="https://crates.io/">crates.io</a> 的包的项目的构建都能继续工作。允许删除版本会使实现该目标变得不可能。但是，你可以发布的包版本数量没有限制。</p>
<p>Run the <code>cargo publish</code> command again. It should succeed now:</p>
<p>再次运行 <code>cargo publish</code> 命令。现在它应该成功了：</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
    Packaged 6 files, 1.2KiB (895.0B compressed)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
    Uploaded guessing_game v0.1.0 to registry `crates-io`
note: waiting for `guessing_game v0.1.0` to be available at registry
`crates-io`.
You may press ctrl-c to skip waiting; the crate should be available shortly.
   Published guessing_game v0.1.0 at registry `crates-io`
</code></pre>
<p>Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.</p>
<p>恭喜！你现在已经与 Rust 社区分享了你的代码，任何人都可以轻松地将你的包添加为他们项目的依赖项。</p>
<h3 id="publishing-a-new-version-of-an-existing-crate-发布现有包的新版本"><a class="header" href="#publishing-a-new-version-of-an-existing-crate-发布现有包的新版本">Publishing a New Version of an Existing Crate 发布现有包的新版本</a></h3>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the Semantic Versioning rules to decide what an
appropriate next version number is, based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<p>当你对包进行了更改并准备发布新版本时，你可以更改 <em>Cargo.toml</em> 文件中指定的 <code>version</code> 值并重新发布。使用语义版本控制规则（Semantic Versioning rules），根据你所做更改的类型决定合适的下一个版本号。然后运行 <code>cargo publish</code> 上传新版本。</p>
<h3 id="deprecating-versions-from-cratesio-with-cargo-yank-使用-cargo-yank-从-cratesio-弃用版本"><a class="header" href="#deprecating-versions-from-cratesio-with-cargo-yank-使用-cargo-yank-从-cratesio-弃用版本">Deprecating Versions from Crates.io with <code>cargo yank</code> 使用 <code>cargo yank</code> 从 Crates.io 弃用版本</a></h3>
<p>Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports yanking a crate version.</p>
<p>虽然你不能删除包的先前版本，但你可以阻止任何未来的项目将它们添加为新的依赖项。这在包的某个版本因某种原因损坏时很有用。在这种情况下，Cargo 支持撤回（yank）一个包版本。</p>
<p><em>Yanking</em> a version prevents new projects from depending on that version while
allowing all existing projects that depend on it to continue. Essentially, a
yank means that all projects with a <em>Cargo.lock</em> will not break, and any future
<em>Cargo.lock</em> files generated will not use the yanked version.</p>
<p><em>撤回</em>一个版本会阻止新项目依赖该版本，同时允许所有已依赖它的现有项目继续使用。本质上，撤回意味着所有拥有 <em>Cargo.lock</em> 的项目都不会损坏，并且将来生成的任何 <em>Cargo.lock</em> 文件都不会使用被撤回的版本。</p>
<p>To yank a version of a crate, in the directory of the crate that you’ve
previously published, run <code>cargo yank</code> and specify which version you want to
yank. For example, if we’ve published a crate named <code>guessing_game</code> version
1.0.1 and we want to yank it, in the project directory for <code>guessing_game</code> we’d
run:</p>
<p>要撤回一个包的版本，在你之前发布的包所在的目录中运行 <code>cargo yank</code> 并指定你想要撤回的版本。例如，如果我们发布了一个名为 <code>guessing_game</code> 的版本 1.0.1 的包，并且我们想撤回它，那么在 <code>guessing_game</code> 的项目目录中我们会运行：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>By adding <code>--undo</code> to the command, you can also undo a yank and allow projects
to start depending on a version again:</p>
<p>通过在命令中添加 <code>--undo</code>，你也可以撤销撤回操作，并允许项目再次依赖某个版本：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>A yank <em>does not</em> delete any code. It cannot, for example, delete accidentally
uploaded secrets. If that happens, you must reset those secrets immediately.</p>
<p>撤回<em>不会</em>删除任何代码。例如，它不能删除意外上传的密钥。如果发生这种情况，你必须立即重置这些密钥。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch14-01-release-profiles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch14-01-release-profiles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
