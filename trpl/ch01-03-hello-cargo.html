<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hello, Cargo! - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
<em>dependencies</em>.)</p>
<p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rust 开发者使用这个工具来管理他们的 Rust 项目，因为 Cargo 为你处理许多任务，例如构建代码、下载代码所依赖的库以及构建这些库。（我们将你的代码所需的库称为<em>依赖项</em>）。</p>
<p>The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. If we had built the “Hello, world!” project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.</p>
<p>最简单的 Rust 程序（比如我们目前编写的程序）没有任何依赖项。如果我们使用 Cargo 构建“Hello, world!”项目，它只会用到 Cargo 处理代码构建的部分。随着你编写更复杂的 Rust 程序，你会添加依赖项；而如果你使用 Cargo 启动项目，添加依赖项将变得容易得多。</p>
<p>Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
“Installation” section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following in your terminal:</p>
<p>由于绝大多数 Rust 项目都使用 Cargo，本书后续内容也假定你在使用 Cargo。如果你使用了“安装”章节中讨论的官方安装程序，安装 Rust 时会附带安装 Cargo。如果你通过其他方式安装了 Rust，请在终端中输入以下命令来检查是否安装了 Cargo：</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>If you see a version number, you have it! If you see an error, such as <code>command not found</code>, look at the documentation for your method of installation to
determine how to install Cargo separately.</p>
<p>如果你看到版本号，说明已安装！如果看到错误（例如 <code>command not found</code>），请查阅你所用安装方式的文档以确定如何单独安装 Cargo。</p>
<h3 id="creating-a-project-with-cargo-使用-cargo-创建项目"><a class="header" href="#creating-a-project-with-cargo-使用-cargo-创建项目">Creating a Project with Cargo 使用 Cargo 创建项目</a></h3>
<p>Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your <em>projects</em> directory
(or wherever you decided to store your code). Then, on any operating system,
run the following:</p>
<p>让我们使用 Cargo 创建一个新项目，看看它与我们最初的“Hello, world!”项目有何不同。导航回你的 <em>projects</em> 目录（或你决定存储代码的任何位置）。然后，在任何操作系统上运行以下命令：</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>The first command creates a new directory and project called <em>hello_cargo</em>.
We’ve named our project <em>hello_cargo</em>, and Cargo creates its files in a
directory of the same name.</p>
<p>第一条命令创建了一个名为 <em>hello_cargo</em> 的新目录和项目。我们将项目命名为 <em>hello_cargo</em>，Cargo 会在同名目录中创建其文件。</p>
<p>Go into the <em>hello_cargo</em> directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a <em>Cargo.toml</em> file and a
<em>src</em> directory with a <em>main.rs</em> file inside.</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。你会看到 Cargo 为我们生成了两个文件和一个目录：一个 <em>Cargo.toml</em> 文件，以及一个包含 <em>main.rs</em> 文件的 <em>src</em> 目录。</p>
<p>It has also initialized a new Git repository along with a <em>.gitignore</em> file.
Git files won’t be generated if you run <code>cargo new</code> within an existing Git
repository; you can override this behavior by using <code>cargo new --vcs=git</code>.</p>
<p>它还会初始化一个新的 Git 仓库并生成一个 <em>.gitignore</em> 文件。如果在现有的 Git 仓库中运行 <code>cargo new</code>，则不会生成 Git 文件；你可以使用 <code>cargo new --vcs=git</code> 覆盖此行为。</p>
<section class="note" aria-role="note">
<p>Note: Git is a common version control system. You can change <code>cargo new</code> to
use a different version control system or no version control system by using
the <code>--vcs</code> flag. Run <code>cargo new --help</code> to see the available options.</p>
<p>注意：Git 是一个常见的版本控制系统。你可以使用 <code>--vcs</code> 标志来更改 <code>cargo new</code> 使用的版本控制系统或不使用任何版本控制系统。运行 <code>cargo new --help</code> 查看可用选项。</p>
</section>
<p>Open <em>Cargo.toml</em> in your text editor of choice. It should look similar to the
code in Listing 1-2.</p>
<p>在你选择的文本编辑器中打开 <em>Cargo.toml</em>。它应类似于代码清单 1-2 中的代码。</p>
<figure class="listing" id="listing-1-2">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<figcaption><a href="#listing-1-2">Listing 1-2</a>: Contents of <em>Cargo.toml</em> generated by <code>cargo new</code> <code>cargo new</code>生成的<em>Cargo.toml</em>内容</figcaption>
</figure>
<p>This file is in the <em>TOML</em> (<em>Tom’s Obvious, Minimal
Language</em>) format, which is Cargo’s configuration format.</p>
<p>此文件采用 <em>TOML</em>（<em>Tom’s Obvious, Minimal Language</em>）格式，这是 Cargo 的配置格式。</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>第一行 <code>[package]</code> 是一个段落标题，表示后续语句用于配置一个包。随着我们向此文件添加更多信息，我们将添加其他段落。</p>
<p>The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the <code>edition</code> key in Appendix E.</p>
<p>接下来的三行设置了 Cargo 编译程序所需的配置信息：名称、版本和要使用的 Rust 版本。我们将在附录 E 中讨论 <code>edition</code> 键。</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
<em>crates</em>. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.</p>
<p>最后一行 <code>[dependencies]</code> 是用于列出项目所有依赖项的段落的开始。在 Rust 中，代码包被称为 <em>crate</em>（包）。本项目不需要其他包，但在第二章的第一个项目中会用到，那时我们将使用这个依赖项段落。</p>
<p>Now open <em>src/main.rs</em> and take a look:</p>
<p>现在打开 <em>src/main.rs</em> 看看：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our project and the
project Cargo generated are that Cargo placed the code in the <em>src</em> directory
and we have a <em>Cargo.toml</em> configuration file in the top directory.</p>
<p>Cargo 为你生成了一个“Hello, world!”程序，与我们代码清单 1-1 中编写的完全一样！到目前为止，我们的项目与 Cargo 生成的项目之间的区别在于：Cargo 将代码放在 <em>src</em> 目录中，并且在顶层目录有一个 <em>Cargo.toml</em> 配置文件。</p>
<p>Cargo expects your source files to live inside the <em>src</em> directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.</p>
<p>Cargo 期望你的源文件位于 <em>src</em> 目录中。顶层项目目录仅用于 README 文件、许可证信息、配置文件以及其他与代码无关的内容。使用 Cargo 有助于你组织项目。各得其所，井井有条。</p>
<p>If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the <em>src</em> directory and create an appropriate <em>Cargo.toml</em>
file. One easy way to get that <em>Cargo.toml</em> file is to run <code>cargo init</code>, which
will create it for you automatically.</p>
<p>如果你启动的项目没有使用 Cargo（就像我们之前的“Hello, world!”项目），可以将其转换为使用 Cargo 的项目。将项目代码移动到 <em>src</em> 目录中，并创建一个合适的 <em>Cargo.toml</em> 文件。获取该 <em>Cargo.toml</em> 文件的一个简单方法是运行 <code>cargo init</code>，它会自动为你创建。</p>
<h3 id="building-and-running-a-cargo-project-构建和运行-cargo-项目"><a class="header" href="#building-and-running-a-cargo-project-构建和运行-cargo-项目">Building and Running a Cargo Project 构建和运行 Cargo 项目</a></h3>
<p>Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your <em>hello_cargo</em> directory, build your project by
entering the following command:</p>
<p>现在让我们看看使用 Cargo 构建和运行“Hello, world!”程序有什么不同！在你的 <em>hello_cargo</em> 目录中，输入以下命令构建项目：</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>This command creates an executable file in <em>target/debug/hello_cargo</em> (or
<em>target\debug\hello_cargo.exe</em> on Windows) rather than in your current
directory. Because the default build is a debug build, Cargo puts the binary in
a directory named <em>debug</em>. You can run the executable with this command:</p>
<p>此命令在 <em>target/debug/hello_cargo</em>（在 Windows 上是 <em>target\debug\hello_cargo.exe</em>）创建可执行文件，而不是在当前目录中。因为默认构建是调试构建（debug build），所以 Cargo 将二进制文件放在名为 <em>debug</em> 的目录中。你可以使用以下命令运行该可执行文件：</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>If all goes well, <code>Hello, world!</code> should print to the terminal. Running <code>cargo build</code> for the first time also causes Cargo to create a new file at the top
level: <em>Cargo.lock</em>. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.</p>
<p>如果一切顺利，<code>Hello, world!</code> 应打印到终端。首次运行 <code>cargo build</code> 还会导致 Cargo 在顶层创建一个新文件：<em>Cargo.lock</em>。此文件跟踪项目中依赖项的确切版本。本项目没有依赖项，因此该文件内容较少。你永远不需要手动更改此文件；Cargo 会为你管理其内容。</p>
<p>We just built a project with <code>cargo build</code> and ran it with
<code>./target/debug/hello_cargo</code>, but we can also use <code>cargo run</code> to compile the
code and then run the resultant executable all in one command:</p>
<p>我们刚刚使用 <code>cargo build</code> 构建了项目，并用 <code>./target/debug/hello_cargo</code> 运行它，但我们也可以使用 <code>cargo run</code> 在一个命令中编译代码并运行生成的可执行文件：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Using <code>cargo run</code> is more convenient than having to remember to run <code>cargo build</code> and then use the whole path to the binary, so most developers use <code>cargo run</code>.</p>
<p>使用 <code>cargo run</code> 比必须记住先运行 <code>cargo build</code> 然后再使用二进制文件的完整路径更方便，因此大多数开发者使用 <code>cargo run</code>。</p>
<p>Notice that this time we didn’t see output indicating that Cargo was compiling
<code>hello_cargo</code>. Cargo figured out that the files hadn’t changed, so it didn’t
rebuild but just ran the binary. If you had modified your source code, Cargo
would have rebuilt the project before running it, and you would have seen this
output:</p>
<p>注意，这次我们没有看到表明 Cargo 正在编译 <code>hello_cargo</code> 的输出。Cargo 判断出文件没有更改，因此它没有重新构建，而是直接运行了二进制文件。如果你修改了源代码，Cargo 会在运行前重新构建项目，你会看到这样的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo also provides a command called <code>cargo check</code>. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:</p>
<p>Cargo 还提供了一个名为 <code>cargo check</code> 的命令。此命令快速检查你的代码以确保它能编译，但不会生成可执行文件：</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Why would you not want an executable? Often, <code>cargo check</code> is much faster than
<code>cargo build</code> because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using <code>cargo check</code> will
speed up the process of letting you know if your project is still compiling! As
such, many Rustaceans run <code>cargo check</code> periodically as they write their
program to make sure it compiles. Then they run <code>cargo build</code> when they’re
ready to use the executable.</p>
<p>为什么你可能不需要生成可执行文件呢？通常，<code>cargo check</code> 比 <code>cargo build</code> 快得多，因为它跳过了生成可执行文件的步骤。如果你在编写代码时持续检查工作，使用 <code>cargo check</code> 将加速获知项目是否仍能编译的过程！因此，许多 Rust 开发者在编写程序时会定期运行 <code>cargo check</code> 以确保它能编译。然后当他们准备使用可执行文件时再运行 <code>cargo build</code>。</p>
<p>Let’s recap what we’ve learned so far about Cargo:</p>
<p>让我们回顾一下目前学到的关于 Cargo 的知识：</p>
<ul>
<li>We can create a project using <code>cargo new</code>.</li>
<li>我们可以使用 <code>cargo new</code> 创建项目。</li>
<li>We can build a project using <code>cargo build</code>.</li>
<li>我们可以使用 <code>cargo build</code> 构建项目。</li>
<li>We can build and run a project in one step using <code>cargo run</code>.</li>
<li>我们可以使用 <code>cargo run</code> 一步完成构建并运行项目。</li>
<li>We can build a project without producing a binary to check for errors using
<code>cargo check</code>.</li>
<li>我们可以使用 <code>cargo check</code> 在不生成二进制文件的情况下构建项目以检查错误。</li>
<li>Instead of saving the result of the build in the same directory as our code,
Cargo stores it in the <em>target/debug</em> directory.</li>
<li>Cargo 将构建结果存储到 <em>target/debug</em> 目录中，而不是与我们的代码放在同一目录下。</li>
</ul>
<p>An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.</p>
<p>使用 Cargo 的另一个优点是，无论你在哪个操作系统上工作，命令都是相同的。因此，从现在开始，我们将不再提供针对 Linux、macOS 与 Windows 的具体说明。</p>
<h3 id="building-for-release-构建发布版本"><a class="header" href="#building-for-release-构建发布版本">Building for Release 构建发布版本</a></h3>
<p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile it with optimizations. This command will create an
executable in <em>target/release</em> instead of <em>target/debug</em>. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run <code>cargo build --release</code> and benchmark with
the executable in <em>target/release</em>.</p>
<p>当你的项目最终准备好发布时，可以使用 <code>cargo build --release</code> 进行优化编译。此命令将在 <em>target/release</em> 而不是 <em>target/debug</em> 中创建可执行文件。这些优化使你的 Rust 代码运行得更快，但启用它们会延长程序的编译时间。这就是为什么有两种不同的配置：一种用于开发，此时你希望快速且频繁地重新构建；另一种用于构建最终交付给用户的程序，该程序不会被重复构建，并且需要尽可能快地运行。如果你要对代码的运行时间进行基准测试，请务必运行 <code>cargo build --release</code> 并使用 <em>target/release</em> 中的可执行文件进行基准测试。</p>
<h3 id="cargo-as-convention-cargo-作为约定"><a class="header" href="#cargo-as-convention-cargo-作为约定">Cargo as Convention Cargo 作为约定</a></h3>
<p>With simple projects, Cargo doesn’t provide a lot of value over just using
<code>rustc</code>, but it will prove its worth as your programs become more intricate.
Once programs grow to multiple files or need a dependency, it’s much easier to
let Cargo coordinate the build.</p>
<p>对于简单项目，Cargo 相比直接使用 <code>rustc</code> 并没有提供太多额外价值，但随着程序变得更加复杂，它将证明其价值。一旦程序增长到包含多个文件或需要依赖项，让 Cargo 来协调构建会容易得多。</p>
<p>Even though the <code>hello_cargo</code> project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:</p>
<p>尽管 <code>hello_cargo</code> 项目很简单，但它现在使用了许多你在后续 Rust 生涯中会使用的真实工具。事实上，要处理任何现有项目，你可以使用以下命令通过 Git 检出代码、切换到项目目录并进行构建：</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>For more information about Cargo, check out its documentation.</p>
<p>有关 Cargo 的更多信息，请查阅其文档。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:</p>
<p>你的 Rust 之旅已经有了一个良好的开端！在本章中，你学习了如何：</p>
<ul>
<li>Install the latest stable version of Rust using <code>rustup</code></li>
<li>使用 <code>rustup</code> 安装最新的稳定版 Rust</li>
<li>Update to a newer Rust version</li>
<li>更新到更新的 Rust 版本</li>
<li>Open locally installed documentation</li>
<li>打开本地安装的文档</li>
<li>Write and run a “Hello, world!” program using <code>rustc</code> directly</li>
<li>直接使用 <code>rustc</code> 编写和运行“Hello, world!”程序</li>
<li>Create and run a new project using the conventions of Cargo</li>
<li>使用 Cargo 的约定创建和运行新项目</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.</p>
<p>现在是构建一个更实质性的程序来习惯阅读和编写 Rust 代码的好时机。因此，在第二章中，我们将构建一个猜数字游戏程序。如果你更愿意从学习 Rust 中常见编程概念的工作原理开始，请参阅第三章，然后再回到第二章。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-02-hello-world.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch02-00-guessing-game-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-02-hello-world.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch02-00-guessing-game-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
