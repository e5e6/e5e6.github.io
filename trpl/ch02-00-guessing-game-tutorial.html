<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming a Guessing Game 编写猜数游戏 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programming-a-guessing-game-编写猜数游戏"><a class="header" href="#programming-a-guessing-game-编写猜数游戏">Programming a Guessing Game 编写猜数游戏</a></h1>
<p>Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about <code>let</code>, <code>match</code>, methods, associated
functions, external crates, and more! In the following chapters, we’ll explore
these ideas in more detail. In this chapter, you’ll just practice the
fundamentals.</p>
<p>让我们通过一个动手项目来快速入门 Rust！本章将通过展示如何在实际程序中使用一些常见的 Rust 概念，向你介绍这些概念。你将学习 <code>let</code>、<code>match</code>、方法、关联函数、外部包等内容！在后续章节中，我们将更详细地探讨这些概念。本章中，你只需练习基础知识。</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.</p>
<p>我们将实现一个经典的初学者编程问题：猜数游戏。规则如下：程序会生成一个 1 到 100 之间的随机整数。然后提示玩家输入猜测值。输入后，程序会提示猜测值是太小还是太大。如果猜对了，游戏将打印祝贺信息并退出。</p>
<h2 id="setting-up-a-new-project-创建新项目"><a class="header" href="#setting-up-a-new-project-创建新项目">Setting Up a New Project 创建新项目</a></h2>
<p>To set up a new project, go to the <em>projects</em> directory that you created in
Chapter 1 and make a new project using Cargo, like so:</p>
<p>要创建新项目，请进入你在第 1 章创建的 <em>projects</em> 目录，使用 Cargo 新建项目：</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project (<code>guessing_game</code>)
as the first argument. The second command changes to the new project’s
directory.</p>
<p>第一条命令 <code>cargo new</code> 将项目名 (<code>guessing_game</code>) 作为第一个参数。第二条命令切换到新项目的目录。</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p>查看生成的 <em>Cargo.toml</em> 文件：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>As you saw in Chapter 1, <code>cargo new</code> generates a “Hello, world!” program for
you. Check out the <em>src/main.rs</em> file:</p>
<p>如第 1 章所见，<code>cargo new</code> 会为你生成一个 “Hello, world!” 程序。查看 <em>src/main.rs</em> 文件：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Now let’s compile this “Hello, world!” program and run it in the same step
using the <code>cargo run</code> command:</p>
<p>现在使用 <code>cargo run</code> 命令编译并运行这个 “Hello, world!” 程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>The <code>run</code> command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.</p>
<p>当你需要快速迭代项目时（就像我们在这个游戏中所做的那样），<code>run</code> 命令非常有用，它能在进入下一次迭代前快速测试当前版本。</p>
<p>Reopen the <em>src/main.rs</em> file. You’ll be writing all the code in this file.</p>
<p>重新打开 <em>src/main.rs</em> 文件。你将在此文件中编写所有代码。</p>
<h2 id="processing-a-guess-处理猜测值"><a class="header" href="#processing-a-guess-处理猜测值">Processing a Guess 处理猜测值</a></h2>
<p>The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
<em>src/main.rs</em>.</p>
<p>猜数游戏的第一部分将请求用户输入，处理该输入，并检查输入是否符合预期格式。首先，我们允许玩家输入猜测值。将代码清单 2-1 中的代码输入 <em>src/main.rs</em>。</p>
<figure class="listing" id="listing-2-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="#listing-2-1">Listing 2-1</a>: Code that gets a guess from the user and prints it 获取用户输入并打印的代码</figcaption>
</figure>
<p>This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
<code>io</code> input/output library into scope. The <code>io</code> library comes from the standard
library, known as <code>std</code>:</p>
<p>这段代码包含大量信息，让我们逐行分析。为了获取用户输入并打印结果，我们需要将输入/输出库 <code>io</code> 引入作用域。<code>io</code> 库来自标准库（即 <code>std</code>）：</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>By default, Rust has a set of items defined in the standard library that it
brings into the scope of every program. This set is called the <em>prelude</em>, and
you can see everything in it in the standard library documentation.</p>
<p>默认情况下，Rust 会将标准库中预定义的一组条目引入每个程序的作用域。这组条目称为 <em>预导入（prelude）</em>，你可以在标准库文档中查看其全部内容。</p>
<p>If a type you want to use isn’t in the prelude, you have to bring that type
into scope explicitly with a <code>use</code> statement. Using the <code>std::io</code> library
provides you with a number of useful features, including the ability to accept
user input.</p>
<p>如果你想使用的类型不在预导入中，必须使用 <code>use</code> 语句显式引入作用域。使用 <code>std::io</code> 库提供了许多有用功能，包括接收用户输入的能力。</p>
<p>As you saw in Chapter 1, the <code>main</code> function is the entry point into the
program:</p>
<p>如第 1 章所述，<code>main</code> 函数是程序的入口点：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>The <code>fn</code> syntax declares a new function; the parentheses, <code>()</code>, indicate there
are no parameters; and the curly bracket, <code>{</code>, starts the body of the function.</p>
<p><code>fn</code> 语法声明新函数；括号 <code>()</code> 表示无参数；花括号 <code>{</code> 开始函数体。</p>
<p>As you also learned in Chapter 1, <code>println!</code> is a macro that prints a string to
the screen:</p>
<p>同样如第 1 章所学，<code>println!</code> 是将字符串打印到屏幕的宏：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>This code is printing a prompt stating what the game is and requesting input
from the user.</p>
<p>这段代码打印提示信息，说明游戏内容并要求用户输入。</p>
<h3 id="storing-values-with-variables-用变量存储值"><a class="header" href="#storing-values-with-variables-用变量存储值">Storing Values with Variables 用变量存储值</a></h3>
<p>Next, we’ll create a <em>variable</em> to store the user input, like this:</p>
<p>接下来，我们创建一个<strong>变量</strong>来存储用户输入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Now the program is getting interesting! There’s a lot going on in this little
line. We use the <code>let</code> statement to create the variable. Here’s another example:</p>
<p>现在程序变得有趣了！这短短一行发生了很多事情。我们使用 <code>let</code> 语句创建变量。再看另一个例子：</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>This line creates a new variable named <code>apples</code> and binds it to the value 5. In
Rust, variables are immutable by default, meaning once we give the variable a
value, the value won’t change. We’ll be discussing this concept in detail in
the “Variables and Mutability”
section in Chapter 3. To make a variable mutable, we add <code>mut</code> before the
variable name:</p>
<p>这段代码创建了一个名为 <code>apples</code> 的新变量，并将其绑定到值 <code>5</code>。在 Rust 中，变量默认是
<strong>不可变</strong>的，这意味着一旦我们给变量赋值，该值就不会改变。我们将在第 3 章的
“变量与可变性”一节详细讨论这个概念。要使变量可变，我们在变量名前添加 <code>mut</code>：</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<section class="note" aria-role="note">
<p>Note: The <code>//</code> syntax starts a comment that continues until the end of the
line. Rust ignores everything in comments. We’ll discuss comments in more
detail in Chapter 3.</p>
<p>注意：<code>//</code> 语法开始一个注释，持续到行尾。Rust 会忽略注释中的所有内容。我们将在第 3 章详细讨论注释。</p>
</section>
<p>Returning to the guessing game program, you now know that <code>let mut guess</code> will
introduce a mutable variable named <code>guess</code>. The equal sign (<code>=</code>) tells Rust we
want to bind something to the variable now. On the right of the equal sign is
the value that <code>guess</code> is bound to, which is the result of calling
<code>String::new</code>, a function that returns a new instance of a <code>String</code>.
<code>String</code> is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.</p>
<p>回到猜数游戏程序，你现在知道 <code>let mut guess</code> 将引入一个名为 <code>guess</code> 的可变变量。等号 (<code>=</code>) 告诉 Rust 现在要将某物绑定到变量。等号右边是 <code>guess</code> 绑定的值，即调用 <code>String::new</code> 的结果，该函数返回 <code>String</code> 的新实例。<code>String</code> 是标准库提供的字符串类型，是可增长的 UTF-8 编码文本。</p>
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an associated
function of the <code>String</code> type. An <em>associated function</em> is a function that’s
implemented on a type, in this case <code>String</code>. This <code>new</code> function creates a
new, empty string. You’ll find a <code>new</code> function on many types because it’s a
common name for a function that makes a new value of some kind.</p>
<p><code>::new</code> 行中的 <code>::</code> 语法表明 <code>new</code> 是 <code>String</code> 类型的<strong>关联函数</strong>。关联函数是针对类型实现的函数，此处即 <code>String</code>。这个 <code>new</code> 函数会创建新的空字符串。许多类型上都有 <code>new</code> 函数，因为它是创建某种新值的常见函数名。</p>
<p>In full, the <code>let mut guess = String::new();</code> line has created a mutable
variable that is currently bound to a new, empty instance of a <code>String</code>. Whew!</p>
<p>总结来说，<code>let mut guess = String::new();</code> 这行代码创建了一个可变变量，该变量当前绑定到一个新的空 <code>String</code> 实例。搞定！</p>
<h3 id="receiving-user-input-接收用户输入"><a class="header" href="#receiving-user-input-接收用户输入">Receiving User Input 接收用户输入</a></h3>
<p>Recall that we included the input/output functionality from the standard
library with <code>use std::io;</code> on the first line of the program. Now we’ll call
the <code>stdin</code> function from the <code>io</code> module, which will allow us to handle user
input:</p>
<p>回想一下，我们在程序第一行用 <code>use std::io;</code> 导入了标准库的输入/输出功能。现在我们将调用 <code>io</code> 模块中的 <code>stdin</code> 函数来处理用户输入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>If we hadn’t imported the <code>io</code> module with <code>use std::io;</code> at the beginning of
the program, we could still use the function by writing this function call as
<code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of
<code>std::io::Stdin</code>, which is a type that represents a
handle to the standard input for your terminal.</p>
<p>如果开头没有用 <code>use std::io;</code> 导入 <code>io</code> 模块，仍可通过 <code>std::io::stdin</code> 调用此函数。<code>stdin</code> 函数返回 <code>std::io::Stdin</code> 的实例，这是表示终端标准输入句柄的类型。</p>
<p>Next, the line <code>.read_line(&amp;mut guess)</code> calls the <code>read_line</code> method on the standard input handle to get input from the user.
We’re also passing <code>&amp;mut guess</code> as the argument to <code>read_line</code> to tell it what
string to store the user input in. The full job of <code>read_line</code> is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string’s content.</p>
<p>接下来，<code>.read_line(&amp;mut guess)</code> 行在标准输入句柄上调用 <code>read_line</code> 方法以获取用户输入。我们还将 <code>&amp;mut guess</code> 作为参数传递给 <code>read_line</code>，告诉它存储用户输入的字符串。<code>read_line</code> 的完整工作是获取用户键入到标准输入的任何内容，并将其追加到字符串中（不覆盖内容），因此我们将该字符串作为参数传递。字符串参数需要是可变的，以便方法能更改其内容。</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that, like variables, references are
immutable by default. Hence, you need to write <code>&amp;mut guess</code> rather than
<code>&amp;guess</code> to make it mutable. (Chapter 4 will explain references more
thoroughly.)</p>
<p><code>&amp;</code> 表示此参数是一个<strong>引用</strong>，它让你无需多次将数据复制到内存中，就能让代码的多个部分访问同一数据片段。引用是一个复杂特性，而 Rust 的主要优势之一就是安全且易于使用引用。要完成此程序，你无需了解太多细节。现在只需知道，与变量类似，引用默认是不可变的。因此，你需要写 <code>&amp;mut guess</code> 而非 <code>&amp;guess</code> 来使其可变。（第 4 章会更详细地解释引用。）</p>
<h3 id="handling-potential-failure-with-result-用-result-处理潜在错误"><a class="header" href="#handling-potential-failure-with-result-用-result-处理潜在错误">Handling Potential Failure with <code>Result</code> 用 <code>Result</code> 处理潜在错误</a></h3>
<p>We’re still working on this line of code. We’re now discussing a third line of
text, but note that it’s still part of a single logical line of code. The next
part is this method:</p>
<p>我们仍在处理这行代码。现在讨论第三行文本，但请注意它仍是单个逻辑代码行的一部分。下一部分是这个方法：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>We could have written this code as:</p>
<p>我们本可以将此代码写成：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>However, one long line is difficult to read, so it’s best to divide it. It’s
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the <code>.method_name()</code> syntax. Now let’s
discuss what this line does.</p>
<p>但长行难以阅读，最好拆开。使用 <code>.method_name()</code> 语法调用方法时，通常明智的做法是换行和添加空格来分隔长行。现在讨论这行代码的作用。</p>
<p>As mentioned earlier, <code>read_line</code> puts whatever the user enters into the string
we pass to it, but it also returns a <code>Result</code> value. <code>Result</code> is an <em>enumeration</em>, often called an <em>enum</em>,
which is a type that can be in one of multiple possible states. We call each
possible state a <em>variant</em>.</p>
<p>如前所述，<code>read_line</code> 将用户输入的内容放入我们传递的字符串中，但它也返回一个 <code>Result</code> 值。<code>Result</code> 是<strong>枚举（enumeration）</strong>，通常称为 <strong>enum</strong>，是一种可以处于多种可能状态之一的类型。我们将每个可能的状态称为<strong>变体（variant）</strong>。</p>
<p>Chapter 6 will cover enums in more detail. The purpose
of these <code>Result</code> types is to encode error-handling information.</p>
<p>第 6 章将更详细地介绍枚举。这些 <code>Result</code> 类型的目的是编码错误处理信息。</p>
<p><code>Result</code>’s variants are <code>Ok</code> and <code>Err</code>. The <code>Ok</code> variant indicates the
operation was successful, and it contains the successfully generated value.
The <code>Err</code> variant means the operation failed, and it contains information
about how or why the operation failed.</p>
<p><code>Result</code> 的变体是 <code>Ok</code> 和 <code>Err</code>。<code>Ok</code> 变体表示操作成功，并包含成功生成的值。<code>Err</code> 变体表示操作失败，并包含有关操作失败方式或原因的信息。</p>
<p>Values of the <code>Result</code> type, like values of any type, have methods defined on
them. An instance of <code>Result</code> has an <code>expect</code> method
that you can call. If this instance of <code>Result</code> is an <code>Err</code> value, <code>expect</code>
will cause the program to crash and display the message that you passed as an
argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>, it would
likely be the result of an error coming from the underlying operating system.
If this instance of <code>Result</code> is an <code>Ok</code> value, <code>expect</code> will take the return
value that <code>Ok</code> is holding and return just that value to you so you can use it.
In this case, that value is the number of bytes in the user’s input.</p>
<p><code>Result</code> 类型的值（如任何类型的值）都定义了方法。<code>Result</code> 实例有一个可调用的 <code>expect</code> 方法。如果此 <code>Result</code> 实例是 <code>Err</code> 值，<code>expect</code> 将导致程序崩溃并显示你作为参数传递给 <code>expect</code> 的消息。如果 <code>read_line</code> 方法返回 <code>Err</code>，很可能是因为底层操作系统错误。如果此 <code>Result</code> 实例是 <code>Ok</code> 值，<code>expect</code> 将获取 <code>Ok</code> 保存的返回值，并将该值返回给你以便使用。此时，该值是用户输入的字节数。</p>
<p>If you don’t call <code>expect</code>, the program will compile, but you’ll get a warning:</p>
<p>如果不调用 <code>expect</code>，程序会编译，但会收到警告：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warns that you haven’t used the <code>Result</code> value returned from <code>read_line</code>,
indicating that the program hasn’t handled a possible error.</p>
<p>Rust 警告你未使用 <code>read_line</code> 返回的 <code>Result</code> 值，表明程序尚未处理可能的错误。</p>
<p>The right way to suppress the warning is to actually write error-handling code,
but in our case we just want to crash this program when a problem occurs, so we
can use <code>expect</code>. You’ll learn about recovering from errors in Chapter
9.</p>
<p>消除警告的正确方法是编写错误处理代码，但在本例中，我们只希望在发生问题时让程序崩溃，因此可以使用 <code>expect</code>。你将在第 9 章学习如何从错误中恢复。</p>
<h3 id="printing-values-with-println-placeholders-用-println-占位符打印值"><a class="header" href="#printing-values-with-println-placeholders-用-println-占位符打印值">Printing Values with <code>println!</code> Placeholders 用 <code>println!</code> 占位符打印值</a></h3>
<p>Aside from the closing curly bracket, there’s only one more line to discuss in
the code so far:</p>
<p>除了右花括号外，目前代码中只有一行需要讨论：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {guess}");
<span class="boring">}</span></code></pre>
<p>This line prints the string that now contains the user’s input. The <code>{}</code> set of
curly brackets is a placeholder: think of <code>{}</code> as little crab pincers that hold
a value in place. When printing the value of a variable, the variable name can
go inside the curly brackets. When printing the result of evaluating an
expression, place empty curly brackets in the format string, then follow the
format string with a comma-separated list of expressions to print in each empty
curly bracket placeholder in the same order. Printing a variable and the result
of an expression in one call to <code>println!</code> would look like this:</p>
<p>此行打印现在包含用户输入的字符串。<code>{}</code> 花括号是一个占位符：将 <code>{}</code> 视为固定值的小蟹钳。打印变量值时，变量名可以放在花括号内。打印表达式求值结果时，在格式字符串中放置空花括号，然后按相同顺序在空花括号占位符中打印以逗号分隔的表达式列表。在单次 <code>println!</code> 调用中打印变量和表达式结果如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>This code would print <code>x = 5 and y + 2 = 12</code>.</p>
<p>此代码将打印 <code>x = 5 and y + 2 = 12</code>。</p>
<h3 id="testing-the-first-part-测试第一部分"><a class="header" href="#testing-the-first-part-测试第一部分">Testing the First Part 测试第一部分</a></h3>
<p>Let’s test the first part of the guessing game. Run it using <code>cargo run</code>:</p>
<p>让我们测试猜数游戏的第一部分。用 <code>cargo run</code> 运行它：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.</p>
<p>至此，游戏的第一部分已完成：我们从键盘获取输入并打印它。</p>
<h2 id="generating-a-secret-number-生成秘密数字"><a class="header" href="#generating-a-secret-number-生成秘密数字">Generating a Secret Number 生成秘密数字</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We’ll use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a <code>rand</code> crate with
said functionality.</p>
<p>接下来，我们需要生成一个用户将尝试猜测的秘密数字。每次秘密数字都应不同，以便游戏可重复游玩。我们将使用 1 到 100 之间的随机数，这样游戏不会太难。Rust 的标准库尚未包含随机数功能。不过，Rust 团队提供了一个具有此功能的 <code>rand</code> 包。</p>
<h3 id="using-a-crate-to-get-more-functionality-使用包获取更多功能"><a class="header" href="#using-a-crate-to-get-more-functionality-使用包获取更多功能">Using a Crate to Get More Functionality 使用包获取更多功能</a></h3>
<p>Remember that a crate is a collection of Rust source code files. The project
we’ve been building is a <em>binary crate</em>, which is an executable. The <code>rand</code>
crate is a <em>library crate</em>, which contains code that is intended to be used in
other programs and can’t be executed on its own.</p>
<p>请记住，<strong>包（crate）</strong> 是 Rust 源代码文件的集合。我们一直在构建的项目是一个<strong>二进制包（binary crate）</strong>，即可执行文件。<code>rand</code> 包是一个<strong>库包（library crate）</strong>，包含供其他程序使用的代码，本身不能执行。</p>
<p>Cargo’s coordination of external crates is where Cargo really shines. Before we
can write code that uses <code>rand</code>, we need to modify the <em>Cargo.toml</em> file to
include the <code>rand</code> crate as a dependency. Open that file now and add the
following line to the bottom, beneath the <code>[dependencies]</code> section header that
Cargo created for you. Be sure to specify <code>rand</code> exactly as we have here, with
this version number, or the code examples in this tutorial may not work:</p>
<p>Cargo 对外部包的协调是其真正亮点所在。在使用 <code>rand</code> 编写代码之前，我们需要修改 <em>Cargo.toml</em> 文件以将 <code>rand</code> 包添加为依赖项。现在打开该文件，在 Cargo 为你创建的 <code>[dependencies]</code> 部分标题下方添加以下行。请务必完全按此处指定 <code>rand</code> 和版本号，否则本教程中的代码示例可能无法工作：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of that
section that continues until another section starts. In <code>[dependencies]</code> you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the <code>rand</code> crate with the
semantic version specifier <code>0.8.5</code>. Cargo understands Semantic
Versioning (sometimes called <em>SemVer</em>), which is a
standard for writing version numbers. The specifier <code>0.8.5</code> is actually
shorthand for <code>^0.8.5</code>, which means any version that is at least 0.8.5 but
below 0.9.0.</p>
<p>在 <em>Cargo.toml</em> 文件中，标题之后的所有内容都属于该部分，直到另一部分开始。
在 <code>[dependencies]</code> 中，你告诉 Cargo 项目依赖哪些外部包以及所需的版本。
此处，我们使用语义版本说明符 <code>0.8.5</code> 指定 <code>rand</code> 包。Cargo 理解语义化版本
（有时称为 <em>SemVer</em>），这是编写版本号的标准。
<span class="highlight">[note]说明符 <code>0.8.5</code> 实际上是 <code>^0.8.5</code> 的简写，
表示至少为 0.8.5 但低于 0.9.0 的任何版本。</span></p>
<p>Cargo considers these versions to have public APIs compatible with version
0.8.5, and this specification ensures you’ll get the latest patch release that
will still compile with the code in this chapter. Any version 0.9.0 or greater
is not guaranteed to have the same API as what the following examples use.</p>
<p>Cargo 认为这些版本与 0.8.5 版本具有兼容的公共 API，此规范确保你将获得仍能编译本章代码的最新补丁版本。0.9.0 或更高版本不保证具有与以下示例相同的 API。</p>
<p>Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.</p>
<p>现在，在不更改任何代码的情况下构建项目，如代码清单 2-2 所示。</p>
<figure class="listing" id="listing-2-2">
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
<figcaption><a href="#listing-2-2">Listing 2-2</a>: The output from running <code>cargo build</code> after adding the rand crate as a dependency 添加<code>rand</code>依赖后<code>cargo build</code>的输出</figcaption>
</figure>
<p>You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!) and different lines (depending on the operating
system), and the lines may be in a different order.</p>
<p>你可能会看到不同的版本号（但由于 SemVer，它们都与代码兼容！）和不同的行（取决于操作系统），且行的顺序可能不同。</p>
<p>When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the <em>registry</em>, which is a copy of data
from Crates.io. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>
<p>当我们包含外部依赖项时，Cargo 会从<strong>注册表（registry）</strong>（Crates.io 的数据副本）获取依赖项所需的所有内容的最新版本。Crates.io 是 Rust 生态系统中人们发布开源 Rust 项目供他人使用的地方。</p>
<p>After updating the registry, Cargo checks the <code>[dependencies]</code> section and
downloads any crates listed that aren’t already downloaded. In this case,
although we only listed <code>rand</code> as a dependency, Cargo also grabbed other crates
that <code>rand</code> depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.</p>
<p>更新注册表后，Cargo 检查 <code>[dependencies]</code> 部分并下载列出的所有尚未下载的包。本例中，尽管只列出了 <code>rand</code> 作为依赖项，但 Cargo 也获取了 <code>rand</code> 工作所需的其他包。下载包后，Rust 编译它们，然后编译项目（依赖项可用）。</p>
<p>If you immediately run <code>cargo build</code> again without making any changes, you
won’t get any output aside from the <code>Finished</code> line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your <em>Cargo.toml</em> file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.</p>
<p>如果未进行任何更改立即再次运行 <code>cargo build</code>，除了 <code>Finished</code> 行外不会有任何输出。Cargo 知道它已下载并编译了依赖项，且你未更改 <em>Cargo.toml</em> 文件中的任何内容。Cargo 也知道你未更改代码，因此也不会重新编译代码。无事可做，它直接退出。</p>
<p>If you open the <em>src/main.rs</em> file, make a trivial change, and then save it and
build again, you’ll only see two lines of output:</p>
<p>如果打开 <em>src/main.rs</em> 文件，进行微小更改，保存后再次构建，只会看到两行输出：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>These lines show that Cargo only updates the build with your tiny change to the
<em>src/main.rs</em> file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.</p>
<p>这些行显示 Cargo 仅使用你对 <em>src/main.rs</em> 文件的微小更改更新构建。依赖项未更改，因此 Cargo 知道它可以重用已下载和编译的内容。</p>
<h4 id="ensuring-reproducible-builds-with-the-cargolock-file-用-cargolock-文件确保可重现构建"><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file-用-cargolock-文件确保可重现构建">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File 用 <em>Cargo.lock</em> 文件确保可重现构建</a></h4>
<p>Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.6 of the <code>rand</code> crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the <em>Cargo.lock</em> file the first
time you run <code>cargo build</code>, so we now have this in the <em>guessing_game</em>
directory.</p>
<p>Cargo 有一种机制确保每次你或他人构建代码时都能重建相同的产物：Cargo 将仅使用你指定的依赖版本，直到你另有指示。例如，假设下周 <code>rand</code> 包的 0.8.6 版本发布，该版本包含重要的错误修复，但也包含会破坏代码的回归问题。为处理此情况，Rust 在你首次运行 <code>cargo build</code> 时创建 <em>Cargo.lock</em> 文件，因此 <em>guessing_game</em> 目录中现在有此文件。</p>
<p>When you build a project for the first time, Cargo figures out all the versions
of the dependencies that fit the criteria and then writes them to the
<em>Cargo.lock</em> file. When you build your project in the future, Cargo will see
that the <em>Cargo.lock</em> file exists and will use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at 0.8.5 until you explicitly upgrade, thanks to the <em>Cargo.lock</em> file.
Because the <em>Cargo.lock</em> file is important for reproducible builds, it’s often
checked into source control with the rest of the code in your project.</p>
<p><span class="highlight">[note]首次构建项目时，Cargo 会确定所有符合条件的依赖版本，然后将它们写入 <em>Cargo.lock</em> 文件。将来构建项目时，Cargo 将看到 <em>Cargo.lock</em> 文件存在，并使用其中指定的版本，而不再重新计算版本。这让你自动拥有可重现的构建。换句话说，由于 <em>Cargo.lock</em> 文件的存在，项目将保持在 0.8.5 版本，直到你显式升级。因为 <em>Cargo.lock</em> 文件对可重现构建很重要，它通常与项目中的其余代码一起检入源代码管理。<span></p>
<h4 id="updating-a-crate-to-get-a-new-version-更新包以获取新版本"><a class="header" href="#updating-a-crate-to-get-a-new-version-更新包以获取新版本">Updating a Crate to Get a New Version 更新包以获取新版本</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides the command <code>update</code>,
which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions
that fit your specifications in <em>Cargo.toml</em>. Cargo will then write those
versions to the <em>Cargo.lock</em> file. In this case, Cargo will only look for
versions greater than 0.8.5 and less than 0.9.0. If the <code>rand</code> crate has
released the two new versions 0.8.6 and 0.9.0, you would see the following if
you ran <code>cargo update</code>:</p>
<p><span class="highlight">[note]当你确实想更新包时，Cargo 提供了 <code>update</code> 命令</span>，该命令会忽略 <em>Cargo.lock</em> 文件，并找出 <em>Cargo.toml</em> 中符合你规范的所有最新版本。然后 Cargo 将这些版本写入 <em>Cargo.lock</em> 文件。本例中，Cargo 仅查找大于 0.8.5 且小于 0.9.0 的版本。如果 <code>rand</code> 包已发布两个新版本 0.8.6 和 0.9.0，运行 <code>cargo update</code> 会看到：</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.9.0)
</code></pre>
<p>Cargo ignores the 0.9.0 release. At this point, you would also notice a change
in your <em>Cargo.lock</em> file noting that the version of the <code>rand</code> crate you are
now using is 0.8.6. To use <code>rand</code> version 0.9.0 or any version in the 0.9.<em>x</em>
series, you’d have to update the <em>Cargo.toml</em> file to look like this instead:</p>
<p>Cargo 忽略了 0.9.0 版本。此时，你还会注意到 <em>Cargo.lock</em> 文件中的变化，表明你现在使用的 <code>rand</code> 包版本是 0.8.6。要使用 <code>rand</code> 0.9.0 或 0.9.<em>x</em> 系列的任何版本，必须将 <em>Cargo.toml</em> 文件更新为如下内容：</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>The next time you run <code>cargo build</code>, Cargo will update the registry of crates
available and reevaluate your <code>rand</code> requirements according to the new version
you have specified.</p>
<p>下次运行 <code>cargo build</code> 时，Cargo 将更新可用包的注册表，并根据你指定的新版本重新评估 <code>rand</code> 要求。</p>
<p>There’s a lot more to say about Cargo and its
ecosystem, which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.</p>
<p>关于 Cargo 及其生态系统还有很多内容，我们将在第 14 章讨论，但现在你只需了解这些。Cargo 让重用库变得非常容易，因此 Rust 开发者能够编写由多个包组成的更小项目。</p>
<h3 id="generating-a-random-number-生成随机数"><a class="header" href="#generating-a-random-number-生成随机数">Generating a Random Number 生成随机数</a></h3>
<p>Let’s start using <code>rand</code> to generate a number to guess. The next step is to
update <em>src/main.rs</em>, as shown in Listing 2-3.</p>
<p>让我们开始使用 <code>rand</code> 生成要猜测的数字。下一步是更新 <em>src/main.rs</em>，如代码清单 2-3 所示。</p>
<figure class="listing" id="listing-2-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="#listing-2-3">Listing 2-3</a>: Adding code to generate a random number 添加生成随机数的代码</figcaption>
</figure>
<p>First we add the line <code>use rand::Rng;</code>. The <code>Rng</code> trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.</p>
<p>首先添加行 <code>use rand::Rng;</code>。<code>Rng</code> 特性定义了随机数生成器实现的方法，该特性必须在作用域中才能使用这些方法。第 10 章将详细讨论特性。</p>
<p>Next, we’re adding two lines in the middle. In the first line, we call the
<code>rand::thread_rng</code> function that gives us the particular random number
generator we’re going to use: one that is local to the current thread of
execution and is seeded by the operating system. Then we call the <code>gen_range</code>
method on the random number generator. This method is defined by the <code>Rng</code>
trait that we brought into scope with the <code>use rand::Rng;</code> statement. The
<code>gen_range</code> method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we’re using here takes
the form <code>start..=end</code> and is inclusive on the lower and upper bounds, so we
need to specify <code>1..=100</code> to request a number between 1 and 100.</p>
<p>接下来，我们在中间添加两行。第一行调用 <code>rand::thread_rng</code> 函数，该函数提供我们将要使用的特定随机数生成器：一个植根于当前执行线程并由操作系统提供种子。然后我们在随机数生成器上调用 <code>gen_range</code> 方法。此方法由我们通过 <code>use rand::Rng;</code> 语句引入作用域的 <code>Rng</code> 特性定义。<code>gen_range</code> 方法将范围表达式作为参数，并在该范围内生成随机数。此处使用的范围表达式形式为 <code>start..=end</code>（包含下限和上限），因此需要指定 <code>1..=100</code> 来请求 1 到 100 之间的数字。</p>
<section class="note" aria-role="note">
<p>Note: You won’t just know which traits to use and which methods and functions
to call from a crate, so each crate has documentation with instructions for
using it. Another neat feature of Cargo is that running the <code>cargo doc  --open</code> command will build documentation provided by all your dependencies
locally and open it in your browser. If you’re interested in other
functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code> and
click <code>rand</code> in the sidebar on the left.</p>
<p>注意：你无法仅凭直觉知道要使用哪些特性以及从包中调用哪些方法和函数，因此每个包都有说明文档。Cargo 的另一个巧妙特性是，运行 <code>cargo doc --open</code> 命令会在本地构建所有依赖项提供的文档并在浏览器中打开。例如，如果你对 <code>rand</code> 包中的其他功能感兴趣，请运行 <code>cargo doc --open</code> 并点击左侧边栏中的 <code>rand</code>。</p>
</section>
<p>The second new line prints the secret number. This is useful while we’re
developing the program to be able to test it, but we’ll delete it from the
final version. It’s not much of a game if the program prints the answer as soon
as it starts!</p>
<p>第二行打印秘密数字。这在开发程序时很有用，但最终版本会删除它。如果程序一启动就打印答案，那就不算游戏了！</p>
<p>Try running the program a few times:</p>
<p>尝试多次运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<p>你应该得到不同的随机数，且它们都应在 1 到 100 之间。干得好！</p>
<h2 id="comparing-the-guess-to-the-secret-number-比较猜测值和秘密数字"><a class="header" href="#comparing-the-guess-to-the-secret-number-比较猜测值和秘密数字">Comparing the Guess to the Secret Number 比较猜测值和秘密数字</a></h2>
<p>Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile just yet, as we will
explain.</p>
<p>现在我们有了用户输入和随机数，可以比较它们了。此步骤如代码清单 2-4 所示。请注意，此代码暂时无法编译，我们将解释原因。</p>
<figure class="listing" id="listing-2-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<figcaption><a href="#listing-2-4">Listing 2-4</a>: Handling the possible return values of comparing two numbers 处理比较两个数字可能的返回值</figcaption>
</figure>
<p>First we add another <code>use</code> statement, bringing a type called
<code>std::cmp::Ordering</code> into scope from the standard library. The <code>Ordering</code> type
is another enum and has the variants <code>Less</code>, <code>Greater</code>, and <code>Equal</code>. These are
the three outcomes that are possible when you compare two values.</p>
<p>首先添加另一个 <code>use</code> 语句，将名为 <code>std::cmp::Ordering</code> 的类型从标准库引入作用域。<code>Ordering</code> 类型是另一个枚举，具有变体 <code>Less</code>、<code>Greater</code> 和 <code>Equal</code>。这是比较两个值时可能的三种结果。</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type. The
<code>cmp</code> method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing <code>guess</code> to <code>secret_number</code>. Then it returns a variant of the
<code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a
<code>match</code> expression to decide what to do next based on
which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values
in <code>guess</code> and <code>secret_number</code>.</p>
<p>然后我们在底部添加五行使用 <code>Ordering</code> 类型的代码。<code>cmp</code> 方法比较两个值，可在任何可比较对象上调用。它接受一个引用作为参数：此处将 <code>guess</code> 与 <code>secret_number</code> 比较。然后返回我们通过 <code>use</code> 语句引入作用域的 <code>Ordering</code> 枚举变体。我们使用 <code>match</code> 表达式根据调用 <code>cmp</code> 返回的 <code>Ordering</code> 变体决定下一步操作（参数为 <code>guess</code> 和 <code>secret_number</code> 的值）。</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> to
match against, and the code that should be run if the value given to <code>match</code>
fits that arm’s pattern. Rust takes the value given to <code>match</code> and looks
through each arm’s pattern in turn. Patterns and the <code>match</code> construct are
powerful Rust features: they let you express a variety of situations your code
might encounter and they make sure you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 19, respectively.</p>
<p><code>match</code> 表达式由<strong>分支（arms）</strong> 组成。分支包含要匹配的<strong>模式（pattern）</strong>，以及当 <code>match</code> 的值符合该分支模式时应运行的代码。Rust 获取给 <code>match</code> 的值，并依次检查每个分支的模式。模式和 <code>match</code> 结构是 Rust 的强大特性：它们让你表达代码可能遇到的各种情况，并确保你处理所有情况。这些特性将在第 6 章和第 19 章分别详细讨论。</p>
<p>Let’s walk through an example with the <code>match</code> expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is 38.</p>
<p>让我们通过此处的 <code>match</code> 表达式走一遍示例。假设用户猜了 50，而本次随机生成的秘密数字是 38。</p>
<p>When the code compares 50 to 38, the <code>cmp</code> method will return
<code>Ordering::Greater</code> because 50 is greater than 38. The <code>match</code> expression gets
the <code>Ordering::Greater</code> value and starts checking each arm’s pattern. It looks
at the first arm’s pattern, <code>Ordering::Less</code>, and sees that the value
<code>Ordering::Greater</code> does not match <code>Ordering::Less</code>, so it ignores the code in
that arm and moves to the next arm. The next arm’s pattern is
<code>Ordering::Greater</code>, which <em>does</em> match <code>Ordering::Greater</code>! The associated
code in that arm will execute and print <code>Too big!</code> to the screen. The <code>match</code>
expression ends after the first successful match, so it won’t look at the last
arm in this scenario.</p>
<p>当代码比较 50 和 38 时，<code>cmp</code> 方法将返回 <code>Ordering::Greater</code>，因为 50 大于 38。
<code>match</code> 表达式获取 <code>Ordering::Greater</code> 值并开始检查每个分支的模式。它查看第一个分支的模
式 <code>Ordering::Less</code>，发现值 <code>Ordering::Greater</code> 不匹配 <code>Ordering::Less</code>，因此忽略
该分支的代码并移至下一个分支。下一个分支的模式是 <code>Ordering::Greater</code>，它<strong>确实</strong>匹配
<code>Ordering::Greater</code>！该分支的关联代码将执行并在屏幕上打印 <code>Too big!</code>。<code>match</code> 表达式在
第一次成功匹配后结束，因此在此情况下不会查看最后一个分支。</p>
<p>However, the code in Listing 2-4 won’t compile yet. Let’s try it:</p>
<p>但是，代码清单 2-4 中的代码目前无法编译。让我们尝试一下：</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>The core of the error states that there are <em>mismatched types</em>. Rust has a
strong, static type system. However, it also has type inference. When we wrote
<code>let mut guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be
a <code>String</code> and didn’t make us write the type. The <code>secret_number</code>, on the other
hand, is a number type. A few of Rust’s number types can have a value between 1
and 100: <code>i32</code>, a 32-bit number; <code>u32</code>, an unsigned 32-bit number; <code>i64</code>, a
64-bit number; as well as others. Unless otherwise specified, Rust defaults to
an <code>i32</code>, which is the type of <code>secret_number</code> unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.</p>
<p>错误的核心是存在<strong>类型不匹配</strong>。Rust 具有强大的静态类型系统。但它也有类型推断。当我们写 <code>let mut guess = String::new()</code> 时，Rust 能够推断 <code>guess</code> 应为 <code>String</code>，无需我们写出类型。而 <code>secret_number</code> 是数字类型。Rust 的几种数字类型可具有 1 到 100 之间的值：<code>i32</code>（32 位数字）、<code>u32</code>（无符号 32 位数字）、<code>i64</code>（64 位数字）等。除非另有指定，Rust 默认为 <code>i32</code>，即 <code>secret_number</code> 的类型（除非在其他地方添加类型信息导致 Rust 推断出不同的数值类型）。错误原因是 Rust 无法比较字符串和数字类型。</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a
number type so we can compare it numerically to the secret number. We do so by
adding this line to the <code>main</code> function body:</p>
<p>最终，我们希望将程序读取的输入 <code>String</code> 转换为数字类型，以便与秘密数字进行数值比较。通过将此行添加到 <code>main</code> 函数体来实现：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>The line is:</p>
<p>该行代码是：</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>We create a variable named <code>guess</code>. But wait, doesn’t the program already have
a variable named <code>guess</code>? It does, but helpfully Rust allows us to shadow the
previous value of <code>guess</code> with a new one. <em>Shadowing</em> lets us reuse the <code>guess</code>
variable name rather than forcing us to create two unique variables, such as
<code>guess_str</code> and <code>guess</code>, for example. We’ll cover this in more detail in
Chapter 3, but for now, know that this feature is
often used when you want to convert a value from one type to another type.</p>
<p>我们创建名为 <code>guess</code> 的变量。但等等，程序不是已有一个名为 <code>guess</code> 的变量吗？确实有，但 Rust 允许我们<strong>遮蔽（shadow）</strong> <code>guess</code> 的先前值。遮蔽让我们可以重用 <code>guess</code> 变量名，而不必创建两个唯一变量（例如 <code>guess_str</code> 和 <code>guess</code>）。我们将在第 3 章详细介绍此特性，但现在只需知道，当你希望将值从一种类型转换为另一种类型时，通常会使用此特性。</p>
<p>We bind this new variable to the expression <code>guess.trim().parse()</code>. The <code>guess</code>
in the expression refers to the original <code>guess</code> variable that contained the
input as a string. The <code>trim</code> method on a <code>String</code> instance will eliminate any
whitespace at the beginning and end, which we must do before we can convert the
string to a <code>u32</code>, which can only contain numerical data. The user must press
<kbd>enter</kbd> to satisfy <code>read_line</code> and input their guess, which adds a
newline character to the string. For example, if the user types <kbd>5</kbd> and
presses <kbd>enter</kbd>, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents
“newline.” (On Windows, pressing <kbd>enter</kbd> results in a carriage return
and a newline, <code>\r\n</code>.) The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>, resulting
in just <code>5</code>.</p>
<p>我们将这个新变量绑定到表达式 <code>guess.trim().parse()</code>。表达式中的 <code>guess</code> 指的是原始的 <code>guess</code> 变量（包含字符串形式的输入）。<code>String</code> 实例上的 <code>trim</code> 方法将消除开头和结尾的任何空白，我们必须先执行此操作才能将字符串转换为 <code>u32</code>（只能包含数字数据）。用户必须按 <kbd>enter</kbd> 键来满足 <code>read_line</code> 并输入猜测值，这会在字符串中添加换行符。例如，如果用户键入 <kbd>5</kbd> 并按 <kbd>enter</kbd>，<code>guess</code> 看起来像这样：<code>5\n</code>。<code>\n</code> 表示“换行”。（在 Windows 上，按 <kbd>enter</kbd> 会产生回车符和换行符 <code>\r\n</code>。）<code>trim</code> 方法会消除 <code>\n</code> 或 <code>\r\n</code>，仅留下 <code>5</code>。</p>
<p>The <code>parse</code> method on strings converts a string to
another type. Here, we use it to convert from a string to a number. We need to
tell Rust the exact number type we want by using <code>let guess: u32</code>. The colon
(<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust has a
few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit integer.
It’s a good default choice for a small positive number. You’ll learn about
other number types in Chapter 3.</p>
<p>字符串上的 <code>parse</code> 方法将字符串转换为另一种类型。此处，我们用它从字符串转换为数字。我们需要使用 <code>let guess: u32</code> 告诉 Rust 所需的数字类型。<code>guess</code> 后的冒号 (<code>:</code>) 告诉 Rust 我们将注解变量类型。Rust 有一些内置的数字类型；此处看到的 <code>u32</code> 是无符号 32 位整数。对于小的正数来说，这是一个不错的选择。你将在第 3 章了解其他数字类型。</p>
<p>Additionally, the <code>u32</code> annotation in this example program and the comparison
with <code>secret_number</code> means Rust will infer that <code>secret_number</code> should be a
<code>u32</code> as well. So now the comparison will be between two values of the same
type!</p>
<p>此外，本例中的 <code>u32</code> 注解以及与 <code>secret_number</code> 的比较意味着 Rust 将推断 <code>secret_number</code> 也应为 <code>u32</code>。因此现在比较将在两个相同类型的值之间进行！</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained <code>A👍%</code>, there would be no way to convert that to a number. Because it
might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code>
method does (discussed earlier in “Handling Potential Failure with
<code>Result</code>”). We’ll treat
this <code>Result</code> the same way by using the <code>expect</code> method again. If <code>parse</code>
returns an <code>Err</code> <code>Result</code> variant because it couldn’t create a number from the
string, the <code>expect</code> call will crash the game and print the message we give it.
If <code>parse</code> can successfully convert the string to a number, it will return the
<code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the number that we want from
the <code>Ok</code> value.</p>
<p><code>parse</code> 方法仅适用于逻辑上可转换为数字的字符，因此很容易出错。例如，如果字符串包含 <code>A👍%</code>，则无法将其转换为数字。因为它可能失败，<code>parse</code> 方法返回 <code>Result</code> 类型（类似于前面讨论的 <code>read_line</code> 方法）。我们将以相同方式处理此 <code>Result</code>：再次使用 <code>expect</code> 方法。如果 <code>parse</code> 因无法从字符串创建数字而返回 <code>Err</code> <code>Result</code> 变体，<code>expect</code> 调用将使游戏崩溃并打印我们给它的消息。如果 <code>parse</code> 成功将字符串转换为数字，它将返回 <code>Result</code> 的 <code>Ok</code> 变体，而 <code>expect</code> 将从 <code>Ok</code> 值中返回我们想要的数字。</p>
<p>Let’s run the program now:</p>
<p>现在运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.</p>
<p>很好！即使猜测值前添加了空格，程序仍能识别用户猜的是 76。多次运行程序以验证不同输入的行为：正确猜出数字、猜得太大和猜得太小。</p>
<p>We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!</p>
<p>现在游戏的大部分功能已实现，但用户只能猜一次。让我们通过添加循环来改变这一点！</p>
<h2 id="allowing-multiple-guesses-with-looping-使用循环允许多次猜测"><a class="header" href="#allowing-multiple-guesses-with-looping-使用循环允许多次猜测">Allowing Multiple Guesses with Looping 使用循环允许多次猜测</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. We’ll add a loop to give users
more chances at guessing the number:</p>
<p><code>loop</code> 关键字创建一个无限循环。我们将添加循环以让用户有更多机会猜测数字：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>As you can see, we’ve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn’t seem like the user can quit!</p>
<p>如你所见，我们将从猜测输入提示之后的所有内容移入循环。请确保将循环内的行再缩进四个空格，然后再次运行程序。程序现在将永远要求再次猜测，这实际上引入了一个新问题：用户似乎无法退出！</p>
<p>The user could always interrupt the program by using the keyboard shortcut
<kbd>ctrl</kbd>-<kbd>c</kbd>. But there’s another way to escape this insatiable
monster, as mentioned in the <code>parse</code> discussion in “Comparing the Guess to the
Secret Number”: if
the user enters a non-number answer, the program will crash. We can take
advantage of that to allow the user to quit, as shown here:</p>
<p>用户总是可以通过键盘快捷键 <kbd>ctrl</kbd>-<kbd>c</kbd> 中断程序。但还有另一种方法逃离这
个贪得无厌的怪物，正如在“比较猜测值和秘密数字”中 <code>parse</code> 讨论所提到的：如果用户输入非数字答案，程序将崩溃。我们可以利用这一点允许用户退出，如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Typing <code>quit</code> will quit the game, but as you’ll notice, so will entering any
other non-number input. This is suboptimal, to say the least; we want the game
to also stop when the correct number is guessed.</p>
<p>输入 <code>quit</code> 会退出游戏，但你会注意到，输入任何其他非数字输入也是如此。这充其量只是次优解；我们希望游戏在猜对数字时也停止。</p>
<h3 id="quitting-after-a-correct-guess-猜对后退出"><a class="header" href="#quitting-after-a-correct-guess-猜对后退出">Quitting After a Correct Guess 猜对后退出</a></h3>
<p>Let’s program the game to quit when the user wins by adding a <code>break</code> statement:</p>
<p>让我们通过添加 <code>break</code> 语句来让游戏在用户获胜时退出：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>Adding the <code>break</code> line after <code>You win!</code> makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of <code>main</code>.</p>
<p>在 <code>You win!</code> 后添加 <code>break</code> 行，使程序在用户猜对秘密数字时退出循环。退出循环也意味着退出程序，因为循环是 <code>main</code> 的最后一部分。</p>
<h3 id="handling-invalid-input-处理无效输入"><a class="header" href="#handling-invalid-input-处理无效输入">Handling Invalid Input 处理无效输入</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where <code>guess</code>
is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<p>为了进一步完善游戏行为，我们不让程序在用户输入非数字时崩溃，而是忽略非数字以便用户可以继续猜测。我们可以通过更改将 <code>guess</code> 从 <code>String</code> 转换为 <code>u32</code> 的行来实现，如代码清单 2-5 所示。</p>
<figure class="listing" id="listing-2-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-2-5">Listing 2-5</a>: Ignoring a non-number guess and asking for another guess instead of crashing the program 忽略非数字的猜测，让用户输入另一个猜测而不是让程序崩溃</figcaption>
</figure>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing
on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code>
type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We’re using
a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code>
method.</p>
<p>我们将 <code>expect</code> 调用替换为 <code>match</code> 表达式，以从崩溃错误转为处理错误。请记住，<code>parse</code> 返回 <code>Result</code> 类型，而 <code>Result</code> 是具有 <code>Ok</code> 和 <code>Err</code> 变体的枚举。我们在此处使用 <code>match</code> 表达式（就像处理 <code>cmp</code> 方法的 <code>Ordering</code> 结果一样）。</p>
<p>If <code>parse</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resultant number. That <code>Ok</code> value will
match the first arm’s pattern, and the <code>match</code> expression will just return the
<code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it in the new <code>guess</code> variable we’re creating.</p>
<p>如果 <code>parse</code> 能成功将字符串转换为数字，它将返回包含结果数字的 <code>Ok</code> 值。该 <code>Ok</code> 值将匹配第一个分支的模式，<code>match</code> 表达式将仅返回 <code>parse</code> 生成并放入 <code>Ok</code> 值中的 <code>num</code> 值。该数字最终将出现在我们创建的新 <code>guess</code> 变量中。</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does
match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a
catch-all value; in this example, we’re saying we want to match all <code>Err</code>
values, no matter what information they have inside them. So the program will
execute the second arm’s code, <code>continue</code>, which tells the program to go to the
next iteration of the <code>loop</code> and ask for another guess. So, effectively, the
program ignores all errors that <code>parse</code> might encounter!</p>
<p>如果 <code>parse</code> <strong>无法</strong>将字符串转换为数字，它将返回包含有关错误更多信息的 <code>Err</code> 值。<code>Err</code> 值与第一个 <code>match</code> 分支中的 <code>Ok(num)</code> 模式不匹配，但它与第二个分支中的 <code>Err(_)</code> 模式匹配。下划线 <code>_</code> 是通配符值；此例中，我们希望匹配所有 <code>Err</code> 值，无论它们内部有何信息。因此程序将执行第二个分支的代码 <code>continue</code>，这告诉程序进入循环的下一次迭代并要求再次猜测。因此，程序实际上忽略了 <code>parse</code> 可能遇到的所有错误！</p>
<p>Now everything in the program should work as expected. Let’s try it:</p>
<p>现在程序中的所有内容都应如预期工作。让我们试试：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the <code>println!</code> that outputs the
secret number. Listing 2-6 shows the final code.</p>
<p>太棒了！再做一个微小的最终调整，我们将完成猜数游戏。回想一下，程序仍在打印秘密数字。这对测试很有效，但它破坏了游戏。让我们删除输出秘密数字的 <code>println!</code>。代码清单 2-6 展示了最终代码。</p>
<figure class="listing" id="listing-2-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<figcaption><a href="#listing-2-6">Listing 2-6</a>: Complete guessing game code 猜数游戏的完整代码</figcaption>
</figure>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>至此，你已成功构建了猜数游戏。恭喜！</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>This project was a hands-on way to introduce you to many new Rust concepts:
<code>let</code>, <code>match</code>, functions, the use of external crates, and more. In the next
few chapters, you’ll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.</p>
<p>本项目通过实践向你介绍了许多新的 Rust 概念：<code>let</code>、<code>match</code>、函数、外部包的使用等。在接下来的几章中，你将更详细地学习这些概念。第 3 章涵盖大多数编程语言共有的概念（如变量、数据类型和函数），并展示如何在 Rust 中使用它们。第 4 章探讨所有权（Rust 区别于其他语言的特性）。第 5 章讨论结构体和方法语法，第 6 章解释枚举的工作原理。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
