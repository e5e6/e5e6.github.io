<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C - Derivable Traits 可派生特质 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="appendix-c-derivable-traits-可派生特质"><a class="header" href="#appendix-c-derivable-traits-可派生特质">Appendix C: Derivable Traits 可派生特质</a></h2>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the <code>derive</code> syntax.</p>
<p>在本书的不同地方，我们讨论了<code>derive</code>属性，您可以将其应用于结构体或枚举定义。<code>derive</code>属性生成代码，将在使用<code>derive</code>语法标注的类型上使用其默认实现来实现特质。</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<p>在本附录中，我们提供了标准库中所有可通过<code>derive</code>使用的特质的参考。每个部分涵盖：</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<!-- -->
<ul>
<li>派生该特质将启用的运算符和方法</li>
<li><code>derive</code>提供的特质实现的功能</li>
<li>实现该特质对类型的意义</li>
<li>允许或不允许实现该特质的条件</li>
<li>需要该特质的操作示例</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute,
consult the <a href="../std/index.html">standard library documentation</a>
for each trait for details on how to manually implement them.</p>
<p>如果您需要不同于<code>derive</code>属性提供的功能，请查阅<a href="https://doc.rust-lang.org/std/index.html">标准库文档</a>获取手动实现这些特质的详细信息。</p>
<p>The traits listed here are the only ones defined by the standard library that
can be implemented on your types using <code>derive</code>. Other traits defined in the
standard library don’t have sensible default behavior, so it’s up to you to
implement them in the way that makes sense for what you’re trying to accomplish.</p>
<p>此处列出的特质是标准库中唯一可以通过<code>derive</code>在您的类型上实现的特质。标准库中定义的其他特质没有合理的默认行为，因此需要您根据要实现的目标以合理的方式实现它们。</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.</p>
<p>无法被派生的特质的一个例子是<code>Display</code>，它处理面向最终用户的格式化。您应始终考虑向最终用户展示类型的适当方式。最终用户应被允许看到类型的哪些部分？哪些部分对他们来说是相关的？数据的什么格式对他们最相关？Rust编译器没有这种洞察力，因此无法为您提供适当的默认行为。</p>
<p>The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the
“Macros” section of Chapter 20.</p>
<p>本附录提供的可派生特质列表并非详尽无遗：库可以为它们自己的特质实现<code>derive</code>，使您可以使用<code>derive</code>的特质列表真正无限扩展。实现<code>derive</code>涉及使用过程宏，这将在第20章的“宏“部分介绍。</p>
<h3 id="debug-for-programmer-output-面向程序输出的debug"><a class="header" href="#debug-for-programmer-output-面向程序输出的debug"><code>Debug</code> for Programmer Output 面向程序输出的<code>Debug</code></a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p><code>Debug</code>特质在格式化字符串中启用调试格式化，通过在<code>{}</code>占位符内添加<code>:?</code>来指示。</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.</p>
<p><code>Debug</code>特质允许您打印类型的实例以进行调试，这样您和其他使用您的类型的程序员可以在程序执行的特定点检查实例。</p>
<p>The <code>Debug</code> trait is required, for example, in the use of the <code>assert_eq!</code>
macro. This macro prints the values of instances given as arguments if the
equality assertion fails so programmers can see why the two instances weren’t
equal.</p>
<p>例如，在使用<code>assert_eq!</code>宏时就需要<code>Debug</code>特质。如果相等断言失败，此宏会打印作为参数给出的实例值，以便程序员可以看到两个实例不相等的原因。</p>
<h3 id="partialeq-and-eq-for-equality-comparisons-用于相等比较的partialeq和eq"><a class="header" href="#partialeq-and-eq-for-equality-comparisons-用于相等比较的partialeq和eq"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons 用于相等比较的<code>PartialEq</code>和<code>Eq</code></a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p><code>PartialEq</code>特质允许您比较类型的实例以检查相等性，并启用<code>==</code>和<code>!=</code>运算符的使用。</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p><span class="highlight">[note]派生<code>PartialEq</code>会实现<code>eq</code>方法</span>。当在结构体上派生时，仅当所有字段相等时两个实例才相等，如果有任何字段不相等则实例不相等。当在枚举上派生时，每个变体等于其自身而不等于其他变体。</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>例如，在使用<code>assert_eq!</code>宏时就需要<code>PartialEq</code>特质，该宏需要能够比较两个类型的实例是否相等。</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p><span class="highlight">[note]<code>Eq</code>特质没有方法。其目的是表明对于带注释类型的每个值，该值都等于其自身。<code>Eq</code>特质只能应用于也实现了<code>PartialEq</code>的类型，尽管并非所有实现<code>PartialEq</code>的类型都能实现<code>Eq</code>。</span>这方面的一个例子是浮点数类型：浮点数的实现规定两个非数字（<code>NaN</code>）值彼此不相等。</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<p>当<code>Eq</code>被要求的一个例子是<code>HashMap&lt;K, V&gt;</code>中的键，这样<code>HashMap&lt;K, V&gt;</code>可以判断两个键是否相同。</p>
<h3 id="partialord-and-ord-for-ordering-comparisons-用于排序比较的partialord和ord"><a class="header" href="#partialord-and-ord-for-ordering-comparisons-用于排序比较的partialord和ord"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons 用于排序比较的<code>PartialOrd</code>和<code>Ord</code></a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p><code>PartialOrd</code>特质允许您比较类型的实例以进行排序。实现<code>PartialOrd</code>的类型可以与<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>和<code>&gt;=</code>运算符一起使用。<code>PartialOrd</code>特质只能应用于也实现了<code>PartialEq</code>的类型。</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating-point number and the <code>NaN</code>
floating-point value will return <code>None</code>.</p>
<p>派生<code>PartialOrd</code>会实现<code>partial_cmp</code>方法，该方法返回一个<code>Option&lt;Ordering&gt;</code>，当给定值无法产生排序时将返回<code>None</code>。一个即使该类型的大多数值可以比较也无法产生排序的值的例子是非数字（<code>NaN</code>）浮点值。使用任何浮点数和<code>NaN</code>浮点值调用<code>partial_cmp</code>都将返回<code>None</code>。</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>在结构体上派生时，<code>PartialOrd</code>通过比较结构体定义中字段出现的顺序来比较两个实例。在枚举上派生时，枚举定义中较早声明的变体被认为小于后面列出的变体。</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
range expression.</p>
<p>例如，<code>rand</code> crate中的<code>gen_range</code>方法就需要<code>PartialOrd</code>特质，该方法生成范围表达式中指定范围内的随机值。</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p><span class="highlight">[note]<code>Ord</code>特质允许您知道对于带注释类型的任意两个值，都存在有效的排序。</span><code>Ord</code>特质实现了<code>cmp</code>方法，该方法返回<code>Ordering</code>而不是<code>Option&lt;Ordering&gt;</code>，因为始终可能存在有效的排序。<code>Ord</code>特质只能应用于也实现了<code>PartialOrd</code>和<code>Eq</code>的类型（而<code>Eq</code>需要<code>PartialEq</code>）。在结构体和枚举上派生时，<code>cmp</code>的行为方式与<code>PartialOrd</code>的派生实现中的<code>partial_cmp</code>相同。</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<p>当将值存储在<code>BTreeSet&lt;T&gt;</code>（一种根据值排序存储数据的数据结构）中时，就需要<code>Ord</code>特质。</p>
<h3 id="clone-and-copy-for-duplicating-values-用于复制值的clone和copy"><a class="header" href="#clone-and-copy-for-duplicating-values-用于复制值的clone和copy"><code>Clone</code> and <code>Copy</code> for Duplicating Values 用于复制值的<code>Clone</code>和<code>Copy</code></a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See Variables and Data Interacting with
Clone” in Chapter 4
for more information on <code>Clone</code>.</p>
<p><code>Clone</code>特质允许您显式创建值的深拷贝，复制过程可能涉及运行任意代码和复制堆数据。有关<code>Clone</code>的更多信息，请参见第4章“变量与数据交互：克隆“。</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>派生<code>Clone</code>会实现<code>clone</code>方法，当为整个类型实现时，会调用类型各部分的<code>clone</code>方法。这意味着类型的所有字段或值也必须实现<code>Clone</code>才能派生<code>Clone</code>。</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus the type stored in the slice must implement <code>Clone</code>.</p>
<p>当在切片上调用<code>to_vec</code>方法时就需要<code>Clone</code>。切片不拥有其包含的类型实例，但从<code>to_vec</code>返回的向量需要拥有其实例，因此<code>to_vec</code>会对每个项调用<code>clone</code>。因此存储在切片中的类型必须实现<code>Clone</code>。</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See “Stack-Only Data:
Copy” in Chapter 4 for more information on
<code>Copy</code>.</p>
<p><code>Copy</code>特质允许您仅通过复制存储在栈上的位来复制值；无需运行任意代码。有关<code>Copy</code>的更多信息，请参见第4章“仅栈数据：复制“。</p>
<p>The <code>Copy</code> trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p><code>Copy</code>特质没有定义任何方法来防止程序员重载这些方法并违反不运行任意代码的假设。这样，所有程序员都可以假设复制值会非常快。</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. A type that
implements <code>Copy</code> must also implement <code>Clone</code>, because a type that implements
<code>Copy</code> has a trivial implementation of <code>Clone</code> that performs the same task as
<code>Copy</code>.</p>
<p>您可以在所有部分都实现<code>Copy</code>的任何类型上派生<code>Copy</code>。实现<code>Copy</code>的类型也必须实现<code>Clone</code>，因为实现<code>Copy</code>的类型具有执行与<code>Copy</code>相同任务的<code>Clone</code>的简单实现。</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don’t have to call <code>clone</code>, which makes
the code more concise.</p>
<p><code>Copy</code>特质很少被要求；实现<code>Copy</code>的类型具有可用的优化，这意味着您不必调用<code>clone</code>，从而使代码更简洁。</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<p><code>Copy</code>能完成的一切也可以通过<code>Clone</code>完成，但代码可能更慢或必须在某些地方使用<code>clone</code>。</p>
<h3 id="hash-for-mapping-a-value-to-a-value-of-fixed-size-用于将值映射到固定大小值的hash"><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size-用于将值映射到固定大小值的hash"><code>Hash</code> for Mapping a Value to a Value of Fixed Size 用于将值映射到固定大小值的<code>Hash</code></a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p><code>Hash</code>特质允许您使用哈希函数获取任意大小的类型实例并将该实例映射到固定大小的值。派生<code>Hash</code>会实现<code>hash</code>方法。<code>hash</code>方法的派生实现会组合对类型各部分调用<code>hash</code>的结果，这意味着所有字段或值也必须实现<code>Hash</code>才能派生<code>Hash</code>。</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<p>当在<code>HashMap&lt;K, V&gt;</code>中存储键以高效存储数据时就需要<code>Hash</code>。</p>
<h3 id="default-for-default-values-用于默认值的default"><a class="header" href="#default-for-default-values-用于默认值的default"><code>Default</code> for Default Values 用于默认值的<code>Default</code></a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p><code>Default</code>特质允许您为类型创建默认值。派生<code>Default</code>会实现<code>default</code>函数。<code>default</code>函数的派生实现会调用类型各部分的<code>default</code>函数，这意味着所有字段或值也必须实现<code>Default</code>才能派生<code>Default</code>。</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in “Creating Instances from Other Instances with Struct
Update
Syntax” in Chapter 5. You can customize a few fields of a struct and then set
and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p><span class="highlight">[note]<code>Default::default</code>函数通常与第5章“使用结构体更新语法从其他实例创建实例“中讨论的结构体更新语法结合使用。您可以自定义结构体的几个字段，然后使用<code>..Default::default()</code>为其余字段设置并使用默认值。</span></p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<p>当您对<code>Option&lt;T&gt;</code>实例使用方法<code>unwrap_or_default</code>时就需要<code>Default</code>特质。如果<code>Option&lt;T&gt;</code>是<code>None</code>，则方法<code>unwrap_or_default</code>将返回类型<code>T</code>的<code>Default::default</code>的结果。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="appendix-02-operators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="appendix-04-useful-development-tools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="appendix-02-operators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="appendix-04-useful-development-tools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
