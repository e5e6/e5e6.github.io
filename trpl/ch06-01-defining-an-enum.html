<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining an Enum 定义枚举 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="defining-an-enum-定义枚举"><a class="header" href="#defining-an-enum-定义枚举">Defining an Enum 定义枚举</a></h2>
<p>Where structs give you a way of grouping together related fields and data, like
a <code>Rectangle</code> with its <code>width</code> and <code>height</code>, enums give you a way of saying a
value is one of a possible set of values. For example, we may want to say that
<code>Rectangle</code> is one of a set of possible shapes that also includes <code>Circle</code> and
<code>Triangle</code>. To do this, Rust allows us to encode these possibilities as an enum.</p>
<p>结构体让您能够将相关字段和数据分组（例如包含<code>width</code>和<code>height</code>的<code>Rectangle</code>），而枚举则允许您声明一个值属于可能的取值集合之一。例如，我们可能希望说明<code>Rectangle</code>是包含<code>Circle</code>和<code>Triangle</code>在内的可能形状之一。为此，Rust允许我们将这些可能性编码为枚举。</p>
<p>Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. Because these are the only possibilities for an
IP address that our program will come across, we can <em>enumerate</em> all possible
variants, which is where enumeration gets its name.</p>
<p>让我们看一个我们可能想在代码中表达的情况，并看看为什么在这种情况下枚举比结构体更有用且更合适。假设我们需要处理IP地址。目前IP地址主要使用两个标准：IPv4和IPv6。由于程序只会遇到这两种IP地址，我们可以<strong>枚举</strong>所有可能的变体——这正是枚举名称的由来。</p>
<p>Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate because an enum value can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.</p>
<p>任何IP地址只能是IPv4或IPv6，不能同时是两者。IP地址的这种特性使得枚举数据结构非常适用，因为枚举值只能是其变体之一。IPv4和IPv6地址本质上都是IP地址，因此在处理适用于所有IP地址的场景时，它们应被视为同类型。</p>
<p>We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and
listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are the
variants of the enum:</p>
<p>我们可以通过定义<code>IpAddrKind</code>枚举并在其中列出可能的类型<code>V4</code>和<code>V6</code>，在代码中表达这一概念：</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>
<p>现在<code>IpAddrKind</code>成为了可在代码其他地方使用的自定义数据类型。</p>
<h3 id="enum-values-枚举值"><a class="header" href="#enum-values-枚举值">Enum Values 枚举值</a></h3>
<p>We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p>
<p>我们可以这样创建<code>IpAddrKind</code>两个变体的实例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. This is useful because now both values
<code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type: <code>IpAddrKind</code>. We
can then, for instance, define a function that takes any <code>IpAddrKind</code>:</p>
<p>注意枚举变体位于其标识符的命名空间下，我们使用双冒号进行分隔。这很有用，因为<code>IpAddrKind::V4</code>和<code>IpAddrKind::V6</code>现在属于同一类型<code>IpAddrKind</code>。例如，我们可以定义一个接受任何<code>IpAddrKind</code>的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>And we can call this function with either variant:</p>
<p>并且可以用任一变体调用此函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address <em>data</em>; we
only know what <em>kind</em> it is. Given that you just learned about structs in
Chapter 5, you might be tempted to tackle this problem with structs as shown in
Listing 6-1.</p>
<p>使用枚举还有更多优势。回到IP地址类型，目前我们无法存储实际的IP地址<strong>数据</strong>，只知道其<strong>类型</strong>。鉴于您刚在第5章学习了结构体，可能会想用结构体解决这个问题，如示例6-1所示。</p>
<figure class="listing" id="listing-6-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-6-1">Listing 6-1</a>: Storing the data and <code>IpAddrKind</code> variant of an IP address using a <code>struct</code> 使用结构体存储IP地址数据和<code>IpAddrKind</code>变体</figcaption>
</figure>
<p>Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that
is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field
of type <code>String</code>. We have two instances of this struct. The first is <code>home</code>,
and it has the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address
data of <code>127.0.0.1</code>. The second instance is <code>loopback</code>. It has the other
variant of <code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code>
associated with it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code>
values together, so now the variant is associated with the value.</p>
<p>这里我们定义了结构体<code>IpAddr</code>，它有两个字段：类型为<code>IpAddrKind</code>（先前定义的枚举）的<code>kind</code>字段，和类型为<code>String</code>的<code>address</code>字段。我们创建了这个结构体的两个实例：第一个是<code>home</code>，其<code>kind</code>值为<code>IpAddrKind::V4</code>，关联地址数据为<code>127.0.0.1</code>；第二个实例是<code>loopback</code>，其<code>kind</code>值为另一变体<code>V6</code>，关联地址为<code>::1</code>。我们使用结构体将<code>kind</code>和<code>address</code>值打包在一起，现在变体已与值关联。</p>
<p>However, representing the same concept using just an enum is more concise:
rather than an enum inside a struct, we can put data directly into each enum
variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code>
variants will have associated <code>String</code> values:</p>
<p>但仅用枚举表示相同概念会更简洁：无需将枚举嵌套在结构体中，我们可以直接将数据放入每个枚举变体。<code>IpAddr</code>枚举的新定义表明<code>V4</code>和<code>V6</code>变体都将关联<code>String</code>值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an
extra struct. Here, it’s also easier to see another detail of how enums work:
the name of each enum variant that we define also becomes a function that
constructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call
that takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We
automatically get this constructor function defined as a result of defining the
enum.</p>
<p>我们直接将数据附加到枚举的每个变体，省去了额外的结构体。这里也更容易看到枚举的另一个细节：我们<span class="highlight">[note]定义的每个枚举变体名称也会成为构造枚举实例的函数</span>。即<code>IpAddr::V4()</code>是一个函数调用，它接受<code>String</code>参数并返回<code>IpAddr</code>类型的实例。定义枚举时会自动获得此构造函数。</p>
<p>There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but
still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with
a struct. Enums handle this case with ease:</p>
<p>使用枚举而非结构体还有另一个优势：每个变体可以拥有不同类型和数量的关联数据。IPv4地址总是由四个取值范围在0到255的数值组成。若想将<code>V4</code>地址存储为四个<code>u8</code>值，而<code>V6</code>地址仍存储为<code>String</code>值，结构体无法实现，但枚举可以轻松处理：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that the standard
library has a definition we can use! Let’s look at how
the standard library defines <code>IpAddr</code>: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:</p>
<p>我们展示了多种定义数据结构存储IPv4和IPv6地址的方式。但实际上，存储IP地址并编码其类型的需求如此常见，标准库已提供了定义！让我们看看标准库如何定义<code>IpAddr</code>：它使用了与我们定义完全相同的枚举和变体，但将地址数据嵌入变体中，形式是两个不同的结构体（每个变体有不同定义）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.</p>
<p>这段代码说明您可以在枚举变体中放入任意类型数据：字符串、数值类型或结构体等。甚至可以包含另一个枚举！标准库类型通常也不会比您能想到的复杂多少。</p>
<p>Note that even though the standard library contains a definition for <code>IpAddr</code>,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.</p>
<p>注意：即使标准库包含<code>IpAddr</code>定义，我们仍可创建并使用自己的定义而不会冲突，因为我们尚未将标准库的定义引入作用域。第7章将详细讨论类型引入作用域。</p>
<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.</p>
<p>再看<span class="highlight">[note]示例6-2中的枚举，其变体嵌入了多种类型</span>：</p>
<figure class="listing" id="listing-6-2">
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-6-2">Listing 6-2</a>: A <code>Message</code> enum whose variants each store different amounts and types of values <code>Message</code>枚举的变体各自存储不同类型和数量的值</figcaption>
</figure>
<p>This enum has four variants with different types:</p>
<p>该枚举有四个不同类型的变体：</p>
<ul>
<li><code>Quit</code>: Has no data associated with it at all</li>
<li><code>Quit</code>：完全不关联数据</li>
<li><code>Move</code>: Has named fields, like a struct does</li>
<li><code>Move</code>：包含具名字段（类似结构体）</li>
<li><code>Write</code>: Includes a single <code>String</code></li>
<li><code>Write</code>：包含单个<code>String</code></li>
<li><code>ChangeColor</code>: Includes three <code>i32</code> values</li>
<li><code>ChangeColor</code>：包含三个<code>i32</code>值</li>
</ul>
<p>Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
<code>struct</code> keyword and all the variants are grouped together under the <code>Message</code>
type. The following structs could hold the same data that the preceding enum
variants hold:</p>
<p>定义如示例6-2的枚举变体类似于定义不同结构体，区别在于枚举不使用<code>struct</code>关键字，且所有变体都归在<code>Message</code>类型下。以下结构体可保存与上述枚举变体相同的数据：</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>But if we used the different structs, each of which has its own type, we
couldn’t as easily define a function to take any of these kinds of messages as
we could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</p>
<p>但如果使用这些独立结构体（每个都有自己的类型），就无法像示例6-2定义的<code>Message</code>枚举那样轻松定义函数来接收任意消息类型（枚举是单一类型）。</p>
<p>There is one more similarity between enums and structs: just as we’re able to
define methods on structs using <code>impl</code>, we’re also able to define methods on
enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<p>枚举和结构体还有一点相似：正如可以用<code>impl</code>为结构体定义方法，也能为枚举定义方法。以下是可为<code>Message</code>枚举定义的<code>call</code>方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>The body of the method would use <code>self</code> to get the value that we called the
method on. In this example, we’ve created a variable <code>m</code> that has the value
<code>Message::Write(String::from("hello"))</code>, and that is what <code>self</code> will be in the
body of the <code>call</code> method when <code>m.call()</code> runs.</p>
<p>方法体使用<code>self</code>获取调用该方法的实例值。此例中，变量<code>m</code>的值是<code>Message::Write(String::from("hello"))</code>，当执行<code>m.call()</code>时，<code>call</code>方法体中的<code>self</code>即为此值。</p>
<p>Let’s look at another enum in the standard library that is very common and
useful: <code>Option</code>.</p>
<p>现在看看标准库中另一个常见且实用的枚举：<code>Option</code>。</p>
<h3 id="the-option-enum-and-its-advantages-over-null-values-option枚举及其相对空值的优势"><a class="header" href="#the-option-enum-and-its-advantages-over-null-values-option枚举及其相对空值的优势">The <code>Option</code> Enum and Its Advantages Over Null Values <code>Option</code>枚举及其相对空值的优势</a></h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined
by the standard library. The <code>Option</code> type encodes the very common scenario in
which a value could be something or it could be nothing.</p>
<p>本节探讨标准库定义的另一个枚举<code>Option</code>。<code>Option</code>类型编码了一种常见场景：值可能有意义（某物），也可能无意义（空无）。</p>
<p>For example, if you request the first item in a non-empty list, you would get
a value. If you request the first item in an empty list, you would get nothing.
Expressing this concept in terms of the type system means the compiler can
check whether you’ve handled all the cases you should be handling; this
functionality can prevent bugs that are extremely common in other programming
languages.</p>
<p>例如，请求非空列表的首项会得到值，而请求空列表的首项会得到空无。在类型系统中表达此概念意味着编译器可检查您是否处理了所有应处理的情况，此功能可预防其他语言中极为常见的错误。</p>
<p>Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. <em>Null</em> is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.</p>
<p>编程语言设计常关注包含哪些特性，但排除的特性同样重要。Rust没有许多其他语言拥有的空值（null）特性。<strong>空值</strong>（null）表示“无值“的概念。在有空值的语言中，变量总是处于两种状态之一：空或非空。</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, had this to say:</p>
<p>在2009年的演讲“空引用：十亿美元的错误“中，空值发明者Tony Hoare表示：</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
<p>我称之为十亿美元的错误。当时我在为面向对象语言设计首个全面的引用类型系统，目标是确保所有引用使用绝对安全，由编译器自动检查。但我未能抵制添加空引用的诱惑，只因它太容易实现。这导致了无数错误、漏洞和系统崩溃，过去四十年可能已造成十亿美元的损失和痛苦。</p>
</blockquote>
<p>The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.</p>
<p>空值的问题在于：若将空值当作非空值使用，会导致某种错误。由于“空或非空“属性无处不在，此类错误极易发生。</p>
<p>However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.</p>
<p>然而，空值试图表达的概念仍有价值：空值表示当前因故无效或缺失的值。</p>
<p>The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
<code>Option&lt;T&gt;</code>, and it is defined by the standard library
as follows:</p>
<p>问题不在概念本身，而在具体实现。因此Rust没有空值，但提供了可编码“值存在或缺失“概念的枚举，即<code>Option&lt;T&gt;</code>，标准库定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. Its variants are also included in
the prelude: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code>
prefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and
<code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>
<p><code>Option&lt;T&gt;</code>枚举非常实用，它甚至包含在预导入模块（prelude）中——无需显式引入作用域。其变体也在预导入中：可直接使用<code>Some</code>和<code>None</code>，无需<code>Option::</code>前缀。<code>Option&lt;T&gt;</code>仍是常规枚举，<code>Some(T)</code>和<code>None</code>仍是其变体。</p>
<p>The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that <code>&lt;T&gt;</code> means that the <code>Some</code> variant of
the <code>Option</code> enum can hold one piece of data of any type, and that each
concrete type that gets used in place of <code>T</code> makes the overall <code>Option&lt;T&gt;</code> type
a different type. Here are some examples of using <code>Option</code> values to hold
number types and char types:</p>
<p><code>&lt;T&gt;</code>语法是Rust的泛型类型参数（第10章详解泛型）。目前只需知道：<code>&lt;T&gt;</code>表示<code>Option</code>枚举的<code>Some</code>变体能持有任意类型的单块数据，每个替换<code>T</code>的具体类型都会使<code>Option&lt;T&gt;</code>整体成为不同类型。以下是使用<code>Option</code>值保存数值类型和字符类型的示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is
<code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because
we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust
requires us to annotate the overall <code>Option</code> type: the compiler can’t infer the
type that the corresponding <code>Some</code> variant will hold by looking only at a
<code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type
<code>Option&lt;i32&gt;</code>.</p>
<p><code>some_number</code>的类型是<code>Option&lt;i32&gt;</code>，<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>（不同类）。Rust能推断这些类型，因为我们在<code>Some</code>变体中指定了值。对于<code>absent_number</code>，Rust要求标注整个<code>Option</code>类型——编译器无法仅通过<code>None</code>值推断对应<code>Some</code>变体将持有的类型。这里我们明确告知Rust：<code>absent_number</code>应为<code>Option&lt;i32&gt;</code>类型。</p>
<p>When we have a <code>Some</code> value, we know that a value is present and the value is
held within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the
same thing as null: we don’t have a valid value. So why is having <code>Option&lt;T&gt;</code>
any better than having null?</p>
<p>当持有<code>Some</code>值时，表明值存在且包含在<code>Some</code>中。当持有<code>None</code>值时，某种意义上等同于空值：无有效值。那么为何<code>Option&lt;T&gt;</code>优于空值？</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different
types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were
definitely a valid value. For example, this code won’t compile, because it’s
trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<p>简言之，因为<code>Option&lt;T&gt;</code>和<code>T</code>（<code>T</code>可为任意类型）是不同类型，编译器不会允许我们将<code>Option&lt;T&gt;</code>当作有效值使用。例如以下代码无法编译，因为它试图将<code>i8</code>与<code>Option&lt;i8&gt;</code>相加：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>If we run this code, we get an error message like this one:</p>
<p>运行此代码会产生类似错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Intense! In effect, this error message means that Rust doesn’t understand how
to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we
have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.</p>
<p>这明确意味着：Rust无法理解如何将<code>i8</code>和<code>Option&lt;i8&gt;</code>相加，因为它们是不同类型。在Rust中持有<code>i8</code>这类类型的值时，编译器确保它总是有效值，我们可以放心使用而无需空值检查。只有持有<code>Option&lt;i8&gt;</code>（或任何正在处理的类型）时，才需考虑可能无值的情况，编译器会确保我们在使用值前处理该情况。</p>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can
perform <code>T</code> operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually is.</p>
<p>换言之，必须先转换<code>Option&lt;T&gt;</code>为<code>T</code>，才能执行<code>T</code>的操作。这通常能捕获空值最常见的问题：在值实际为空时错误假设其非空。</p>
<p>Eliminating the risk of incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
<code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.</p>
<p>消除错误假设非空值的风险有助于提升代码信心。要让值可能为空，必须显式选择将其类型设为<code>Option&lt;T&gt;</code>。使用该值时，必须显式处理空值情况。对于类型非<code>Option&lt;T&gt;</code>的值，您可以<strong>安全</strong>假设其非空。这是Rust有意为之的设计决策，旨在限制空值泛滥，提升Rust代码安全性。</p>
<p>So how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value
of type <code>Option&lt;T&gt;</code> so that you can use that value? The <code>Option&lt;T&gt;</code> enum has a
large number of methods that are useful in a variety of situations; you can
check them out in its documentation. Becoming familiar
with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with
Rust.</p>
<p>那么当持有<code>Option&lt;T&gt;</code>类型的值时，如何从<code>Some</code>变体中取出<code>T</code>值以便使用？<code>Option&lt;T&gt;</code>枚举提供大量实用方法（详见文档）。熟悉这些方法对Rust编程之旅极其有用。</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that
will handle each variant. You want some code that will run only when you have a
<code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some
other code to run only if you have a <code>None</code> value, and that code doesn’t have a
<code>T</code> value available. The <code>match</code> expression is a control flow construct that
does just this when used with enums: it will run different code depending on
which variant of the enum it has, and that code can use the data inside the
matching value.</p>
<p>通常，使用<code>Option&lt;T&gt;</code>值时，您需要处理所有变体的代码：部分代码仅在持有<code>Some(T)</code>时运行，且可使用内部的<code>T</code>；另一部分代码仅在持有<code>None</code>时运行，且无法使用<code>T</code>值。<code>match</code>表达式正是处理枚举的控制流结构：根据枚举变体运行不同代码，且该代码可使用匹配值内部的数据。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
