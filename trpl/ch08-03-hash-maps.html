<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storing Keys with Associated Values in Hash Maps 在哈希映射中存储键值对 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="storing-keys-with-associated-values-in-hash-maps-在哈希映射中存储键值对"><a class="header" href="#storing-keys-with-associated-values-in-hash-maps-在哈希映射中存储键值对">Storing Keys with Associated Values in Hash Maps 在哈希映射中存储键值对</a></h2>
<p>The last of our common collections is the <em>hash map</em>. The type <code>HashMap&lt;K, V&gt;</code>
stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a <em>hashing
function</em>, which determines how it places these keys and values into memory.
Many programming languages support this kind of data structure, but they often
use a different name, such as <em>hash</em>, <em>map</em>, <em>object</em>, <em>hash table</em>,
<em>dictionary</em>, or <em>associative array</em>, just to name a few.</p>
<p>最后一种常见的集合类型是 <em>哈希映射（hash map）</em>。类型 <code>HashMap&lt;K, V&gt;</code> 通过 <em>哈希函数（hashing function）</em> 存储键类型 <code>K</code> 到值类型 <code>V</code> 的映射，该函数决定了键值对在内存中的存储方式。许多编程语言支持此类数据结构，但命名可能不同，例如 <em>hash</em>、<em>map</em>、<em>object</em>、<em>hash table</em>、<em>dictionary</em> 或 <em>associative array</em> 等。</p>
<p>Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team’s score in a hash map in which
each key is a team’s name and the values are each team’s score. Given a team
name, you can retrieve its score.</p>
<p>当你希望基于任意类型的键（而非像向量那样使用索引）来查找数据时，哈希映射非常有用。例如，在游戏中可以用哈希映射跟踪各队伍分数：键是队伍名，值是对应分数。输入队伍名即可获取其分数。</p>
<p>We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on <code>HashMap&lt;K, V&gt;</code> by the standard library.
As always, check the standard library documentation for more information.</p>
<p>本节将介绍哈希映射的基础 API，但标准库在 <code>HashMap&lt;K, V&gt;</code> 上定义的函数还隐藏着更多功能。请一如既往地查阅标准库文档以获取更多信息。</p>
<h3 id="creating-a-new-hash-map-创建新哈希映射"><a class="header" href="#creating-a-new-hash-map-创建新哈希映射">Creating a New Hash Map 创建新哈希映射</a></h3>
<p>One way to create an empty hash map is to use <code>new</code> and to add elements with
<code>insert</code>. In Listing 8-20, we’re keeping track of the scores of two teams whose
names are <em>Blue</em> and <em>Yellow</em>. The Blue team starts with 10 points, and the
Yellow team starts with 50.</p>
<p>创建空哈希映射的一种方法是使用 <code>new</code> 并通过 <code>insert</code> 添加元素。在示例 8-20 中，我们记录名为 <em>Blue</em> 和 <em>Yellow</em> 的两支队伍分数。蓝队初始 10 分，黄队初始 50 分。</p>
<figure class="listing" id="listing-8-20">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-20">Listing 8-20</a>: Creating a new hash map and inserting some keys and values 创建新哈希映射并插入键值对</figcaption>
</figure>
<p>Note that we need to first <code>use</code> the <code>HashMap</code> from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there’s no built-in macro to construct them, for example.</p>
<p>注意需先从标准库的集合部分 <code>use</code> 引入 <code>HashMap</code>。在三种常见集合中，哈希映射最不常用，因此未被预导入（prelude）自动引入作用域。标准库对其支持也较少，例如没有内置宏来构造它们。</p>
<p>Just like vectors, hash maps store their data on the heap. This <code>HashMap</code> has
keys of type <code>String</code> and values of type <code>i32</code>. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.</p>
<p>与向量类似，哈希映射将数据存储在堆上。此处的 <code>HashMap</code> 键类型为 <code>String</code>，值类型为 <code>i32</code>。同样地，哈希映射是同质的：所有键类型必须相同，所有值类型也必须相同。</p>
<h3 id="accessing-values-in-a-hash-map-访问哈希映射中的值"><a class="header" href="#accessing-values-in-a-hash-map-访问哈希映射中的值">Accessing Values in a Hash Map 访问哈希映射中的值</a></h3>
<p>We can get a value out of the hash map by providing its key to the <code>get</code>
method, as shown in Listing 8-21.</p>
<p><span class="highlight">[note]可通过 <code>get</code> 方法传入键来获取值</span>，如示例 8-21 所示。</p>
<figure class="listing" id="listing-8-21">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-21">Listing 8-21</a>: Accessing the score for the Blue team stored in the hash map 访问哈希映射中蓝队的分数</figcaption>
</figure>
<p>Here, <code>score</code> will have the value that’s associated with the Blue team, and the
result will be <code>10</code>. The <code>get</code> method returns an <code>Option&lt;&amp;V&gt;</code>; if there’s no
value for that key in the hash map, <code>get</code> will return <code>None</code>. This program
handles the <code>Option</code> by calling <code>copied</code> to get an <code>Option&lt;i32&gt;</code> rather than an
<code>Option&lt;&amp;i32&gt;</code>, then <code>unwrap_or</code> to set <code>score</code> to zero if <code>scores</code> doesn’t
have an entry for the key.</p>
<p>此处 <code>score</code> 将获得与蓝队关联的值，结果为 <code>10</code>。<span class="highlight">[note]<code>get</code> 方法返回 <code>Option&lt;&amp;V&gt;</code></span>；若键无对应值则返回 <code>None</code>。此代码通过 <code>copied</code> 将 <code>Option&lt;&amp;i32&gt;</code> 转为 <code>Option&lt;i32&gt;</code>，再用 <code>unwrap_or</code> 在键不存在时将 <code>score</code> 置零。</p>
<p>We can iterate over each key-value pair in a hash map in a similar manner as we
do with vectors, using a <code>for</code> loop:</p>
<p>可用 <code>for</code> 循环遍历键值对，方式类似向量遍历：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>This code will print each pair in an arbitrary order:</p>
<p>此代码会以任意顺序打印各键值对：</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="hash-maps-and-ownership-哈希映射与所有权"><a class="header" href="#hash-maps-and-ownership-哈希映射与所有权">Hash Maps and Ownership 哈希映射与所有权</a></h3>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code>, the values are copied
into the hash map. For owned values like <code>String</code>, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.</p>
<p>对于实现 <code>Copy</code> trait 的类型（如 <code>i32</code>），值会被复制到哈希映射中。对于拥有所有权的值（如 <code>String</code>），值会被移动且哈希映射将成为其新所有者，如示例 8-22 所示。</p>
<figure class="listing" id="listing-8-22">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-22">Listing 8-22</a>: Showing that keys and values are owned by the hash map once they’re inserted 展示键值插入后所有权归哈希映射所有</figcaption>
</figure>
<p>We aren’t able to use the variables <code>field_name</code> and <code>field_value</code> after
they’ve been moved into the hash map with the call to <code>insert</code>.</p>
<p>在通过 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移入哈希映射后，无法再使用这两个变量。</p>
<p>If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
“Validating References with
Lifetimes” in Chapter 10.</p>
<p>若插入值的引用，则值不会被移入哈希映射。引用指向的值在哈希映射有效期间必须保持有效。第 10 章“生命周期验证引用“将深入讨论此问题。</p>
<h3 id="updating-a-hash-map-更新哈希映射"><a class="header" href="#updating-a-hash-map-更新哈希映射">Updating a Hash Map 更新哈希映射</a></h3>
<p>Although the number of key and value pairs is growable, each unique key can
only have one value associated with it at a time (but not vice versa: for
example, both the Blue team and the Yellow team could have the value <code>10</code>
stored in the <code>scores</code> hash map).</p>
<p>尽管键值对数量可变，但同一时刻每个唯一键只能关联一个值（反之则不然：例如蓝队和黄队可同时在 <code>scores</code> 哈希映射中存储值 <code>10</code>）。</p>
<p>When you want to change the data in a hash map, you have to decide how to
handle the case when a key already has a value assigned. You could replace the
old value with the new value, completely disregarding the old value. You could
keep the old value and ignore the new value, only adding the new value if the
key <em>doesn’t</em> already have a value. Or you could combine the old value and the
new value. Let’s look at how to do each of these!</p>
<p>更新哈希映射数据时，需处理键已存在值的情况：可完全忽略旧值并用新值覆盖；可保留旧值忽略新值，仅当键 <em>无</em> 值时插入新值；亦可合并新旧值。下面分别说明：</p>
<h4 id="overwriting-a-value-覆盖值"><a class="header" href="#overwriting-a-value-覆盖值">Overwriting a Value 覆盖值</a></h4>
<p>If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-23 calls <code>insert</code> twice, the hash map will
only contain one key-value pair because we’re inserting the value for the Blue
team’s key both times.</p>
<p>若对同一键重复插入不同值，旧值会被替换。示例 8-23 虽调用两次 <code>insert</code>，但哈希映射仅存一个键值对，因为两次均为蓝队键插入值。</p>
<figure class="listing" id="listing-8-23">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-23">Listing 8-23</a>: Replacing a value stored with a particular key 替换特定键对应的值</figcaption>
</figure>
<p>This code will print <code>{"Blue": 25}</code>. The original value of <code>10</code> has been
overwritten.</p>
<p>此代码将打印 <code>{"Blue": 25}</code>，原始值 <code>10</code> 已被覆盖。</p>
<h4 id="adding-a-key-and-value-only-if-a-key-isnt-present-仅当键不存在时插入"><a class="header" href="#adding-a-key-and-value-only-if-a-key-isnt-present-仅当键不存在时插入">Adding a Key and Value Only If a Key Isn’t Present 仅当键不存在时插入</a></h4>
<p>It’s common to check whether a particular key already exists in the hash map
with a value and then to take the following actions: if the key does exist in
the hash map, the existing value should remain the way it is; if the key
doesn’t exist, insert it and a value for it.</p>
<p>常见操作是检查特定键是否存在值：若存在则保留原值；若不存在则插入键及其值。</p>
<p>Hash maps have a special API for this called <code>entry</code> that takes the key you
want to check as a parameter. The return value of the <code>entry</code> method is an enum
called <code>Entry</code> that represents a value that might or might not exist. Let’s say
we want to check whether the key for the Yellow team has a value associated
with it. If it doesn’t, we want to insert the value <code>50</code>, and the same for the
Blue team. Using the <code>entry</code> API, the code looks like Listing 8-24.</p>
<p><span class="highlight">[note]哈希映射为此提供 <code>entry</code> API，它以待检查键为参数，返回表示值可能存在的枚举 <code>Entry</code>。</span>假设要检查黄队键是否有值，若无则插入 <code>50</code>，蓝队同理。使用 <code>entry</code> API 的代码如示例 8-24 所示。</p>
<figure class="listing" id="listing-8-24">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-24">Listing 8-24</a>: Using the <code>entry</code> method to only insert if the key does not already have a value 使用 <code>entry</code> 方法仅在键无值时插入</figcaption>
</figure>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to
the value for the corresponding <code>Entry</code> key if that key exists, and if not, it
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.</p>
<p><span class="highlight">[note]<code>Entry</code> 的 <code>or_insert</code> 方法在键存在时返回其值的可变引用，不存在时插入参数作为新值并返回新值的可变引用。</span>此方法比手动实现逻辑更简洁，且更兼容借用检查器。</p>
<p>Running the code in Listing 8-24 will print <code>{"Yellow": 50, "Blue": 10}</code>. The
first call to <code>entry</code> will insert the key for the Yellow team with the value
<code>50</code> because the Yellow team doesn’t have a value already. The second call to
<code>entry</code> will not change the hash map because the Blue team already has the
value <code>10</code>.</p>
<p>运行示例 8-24 将打印 <code>{"Yellow": 50, "Blue": 10}</code>。首次调用 <code>entry</code> 会为黄队插入值 <code>50</code>（因其原无值），第二次调用不会改变哈希映射（因蓝队已有值 <code>10</code>）。</p>
<h4 id="updating-a-value-based-on-the-old-value-基于旧值更新"><a class="header" href="#updating-a-value-based-on-the-old-value-基于旧值更新">Updating a Value Based on the Old Value 基于旧值更新</a></h4>
<p>Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-25 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value <code>0</code>.</p>
<p>哈希映射另一常见用途是查找键的值并基于旧值更新。例如示例 8-25 统计文本中单词出现次数：以单词为键，增加值以跟踪出现频率。若单词首次出现，先插入值 <code>0</code>。</p>
<figure class="listing" id="listing-8-25">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-25">Listing 8-25</a>: Counting occurrences of words using a hash map that stores words and counts 使用存储单词和计数的哈希映射进行词频统计</figcaption>
</figure>
<p>This code will print <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. You might see
the same key-value pairs printed in a different order: recall from “Accessing
Values in a Hash Map” that iterating over a hash map
happens in an arbitrary order.</p>
<p>此代码可能打印 <code>{"world": 2, "hello": 1, "wonderful": 1}</code>（顺序可能不同，回忆“访问哈希映射中的值“可知迭代顺序是任意的）。</p>
<p>The <code>split_whitespace</code> method returns an iterator over subslices, separated by
whitespace, of the value in <code>text</code>. The <code>or_insert</code> method returns a mutable
reference (<code>&amp;mut V</code>) to the value for the specified key. Here, we store that
mutable reference in the <code>count</code> variable, so in order to assign to that value,
we must first dereference <code>count</code> using the asterisk (<code>*</code>). The mutable
reference goes out of scope at the end of the <code>for</code> loop, so all of these
changes are safe and allowed by the borrowing rules.</p>
<p><code>split_whitespace</code> 方法返回基于空白分隔的文本子切片迭代器。<code>or_insert</code> 返回键对应值的可变引用（<code>&amp;mut V</code>）。此处将可变引用存入 <code>count</code> 变量，赋值时需先用星号（<code>*</code>）解引用 <code>count</code>。可变引用在 <code>for</code> 循环结束时离开作用域，因此这些变更均符合借用规则且安全。</p>
<h3 id="hashing-functions-哈希函数"><a class="header" href="#hashing-functions-哈希函数">Hashing Functions 哈希函数</a></h3>
<p>By default, <code>HashMap</code> uses a hashing function called <em>SipHash</em> that can provide
resistance to denial-of-service (DoS) attacks involving hash
tables. This is not the fastest hashing algorithm
available, but the trade-off for better security that comes with the drop in
performance is worth it. If you profile your code and find that the default
hash function is too slow for your purposes, you can switch to another function
by specifying a different hasher. A <em>hasher</em> is a type that implements the
<code>BuildHasher</code> trait. We’ll talk about traits and how to implement them in
Chapter 10. You don’t necessarily have to implement
your own hasher from scratch; <a href="https://crates.io/">crates.io</a>
has libraries shared by other Rust users that provide hashers implementing many
common hashing algorithms.</p>
<p>默认情况下，<code>HashMap</code> 使用名为 <em>SipHash</em> 的哈希函数，可抵御涉及哈希表的拒绝服务（DoS）攻击。此非最快的哈希算法，但以性能换取更高安全性是值得的。若性能分析表明默认哈希函数过慢，可通过指定不同的 hasher 切换算法。<em>hasher</em> 是实现了 <code>BuildHasher</code> trait 的类型。第 10 章将讨论 trait 及其实现。不必从头实现自己的 hasher，<a href="https://crates.io/">crates.io</a> 上有其他 Rust 用户共享的提供常见哈希算法的库。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:</p>
<p>当你需要存储、访问和修改数据时，向量、字符串和哈希映射将提供大量必要功能。现在你已能解决以下练习：</p>
<ul>
<li>Given a list of integers, use a vector and return the median (when sorted,
the value in the middle position) and mode (the value that occurs most
often; a hash map will be helpful here) of the list.</li>
<li>给定整数列表，使用向量返回中位数（排序后位于中间的值）和众数（出现最频繁的值，哈希映射对此很有帮助）。</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to
the end of the word and <em>ay</em> is added, so <em>first</em> becomes <em>irst-fay</em>. Words
that start with a vowel have <em>hay</em> added to the end instead (<em>apple</em> becomes
<em>apple-hay</em>). Keep in mind the details about UTF-8 encoding!</li>
<li>将字符串转换为拉丁猪文：单词首辅音移至末尾并添加 <em>ay</em>（如 <em>first</em> 变为 <em>irst-fay</em>）；元音开头的单词则添加 <em>hay</em>（如 <em>apple</em> 变为 <em>apple-hay</em>）。请注意 UTF-8 编码细节！</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add
employee names to a department in a company; for example, “Add Sally to
Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
people in a department or all people in the company by department, sorted
alphabetically.</li>
<li>使用哈希映射和向量创建文本接口：用户可添加员工姓名到公司部门（如“Add Sally to Engineering“或“Add Amir to Sales“），并支持按部门检索人员列表或按部门排序的全公司人员列表。</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!</p>
<p>标准库 API 文档描述了向量、字符串和哈希映射的有用方法！</p>
<p>We’re getting into more complex programs in which operations can fail, so it’s
a perfect time to discuss error handling. We’ll do that next!</p>
<p>我们正进入更复杂的程序领域，操作可能失败，是时候讨论错误处理了。下一章见！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch09-00-error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch09-00-error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
