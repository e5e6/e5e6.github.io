<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust 不安全 Rust - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="unsafe-rust-不安全-rust"><a class="header" href="#unsafe-rust-不安全-rust">Unsafe Rust 不安全 Rust</a></h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>目前讨论的所有代码都在编译时强制执行 Rust 的内存安全保证。然而，Rust 内部隐藏着另一种不强制执行这些内存安全保证的语言：它被称为<strong>不安全 Rust</strong>，其行为与常规 Rust 相同，但赋予我们额外的超能力。</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs than to accept some invalid
programs. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have
enough information to be confident, it will reject the code. In these cases,
you can use unsafe code to tell the compiler, “Trust me, I know what I’m
doing.” Be warned, however, that you use unsafe Rust at your own risk: if you
use unsafe code incorrectly, problems can occur due to memory unsafety, such as
null pointer dereferencing.</p>
<p>不安全 Rust 的存在是因为静态分析本质上是保守的。当编译器尝试判断代码是否遵守保证时，拒绝某些有效程序比接受无效程序更安全。虽然代码<strong>可能</strong>没问题，但如果 Rust 编译器没有足够信息来确信，它会拒绝代码。此时，你可以使用不安全代码告诉编译器：“请相信我，我知道自己在做什么。“但请注意，使用不安全 Rust 需自行承担风险：如果不正确使用不安全代码，可能导致内存安全问题，例如空指针解引用。</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<p>Rust 存在不安全版本的另一个原因是底层计算机硬件本身就不安全。如果 Rust 不允许不安全操作，某些任务将无法完成。Rust 需要支持底层系统编程，例如直接与操作系统交互甚至编写自己的操作系统。处理底层系统编程是该语言的目标之一。让我们探索不安全 Rust 的功能及其使用方法。</p>
<h3 id="unsafe-superpowers-不安全超能力"><a class="header" href="#unsafe-superpowers-不安全超能力">Unsafe Superpowers 不安全超能力</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust that you
can’t in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers
include the ability to:</p>
<p>要切换到不安全 Rust，需使用 <code>unsafe</code> 关键字并开启包含不安全代码的新代码块。在不安全 Rust 中可执行五项安全 Rust 中不允许的操作，称为<strong>不安全超能力</strong>：</p>
<ol>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ol>
<!-- -->
<ol>
<li>解引用原始指针</li>
<li>调用不安全函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问联合体（union）的字段</li>
</ol>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any of Rust’s other safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside an unsafe block.</p>
<p>需理解 <code>unsafe</code> 不会关闭借用检查器或禁用 Rust 的其他安全检查：在不安全代码中使用引用时仍会检查。<code>unsafe</code> 关键字仅提供访问这五项特性的权限，编译器不会检查它们的内存安全性。在不安全块内部仍会获得一定程度的安全性。</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>此外，<code>unsafe</code> 并不意味着块内代码必然危险或肯定存在内存安全问题：其意图是作为程序员，你应确保 <code>unsafe</code> 块内的代码会以有效方式访问内存。</p>
<p>People are fallible and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with <code>unsafe</code>, you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>人非圣贤孰能无过，但通过要求这五项不安全操作位于 <code>unsafe</code> 标注的块内，可知任何与内存安全相关的错误必定在 <code>unsafe</code> 块中。保持 <code>unsafe</code> 块精简；在调查内存错误时会感激这种做法。</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose such code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>为最大限度隔离不安全代码，最佳实践是将其封装在安全抽象中并提供安全 API，本章稍后探讨不安全函数和方法时将讨论这点。标准库的部分内容就是基于已审计的不安全代码实现的安全抽象。将不安全代码包装在安全抽象中可防止 <code>unsafe</code> 用法泄漏到你或用户可能希望使用该功能的所有地方，因为使用安全抽象本身是安全的。</p>
<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<p>现在依次探讨这五项不安全超能力，同时了解为不安全代码提供安全接口的抽象实现。</p>
<h3 id="dereferencing-a-raw-pointer-解引用原始指针"><a class="header" href="#dereferencing-a-raw-pointer-解引用原始指针">Dereferencing a Raw Pointer 解引用原始指针</a></h3>
<p>In Chapter 4, in “Dangling References”, we
mentioned that the compiler ensures references are always valid. Unsafe Rust has
two new types called <em>raw pointers</em> that are similar to references. As with
references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s
part of the type name. In the context of raw pointers, <em>immutable</em> means that
the pointer can’t be directly assigned to after being dereferenced.</p>
<p>在第 4 章的“悬垂引用“中，我们提到编译器确保引用始终有效。不安全 Rust 有两种称为<strong>原始指针</strong>的新类型，类似于引用。原始指针可以是不可变或可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。星号不是解引用运算符，而是类型名的一部分。在原始指针语境中，“不可变“表示指针解引用后不能被直接赋值。</p>
<p>Different from references and smart pointers, raw pointers:</p>
<p>原始指针与引用和智能指针的区别在于：</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<!-- -->
<ul>
<li>允许忽略借用规则（可同时存在指向同一位置的不可变和可变指针或多个可变指针）</li>
<li>不保证指向有效内存</li>
<li>允许为空</li>
<li>不实现任何自动清理机制</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>通过退出 Rust 的强制保证，可放弃安全性以换取更高性能，或与不适用 Rust 保证的其他语言/硬件交互。</p>
<p>Listing 20-1 shows how to create an immutable and a mutable raw pointer.</p>
<p>示例 20-1 展示如何创建不可变和可变原始指针。</p>
<figure class="listing" id="listing-20-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-1">Listing 20-1</a>: Creating raw pointers with the raw borrow operators 使用原始借用运算符创建原始指针</figcaption>
</figure>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>注意此代码未使用 <code>unsafe</code> 关键字。我们可在安全代码中创建原始指针，但稍后会看到，不能在 <code>unsafe</code> 块外解引用原始指针。</p>
<p>We’ve created raw pointers by using the raw borrow operators: <code>&amp;raw const num</code>
creates a <code>*const i32</code> immutable raw pointer, and <code>&amp;raw mut num</code> creates a <code>*mut i32</code> mutable raw pointer. Because we created them directly from a local
variable, we know these particular raw pointers are valid, but we can’t make
that assumption about just any raw pointer.</p>
<p>我们使用原始借用运算符创建原始指针：<code>&amp;raw const num</code> 创建 <code>*const i32</code> 不可变原始指针，<code>&amp;raw mut num</code> 创建 <code>*mut i32</code> 可变原始指针。由于直接从局部变量创建，可知这些特定原始指针有效，但不能假设任意原始指针均有效。</p>
<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be
so certain of, using the keyword <code>as</code> to cast a value instead of using the raw
borrow operator. Listing 20-2 shows how to create a raw pointer to an arbitrary
location in memory. Trying to use arbitrary memory is undefined: there might be
data at that address or there might not, the compiler might optimize the code
so there is no memory access, or the program might terminate with a
segmentation fault. Usually, there is no good reason to write code like this,
especially in cases where you can use a raw borrow operator instead, but it is
possible.</p>
<p>为演示这点，接下来使用 <code>as</code> 关键字转换值（而非原始借用运算符）创建有效性不确定的原始指针。示例 20-2 展示如何创建指向内存任意位置的原始指针。尝试使用任意内存是未定义行为：该地址可能有数据也可能没有，编译器可能优化代码导致无内存访问，或程序可能以段错误终止。通常没有充分理由编写此类代码（尤其当可使用原始借用运算符时），但技术上可行。</p>
<figure class="listing" id="listing-20-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-2">Listing 20-2</a>: Creating a raw pointer to an arbitrary memory address 创建指向任意内存地址的原始指针</figcaption>
</figure>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 20-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<p>回忆可知，在安全代码中可创建原始指针，但不能<strong>解引用</strong>原始指针来读取指向的数据。示例 20-3 在需要 <code>unsafe</code> 块的原始指针上使用解引用运算符 <code>*</code>。</p>
<figure class="listing" id="listing-20-3">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-3">Listing 20-3</a>: Dereferencing raw pointers within an <code>unsafe</code> block 在 <code>unsafe</code> 块中解引用原始指针</figcaption>
</figure>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>创建指针无害；仅当尝试访问其指向的值时才可能处理无效值。</p>
<p>Note also that in Listings 20-1 and 20-3, we created <code>*const i32</code> and <code>*mut i32</code> raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>另请注意，在示例 20-1 和 20-3 中，我们创建了指向同一内存位置（存储 <code>num</code> 的位置）的 <code>*const i32</code> 和 <code>*mut i32</code> 原始指针。若尝试创建 <code>num</code> 的不可变和可变引用，代码将无法编译（因 Rust 所有权规则不允许同时存在可变引用和不可变引用）。使用原始指针时，可创建指向同一位置的可变和不可变指针并通过可变指针修改数据，可能导致数据竞争。务必谨慎！</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section.
Another case is when building up safe abstractions that the borrow checker
doesn’t understand. We’ll introduce unsafe functions and then look at an
example of a safe abstraction that uses unsafe code.</p>
<p>既然存在这些危险，为何还要使用原始指针？主要场景是与 C 代码交互（下节将介绍）。另一场景是构建借用检查器无法理解的安全抽象。我们将先介绍不安全函数，再分析使用不安全代码的安全抽象示例。</p>
<h3 id="calling-an-unsafe-function-or-method-调用不安全函数或方法"><a class="header" href="#calling-an-unsafe-function-or-method-调用不安全函数或方法">Calling an Unsafe Function or Method 调用不安全函数或方法</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling
unsafe functions. Unsafe functions and methods look exactly like regular
functions and methods, but they have an extra <code>unsafe</code> before the rest of the
definition. The <code>unsafe</code> keyword in this context indicates the function has
requirements we need to uphold when we call this function, because Rust can’t
guarantee we’ve met these requirements. By calling an unsafe function within an
<code>unsafe</code> block, we’re saying that we’ve read this function’s documentation and
we take responsibility for upholding the function’s contracts.</p>
<p>在 <code>unsafe</code> 块中可执行的第二类操作是调用不安全函数。不安全函数和方法外观与常规函数/方法相同，但在定义其余部分前多一个 <code>unsafe</code>。此处的 <code>unsafe</code> 关键字表示调用该函数时有需要维护的条件（因 Rust 无法保证我们满足这些条件）。通过在 <code>unsafe</code> 块内调用不安全函数，表明我们已阅读其文档并承诺履行函数约定。</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<p>以下是一个名为 <code>dangerous</code> 的不安全函数（其函数体不执行任何操作）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<p>必须在单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。若尝试无 <code>unsafe</code> 块调用，将报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>With the <code>unsafe</code> block, we’re asserting to Rust that we’ve read the function’s
documentation, we understand how to use it properly, and we’ve verified that
we’re fulfilling the contract of the function.</p>
<p>通过 <code>unsafe</code> 块，我们向 Rust 声明：已阅读函数文档，理解正确用法，并已验证满足函数约定。</p>
<p>To perform unsafe operations in the body of an <code>unsafe</code> function, you still
need to use an <code>unsafe</code> block, just as within a regular function, and the
compiler will warn you if you forget. This helps us keep <code>unsafe</code> blocks as
small as possible, as unsafe operations may not be needed across the whole
function body.</p>
<p>在 <code>unsafe</code> 函数体中执行不安全操作时，仍需 <code>unsafe</code> 块（与常规函数相同）。若忘记，编译器将警告。这有助于将 <code>unsafe</code> 块保持最小化（因可能不需要在整个函数体执行不安全操作）。</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code-构建不安全代码的安全抽象"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code-构建不安全代码的安全抽象">Creating a Safe Abstraction over Unsafe Code 构建不安全代码的安全抽象</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study the <code>split_at_mut</code> function
from the standard library, which requires some unsafe code. We’ll explore how
we might implement it. This safe method is defined on mutable slices: it takes
one slice and makes it two by splitting the slice at the index given as an
argument. Listing 20-4 shows how to use <code>split_at_mut</code>.</p>
<p>仅因函数包含不安全代码，并不意味着需将整个函数标记为不安全。实际上，将不安全代码包装在安全函数中是常见抽象。例如，我们研究标准库中的 <code>split_at_mut</code> 函数（需要不安全代码）。我们将探索如何实现它。此安全方法定义在可变切片上：获取一个切片并通过参数给定索引将其拆分为两个切片。示例 20-4 展示如何使用 <code>split_at_mut</code>。</p>
<figure class="listing" id="listing-20-4">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-4">Listing 20-4</a>: Using the safe <code>split_at_mut</code> function 使用安全的 <code>split_at_mut</code> 函数</figcaption>
</figure>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 20-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<p>仅使用安全 Rust 无法实现此函数。尝试实现可能如示例 20-5（无法编译）。为简化，我们将 <code>split_at_mut</code> 实现为函数而非方法，且仅针对 <code>i32</code> 切片而非泛型 <code>T</code>。</p>
<figure class="listing" id="listing-20-5">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-5">Listing 20-5</a>: An attempted implementation of <code>split_at_mut</code> using only safe Rust 尝试仅用安全 Rust 实现 <code>split_at_mut</code></figcaption>
</figure>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>此函数首先获取切片总长度，再断言参数索引在切片内（检查是否小于等于长度）。该断言意味着若传入大于长度的索引来拆分切片，函数将在尝试使用索引前 panic。</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>然后在元组中返回两个可变切片：一个从原始切片起始到 <code>mid</code> 索引，另一个从 <code>mid</code> 到切片末尾。</p>
<p>When we try to compile the code in Listing 20-5, we’ll get an error:</p>
<p>尝试编译示例 20-5 的代码时将报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Rust 的借用检查器无法理解我们借用了切片的不同部分；它只知道我们两次借用同一切片。借用切片不同部分本质上是安全的（因两个切片不重叠），但 Rust 不够智能而无法识别这点。当确信代码正确而 Rust 无法识别时，就该使用不安全代码。</p>
<p>Listing 20-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<p>示例 20-6 展示如何使用 <code>unsafe</code> 块、原始指针及不安全函数调用来实现 <code>split_at_mut</code>。</p>
<figure class="listing" id="listing-20-6">
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-6">Listing 20-6</a>: Using unsafe code in the implementation of the <code>split_at_mut</code> function 在 <code>split_at_mut</code> 函数实现中使用不安全代码</figcaption>
</figure>
<p>Recall from “The Slice Type” in Chapter 4 that
a slice is a pointer to some data and the length of the slice. We use the <code>len</code>
method to get the length of a slice and the <code>as_mut_ptr</code> method to access the
raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code>
values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve
stored in the variable <code>ptr</code>.</p>
<p>回忆第 4 章“切片类型“，切片是指向数据及其长度的指针。我们使用 <code>len</code> 方法获取切片长度，使用 <code>as_mut_ptr</code> 方法访问切片的原始指针。本例中，因有 <code>i32</code> 值的可变切片，<code>as_mut_ptr</code> 返回类型为 <code>*mut i32</code> 的原始指针（存储在变量 <code>ptr</code> 中）。</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>保留 <code>mid</code> 索引在切片内的断言。然后进入不安全代码：<code>slice::from_raw_parts_mut</code> 函数接收原始指针和长度来创建切片。我们使用它创建从 <code>ptr</code> 开始且长为 <code>mid</code> 项的切片。接着在 <code>ptr</code> 上调用 <code>add</code> 方法（以 <code>mid</code> 为参数）获取从 <code>mid</code> 开始的原始指针，并使用该指针及 <code>mid</code> 之后剩余项数作为长度创建切片。</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>add</code> method on raw
pointers is also unsafe because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>函数 <code>slice::from_raw_parts_mut</code> 不安全（因接收原始指针且必须信任其有效）。原始指针的 <code>add</code> 方法也不安全（因必须信任偏移位置也是有效指针）。因此，必须将调用 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 的代码放入 <code>unsafe</code> 块。通过查看代码并添加 <code>mid</code> 必须小于等于 <code>len</code> 的断言，可知 <code>unsafe</code> 块内使用的所有原始指针均指向切片内数据的有效指针。这是可接受且恰当的 <code>unsafe</code> 用法。</p>
<p>Note that we don’t need to mark the resultant <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>注意，无需将结果函数 <code>split_at_mut</code> 标记为 <code>unsafe</code>，且可从安全 Rust 调用此函数。我们通过使用 <code>unsafe</code> 代码的安全实现，为不安全代码创建了安全抽象（因仅根据函数可访问的数据创建有效指针）。</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 20-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<p>相反，示例 20-7 使用 <code>slice::from_raw_parts_mut</code> 很可能在使用切片时崩溃。此代码获取任意内存位置并创建长 10,000 项的切片。</p>
<figure class="listing" id="listing-20-7">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-7">Listing 20-7</a>: Creating a slice from an arbitrary memory location 从任意内存位置创建切片</figcaption>
</figure>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>values</code> as though it’s a valid slice results in undefined behavior.</p>
<p>我们不拥有此任意位置的内存，且无法保证此代码创建的切片包含有效的 <code>i32</code> 值。尝试像使用有效切片那样使用 <code>values</code> 将导致未定义行为。</p>
<h4 id="using-extern-functions-to-call-external-code-使用-extern-函数调用外部代码"><a class="header" href="#using-extern-functions-to-call-external-code-使用-extern-函数调用外部代码">Using <code>extern</code> Functions to Call External Code 使用 <code>extern</code> 函数调用外部代码</a></h4>
<p>Sometimes your Rust code might need to interact with code written in another
language. For this, Rust has the keyword <code>extern</code> that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>, which is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>有时 Rust 代码可能需要与其他语言编写的代码交互。为此，Rust 提供 <code>extern</code> 关键字来简化<strong>外部函数接口（FFI）</strong> 的创建和使用——FFI 是编程语言定义函数并允许不同（外部）编程语言调用这些函数的方式。</p>
<p>Listing 20-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
generally unsafe to call from Rust code, so <code>extern</code> blocks must also be marked
<code>unsafe</code>. The reason is that other languages don’t enforce Rust’s rules and
guarantees, and Rust can’t check them, so responsibility falls on the
programmer to ensure safety.</p>
<p>示例 20-8 演示如何与 C 标准库的 <code>abs</code> 函数集成。在 <code>extern</code> 块中声明的函数从 Rust 代码调用通常不安全，因此 <code>extern</code> 块也必须标记为 <code>unsafe</code>。原因在于其他语言不强制执行 Rust 的规则和保证，而 Rust 无法检查它们，因此确保安全的责任落在程序员身上。</p>
<figure class="listing" id="listing-20-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<figcaption><a href="#listing-20-8">Listing 20-8</a>: Declaring and calling an <code>extern</code> function defined in another language 声明并调用另一语言定义的 <code>extern</code> 函数</figcaption>
</figure>
<p>Within the <code>unsafe extern "C"</code> block, we list the names and signatures of
external functions from another language we want to call. The <code>"C"</code> part
defines which <em>application binary interface (ABI)</em> the external function uses:
the ABI defines how to call the function at the assembly level. The <code>"C"</code> ABI
is the most common and follows the C programming language’s ABI. Information
about all the ABIs Rust supports is available in the Rust Reference.</p>
<p>在 <code>unsafe extern "C"</code> 块中，我们列出要调用的另一语言的外部函数名称和签名。<code>"C"</code> 部分定义外部函数使用的<strong>应用程序二进制接口（ABI）</strong>：ABI 定义了汇编级别的函数调用方式。<code>"C"</code> ABI 最常见且遵循 C 编程语言的 ABI。Rust 支持的所有 ABI 信息见 Rust 参考手册。</p>
<p>Every item declared within an <code>unsafe extern</code> block is implicitly unsafe.
However, some FFI functions <em>are</em> safe to call. For example, the <code>abs</code> function
from C’s standard library does not have any memory safety considerations and we
know it can be called with any <code>i32</code>. In cases like this, we can use the <code>safe</code>
keyword to say that this specific function is safe to call even though it is in
an <code>unsafe extern</code> block. Once we make that change, calling it no longer
requires an <code>unsafe</code> block, as shown in Listing 20-9.</p>
<p>在 <code>unsafe extern</code> 块内声明的每个项都隐式不安全。但某些 FFI 函数<strong>是</strong>安全可调用的。例如，C 标准库的 <code>abs</code> 函数无任何内存安全考量，且我们知道可使用任意 <code>i32</code> 调用它。此类情况下，可用 <code>safe</code> 关键字标记该特定函数安全（即使位于 <code>unsafe extern</code> 块中）。修改后调用它不再需要 <code>unsafe</code> 块，如示例 20-9 所示。</p>
<figure class="listing" id="listing-20-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
<figcaption><a href="#listing-20-9">Listing 20-9</a>: Explicitly marking a function as <code>safe</code> within an <code>unsafe extern</code> block and calling it safely 在 <code>unsafe extern</code> 块中显式标记函数为 <code>safe</code> 并安全调用</figcaption>
</figure>
<p>Marking a function as <code>safe</code> does not inherently make it safe! Instead, it is
like a promise you are making to Rust that it is safe. It is still your
responsibility to make sure that promise is kept!</p>
<p>将函数标记为 <code>safe</code> 并不天然使其安全！相反，这像是你向 Rust 承诺它是安全的。确保信守承诺仍是你的责任！</p>
<h4 id="calling-rust-functions-from-other-languages-从其他语言调用-rust-函数"><a class="header" href="#calling-rust-functions-from-other-languages-从其他语言调用-rust-函数">Calling Rust Functions from Other Languages 从其他语言调用 Rust 函数</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages to
call Rust functions. Instead of creating a whole <code>extern</code> block, we add the
<code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword for
the relevant function. We also need to add an <code>#[unsafe(no_mangle)]</code> annotation
to tell the Rust compiler not to mangle the name of this function. <em>Mangling</em>
is when a compiler changes the name we’ve given a function to a different name
that contains more information for other parts of the compilation process to
consume but is less human readable. Every programming language compiler mangles
names slightly differently, so for a Rust function to be nameable by other
languages, we must disable the Rust compiler’s name mangling. This is unsafe
because there might be name collisions across libraries without the built-in
mangling, so it is our responsibility to make sure the name we choose is safe
to export without mangling.</p>
<p>我们也可用 <code>extern</code> 创建允许其他语言调用 Rust 函数的接口。无需创建整个 <code>extern</code> 块，只需在相关函数的 <code>fn</code> 关键字前添加 <code>extern</code> 关键字并指定 ABI。还需添加 <code>#[unsafe(no_mangle)]</code> 注解告诉 Rust 编译器不要破坏此函数名称。<strong>名称破坏</strong>是编译器将函数名更改为包含更多信息（供编译过程其他部分使用）但可读性更低的名称。每种编程语言编译器破坏名称的方式略有不同，因此要使 Rust 函数可被其他语言调用，必须禁用 Rust 编译器的名称破坏。此操作不安全（因无内置破坏时库间可能存在名称冲突），因此确保所选名称可安全导出（无需破坏）是我们的责任。</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from C
code, after it’s compiled to a shared library and linked from C:</p>
<p>下例使 <code>call_from_c</code> 函数可从 C 代码访问（编译为共享库并从 C 链接后）：</p>
<pre><code>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</code></pre>
<p>This usage of <code>extern</code> requires <code>unsafe</code> only in the attribute, not on the
<code>extern</code> block.</p>
<p>此 <code>extern</code> 用法仅在属性中需要 <code>unsafe</code>，而非在 <code>extern</code> 块上。</p>
<h3 id="accessing-or-modifying-a-mutable-static-variable-访问或修改可变静态变量"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable-访问或修改可变静态变量">Accessing or Modifying a Mutable Static Variable 访问或修改可变静态变量</a></h3>
<p>In this book, we’ve not yet talked about global variables, which Rust does
support but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>本书尚未讨论全局变量（Rust 支持但可能因所有权规则引发问题）。若两个线程访问同一可变全局变量，可能导致数据竞争。</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 20-10 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p>在 Rust 中，全局变量称为<strong>静态</strong>变量。示例 20-10 展示以字符串切片为值的静态变量声明及使用示例。</p>
<figure class="listing" id="listing-20-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}</code></pre></pre>
<figcaption><a href="#listing-20-10">Listing 20-10</a>: Defining and using an immutable static variable 定义并使用不可变静态变量</figcaption>
</figure>
<p>Static variables are similar to constants, which we discussed in
“Constants” in
Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by
convention. Static variables can only store references with the <code>'static</code>
lifetime, which means the Rust compiler can figure out the lifetime and we
aren’t required to annotate it explicitly. Accessing an immutable static
variable is safe.</p>
<p>静态变量类似于常量（第 3 章“常量“中讨论过）。静态变量名按惯例采用 <code>SCREAMING_SNAKE_CASE</code> 格式。静态变量只能存储 <code>'static</code> 生命周期的引用（意味着 Rust 编译器可推断生命周期而无需显式标注）。访问不可变静态变量是安全的。</p>
<p>A subtle difference between constants and immutable static variables is that
values in a static variable have a fixed address in memory. Using the value
will always access the same data. Constants, on the other hand, are allowed to
duplicate their data whenever they’re used. Another difference is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 20-11 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p>常量与不可变静态变量的微妙区别在于：静态变量的值在内存中有固定地址，使用该值总是访问同一数据；而常量允许在每次使用时复制数据。另一区别是静态变量可为可变。访问和修改可变静态变量是<strong>不安全</strong>的。示例 20-11 展示如何声明、访问和修改名为 <code>COUNTER</code> 的可变静态变量。</p>
<figure class="listing" id="listing-20-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
<figcaption><a href="#listing-20-11">Listing 20-11</a>: Reading from or writing to a mutable static variable is unsafe. 读写可变静态变量不安全</figcaption>
</figure>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. The
code in Listing 20-11 compiles and prints <code>COUNTER: 3</code> as we would expect
because it’s single threaded. Having multiple threads access <code>COUNTER</code> would
likely result in data races, so it is undefined behavior. Therefore, we need to
mark the entire function as <code>unsafe</code> and document the safety limitation, so
anyone calling the function knows what they are and are not allowed to do
safely.</p>
<p>与常规变量类似，我们使用 <code>mut</code> 关键字指定可变性。任何读写 <code>COUNTER</code> 的代码必须在 <code>unsafe</code> 块中。示例 20-11 的代码能编译并按预期打印 <code>COUNTER: 3</code>（因是单线程）。多线程访问 <code>COUNTER</code> 可能导致数据竞争（即未定义行为）。因此，需将整个函数标记为 <code>unsafe</code> 并记录安全限制，以便调用者知晓安全操作的边界。</p>
<p>Whenever we write an unsafe function, it is idiomatic to write a comment
starting with <code>SAFETY</code> and explaining what the caller needs to do to call the
function safely. Likewise, whenever we perform an unsafe operation, it is
idiomatic to write a comment starting with <code>SAFETY</code> to explain how the safety
rules are upheld.</p>
<p>编写不安全函数时，惯例是以 <code>SAFETY</code> 开头的注释说明调用者需满足的安全条件。类似地，执行不安全操作时，惯例是用 <code>SAFETY</code> 开头的注释解释如何维护安全规则。</p>
<p>Additionally, the compiler will deny by default any attempt to create
references to a mutable static variable through a compiler lint. You must
either explicitly opt-out of that lint’s protections by adding an
<code>#[allow(static_mut_refs)]</code> annotation or access the mutable static variable
via a raw pointer created with one of the raw borrow operators. That includes
cases where the reference is created invisibly, as when it is used in the
<code>println!</code> in this code listing. Requiring references to static mutable
variables to be created via raw pointers helps make the safety requirements for
using them more obvious.</p>
<p>此外，编译器默认拒绝任何通过编译器 lint 创建对可变静态变量引用的尝试。必须显式选择退出该 lint 的保护（通过添加 <code>#[allow(static_mut_refs)]</code> 注解）或通过原始借用运算符创建的原始指针访问可变静态变量。这包括引用被隐式创建的情况（如本代码清单中在 <code>println!</code> 中使用时）。要求通过原始指针创建对静态可变变量的引用，有助于更明显地体现使用它们的安全要求。</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data access from different threads is done safely.</p>
<p>对于全局可访问的可变数据，确保无数据竞争非常困难，因此 Rust 认为可变静态变量不安全。在可能的情况下，优先使用第 16 章讨论的并发技术和线程安全智能指针，以便编译器检查来自不同线程的数据访问是否安全。</p>
<h3 id="implementing-an-unsafe-trait-实现不安全-trait"><a class="header" href="#implementing-an-unsafe-trait-实现不安全-trait">Implementing an Unsafe Trait 实现不安全 trait</a></h3>
<p>We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at
least one of its methods has some invariant that the compiler can’t verify. We
declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>
and marking the implementation of the trait as <code>unsafe</code> too, as shown in
Listing 20-12.</p>
<p>可使用 <code>unsafe</code> 实现不安全 trait。当 trait 的至少一个方法存在编译器无法验证的不变量时，该 trait 为不安全。通过在 <code>trait</code> 前添加 <code>unsafe</code> 关键字并将 trait 实现标记为 <code>unsafe</code> 来声明 trait 不安全，如示例 20-12 所示。</p>
<figure class="listing" id="listing-20-12">
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-20-12">Listing 20-12</a>: Defining and implementing an unsafe trait 定义并实现不安全 trait</figcaption>
</figure>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>通过 <code>unsafe impl</code>，我们承诺将维护编译器无法验证的不变量。</p>
<p>As an example, recall the <code>Send</code> and <code>Sync</code> marker traits we discussed in
“Extensible Concurrency with the <code>Send</code> and <code>Sync</code>
Traits”
in Chapter 16: the compiler implements these traits automatically if our types
are composed entirely of other types that implement <code>Send</code> and <code>Sync</code>. If we
implement a type that contains a type that does not implement <code>Send</code> or <code>Sync</code>,
such as raw pointers, and we want to mark that type as <code>Send</code> or <code>Sync</code>, we
must use <code>unsafe</code>. Rust can’t verify that our type upholds the guarantees that
it can be safely sent across threads or accessed from multiple threads;
therefore, we need to do those checks manually and indicate as such with
<code>unsafe</code>.</p>
<p>例如，回顾第 16 章“使用 <code>Send</code> 和 <code>Sync</code> trait 的可扩展并发“中讨论的 <code>Send</code> 和 <code>Sync</code> 标记 trait：若类型完全由实现 <code>Send</code> 和 <code>Sync</code> 的其他类型组成，编译器会自动实现这些 trait。若实现包含未实现 <code>Send</code> 或 <code>Sync</code> 的类型（如原始指针），且希望标记该类型为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。Rust 无法验证我们的类型满足可安全跨线程发送或多线程访问的保证，因此需要手动检查并通过 <code>unsafe</code> 表明。</p>
<h3 id="accessing-fields-of-a-union-访问联合体union字段"><a class="header" href="#accessing-fields-of-a-union-访问联合体union字段">Accessing Fields of a Union 访问联合体（union）字段</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a union.
A <em>union</em> is similar to a <code>struct</code>, but only one declared field is used in a
particular instance at one time. Unions are primarily used to interface with
unions in C code. Accessing union fields is unsafe because Rust can’t guarantee
the type of the data currently being stored in the union instance. You can
learn more about unions in the Rust Reference.</p>
<p>仅能通过 <code>unsafe</code> 执行的最后一项操作是访问联合体的字段。<strong>联合体</strong>类似于 <code>struct</code>，但在特定实例中仅使用一个声明的字段。联合体主要用于与 C 代码中的联合体交互。访问联合体字段不安全（因 Rust 无法保证当前存储在联合体实例中的数据类型）。更多关于联合体的信息见 Rust 参考手册。</p>
<h3 id="using-miri-to-check-unsafe-code-使用-miri-检查不安全代码"><a class="header" href="#using-miri-to-check-unsafe-code-使用-miri-检查不安全代码">Using Miri to Check Unsafe Code 使用 Miri 检查不安全代码</a></h3>
<p>When writing unsafe code, you might want to check that what you have written
actually is safe and correct. One of the best ways to do that is to use Miri,
an official Rust tool for detecting undefined behavior. Whereas the borrow
checker is a <em>static</em> tool which works at compile time, Miri is a <em>dynamic</em>
tool which works at runtime. It checks your code by running your program, or
its test suite, and detecting when you violate the rules it understands about
how Rust should work.</p>
<p>编写不安全代码时，可能需要检查所写内容是否安全正确。最佳方法之一是使用 Miri（Rust 官方检测未定义行为的工具）。借用检查器是编译时工作的<strong>静态</strong>工具，而 Miri 是运行时工作的<strong>动态</strong>工具。它通过运行程序或其测试套件来检查代码，并在违反 Rust 规则时检测出来。</p>
<p>Using Miri requires a nightly build of Rust (which we talk about more in
Appendix G: How Rust is Made and “Nightly Rust”). You
can install both a nightly version of Rust and the Miri tool by typing <code>rustup +nightly component add miri</code>. This does not change what version of Rust your
project uses; it only adds the tool to your system so you can use it when you
want to. You can run Miri on a project by typing <code>cargo +nightly miri run</code> or
<code>cargo +nightly miri test</code>.</p>
<p>使用 Miri 需要 nightly 版本的 Rust（附录 G：Rust 开发过程及“Nightly Rust“中详述）。可通过 <code>rustup +nightly component add miri</code> 安装 nightly 版 Rust 和 Miri 工具。这不会改变项目使用的 Rust 版本，仅将该工具添加到系统中以便按需使用。可通过 <code>cargo +nightly miri run</code> 或 <code>cargo +nightly miri test</code> 在项目上运行 Miri。</p>
<p>For an example of how helpful this can be, consider what happens when we run it
against Listing 20-7.</p>
<p>为说明其有效性，考虑在示例 20-7 上运行时的结果：</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
warning: integer-to-pointer cast
 --&gt; src/main.rs:5:13
  |
5 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:5:13: 5:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --&gt; src/main.rs:7:35
  |
7 |     let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:7:35: 7:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted

</code></pre>
<p>Miri correctly warns us that we’re casting an integer to a pointer, which might
be a problem but Miri can’t detect if there is because it doesn’t know how the
pointer originated. Then, Miri returns an error where Listing 20-7 has
undefined behavior because we have a dangling pointer. Thanks to Miri, we now
know there is a risk of undefined behavior, and we can think about how to make
the code safe. In some cases, Miri can even make recommendations about how to
fix errors.</p>
<p>Miri 正确警告我们正将整数转换为指针（可能存在问题），但因不知指针来源而无法检测是否存在问题。接着，Miri 在示例 20-7 处返回错误（因存在悬垂指针）。多亏 Miri，我们现在知道存在未定义行为的风险，并可思考如何使代码安全。某些情况下，Miri 甚至能推荐修复错误的方法。</p>
<p>Miri doesn’t catch everything you might get wrong when writing unsafe code.
Miri is a dynamic analysis tool, so it only catches problems with code that
actually gets run. That means you will need to use it in conjunction with good
testing techniques to increase your confidence about the unsafe code you have
written. Miri also does not cover every possible way your code can be unsound.</p>
<p>Miri 无法捕获编写不安全代码时可能犯的所有错误。Miri 是动态分析工具，因此仅检测实际运行代码中的问题。这意味着需将其与良好测试技术结合使用，以增强对所写不安全代码的信心。Miri 也未涵盖代码可能不健全的所有方式。</p>
<p>Put another way: If Miri <em>does</em> catch a problem, you know there’s a bug, but
just because Miri <em>doesn’t</em> catch a bug doesn’t mean there isn’t a problem. It
can catch a lot, though. Try running it on the other examples of unsafe code in
this chapter and see what it says!</p>
<p>换句话说：若 Miri <strong>确实</strong>发现问题，可知存在 bug；但若 Miri <strong>未</strong>捕获 bug，并不表示没有问题。不过它能捕获很多问题。尝试在本章其他不安全代码示例上运行，看看它怎么说！</p>
<p>You can learn more about Miri at its GitHub repository.</p>
<p>可在其 GitHub 仓库了解更多关于 Miri 的信息。</p>
<h3 id="when-to-use-unsafe-code-何时使用不安全代码"><a class="header" href="#when-to-use-unsafe-code-何时使用不安全代码">When to Use Unsafe Code 何时使用不安全代码</a></h3>
<p>Using <code>unsafe</code> to use one of the five superpowers just discussed isn’t wrong or
even frowned upon, but it is trickier to get <code>unsafe</code> code correct because the
compiler can’t help uphold memory safety. When you have a reason to use
<code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code> annotation makes
it easier to track down the source of problems when they occur. Whenever you
write unsafe code, you can use Miri to help you be more confident that the code
you have written upholds Rust’s rules.</p>
<p>使用 <code>unsafe</code> 来利用上述五项超能力并非错误甚至不被反对，但因编译器无法帮助维护内存安全，正确编写 <code>unsafe</code> 代码更棘手。当有理由使用不安全代码时，可以这样做，且显式的 <code>unsafe</code> 注解使问题溯源更简单。编写不安全代码时，可使用 Miri 帮助确保代码符合 Rust 规则。</p>
<p>For a much deeper exploration of how to work effectively with unsafe Rust, read
Rust’s official guide to the subject, the Rustonomicon.</p>
<p>要更深入掌握如何有效使用不安全 Rust，请阅读 Rust 官方指南《Rustonomicon》。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
