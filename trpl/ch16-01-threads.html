<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Threads to Run Code Simultaneously 使用线程同时运行代码 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="using-threads-to-run-code-simultaneously-使用线程同时运行代码"><a class="header" href="#using-threads-to-run-code-simultaneously-使用线程同时运行代码">Using Threads to Run Code Simultaneously 使用线程同时运行代码</a></h2>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system will manage multiple processes at once.
Within a program, you can also have independent parts that run simultaneously.
The features that run these independent parts are called <em>threads</em>. For
example, a web server could have multiple threads so that it can respond to
more than one request at the same time.</p>
<p>在当今多数操作系统中，执行程序的代码运行于<strong>进程</strong>内，操作系统会同时管理多个进程。程序内部也可有独立部分同时运行，运行这些独立部分的特性称为<strong>线程</strong>。例如，Web 服务器可使用多线程同时响应多个请求。</p>
<p>Splitting the computation in your program into multiple threads to run multiple
tasks at the same time can improve performance, but it also adds complexity.
Because threads can run simultaneously, there’s no inherent guarantee about the
order in which parts of your code on different threads will run. This can lead
to problems, such as:</p>
<p>将程序计算拆分到多个线程以同时执行多任务可提升性能，但也增加复杂性。由于线程可能同时运行，无法保证不同线程上代码的执行顺序。这会导致以下问题：</p>
<ul>
<li>
<p>Race conditions, in which threads are accessing data or resources in an
inconsistent order</p>
</li>
<li>
<p>Deadlocks, in which two threads are waiting for each other, preventing both
threads from continuing</p>
</li>
<li>
<p>Bugs that only happen in certain situations and are hard to reproduce and fix
reliably</p>
</li>
<li>
<p><strong>竞态条件</strong>：线程以不一致顺序访问数据或资源</p>
</li>
<li>
<p><strong>死锁</strong>：两个线程相互等待导致都无法继续</p>
</li>
<li>
<p>仅特定场景出现的 Bug：难以可靠复现和修复</p>
</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Rust 试图减轻使用线程的负面影响，但多线程编程仍需谨慎思考，且代码结构需不同于单线程程序。</p>
<p>Programming languages implement threads in a few different ways, and many
operating systems provide an API the programming language can call for creating
new threads. The Rust standard library uses a <em>1:1</em> model of thread
implementation, whereby a program uses one operating system thread per one
language thread. There are crates that implement other models of threading that
make different trade-offs to the 1:1 model. (Rust’s async system, which we will
see in the next chapter, provides another approach to concurrency as well.)</p>
<p>编程语言以几种不同方式实现线程，许多操作系统提供创建新线程的 API。Rust 标准库采用 <strong>1:1</strong> 线程模型，即每个语言线程对应一个操作系统线程。也有 crate 实现其他线程模型，权衡不同于 1:1 模型（Rust 的异步系统是另一种并发方案，将在下一章介绍）。</p>
<h3 id="creating-a-new-thread-with-spawn-使用-spawn-创建新线程"><a class="header" href="#creating-a-new-thread-with-spawn-使用-spawn-创建新线程">Creating a New Thread with <code>spawn</code> 使用 <code>spawn</code> 创建新线程</a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread.</p>
<p><span class="highlight">[note]创建新线程需调用 <code>thread::spawn</code> 函数并传递闭包</span>（第 13 章讨论过闭包），闭包包含要在新线程中运行的代码。示例 16-1 在主线程和新线程中分别打印文本。</p>
<figure class="listing" id="listing-16-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<figcaption><a href="#listing-16-1">Listing 16-1</a>: Creating a new thread to print one thing while the main thread prints something else 创建新线程，主线程和新线程同时打印内容</figcaption>
</figure>
<p>Note that when the main thread of a Rust program completes, all spawned threads
are shut down, whether or not they have finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<p>注意：当 Rust 程序的主线程结束时，所有派生线程无论是否完成都会被关闭。程序输出可能略有不同，但类似如下：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is <code>9</code>, it only got to <code>5</code>
before the main thread shut down.</p>
<p><span class="highlight">[note]<code>thread::sleep</code> 调用强制线程短暂暂停执行</span>，允许其他线程运行。线程可能轮流执行，但不保证：这取决于操作系统调度策略。此运行中主线程先打印，尽管派生线程的打印语句在代码中更靠前。虽然我们让派生线程打印到 <code>i</code> 为 <code>9</code>，但主线程关闭时它只打印到 <code>5</code>。</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<p>若运行此代码仅见主线程输出或无交替输出，尝试增大范围值以增加操作系统切换线程的机会。</p>
<h3 id="waiting-for-all-threads-to-finish-using-join-handles-使用-join-句柄等待所有线程完成"><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles-使用-join-句柄等待所有线程完成">Waiting for All Threads to Finish Using <code>join</code> Handles 使用 <code>join</code> 句柄等待所有线程完成</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but because there is no guarantee on
the order in which threads run, we also can’t guarantee that the spawned thread
will get to run at all!</p>
<p>示例 16-1 的代码不仅常因主线程结束而提前终止派生线程，且因线程执行顺序无保证，甚至无法确保派生线程能运行！</p>
<p>We can fix the problem of the spawned thread not running or of it ending
prematurely by saving the return value of <code>thread::spawn</code> in a variable. The
return type of <code>thread::spawn</code> is <code>JoinHandle&lt;T&gt;</code>. A <code>JoinHandle&lt;T&gt;</code> is an
owned value that, when we call the <code>join</code> method on it, will wait for its
thread to finish. Listing 16-2 shows how to use the <code>JoinHandle&lt;T&gt;</code> of the
thread we created in Listing 16-1 and how to call <code>join</code> to make sure the
spawned thread finishes before <code>main</code> exits.</p>
<p>通过将 <code>thread::spawn</code> 返回值存入变量可解决派生线程未运行或提前结束的问题。<span class="highlight">[note]<code>thread::spawn</code> 返回 <code>JoinHandle&lt;T&gt;</code> 类型。<code>JoinHandle&lt;T&gt;</code> 是一个拥有值，对其调用 <code>join</code> 方法会等待其线程结束。</span>示例 16-2 展示如何使用示例 16-1 中线程的 <code>JoinHandle&lt;T&gt;</code> 并调用 <code>join</code> 确保派生线程在 <code>main</code> 退出前完成。</p>
<figure class="listing" id="listing-16-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-16-2">Listing 16-2</a>: Saving a <code>JoinHandle&lt;T&gt;</code> from <code>thread::spawn</code> to guarantee the thread is run to completion 保存 <code>thread::spawn</code> 的 <code>JoinHandle&lt;T&gt;</code> 确保线程运行完成</figcaption>
</figure>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<p>对句柄调用 <code>join</code> 会阻塞当前线程，直到句柄代表的线程终止。<strong>阻塞</strong>线程意味着阻止其执行工作或退出。因将 <code>join</code> 调用置于主线程 <code>for</code> 循环后，运行示例 16-2 应产生类似输出：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>两线程继续交替执行，但主线程因 <code>handle.join()</code> 调用而等待，直到派生线程结束后才退出。</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p>但若将 <code>handle.join()</code> 移到 <code>main</code> 的 <code>for</code> 循环之前，如下所示：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</figure>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<p>主线程将等待派生线程完成后再运行其 <code>for</code> 循环，因此输出不再交替，如下所示：</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<p>细微之处（如 <code>join</code> 的调用位置）会影响线程是否同时运行。</p>
<h3 id="using-move-closures-with-threads-在线程中使用-move-闭包"><a class="header" href="#using-move-closures-with-threads-在线程中使用-move-闭包">Using <code>move</code> Closures with Threads 在线程中使用 <code>move</code> 闭包</a></h3>
<p>We’ll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code>
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In “Capturing References or Moving Ownership” in Chapter 13, we discussed <code>move</code> in the context of closures. Now we’ll
concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>传递给 <code>thread::spawn</code> 的闭包常需使用 <code>move</code> 关键字，因为闭包会获取其使用环境值的所有权，从而将所有权从一个线程转移到另一个线程。第 13 章“捕获引用或移动所有权”中讨论过闭包的 <code>move</code>。现在我们将更关注 <code>move</code> 与 <code>thread::spawn</code> 的交互。</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t work yet, as you’ll see in a moment.</p>
<p>注意示例 16-1 中传递给 <code>thread::spawn</code> 的闭包无参数：派生线程未使用主线程中的任何数据。<span class="highlight">[note]要在派生线程中使用主线程数据，其闭包必须捕获所需值。</span>示例 16-3 尝试在主线程创建向量并在派生线程使用，但目前无法工作，稍后会看到原因。</p>
<figure class="listing" id="listing-16-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
<figcaption><a href="#listing-16-3">Listing 16-3</a>: Attempting to use a vector created by the main thread in another thread 尝试在主线程创建的向量在另一线程中使用</figcaption>
</figure>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<p>闭包使用 <code>v</code>，因此会捕获 <code>v</code> 并使其成为闭包环境的一部分。因 <code>thread::spawn</code> 在新线程运行闭包，应能在新线程内访问 <code>v</code>。但编译此示例会报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know whether the
reference to <code>v</code> will always be valid.</p>
<p>Rust <strong>推断</strong>如何捕获 <code>v</code>，因 <code>println!</code> 只需 <code>v</code> 的引用，闭包尝试借用 <code>v</code>。但存在问题：Rust 无法判断派生线程运行多久，故不知 <code>v</code> 的引用是否始终有效。</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid.</p>
<p>示例 16-4 展示了更可能导致 <code>v</code> 引用无效的场景。</p>
<figure class="listing" id="listing-16-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<figcaption><a href="#listing-16-4">Listing 16-4</a>: A thread with a closure that attempts to capture a reference to <code>v</code> from a main thread that drops <code>v</code> 线程闭包尝试捕获主线程 <code>v</code> 的引用，但主线程丢弃了 <code>v</code></figcaption>
</figure>
<p>If Rust allowed us to run this code, there’s a possibility that the spawned
thread would be immediately put in the background without running at all. The
spawned thread has a reference to <code>v</code> inside, but the main thread immediately
drops <code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>若 Rust 允许此代码运行，派生线程可能被立即置于后台而不运行。派生线程内含 <code>v</code> 的引用，但主线程立即用 <code>drop</code> 函数（第 15 章讨论过）丢弃 <code>v</code>。当派生线程开始执行时，<code>v</code> 已无效，其引用也无效。糟糕！</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<p>要修复示例 16-3 的编译错误，可使用错误提示建议：</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend.</p>
<p>在闭包前添加 <code>move</code> 关键字，强制闭包获取其使用值的所有权，而非让 Rust 推断借用值。示例 16-5 对示例 16-3 的修改可正常编译运行。</p>
<figure class="listing" id="listing-16-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-16-5">Listing 16-5</a>: Using the <code>move</code> keyword to force a closure to take ownership of the values it uses 使用 <code>move</code> 关键字强制闭包获取所使用值的所有权</figcaption>
</figure>
<p>We might be tempted to try the same thing to fix the code in Listing 16-4 where
the main thread called <code>drop</code> by using a <code>move</code> closure. However, this fix will
not work because what Listing 16-4 is trying to do is disallowed for a
different reason. If we added <code>move</code> to the closure, we would move <code>v</code> into the
closure’s environment, and we could no longer call <code>drop</code> on it in the main
thread. We would get this compiler error instead:</p>
<p>我们可能想用相同方法修复示例 16-4（主线程调用 <code>drop</code>），但此修复无效，因为示例 16-4 的问题另有原因。若对闭包添加 <code>move</code>，会将 <code>v</code> 移入闭包环境，主线程无法再对其调用 <code>drop</code>。会得到以下编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing to Rust that the main thread won’t use <code>v</code> anymore.
If we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>Rust 的所有权规则再次拯救了我们！示例 16-3 的错误是因 Rust 保守地仅为线程借用 <code>v</code>，意味着主线程理论上可能使派生线程的引用失效。通过告知 Rust 将 <code>v</code> 所有权移至派生线程，我们向 Rust 保证主线程不再使用 <code>v</code>。若同样修改示例 16-4，则会在主线程使用 <code>v</code> 时违反所有权规则。<code>move</code> 关键字覆盖了 Rust 借用默认保守性，但不允许违反所有权规则。</p>
<p>Now that we’ve covered what threads are and the methods supplied by the thread
API, let’s look at some situations in which we can use threads.</p>
<p>现在介绍了线程及线程 API 的方法，来看一些使用线程的场景。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-00-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-02-message-passing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-00-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-02-message-passing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
