<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Slice Type 切片类型 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="the-slice-type-切片类型"><a class="header" href="#the-slice-type-切片类型">The Slice Type 切片类型</a></h2>
<p><em>Slices</em> let you reference a contiguous sequence of elements in a
collection. A slice is a kind
of reference, so it does not have ownership.</p>
<p><strong>切片</strong>（slice）允许你引用集合中一段连续的元素序列。切片是一种引用类型，因此它不拥有所有权。</p>
<p>Here’s a small programming problem: write a function that takes a string of
words separated by spaces and returns the first word it finds in that string.
If the function doesn’t find a space in the string, the whole string must be
one word, so the entire string should be returned.</p>
<p>这里有个小编程问题：编写一个函数，该函数接收一个由空格分隔的单词字符串，并返回该字符串中的第一个单词。如果函数在字符串中未找到空格，则整个字符串必然是一个单词，因此应返回整个字符串。</p>
<section class="note" aria-role="note">
<p>Note: For the purposes of introducing string slices, we are assuming ASCII
only in this section; a more thorough discussion of UTF-8 handling is in the
“Storing UTF-8 Encoded Text with Strings” section
of Chapter 8.</p>
<p>注意：为介绍字符串切片，本节我们仅假设字符串为 ASCII 字符集；关于 UTF-8 处理的更全面讨论请见第 8 章的“使用字符串存储 UTF-8 编码文本”部分。</p>
</section>
<p>Let’s work through how we’d write the signature of this function without using
slices, to understand the problem that slices will solve:</p>
<p>让我们先尝试在不使用切片的情况下编写该函数的签名，以理解切片要解决的问题：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>The <code>first_word</code> function has a parameter of type <code>&amp;String</code>. We don’t need
ownership, so this is fine. (In idiomatic Rust, functions do not take ownership
of their arguments unless they need to, and the reasons for that will become
clear as we keep going.) But what should we return? We don’t really have a way
to talk about <em>part</em> of a string. However, we could return the index of the end
of the word, indicated by a space. Let’s try that, as shown in Listing 4-7.</p>
<p><code>first_word</code> 函数有一个 <code>&amp;String</code> 类型的参数。我们不需要所有权，所以这样没问题。（在惯用的 Rust 代码中，除非必要，函数通常不会获取其参数的所有权，随着深入学习，原因会逐渐清晰。）但我们应该返回什么？实际上我们无法表达字符串的<strong>部分</strong>内容。不过，可以返回单词结尾的索引位置，即空格的位置。让我们尝试如示例 4-7 所示的方法。</p>
<figure class="listing" id="listing-4-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-4-7">Listing 4-7</a>: The <code>first_word</code> function that returns a byte index value into the <code>String</code> parameter 返回 <code>String</code> 参数字节索引值的 <code>first_word</code> 函数</figcaption>
</figure>
<p>Because we need to go through the <code>String</code> element by element and check whether
a value is a space, we’ll convert our <code>String</code> to an array of bytes using the
<code>as_bytes</code> method.</p>
<p>由于需要逐个元素遍历 <code>String</code> 并检查是否为空格，我们将使用 <code>as_bytes</code> 方法将 <code>String</code> 转换为字节数组。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Next, we create an iterator over the array of bytes using the <code>iter</code> method:</p>
<p>接着，使用 <code>iter</code> 方法在字节数组上创建迭代器：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>We’ll discuss iterators in more detail in Chapter 13.
For now, know that <code>iter</code> is a method that returns each element in a collection
and that <code>enumerate</code> wraps the result of <code>iter</code> and returns each element as
part of a tuple instead. The first element of the tuple returned from
<code>enumerate</code> is the index, and the second element is a reference to the element.
This is a bit more convenient than calculating the index ourselves.</p>
<p>我们将在第 13 章详细讨论迭代器。现在只需知道：<code>iter</code> 方法返回集合中的每个元素，而 <code>enumerate</code> 包装 <code>iter</code> 的结果，将每个元素作为元组返回。<code>enumerate</code> 返回元组的第一个元素是索引，第二个元素是元素的引用。这比自己计算索引更方便。</p>
<p>Because the <code>enumerate</code> method returns a tuple, we can use patterns to
destructure that tuple. We’ll be discussing patterns more in Chapter 6.
In the <code>for</code> loop, we specify a pattern that has <code>i</code>
for the index in the tuple and <code>&amp;item</code> for the single byte in the tuple.
Because we get a reference to the element from <code>.iter().enumerate()</code>, we use
<code>&amp;</code> in the pattern.</p>
<p>由于 <code>enumerate</code> 方法返回元组，我们可以使用模式来解构它（第 6 章将深入讨论模式）。在 <code>for</code> 循环中，我们指定一个模式：<code>i</code> 表示元组中的索引，<code>&amp;item</code> 表示元组中的单个字节。因为通过 <code>.iter().enumerate()</code> 获取的是元素的引用，所以在模式中使用了 <code>&amp;</code>。</p>
<p>Inside the <code>for</code> loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using <code>s.len()</code>.</p>
<p>在 <code>for</code> 循环内部，我们使用字节字面值语法查找代表空格的字节。找到空格时返回其位置，否则返回字符串长度 <code>s.len()</code>。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a <code>usize</code> on its own, but it’s
only a meaningful number in the context of the <code>&amp;String</code>. In other words,
because it’s a separate value from the <code>String</code>, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the <code>first_word</code> function from Listing 4-7.</p>
<p>现在有办法获取字符串中第一个单词结尾的索引了，但存在一个问题：返回的 <code>usize</code> 本身脱离了 <code>&amp;String</code> 上下文就失去意义。换句话说，由于它是独立于 <code>String</code> 的值，无法保证未来它仍然有效。考虑示例 4-8 的程序，它使用了示例 4-7 的 <code>first_word</code> 函数。</p>
<figure class="listing" id="listing-4-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but s no longer has any content that we
    // could meaningfully use with the value 5, so word is now totally invalid!
}</code></pre></pre>
<figcaption><a href="#listing-4-8">Listing 4-8</a>: Storing the result from calling the <code>first_word</code> function and then changing the <code>String</code> contents 存储调用 <code>first_word</code> 函数的结果后修改 <code>String</code> 内容</figcaption>
</figure>
<p>This program compiles without any errors and would also do so if we used <code>word</code>
after calling <code>s.clear()</code>. Because <code>word</code> isn’t connected to the state of <code>s</code>
at all, <code>word</code> still contains the value <code>5</code>. We could use that value <code>5</code> with
the variable <code>s</code> to try to extract the first word out, but this would be a bug
because the contents of <code>s</code> have changed since we saved <code>5</code> in <code>word</code>.</p>
<p>此程序编译无错误，即使调用 <code>s.clear()</code> 后使用 <code>word</code> 也能通过。因为 <code>word</code> 与 <code>s</code> 的状态完全无关，它仍然包含值 <code>5</code>。我们可以尝试用这个值 <code>5</code> 从变量 <code>s</code> 中提取第一个单词，但这会产生 bug，因为 <code>s</code> 的内容在我们将 <code>5</code> 存入 <code>word</code> 后已改变。</p>
<p>Having to worry about the index in <code>word</code> getting out of sync with the data in
<code>s</code> is tedious and error prone! Managing these indices is even more brittle if
we write a <code>second_word</code> function. Its signature would have to look like this:</p>
<p>担心 <code>word</code> 的索引与 <code>s</code> 的数据不同步既繁琐又易错！若编写 <code>second_word</code> 函数，管理这些索引会更加脆弱。其签名可能如下：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Now we’re tracking a starting <em>and</em> an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We have three unrelated variables floating around that need
to be kept in sync.</p>
<p>现在需要跟踪起始索引和结束索引，更多计算值依赖于特定状态的数据，却未与该状态绑定。三个独立变量飘荡在代码中，必须保持同步。</p>
<p>Luckily, Rust has a solution to this problem: string slices.</p>
<p>幸运的是，Rust 提供了解决方案：字符串切片。</p>
<h3 id="string-slices-字符串切片"><a class="header" href="#string-slices-字符串切片">String Slices 字符串切片</a></h3>
<p>A <em>string slice</em> is a reference to a contiguous sequence of the elements of a
<code>String</code>, and it looks like this:</p>
<p><strong>字符串切片</strong>（string slice）是对 <code>String</code> 中连续元素的引用，形如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>Rather than a reference to the entire <code>String</code>, <code>hello</code> is a reference to a
portion of the <code>String</code>, specified in the extra <code>[0..5]</code> bit. We create slices
using a range within brackets by specifying <code>[starting_index..ending_index]</code>,
where <em><code>starting_index</code></em> is the first position in the slice and <em><code>ending_index</code></em>
is one more than the last position in the slice. Internally, the slice data
structure stores the starting position and the length of the slice, which
corresponds to <em><code>ending_index</code></em> minus <em><code>starting_index</code></em>. So, in the case of <code>let  world = &amp;s[6..11];</code>, <code>world</code> would be a slice that contains a pointer to the
byte at index 6 of <code>s</code> with a length value of <code>5</code>.</p>
<p>这里 <code>hello</code> 不是对整个 <code>String</code> 的引用，而是通过附加的 <code>[0..5]</code> 指定了 <code>String</code> 的一部分。我们使用括号内的范围创建切片：<code>[起始索引..结束索引]</code>，其中 <em><code>起始索引</code></em> 是切片起始位置，<em><code>结束索引</code></em> 是切片末尾位置的下一个索引。切片数据结构内部存储起始位置和长度（即 <em><code>结束索引</code></em> 减去 <em><code>起始索引</code></em>）。因此 <code>let world = &amp;s[6..11];</code> 中，<code>world</code> 将是一个指向 <code>s</code> 索引 6 处字节的切片，长度值为 <code>5</code>。</p>
<p>Figure 4-7 shows this in a diagram.</p>
<p>图 4-7 展示了此结构。</p>
<img alt="" src="img/trpl04-07.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-7: String slice referring to part of a
<code>String</code> 引用部分 <code>String</code> 的字符串切片</span></p>
<p>With Rust’s <code>..</code> range syntax, if you want to start at index 0, you can drop
the value before the two periods. In other words, these are equal:</p>
<p>使用 Rust 的 <code>..</code> 范围语法时，若从索引 0 开始，可省略句号前的值。即以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>By the same token, if your slice includes the last byte of the <code>String</code>, you
can drop the trailing number. That means these are equal:</p>
<p>同理，若切片包含 <code>String</code> 的最后一个字节，可省略结尾数字。即以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So these
are equal:</p>
<p>也可同时省略两个值来获取整个字符串的切片。因此以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<section class="note" aria-role="note">
<p>Note: String slice range indices must occur at valid UTF-8 character
boundaries. If you attempt to create a string slice in the middle of a
multibyte character, your program will exit with an error.</p>
<p>注意：字符串切片的范围索引必须位于有效的 UTF-8 字符边界。若尝试在多字节字符中间创建字符串切片，程序将因错误退出。</p>
</section>
<p>With all this information in mind, let’s rewrite <code>first_word</code> to return a
slice. The type that signifies “string slice” is written as <code>&amp;str</code>:</p>
<p>了解这些信息后，我们重写 <code>first_word</code> 以返回切片。表示“字符串切片”的类型写作 <code>&amp;str</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</figure>
<p>We get the index for the end of the word the same way we did in Listing 4-7, by
looking for the first occurrence of a space. When we find a space, we return a
string slice using the start of the string and the index of the space as the
starting and ending indices.</p>
<p>我们沿用示例 4-7 的方法获取单词结尾索引：查找第一个空格。找到空格时，用字符串起始位置和空格索引作为起止索引返回字符串切片。</p>
<p>Now when we call <code>first_word</code>, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.</p>
<p>现在调用 <code>first_word</code> 会返回一个与底层数据绑定的值。该值由切片起始点的引用和切片元素数量组成。</p>
<p>Returning a slice would also work for a <code>second_word</code> function:</p>
<p>返回切片同样适用于 <code>second_word</code> 函数：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>We now have a straightforward API that’s much harder to mess up because the
compiler will ensure the references into the <code>String</code> remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of <code>first_word</code> will throw a
compile-time error:</p>
<p>现在我们有了简洁的 API，且更难出错，因为编译器将确保指向 <code>String</code> 的引用保持有效。还记得示例 4-8 中的 bug 吗？我们获取了第一个单词结尾的索引，却清空了字符串导致索引失效。那段代码逻辑错误但未立即显现问题。若继续尝试对已清空的字符串使用第一个单词索引，问题会在后续暴露。切片杜绝了此类 bug，让我们更早发现代码问题。使用切片版本的 <code>first_word</code> 会引发编译时错误：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>
</figure>
<p>Here’s the compiler error:</p>
<p>编译器报错如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because <code>clear</code> needs to
truncate the <code>String</code>, it needs to get a mutable reference. The <code>println!</code>
after the call to <code>clear</code> uses the reference in <code>word</code>, so the immutable
reference must still be active at that point. Rust disallows the mutable
reference in <code>clear</code> and the immutable reference in <code>word</code> from existing at the
same time, and compilation fails. Not only has Rust made our API easier to use,
but it has also eliminated an entire class of errors at compile time!</p>
<p>回忆借用规则：若存在不可变引用，就不能再获取可变引用。因为 <code>clear</code> 需要截断 <code>String</code>，它必须获取可变引用。<code>clear</code> 调用后的 <code>println!</code> 使用了 <code>word</code> 的引用，此时不可变引用必须仍有效。Rust 禁止 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。Rust 不仅使 API 更易用，还在编译时消除了整类错误！</p>
<h4 id="string-literals-as-slices-字符串字面值是切片"><a class="header" href="#string-literals-as-slices-字符串字面值是切片">String Literals as Slices 字符串字面值是切片</a></h4>
<p>Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:</p>
<p>前文提到字符串字面值存储在二进制文件中。了解切片后，我们可以正确理解字符串字面值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; <code>&amp;str</code> is an
immutable reference.</p>
<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制文件特定位置的切片。这也解释了字符串字面值不可变的原因：<code>&amp;str</code> 是不可变引用。</p>
<h4 id="string-slices-as-parameters-将字符串切片作为参数"><a class="header" href="#string-slices-as-parameters-将字符串切片作为参数">String Slices as Parameters 将字符串切片作为参数</a></h4>
<p>Knowing that you can take slices of literals and <code>String</code> values leads us to
one more improvement on <code>first_word</code>, and that’s its signature:</p>
<p>知道可以对字面值和 <code>String</code> 值取切片后，我们可以进一步改进 <code>first_word</code> 的签名：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both <code>&amp;String</code> values
and <code>&amp;str</code> values.</p>
<p>更有经验的 Rust 开发者会采用示例 4-9 的签名，因为它允许在 <code>&amp;String</code> 值和 <code>&amp;str</code> 值上使用同一函数。</p>
<figure class="listing" id="listing-4-9">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or
</span><span class="boring">    // whole.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-4-9">Listing 4-9</a>: Improving the <code>first_word</code> function by using a string slice for the type of the <code>s</code> parameter 通过为参数 <code>s</code> 使用字符串切片类型改进 <code>first_word</code> 函数</figcaption>
</figure>
<p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we
can pass a slice of the <code>String</code> or a reference to the <code>String</code>. This
flexibility takes advantage of <em>deref coercions</em>, a feature we will cover in the
“Implicit Deref Coercions with Functions and
Methods” section of Chapter 15.</p>
<p>若拥有字符串切片，可直接传递。若拥有 <code>String</code>，则可传递其切片或引用。这种灵活性利用了<strong>解引用强制转换</strong>（deref coercions）特性，我们将在第 15 章的“函数和方法的隐式解引用强制转换”章节介绍。</p>
<p>Defining a function to take a string slice instead of a reference to a <code>String</code>
makes our API more general and useful without losing any functionality:</p>
<p>定义函数接收字符串切片而非 <code>String</code> 的引用，使 API 更通用实用且不损失功能：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or
    // whole.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</figure>
<h3 id="other-slices-其他切片"><a class="header" href="#other-slices-其他切片">Other Slices 其他切片</a></h3>
<p>String slices, as you might imagine, are specific to strings. But there’s a
more general slice type too. Consider this array:</p>
<p>字符串切片专用于字符串，但存在更通用的切片类型。考虑数组：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Just as we might want to refer to part of a string, we might want to refer to
part of an array. We’d do so like this:</p>
<p>正如可能引用字符串的一部分，也可能引用数组的一部分：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.</p>
<p>此<span class="highlight">[note]切片类型为 <code>&amp;[i32]</code></span>，其工作方式与字符串切片相同：存储首元素引用和长度。这种切片适用于所有集合类型。第 8 章讨论向量（vector）时将深入介绍这些集合。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.</p>
<p>所有权、借用和切片的概念在编译时确保 Rust 程序的内存安全。Rust 语言像其他系统编程语言一样让你控制内存使用，但所有者离开作用域时自动清理数据的功能，意味着你无需编写和调试额外代码来实现这种控制。</p>
<p>Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>
<p>所有权影响着 Rust 的诸多其他部分，因此后续章节将进一步探讨这些概念。接下来，第 5 章将学习如何用 <code>struct</code> 组合数据。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
