<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Validating References with 使用生命周期验证引用 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="validating-references-with-lifetimes-使用生命周期验证引用"><a class="header" href="#validating-references-with-lifetimes-使用生命周期验证引用">Validating References with Lifetimes 使用生命周期验证引用</a></h2>
<p>Lifetimes are another kind of generic that we’ve already been using. Rather
than ensuring that a type has the behavior we want, lifetimes ensure that
references are valid as long as we need them to be.</p>
<p>生命周期是另一种我们已经在使用的泛型。与确保类型具有所需行为不同，生命周期确保引用在需要时保持有效。</p>
<p>One detail we didn’t discuss in the “References and
Borrowing” section in Chapter 4 is
that every reference in Rust has a <em>lifetime</em>, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and inferred,
just like most of the time, types are inferred. We are only required to
annotate types when multiple types are possible. In a similar way, we have to
annotate lifetimes when the lifetimes of references could be related in a few
different ways. Rust requires us to annotate the relationships using generic
lifetime parameters to ensure the actual references used at runtime will
definitely be valid.</p>
<p>在第四章的“引用与借用”部分未讨论的一个细节是：Rust 中的每个引用都有一个<strong>生命周期</strong>（<em>lifetime</em>），即该引用有效的范围。大多数情况下，生命周期是隐式且可推断的，就像类型通常可推断一样。只有在可能存在多种类型时才需要显式标注类型。类似地，当引用的生命周期可能以不同方式关联时，我们必须标注生命周期。Rust 要求我们使用泛型生命周期参数来标注这些关系，以确保运行时使用的实际引用绝对有效。</p>
<p>Annotating lifetimes is not even a concept most other programming languages
have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in
their entirety in this chapter, we’ll discuss common ways you might encounter
lifetime syntax so you can get comfortable with the concept.</p>
<p>生命周期标注在大多数其他编程语言中并不存在，因此这会让人感到陌生。尽管本章不会完整涵盖生命周期，但我们将讨论可能遇到的常见生命周期语法，以便熟悉这一概念。</p>
<h3 id="preventing-dangling-references-with-lifetimes-用生命周期预防悬垂引用"><a class="header" href="#preventing-dangling-references-with-lifetimes-用生命周期预防悬垂引用">Preventing Dangling References with Lifetimes 用生命周期预防悬垂引用</a></h3>
<p>The main aim of lifetimes is to prevent <em>dangling references</em>, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-16, which has an outer scope and an inner
scope.</p>
<p>生命周期的主要目标是防止<strong>悬垂引用</strong>（<em>dangling references</em>），这类引用会导致程序访问非预期的数据。考虑示例 10-16 中的程序，它包含一个外部作用域和一个内部作用域。</p>
<figure class="listing" id="listing-10-16">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
<figcaption><a href="#listing-10-16">Listing 10-16</a>: An attempt to use a reference whose value has gone out of scope 尝试使用一个值已离开作用域的引用</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables
without giving them an initial value, so the variable name exists in the outer
scope. At first glance, this might appear to be in conflict with Rust’s having
no null values. However, if we try to use a variable before giving it a value,
we’ll get a compile-time error, which shows that Rust indeed does not allow
null values.</p>
<p>注意：示例 10-16、10-17 和 10-23 中声明的变量未赋予初始值，因此变量名存在于外部作用域。乍看之下，这可能与 Rust 不允许空值相冲突。然而，若在赋值前使用变量，将引发编译时错误，这表明 Rust 确实不允许空值。</p>
</section>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of <code>5</code>. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t
compile because the value that <code>r</code> is referring to has gone out of scope before
we try to use it. Here is the error message:</p>
<p>外部作用域声明了未初始化的变量 <code>r</code>，内部作用域声明了初始值为 <code>5</code> 的变量 <code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 设为 <code>x</code> 的引用。随后内部作用域结束，我们尝试打印 <code>r</code> 的值。此代码无法编译，因为 <code>r</code> 引用的值在我们尝试使用时已离开作用域。错误信息如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The error message says that the variable <code>x</code> “does not live long enough.” The
reason is that <code>x</code> will be out of scope when the inner scope ends on line 7.
But <code>r</code> is still valid for the outer scope; because its scope is larger, we say
that it “lives longer.” If Rust allowed this code to work, <code>r</code> would be
referencing memory that was deallocated when <code>x</code> went out of scope, and
anything we tried to do with <code>r</code> wouldn’t work correctly. So how does Rust
determine that this code is invalid? It uses a borrow checker.</p>
<p>错误信息指出变量 <code>x</code> “存活时间不够长”。原因是当内部作用域在第 7 行结束时，<code>x</code> 将离开作用域。但 <code>r</code> 在外部作用域中仍然有效；因其作用域更大，我们称其“活得更久”。若 Rust 允许此代码运行，<code>r</code> 将指向 <code>x</code> 离开作用域时已被释放的内存，任何对 <code>r</code> 的操作都将失败。那么 Rust 如何判定此代码无效？它使用借用检查器。</p>
<h3 id="the-borrow-checker-借用检查器"><a class="header" href="#the-borrow-checker-借用检查器">The Borrow Checker 借用检查器</a></h3>
<p>The Rust compiler has a <em>borrow checker</em> that compares scopes to determine
whether all borrows are valid. Listing 10-17 shows the same code as Listing
10-16 but with annotations showing the lifetimes of the variables.</p>
<p>Rust 编译器有一个<strong>借用检查器</strong>（<em>borrow checker</em>），通过比较作用域来判断所有借用是否有效。示例 10-17 展示了与示例 10-16 相同的代码，但添加了变量生命周期的标注。</p>
<figure class="listing" id="listing-10-17">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
<figcaption><a href="#listing-10-17">Listing 10-17</a>: Annotations of the lifetimes of <code>r</code> and <code>x</code>, named <code>'a</code> and <code>'b</code>, respectively 标注变量 <code>r</code> 和 <code>x</code> 的生命周期，分别命名为 <code>'a</code> 和 <code>'b</code></figcaption>
</figure>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code>
with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer
<code>'a</code> lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory
with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than
<code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p>
<p>这里我们将 <code>r</code> 的生命周期标注为 <code>'a</code>，<code>x</code> 的生命周期标注为 <code>'b</code>。如你所见，内部的 <code>'b</code> 块远小于外部的 <code>'a</code> 生命周期块。编译时，Rust 比较两个生命周期的大小，发现 <code>r</code> 拥有生命周期 <code>'a</code>，但它引用的内存的生命周期为 <code>'b</code>。程序被拒绝是因为 <code>'b</code> 比 <code>'a</code> 短：被引用的对象不如引用存活得久。</p>
<p>Listing 10-18 fixes the code so it doesn’t have a dangling reference and it
compiles without any errors.</p>
<p>示例 10-18 修复了代码，消除了悬垂引用，可无错编译。</p>
<figure class="listing" id="listing-10-18">
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<figcaption><a href="#listing-10-18">Listing 10-18</a>: A valid reference because the data has a longer lifetime than the reference 有效引用：数据的生命周期比引用长</figcaption>
</figure>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will
always be valid while <code>x</code> is valid.</p>
<p>此处 <code>x</code> 的生命周期 <code>'b</code> 大于 <code>'a</code>。这意味着 <code>r</code> 可引用 <code>x</code>，因为 Rust 知道只要 <code>x</code> 有效，<code>r</code> 中的引用就始终有效。</p>
<p>Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.</p>
<p>现在你已了解引用的生命周期位置及 Rust 如何分析生命周期以确保引用有效，接下来让我们探索函数上下文中的参数和返回值的泛型生命周期。</p>
<h3 id="generic-lifetimes-in-functions-函数中的泛型生命周期"><a class="header" href="#generic-lifetimes-in-functions-函数中的泛型生命周期">Generic Lifetimes in Functions 函数中的泛型生命周期</a></h3>
<p>We’ll write a function that returns the longer of two string slices. This
function will take two string slices and return a single string slice. After
we’ve implemented the <code>longest</code> function, the code in Listing 10-19 should
print <code>The longest string is abcd</code>.</p>
<p>我们将编写返回两个字符串切片中较长者的函数。该函数接收两个字符串切片并返回单个字符串切片。实现 <code>longest</code> 函数后，示例 10-19 中的代码应打印 <code>The longest string is abcd</code>。</p>
<figure class="listing" id="listing-10-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
<figcaption><a href="#listing-10-19">Listing 10-19</a>: A <code>main</code> function that calls the <code>longest</code> function to find the longer of two string slices 调用 <code>longest</code> 函数以比较两个字符串切片长度的 <code>main</code> 函数</figcaption>
</figure>
<p>Note that we want the function to take string slices, which are references,
rather than strings, because we don’t want the <code>longest</code> function to take
ownership of its parameters. Refer to “String Slices as
Parameters” in Chapter 4 for more
discussion about why the parameters we use in Listing 10-19 are the ones we
want.</p>
<p>注意我们希望函数接收字符串切片（即引用）而非字符串，因为不希望 <code>longest</code> 函数获取参数的所有权。更多讨论请参阅第四章的“字符串切片作为参数”部分。</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-20, it
won’t compile.</p>
<p>若按示例 10-20 实现 <code>longest</code> 函数，将无法编译。</p>
<figure class="listing" id="listing-10-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
<figcaption><a href="#listing-10-20">Listing 10-20</a>: An implementation of the <code>longest</code> function that returns the longer of two string slices but does not yet compile <code>longest</code> 函数实现（尚未能编译）</figcaption>
</figure>
<p>Instead, we get the following error that talks about lifetimes:</p>
<p>编译器会返回关于生命周期的错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
<code>x</code> or <code>y</code>. Actually, we don’t know either, because the <code>if</code> block in the body
of this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>帮助文本指出返回类型需泛型生命周期参数，因为 Rust 无法判断返回的引用指向 <code>x</code> 还是 <code>y</code>。实际上，由于函数体的 <code>if</code> 块返回 <code>x</code> 的引用而 <code>else</code> 块返回 <code>y</code> 的引用，我们同样无法确定！</p>
<p>When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the <code>if</code> case or the
<code>else</code> case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-17 and 10-18 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.</p>
<p>定义函数时，我们不知道将传入的具体值，因此无法预知执行 <code>if</code> 还是 <code>else</code> 分支。我们也不知道传入引用的具体生命周期，故无法像示例 10-17 和 10-18 那样通过作用域判断返回的引用是否始终有效。借用检查器也无法判断，因为它不清楚 <code>x</code> 和 <code>y</code> 的生命周期与返回值的生命周期如何关联。为修复此错误，我们将添加定义引用间关系的泛型生命周期参数，以便借用检查器进行分析。</p>
<h3 id="lifetime-annotation-syntax-生命周期标注语法"><a class="header" href="#lifetime-annotation-syntax-生命周期标注语法">Lifetime Annotation Syntax 生命周期标注语法</a></h3>
<p>Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. Just as functions can accept any type
when the signature specifies a generic type parameter, functions can accept
references with any lifetime by specifying a generic lifetime parameter.</p>
<p>生命周期标注不改变任何引用的存活时间，而是描述多个引用的生命周期关系而不影响其时长。正如函数在签名中指定泛型类型参数时可接受任意类型，函数也可通过指定泛型生命周期参数接受任意生命周期的引用。</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase
and very short, like generic types. Most people use the name <code>'a</code> for the first
lifetime annotation. We place lifetime parameter annotations after the <code>&amp;</code> of a
reference, using a space to separate the annotation from the reference’s type.</p>
<p>生命周期标注语法略特殊：生命周期参数名必须以撇号（<code>'</code>）开头，通常全小写且非常简短（如泛型类型）。多数人用 <code>'a</code> 作为第一个生命周期标注。我们将<span class="highlight">[note]生命周期参数标注放在引用符号 <code>&amp;</code> 之后，并用空格分隔标注与引用类型</span>。</p>
<p>Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>.</p>
<p>示例如下：无生命周期参数的 <code>i32</code> 引用，带生命周期参数 <code>'a</code> 的 <code>i32</code> 引用，以及同具生命周期 <code>'a</code> 的可变 <code>i32</code> 引用。</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. Let’s examine how the lifetime annotations
relate to each other in the context of the <code>longest</code> function.</p>
<p>单个生命周期标注本身意义不大，因其旨在告知 Rust 多个引用的泛型生命周期参数如何关联。接下来探讨 <code>longest</code> 函数中生命周期标注的关联方式。</p>
<h3 id="lifetime-annotations-in-function-signatures-函数签名中的生命周期标注"><a class="header" href="#lifetime-annotations-in-function-signatures-函数签名中的生命周期标注">Lifetime Annotations in Function Signatures 函数签名中的生命周期标注</a></h3>
<p>To use lifetime annotations in function signatures, we need to declare the
generic <em>lifetime</em> parameters inside angle brackets between the function name
and the parameter list, just as we did with generic <em>type</em> parameters.</p>
<p>要在函数签名中使用生命周期标注，需在函数名与参数列表间的尖括号内声明泛型<strong>生命周期</strong>参数，如同处理泛型<strong>类型</strong>参数。</p>
<p>We want the signature to express the following constraint: the returned
reference will be valid as long as both the parameters are valid. This is the
relationship between lifetimes of the parameters and the return value. We’ll
name the lifetime <code>'a</code> and then add it to each reference, as shown in Listing
10-21.</p>
<p>我们希望签名表达以下约束：返回的引用在参数均有效时保持有效。这是参数与返回值的生命周期关系。我们将生命周期命名为 <code>'a</code> 并添加到每个引用，如示例 10-21 所示。</p>
<figure class="listing" id="listing-10-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<figcaption><a href="#listing-10-21">Listing 10-21</a>: The <code>longest</code> function definition specifying that all the references in the signature must have the same lifetime <code>'a</code> <code>longest</code> 函数定义：要求签名中所有引用具有相同生命周期 <code>'a</code></figcaption>
</figure>
<p>This code should compile and produce the result we want when we use it with the
<code>main</code> function in Listing 10-19.</p>
<p>结合示例 10-19 的 <code>main</code> 函数使用此代码时，应能编译并产生预期结果。</p>
<p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime <code>'a</code>. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime <code>'a</code>.
In practice, it means that the lifetime of the reference returned by the
<code>longest</code> function is the same as the smaller of the lifetimes of the values
referred to by the function arguments. These relationships are what we want
Rust to use when analyzing this code.</p>
<p><span class="highlight">[note]函数签名现向 Rust 表明：存在某个生命周期 <code>'a</code>，函数接收的两个参数均为至少存活 <code>'a</code> 的字符串切片，且返回的字符串切片也至少存活 <code>'a</code>。</span>实际上意味着 <code>longest</code> 函数返回引用的生命周期等于函数参数所引用值中较短的生命周期。这正是我们希望 Rust 在代码分析中使用的关系。</p>
<p>Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the <code>longest</code> function doesn’t need to
know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be
substituted for <code>'a</code> that will satisfy this signature.</p>
<p>记住，<span class="highlight">[note]在函数签名中指定生命周期参数时，并未改变任何传入或返回值的实际生命周期，而是规定借用检查器应拒绝不满足这些约束的值。</span>注意 <code>longest</code> 函数无需知道 <code>x</code> 和 <code>y</code> 的具体存活时间，只需存在满足此签名的某个作用域可替代 <code>'a</code>。</p>
<p>When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. The lifetime annotations become part of
the contract of the function, much like the types in the signature. Having
function signatures contain the lifetime contract means the analysis the Rust
compiler does can be simpler. If there’s a problem with the way a function is
annotated or the way it is called, the compiler errors can point to the part of
our code and the constraints more precisely. If, instead, the Rust compiler
made more inferences about what we intended the relationships of the lifetimes
to be, the compiler might only be able to point to a use of our code many steps
away from the cause of the problem.</p>
<p>函数生命周期标注位于函数签名而非函数体。这些标注成为函数契约的一部分，类似于签名中的类型。函数签名包含生命周期契约意味着 Rust 编译器的分析更简单。若函数标注或调用方式有问题，编译器错误可更精确地定位代码位置及约束。反之，若 Rust 对我们期望的生命周期关系进行更多推断，编译器可能仅能指向问题根源的远处代码。</p>
<p>When we pass concrete references to <code>longest</code>, the concrete lifetime that is
substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with the
scope of <code>y</code>. In other words, the generic lifetime <code>'a</code> will get the concrete
lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>. Because
we’ve annotated the returned reference with the same lifetime parameter <code>'a</code>,
the returned reference will also be valid for the length of the smaller of the
lifetimes of <code>x</code> and <code>y</code>.</p>
<p>向 <code>longest</code> 传递具体引用时，替代 <code>'a</code> 的具体生命周期是 <code>x</code> 与 <code>y</code> 作用域的重叠部分。换言之，泛型生命周期 <code>'a</code> 将获得等于 <code>x</code> 和 <code>y</code> 生命周期中较小者的具体生命周期。由于我们以相同生命周期参数 <code>'a</code> 标注返回的引用，该引用在 <code>x</code> 和 <code>y</code> 中较小者的生命周期内均有效。</p>
<p>Let’s look at how the lifetime annotations restrict the <code>longest</code> function by
passing in references that have different concrete lifetimes. Listing 10-22 is
a straightforward example.</p>
<p>让我们通过传入具有不同具体生命周期的引用，观察生命周期标注如何约束 <code>longest</code> 函数。示例 10-22 是一个直观的例子。</p>
<figure class="listing" id="listing-10-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-10-22">Listing 10-22</a>: Using the <code>longest</code> function with references to <code>String</code> values that have different concrete lifetimes 对具有不同生命周期的 <code>String</code> 值使用 <code>longest</code> 函数</figcaption>
</figure>
<p>In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code>
is valid until the end of the inner scope, and <code>result</code> references something
that is valid until the end of the inner scope. Run this code and you’ll see
that the borrow checker approves; it will compile and print <code>The longest string  is long string is long</code>.</p>
<p>此例中，<code>string1</code> 在外部作用域结束前有效，<code>string2</code> 在内部作用域结束前有效，而 <code>result</code> 引用的内容在内部作用域结束前有效。运行此代码可见借用检查器通过：它将编译并打印 <code>The longest string is long string is long</code>。</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We’ll move the
declaration of the <code>result</code> variable outside the inner scope but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Then we’ll move the <code>println!</code> that uses <code>result</code> to outside the
inner scope, after the inner scope has ended. The code in Listing 10-23 will
not compile.</p>
<p>接下来尝试证明 <code>result</code> 引用的生命周期必须是两个参数中较短者的例子。我们将 <code>result</code> 变量的声明移至内部作用域外，但将其赋值保留在 <code>string2</code> 所在的作用域内。然后将使用 <code>result</code> 的 <code>println!</code> 移至内部作用域结束后。示例 10-23 的代码无法编译。</p>
<figure class="listing" id="listing-10-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-10-23">Listing 10-23</a>: Attempting to use <code>result</code> after <code>string2</code> has gone out of scope 尝试在 <code>string2</code> 离开作用域后使用 <code>result</code></figcaption>
</figure>
<p>When we try to compile this code, we get this error:</p>
<p>编译时错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The error shows that for <code>result</code> to be valid for the <code>println!</code> statement,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter <code>'a</code>.</p>
<p>错误表明：为使 <code>result</code> 在 <code>println!</code> 语句中有效，<code>string2</code> 需存活至外部作用域结束。Rust 知晓这一点，因为我们用相同生命周期参数 <code>'a</code> 标注了函数参数和返回值。</p>
<p>As humans, we can look at this code and see that <code>string1</code> is longer than
<code>string2</code>, and therefore, <code>result</code> will contain a reference to <code>string1</code>.
Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will
still be valid for the <code>println!</code> statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the <code>longest</code> function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-23 as possibly having an invalid reference.</p>
<p>作为人类可看出 <code>string1</code> 比 <code>string2</code> 长，因此 <code>result</code> 将包含指向 <code>string1</code> 的引用。由于 <code>string1</code> 尚未离开作用域，其引用在 <code>println!</code> 中仍有效。但编译器无法在此情况下识别引用的有效性。我们已告知 Rust：<code>longest</code> 函数返回引用的生命周期等于所传入引用中较短者的生命周期。因此借用检查器禁止示例 10-23 的代码，因其可能存在无效引用。</p>
<p>Try designing more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!</p>
<p>请尝试设计更多实验：改变传入 <code>longest</code> 函数的引用值和生命周期，并改变返回引用的使用方式。编译前预测试验能否通过借用检查器，然后验证你的判断！</p>
<h3 id="thinking-in-terms-of-lifetimes-生命周期思考模式"><a class="header" href="#thinking-in-terms-of-lifetimes-生命周期思考模式">Thinking in Terms of Lifetimes 生命周期思考模式</a></h3>
<p>The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
<code>longest</code> function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the <code>y</code> parameter. The
following code will compile:</p>
<p>生命周期参数的指定方式取决于函数功能。例如，若将 <code>longest</code> 函数改为始终返回第一个参数而非较长字符串切片，则无需在 <code>y</code> 参数上标注生命周期。以下代码可编译：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</figure>
<p>We’ve specified a lifetime parameter <code>'a</code> for the parameter <code>x</code> and the return
type, but not for the parameter <code>y</code>, because the lifetime of <code>y</code> does not have
any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>我们为参数 <code>x</code> 和返回类型标注了生命周期参数 <code>'a</code>，但未标注参数 <code>y</code>，因为 <code>y</code> 的生命周期与 <code>x</code> 或返回值的生命周期无关。</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does <em>not</em> refer to one of the parameters, it must refer
to a value created within this function. However, this would be a dangling
reference because the value will go out of scope at the end of the function.
Consider this attempted implementation of the <code>longest</code> function that won’t
compile:</p>
<p><span class="highlight">[note]从函数返回引用时，返回类型的生命周期参数必须与某个参数的生命周期参数匹配。</span>若返回的引用<strong>未</strong>指向任何参数，则必须指向此函数内创建的值。但该值将在函数结束时离开作用域，导致悬垂引用。考虑以下无法编译的 <code>longest</code> 函数实现：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</figure>
<p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:</p>
<p>此处尽管为返回类型指定了生命周期参数 <code>'a</code>，实现仍无法编译，因为返回值生命周期与参数生命周期完全无关。错误信息如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end
of the <code>longest</code> function. We’re also trying to return a reference to <code>result</code>
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.</p>
<p>问题在于 <code>result</code> 在 <code>longest</code> 函数结束时离开作用域并被清理。而我们试图从函数返回 <code>result</code> 的引用。无法通过指定生命周期参数来改变悬垂引用，且 Rust 不允许创建悬垂引用。此时最佳解决方案是返回自有数据类型而非引用，让调用函数负责清理该值。</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<p>归根结底，<span class="highlight">[note]生命周期语法旨在连接函数的各参数及返回值的生命周期。</span>一旦建立连接，Rust 便拥有足够信息确保内存安全操作，并禁止可能导致悬垂指针或内存安全违规的操作。</p>
<h3 id="lifetime-annotations-in-struct-definitions-结构体定义中的生命周期标注"><a class="header" href="#lifetime-annotations-in-struct-definitions-结构体定义中的生命周期标注">Lifetime Annotations in Struct Definitions 结构体定义中的生命周期标注</a></h3>
<p>So far, the structs we’ve defined all hold owned types. We can define structs
to hold references, but in that case we would need to add a lifetime annotation
on every reference in the struct’s definition. Listing 10-24 has a struct named
<code>ImportantExcerpt</code> that holds a string slice.</p>
<p>目前我们定义的结构体均持有自有类型。也可定义持有引用的结构体，但需在结构体定义中为每个引用添加生命周期标注。示例 10-24 展示了持有字符串切片的结构体 <code>ImportantExcerpt</code>。</p>
<figure class="listing" id="listing-10-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<figcaption><a href="#listing-10-24">Listing 10-24</a>: A struct that holds a reference, requiring a lifetime annotation 需生命周期标注的持有引用的结构体</figcaption>
</figure>
<p>This struct has the single field <code>part</code> that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference
it holds in its <code>part</code> field.</p>
<p>此结构体的唯一字段 <code>part</code> 是字符串切片（引用）。与泛型数据类型类似，我们在结构体名后的尖括号内声明泛型生命周期参数名，以便在结构体定义体内使用。此标注意味着 <code>ImportantExcerpt</code> 实例的存活时间不能超过其 <code>part</code> 字段的引用。</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>. The data in <code>novel</code> exists before the <code>ImportantExcerpt</code>
instance is created. In addition, <code>novel</code> doesn’t go out of scope until after
the <code>ImportantExcerpt</code> goes out of scope, so the reference in the
<code>ImportantExcerpt</code> instance is valid.</p>
<p><code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 实例，它持有变量 <code>novel</code> 所拥 <code>String</code> 中第一句的引用。<code>novel</code> 的数据在 <code>ImportantExcerpt</code> 实例创建前已存在。此外，<code>novel</code> 在 <code>ImportantExcerpt</code> 离开作用域后才失效，因此该实例中的引用有效。</p>
<h3 id="lifetime-elision-生命周期省略"><a class="header" href="#lifetime-elision-生命周期省略">Lifetime Elision 生命周期省略</a></h3>
<p>You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, we
had a function in Listing 4-9, shown again in Listing 10-25, that compiled
without lifetime annotations.</p>
<p>我们已知每个引用都有生命周期，且需为使用引用的函数或结构体指定生命周期参数。但第四章的示例 4-9（重现为示例 10-25）中的函数在无生命周期标注的情况下编译通过。</p>
<figure class="listing" id="listing-10-25">
<span class="file-name">Filename: src/lib.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-10-25">Listing 10-25</a>: A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references 参数和返回类型均为引用却无需生命周期标注的函数</figcaption>
</figure>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:</p>
<p>此函数能免于生命周期标注有其历史原因：在 Rust 早期版本（1.0 之前），所有引用均需显式生命周期，此代码无法编译。当时函数签名需写作：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.</p>
<p>随着 Rust 代码的积累，Rust 团队发现特定场景下程序员会重复编写相同的生命周期标注。这些场景可预测且遵循确定的模式。<span class="highlight">[note]开发者将这些模式编码至编译器中，使借用检查器能推断这些场景的生命周期，从而无需显式标注。</span></p>
<p>This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>这段 Rust 历史很重要，因为<span class="highlight">[note]未来可能有更多确定性模式被识别并加入编译器。</span>届时生命周期标注的需求会更少。</p>
<p>The patterns programmed into Rust’s analysis of references are called the
<em>lifetime elision rules</em>. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.</p>
<p>这些编码进 Rust 引用分析的模式称为<strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。它们并非供程序员遵循的规则，而是编译器考虑的一组特定场景。若代码符合这些场景，就无需显式标注生命周期。</p>
<p>The elision rules don’t provide full inference. If there is still ambiguity
about what lifetimes the references have after Rust applies the rules, the
compiler won’t guess what the lifetime of the remaining references should be.
Instead of guessing, the compiler will give you an error that you can resolve by
adding the lifetime annotations.</p>
<p>省略规则不提供完整推断。若应用规则后仍存在引用生命周期的歧义，编译器不会猜测剩余引用的生命周期，而是报错要求添加生命周期标注。</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and
lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>函数或方法参数的生命周期称为输入生命周期，返回值的生命周期称为输出生命周期。</p>
<p>The compiler uses three rules to figure out the lifetimes of the references
when there aren’t explicit annotations. The first rule applies to input
lifetimes, and the second and third rules apply to output lifetimes. If the
compiler gets to the end of the three rules and there are still references for
which it can’t figure out lifetimes, the compiler will stop with an error.
These rules apply to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>
<p>当无显式标注时，编译器通过三条规则推断引用的生命周期。第一条规则适用于输入生命周期，第二、三条规则适用于输出生命周期。若应用三条规则后仍有无法确定生命周期的引用，编译器将报错。这些规则适用于 <code>fn</code> 定义和 <code>impl</code> 块。</p>
<p>The first rule is that the compiler assigns a lifetime parameter to each
parameter that’s a reference. In other words, a function with one parameter
gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two
parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32,  y: &amp;'b i32)</code>; and so on.</p>
<p><span class="highlight">[note]第一条规则：编译器为每个引用参数分配一个生命周期参数。</span>即单参数函数获得一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>；双参数函数获得两个独立生命周期参数：<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>；依此类推。</p>
<p>The second rule is that, if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)  -&gt; &amp;'a i32</code>.</p>
<p><span class="highlight">[note]第二条规则：若仅有一个输入生命周期参数，则该生命周期被赋予所有输出生命周期参数</span>：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<p>The third rule is that, if there are multiple input lifetime parameters, but
one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of
<code>self</code> is assigned to all output lifetime parameters. This third rule makes
methods much nicer to read and write because fewer symbols are necessary.</p>
<p><span class="highlight">[note]第三条规则：若存在多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>（因是方法），则 <code>self</code> 的生命周期被赋予所有输出生命周期参数。</span>此规则使方法更易读写，因为所需符号更少。</p>
<p>Let’s pretend we’re the compiler. We’ll apply these rules to figure out the
lifetimes of the references in the signature of the <code>first_word</code> function in
Listing 10-25. The signature starts without any lifetimes associated with the
references:</p>
<p>假设我们是编译器，对示例 10-25 中 <code>first_word</code> 函数签名的引用应用这些规则。签名初始无关联生命周期：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it <code>'a</code> as usual, so now the signature is
this:</p>
<p>应用第一条规则：每个参数分配独立生命周期。按惯例称为 <code>'a</code>，签名变为：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:</p>
<p>因仅有一个输入生命周期，应用第二条规则：输入参数的生命周期被赋予输出生命周期，签名变为：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>现在函数签名中的所有引用均具有生命周期，编译器可继续分析而无需程序员标注此函数签名中的生命周期。</p>
<p>Let’s look at another example, this time using the <code>longest</code> function that had
no lifetime parameters when we started working with it in Listing 10-20:</p>
<p>再看另一示例，使用示例 10-20 中无生命周期参数的 <code>longest</code> 函数：</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:</p>
<p>应用第一条规则：每个参数分配独立生命周期。因有两个参数，故有两个生命周期：</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because <code>longest</code> is a
function rather than a method, so none of the parameters are <code>self</code>. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-20: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.</p>
<p>可见第二条规则不适用（输入生命周期超过一个）。第三条规则也不适用（<code>longest</code> 是函数而非方法，无 <code>self</code> 参数）。应用三条规则后，仍未确定返回类型的生命周期。这就是示例 10-20 编译错误的根源：编译器应用生命周期省略规则后仍无法确定签名中所有引用的生命周期。</p>
<p>Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.</p>
<p>因第三条规则仅适用于方法签名，接下来将在该上下文中探索生命周期，以理解为何此规则能减少方法签名中的生命周期标注。</p>
<h3 id="lifetime-annotations-in-method-definitions-方法定义中的生命周期标注"><a class="header" href="#lifetime-annotations-in-method-definitions-方法定义中的生命周期标注">Lifetime Annotations in Method Definitions 方法定义中的生命周期标注</a></h3>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters, as shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.</p>
<p>在为具有生命周期的结构体实现方法时，语法与示例 10-11 所示的泛型类型参数一致。生命周期参数的声明位置和使用方式取决于其与结构体字段或方法参数及返回值的关联。</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct’s name because those lifetimes are part
of the struct’s type.</p>
<p><span class="highlight">[note]结构体字段的生命周期名必须在 <code>impl</code> 关键字后声明，并在结构体名后使用</span>，因为这些生命周期是结构体类型的一部分。</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-24.</p>
<p>在 <code>impl</code> 块的方法签名中，引用可能与结构体字段的引用生命周期相关联，也可能独立。此外，生命周期省略规则常使方法签名无需生命周期标注。让我们以示例 10-24 定义的 <code>ImportantExcerpt</code> 结构体为例。</p>
<p>First we’ll use a method named <code>level</code> whose only parameter is a reference to
<code>self</code> and whose return value is an <code>i32</code>, which is not a reference to anything:</p>
<p>首先定义方法 <code>level</code>：其唯一参数是 <code>self</code> 的引用，返回值是 <code>i32</code>（非引用类型）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to <code>self</code> because of the first elision rule.</p>
<p><code>impl</code> 后的生命周期参数声明及类型名后的使用是必需的，但无需标注 <code>self</code> 引用的生命周期（因第一条省略规则）。</p>
<p>Here is an example where the third lifetime elision rule applies:</p>
<p>以下是应用第三条生命周期省略规则的示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<p>存在两个输入生命周期，故 Rust 应用第一条规则为 <code>&amp;self</code> 和 <code>announcement</code> 分配独立生命周期。随后因参数之一是 <code>&amp;self</code>，返回类型获得 <code>&amp;self</code> 的生命周期，所有生命周期均得到处理。</p>
<h3 id="the-static-lifetime-静态生命周期"><a class="header" href="#the-static-lifetime-静态生命周期">The Static Lifetime 静态生命周期</a></h3>
<p>One special lifetime we need to discuss is <code>'static</code>, which denotes that the
affected reference <em>can</em> live for the entire duration of the program. All
string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<p>需讨论的一个特殊生命周期是 <code>'static</code>，其表示引用<strong>可能</strong>存活于整个程序期间。所有字符串字面值均具有 <code>'static</code> 生命周期，可标注如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>The text of this string is stored directly in the program’s binary, which is
always available. Therefore, the lifetime of all string literals is <code>'static</code>.</p>
<p>此字符串文本直接存储在程序二进制文件中，始终可用。因此所有字符串字面值的生命周期为 <code>'static</code>。</p>
<p>You might see suggestions in error messages to use the <code>'static</code> lifetime. But
before specifying <code>'static</code> as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not, and whether you want it to. Most of the time, an error message
suggesting the <code>'static</code> lifetime results from attempting to create a dangling
reference or a mismatch of the available lifetimes. In such cases, the solution
is to fix those problems, not to specify the <code>'static</code> lifetime.</p>
<p>错误信息中可能出现建议使用 <code>'static</code> 生命周期的提示。但在为引用指定 <code>'static</code> 生命周期前，请思考该引用是否确实存活于整个程序期间。多数情况下，建议 <code>'static</code> 生命周期的错误源于尝试创建悬垂引用或生命周期不匹配。此时解决方案是修复问题而非指定 <code>'static</code> 生命周期。</p>
<h2 id="generic-type-parameters-trait-bounds-and-lifetimes-together-泛型类型参数trait-约束与生命周期的结合"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together-泛型类型参数trait-约束与生命周期的结合">Generic Type Parameters, Trait Bounds, and Lifetimes Together 泛型类型参数、Trait 约束与生命周期的结合</a></h2>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<p>让我们简要了解在单个函数中指定泛型类型参数、trait 约束和生命周期的语法！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-21 that returns the longer of
two string slices. But now it has an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which can be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
using <code>{}</code>, which is why the <code>Display</code> trait bound is necessary. Because
lifetimes are a type of generic, the declarations of the lifetime parameter
<code>'a</code> and the generic type parameter <code>T</code> go in the same list inside the angle
brackets after the function name.</p>
<p>这是示例 10-21 中返回较长字符串切片的 <code>longest</code> 函数。但现在增加了泛型类型 <code>T</code> 的额外参数 <code>ann</code>，该参数可由任何实现 <code>Display</code> trait 的类型填充（通过 <code>where</code> 子句指定）。此额外参数将用 <code>{}</code> 打印，故需 <code>Display</code> trait 约束。因生命周期是一种泛型，生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 的声明置于函数名后同一尖括号列表中。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>本章涵盖了大量内容！现在你已了解泛型类型参数、trait 与 trait 约束及泛型生命周期参数，可以编写无重复代码以适应多种不同场景。泛型类型参数使代码可应用于不同类型。trait 和 trait 约束确保即使类型是泛型的，代码也能获得所需行为。你学会了使用生命周期标注保证灵活代码不产生悬垂引用。所有这些分析均在编译时完成，不影响运行时性能！</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 18 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the Rust Reference. But next, you’ll learn how to write tests in
Rust so you can make sure your code is working the way it should.</p>
<p>信不信由你，关于本章讨论的主题还有更多内容：第十八章将讨论 trait 对象（使用 trait 的另一方式）。也可能遇到更复杂的生命周期标注场景（仅在非常高级的场景需要），此时应查阅《Rust 参考手册》。接下来你将学习如何在 Rust 中编写测试，以确保代码按预期运行。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-02-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-02-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
