<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extensible Concurrency with the Send and Sync Traits - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="extensible-concurrency-with-the-send-and-sync-traits-通过-send-和-sync-特征扩展并发"><a class="header" href="#extensible-concurrency-with-the-send-and-sync-traits-通过-send-和-sync-特征扩展并发">Extensible Concurrency with the <code>Send</code> and <code>Sync</code> Traits 通过 <code>Send</code> 和 <code>Sync</code> 特征扩展并发</a></h2>
<p>Interestingly, almost every concurrency feature we’ve talked about so far in
this chapter has been part of the standard library, not the language. Your
options for handling concurrency are not limited to the language or the
standard library; you can write your own concurrency features or use those
written by others.</p>
<p>有趣的是，本章讨论的多数并发特性属于标准库而非语言本身。处理并发的选择不限于语言或标准库；可编写自己的并发特性或使用他人编写的。</p>
<p>However, among the key concurrency concepts that are embedded in the language
rather than the standard library are the <code>std::marker</code> traits <code>Send</code> and <code>Sync</code>.</p>
<p>但<span class="highlight">[note]语言本身（而非标准库）的关键并发概念是 <code>std::marker</code> 特征 <code>Send</code> 和 <code>Sync</code>。</span></p>
<h3 id="allowing-transference-of-ownership-between-threads-with-send-用-send-允许所有权在线程间转移"><a class="header" href="#allowing-transference-of-ownership-between-threads-with-send-用-send-允许所有权在线程间转移">Allowing Transference of Ownership Between Threads with <code>Send</code> 用 <code>Send</code> 允许所有权在线程间转移</a></h3>
<p>The <code>Send</code> marker trait indicates that ownership of values of the type
implementing <code>Send</code> can be transferred between threads. Almost every Rust type
implements <code>Send</code>, but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this
cannot implement <code>Send</code> because if you cloned an <code>Rc&lt;T&gt;</code> value and tried to
transfer ownership of the clone to another thread, both threads might update
the reference count at the same time. For this reason, <code>Rc&lt;T&gt;</code> is implemented
for use in single-threaded situations where you don’t want to pay the
thread-safe performance penalty.</p>
<p><span class="highlight">[note]<code>Send</code> 标记特征表示实现 <code>Send</code> 的类型值可跨线程转移所有权。几乎所有 Rust 类型都实现 <code>Send</code>，但例外包括 <code>Rc&lt;T&gt;</code></span>：若克隆 <code>Rc&lt;T&gt;</code> 值并尝试将克隆所有权转移到另一线程，两线程可能同时更新引用计数。因此 <code>Rc&lt;T&gt;</code> 仅用于单线程场景（避免线程安全性能代价）。</p>
<p>Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait `Send` is not implemented  for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. When we switched to <code>Arc&lt;T&gt;</code>, which does implement
<code>Send</code>, the code compiled.</p>
<p>因此，Rust 的类型系统和特征边界确保不会意外不安全地跨线程发送 <code>Rc&lt;T&gt;</code> 值。尝试在示例 16-14 中操作时，出现错误 <code>the trait `Send` is not implemented  for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>。改用实现 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 后，代码成功编译。</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we’ll discuss in Chapter 20.</p>
<p><span class="highlight">[note]完全由 <code>Send</code> 类型组成的类型自动标记为 <code>Send</code>。除原始指针（第 20 章讨论）外，几乎所有原始类型都是 <code>Send</code>。</span></p>
<h3 id="allowing-access-from-multiple-threads-with-sync-用-sync-允许多线程访问"><a class="header" href="#allowing-access-from-multiple-threads-with-sync-用-sync-允许多线程访问">Allowing Access from Multiple Threads with <code>Sync</code> 用 <code>Sync</code> 允许多线程访问</a></h3>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code>
implements <code>Sync</code> if <code>&amp;T</code> (an immutable reference to <code>T</code>) implements <code>Send</code>,
meaning the reference can be sent safely to another thread. Similar to <code>Send</code>,
primitive types all implement <code>Sync</code>, and types composed entirely of types that
implement <code>Sync</code> also implement <code>Sync</code>.</p>
<p><span class="highlight">[note]<code>Sync</code> 标记特征表示实现 <code>Sync</code> 的类型可安全地被多线程引用。换言之，若 <code>&amp;T</code>（<code>T</code> 的不可变引用）实现 <code>Send</code>（即引用可安全发送到另一线程），则类型 <code>T</code> 实现 <code>Sync</code>。与 <code>Send</code> 类似，原始类型都实现 <code>Sync</code>，完全由 <code>Sync</code> 类型组成的类型也实现 <code>Sync</code>。</span></p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> also doesn’t implement <code>Sync</code> for the same reasons
that it doesn’t implement <code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about
in Chapter 15) and the family of related <code>Cell&lt;T&gt;</code> types don’t implement
<code>Sync</code>. The implementation of borrow checking that <code>RefCell&lt;T&gt;</code> does at runtime
is not thread-safe. The smart pointer <code>Mutex&lt;T&gt;</code> implements <code>Sync</code> and can be
used to share access with multiple threads, as you saw in “Sharing a
<code>Mutex&lt;T&gt;</code> Between Multiple
Threads”.</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 同样因 <code>Send</code> 的相同原因不实现 <code>Sync</code>。<code>RefCell&lt;T&gt;</code> 类型（第 15 章讨论）及相关 <code>Cell&lt;T&gt;</code> 类型不实现 <code>Sync</code>。<code>RefCell&lt;T&gt;</code> 的运行时借用检查非线程安全。智能指针 <code>Mutex&lt;T&gt;</code> 实现 <code>Sync</code> 且可共享访问多线程（如“多线程间共享 <code>Mutex&lt;T&gt;</code>”所示）。</p>
<h3 id="implementing-send-and-sync-manually-is-unsafe-手动实现-send-和-sync-不安全"><a class="header" href="#implementing-send-and-sync-manually-is-unsafe-手动实现-send-和-sync-不安全">Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe 手动实现 <code>Send</code> 和 <code>Sync</code> 不安全</a></h3>
<p>Because types composed entirely of other types that implement the <code>Send</code> and
<code>Sync</code> traits also automatically implement <code>Send</code> and <code>Sync</code>, we don’t have to
implement those traits manually. As marker traits, they don’t even have any
methods to implement. They’re just useful for enforcing invariants related to
concurrency.</p>
<p>因完全由实现 <code>Send</code> 和 <code>Sync</code> 特征的类型组成的类型自动实现这些特征，故无需手动实现。作为标记特征，它们甚至无需实现方法。它们仅用于强制并发相关的不变性。</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 20; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees. “The
Rustonomicon” has more information about these guarantees and how to
uphold them.</p>
<p>手动实现这些特征涉及不安全 Rust 代码（第 20 章讨论）。目前需知：构建非由 <code>Send</code> 和 <code>Sync</code> 部分组成的并发新类型需谨慎思考以保证安全。《<a href="https://doc.rust-lang.org/nomicon/">Rust 秘典</a>》有更多关于这些保证及如何维护的信息。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>This isn’t the last you’ll see of concurrency in this book: the next chapter
focuses on async programming, and the project in Chapter 21 will use the
concepts in this chapter in a more realistic situation than the smaller
examples discussed here.</p>
<p>本书后续章节仍涉及并发：下一章聚焦异步编程，第 21 章项目将在比小示例更真实的场景使用本章概念。</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>如前所述，Rust 处理并发的方式极少属于语言本身，故许多并发方案以 crate 形式实现。这些 crate 比标准库发展更快，因此务必在线搜索当前多线程场景的最新 crate。</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Rust 标准库为并发场景提供通道消息传递和智能指针类型（如 <code>Mutex&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>）。类型系统和借用检查器确保使用这些方案的代码不会出现数据竞争或无效引用。一旦代码编译通过，可确信其能无忧运行于多线程。并发编程不再可怕：无畏地前进，让你的程序并发吧！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-03-shared-state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-00-async-await.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-03-shared-state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-00-async-await.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
