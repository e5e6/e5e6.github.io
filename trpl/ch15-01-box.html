<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Box&lt;T&gt; to Point to Data on the Heap 使用 Box&lt;T&gt; 指向堆数据 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="using-boxt-to-point-to-data-on-the-heap-使用-boxt-指向堆数据"><a class="header" href="#using-boxt-to-point-to-data-on-the-heap-使用-boxt-指向堆数据">Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap 使用 <code>Box&lt;T&gt;</code> 指向堆数据</a></h2>
<p>The most straightforward smart pointer is a box, whose type is written
<code>Box&lt;T&gt;</code>. <em>Boxes</em> allow you to store data on the heap rather than the stack.
What remains on the stack is the pointer to the heap data. Refer to Chapter 4
to review the difference between the stack and the heap.</p>
<p>最直接的智能指针是 box，其类型写作 <code>Box&lt;T&gt;</code>。<span class="highlight">[note]<strong>Box</strong> 允许你将数据存储在堆而非栈上。</span>栈中保留的是指向堆数据的指针。栈与堆的区别详见第 4 章。</p>
<p>Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:</p>
<p>Box 除了将数据存储在堆上而非栈外，没有性能开销。但它们也没有太多额外功能。你通常会在以下场景使用它们：</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want
to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that
implements a particular trait rather than being of a specific type</li>
<li>当类型在编译时大小未知，但需在要求确切大小的上下文中使用该类型的值时</li>
<li>当需要转移大量数据的所有权但避免复制时</li>
<li>当只想拥有值并仅关心其实现特定特征而非具体类型时</li>
</ul>
<p>We’ll demonstrate the first situation in “Enabling Recursive Types with
Boxes”. In the second
case, transferring ownership of a large amount of data can take a long time
because the data is copied around on the stack. To improve performance in this
situation, we can store the large amount of data on the heap in a box. Then,
only the small amount of pointer data is copied around on the stack, while the
data it references stays in one place on the heap. The third case is known as a
<em>trait object</em>, and “Using Trait Objects That Allow for Values of Different
Types,” in Chapter 18 is devoted to that topic.
So what you learn here you’ll apply again in that section!</p>
<p>我们将在“通过 Box 启用递归类型”中演示第一种情况。在第二种情况下，转移大量数据所有权可能因栈上数据复制而耗时。为提升性能，可将大量数据存储在堆上的 box 中。这样仅需在栈上复制少量指针数据，其引用的数据则稳定驻留堆中。第三种情况称为<strong>特征对象</strong>，第 18 章的“使用允许不同值类型的特征对象”将专门讨论此主题。因此你在此学到的知识将在该部分再次应用！</p>
<h3 id="using-boxt-to-store-data-on-the-heap-使用-boxt-在堆上存储数据"><a class="header" href="#using-boxt-to-store-data-on-the-heap-使用-boxt-在堆上存储数据">Using <code>Box&lt;T&gt;</code> to Store Data on the Heap 使用 <code>Box&lt;T&gt;</code> 在堆上存储数据</a></h3>
<p>Before we discuss the heap storage use case for <code>Box&lt;T&gt;</code>, we’ll cover the
syntax and how to interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>在讨论 <code>Box&lt;T&gt;</code> 的堆存储用例前，我们先了解其语法及如何与存储在 <code>Box&lt;T&gt;</code> 中的值交互。</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap.</p>
<p>代码清单 15-1 展示了使用 box 在堆上存储 <code>i32</code> 值的方法。</p>
<figure class="listing" id="listing-15-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<figcaption><a href="#listing-15-1">Listing 15-1</a>: Storing an <code>i32</code> value on the heap using a box 使用 box 在堆上存储 <code>i32</code> 值</figcaption>
</figure>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the
value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in
this case, we can access the data in the box similarly to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The
deallocation happens both for the box (stored on the stack) and the data it
points to (stored on the heap).</p>
<p>我们定义变量 <code>b</code> 为指向堆上值 <code>5</code> 的 <code>Box</code>。该程序将打印 <code>b = 5</code>；此时访问 box 中数据的方式与数据在栈上时类似。与任何拥有所有权的值一样，当 box 离开作用域时（如 <code>b</code> 在 <code>main</code> 结尾处），它将被释放。释放同时作用于 box（存储在栈中）及其指向的数据（存储在堆中）。</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single <code>i32</code> on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to define if we didn’t have boxes.</p>
<p>将单个值存入堆实用性有限，因此很少单独这样使用 box。在多数情况下，将如 <code>i32</code> 的默认栈存储值保留在栈上更合适。下面我们通过 box 实现无法直接定义的递归类型。</p>
<h3 id="enabling-recursive-types-with-boxes-通过-box-启用递归类型"><a class="header" href="#enabling-recursive-types-with-boxes-通过-box-启用递归类型">Enabling Recursive Types with Boxes 通过 Box 启用递归类型</a></h3>
<p>A value of a <em>recursive type</em> can have another value of the same type as part of
itself. Recursive types pose an issue because Rust needs to know at compile time
how much space a type takes up. However, the nesting of values of recursive
types could theoretically continue infinitely, so Rust can’t know how much space
the value needs. Because boxes have a known size, we can enable recursive types
by inserting a box in the recursive type definition.</p>
<p><strong>递归类型</strong>的值可将同类型值作为自身组成部分。递归类型会引发问题，因为 Rust 需在编译时确定类型大小。但递归类型的值嵌套理论上可无限延续，导致 Rust 无法确定所需空间大小。由于 box 具有已知大小，我们可在递归类型定义中插入 box 来启用递归类型。</p>
<p>As an example of a recursive type, let’s explore the <em>cons list</em>. This is a data
type commonly found in functional programming languages. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.</p>
<p>以<strong>cons 列表</strong>为例，这是一种函数式编程语言常见的数据类型。我们定义的 cons 列表类型结构简单（递归除外），因此该示例中的概念适用于任何涉及递归类型的复杂场景。</p>
<h4 id="more-information-about-the-cons-list-关于-cons-列表的更多信息"><a class="header" href="#more-information-about-the-cons-list-关于-cons-列表的更多信息">More Information About the Cons List 关于 Cons 列表的更多信息</a></h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects, is made up of nested pairs, and is the Lisp version of a
linked list. Its name comes from the <code>cons</code> function (short for <em>construct
function</em>) in Lisp that constructs a new pair from its two arguments. By
calling <code>cons</code> on a pair consisting of a value and another pair, we can
construct cons lists made up of recursive pairs.</p>
<p><strong>Cons 列表</strong>源自 Lisp 编程语言及其方言，由嵌套对组成，是 Lisp 版的链表。其名源于 Lisp 的 <code>cons</code> 函数（<em>construct function</em> 的缩写），该函数从两个参数构造新对。通过在由值和对组成的对上调用 <code>cons</code>，可构造由递归对组成的 cons 列表。</p>
<p>For example, here’s a pseudocode representation of a cons list containing the
list <code>1, 2, 3</code> with each pair in parentheses:</p>
<p>例如，以下伪代码表示包含列表 <code>1, 2, 3</code> 的 cons 列表，每对用括号表示：</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called <code>Nil</code>
without a next item. A cons list is produced by recursively calling the <code>cons</code>
function. The canonical name to denote the base case of the recursion is <code>Nil</code>.
Note that this is not the same as the “null” or “nil” concept discussed in
Chapter 6, which is an invalid or absent value.</p>
<p>cons 列表中每项包含两个元素：当前项的值和下一项。列表末项仅含值 <code>Nil</code>（无下一项）。cons 列表通过递归调用 <code>cons</code> 函数生成。递归基础情形用 <code>Nil</code> 表示。注意这与第 6 章讨论的“null”或“nil”概念（表示无效或缺失值）不同。</p>
<p>The cons list isn’t a commonly used data structure in Rust. Most of the time
when you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use.
Other, more complex recursive data types <em>are</em> useful in various situations,
but by starting with the cons list in this chapter, we can explore how boxes
let us define a recursive data type without much distraction.</p>
<p>Cons 列表在 Rust 中并不常用。多数情况下 <code>Vec&lt;T&gt;</code> 是更佳选择。但其他更复杂的递归数据类型在某些场景中非常有用。本章通过 cons 列表可清晰展示 box 如何实现递归数据类型定义。</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate.</p>
<p>代码清单 15-2 包含 cons 列表的枚举定义。注意此代码尚不能编译，因为 <code>List</code> 类型大小未知，我们将演示此问题。</p>
<figure class="listing" id="listing-15-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-15-2">Listing 15-2</a>: The first attempt at defining an enum to represent a cons list data structure of <code>i32</code> values 定义枚举表示 <code>i32</code> 值 cons 列表数据结构的首次尝试</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: We’re implementing a cons list that holds only <code>i32</code> values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.</p>
<p>注意：本例为简化仅实现存储 <code>i32</code> 值的 cons 列表。如第 10 章所述，可通过泛型实现存储任意类型值的 cons 列表。</p>
</section>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in
Listing 15-3.</p>
<p>使用 <code>List</code> 类型存储列表 <code>1, 2, 3</code> 的代码如代码清单 15-3 所示。</p>
<figure class="listing" id="listing-15-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<figcaption><a href="#listing-15-3">Listing 15-3</a>: Using the <code>List</code> enum to store the list <code>1, 2, 3</code> 使用 <code>List</code> 枚举存储列表 <code>1, 2, 3</code></figcaption>
</figure>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>第一个 <code>Cons</code> 值持有 <code>1</code> 和另一个 <code>List</code> 值。该 <code>List</code> 值又是持有 <code>2</code> 和另一个 <code>List</code> 的 <code>Cons</code> 值。此 <code>List</code> 值再是持有 <code>3</code> 和 <code>List</code> 值的 <code>Cons</code>，最终以非递归变体 <code>Nil</code> 结束列表。</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4.</p>
<p>若尝试编译代码清单 15-3，将得到如代码清单 15-4 所示的错误。</p>
<figure class="listing" id="listing-15-4">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-15-4">Listing 15-4</a>: The error we get when attempting to define a recursive enum 尝试定义递归枚举时的错误提示</figcaption>
</figure>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error. First we’ll look at how
Rust decides how much space it needs to store a value of a non-recursive type.</p>
<p>错误显示该类型“具有无限大小”。原因是我们定义的 <code>List</code> 包含递归变体：直接持有自身类型的值。因此 Rust 无法确定存储 <code>List</code> 值所需空间。下面分析错误根源。首先观察 Rust 如何确定非递归类型的大小。</p>
<h4 id="computing-the-size-of-a-non-recursive-type-计算非递归类型的大小"><a class="header" href="#computing-the-size-of-a-non-recursive-type-计算非递归类型的大小">Computing the Size of a Non-Recursive Type 计算非递归类型的大小</a></h4>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<p>回顾第 6 章讨论枚举定义时的代码清单 6-2 中的 <code>Message</code> 枚举：</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>为确定分配 <code>Message</code> 值所需空间，Rust 遍历各变体以找出空间需求最大者。Rust 发现 <code>Message::Quit</code> 无需空间，<code>Message::Move</code> 需存储两个 <code>i32</code> 值的空间，依此类推。因仅使用一个变体，<code>Message</code> 值所需最大空间即其最大变体的空间需求。</p>
<p>Contrast this with what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<p>这与 Rust 尝试确定如代码清单 15-2 中递归类型 <code>List</code> 枚举大小的过程形成对比。编译器从持有 <code>i32</code> 类型值和 <code>List</code> 类型值的 <code>Cons</code> 变体开始分析。因此 <code>Cons</code> 所需空间等于 <code>i32</code> 大小加上 <code>List</code> 大小。为计算 <code>List</code> 类型所需内存，编译器再次检查变体（从 <code>Cons</code> 开始）。<code>Cons</code> 变体持有 <code>i32</code> 类型值和 <code>List</code> 类型值，该过程无限循环，如图 15-1 所示。</p>
<img alt="" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants 由无限 <code>Cons</code> 变体组成的无限 <code>List</code></span></p>
<h4 id="using-boxt-to-get-a-recursive-type-with-a-known-size-使用-boxt-获取已知大小的递归类型"><a class="header" href="#using-boxt-to-get-a-recursive-type-with-a-known-size-使用-boxt-获取已知大小的递归类型">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size 使用 <code>Box&lt;T&gt;</code> 获取已知大小的递归类型</a></h4>
<p>Because Rust can’t figure out how much space to allocate for recursively
defined types, the compiler gives an error with this helpful suggestion:</p>
<p>因 Rust 无法确定递归定义类型的分配空间，编译器给出包含实用建议的错误提示：</p>
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In this suggestion, <em>indirection</em> means that instead of storing a value
directly, we should change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>此建议中，<strong>间接性</strong>指我们应改变数据结构，通过存储指向值的指针而非直接存储值本身。</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists holding other lists, but
this implementation is now more like placing the items next to one another
rather than inside one another.</p>
<p>由于 <code>Box&lt;T&gt;</code> 是指针，Rust 始终知晓其所需空间：指针大小不随指向数据量变化。这意味着可将 <code>Box&lt;T&gt;</code> 放入 <code>Cons</code> 变体替代直接存储另一个 <code>List</code> 值。<code>Box&lt;T&gt;</code> 将指向位于堆（而非 <code>Cons</code> 变体内）的下一个 <code>List</code> 值。概念上我们仍有由列表嵌套构成的列表，但此实现方式更近似于元素并置而非相互嵌套。</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile.</p>
<p>我们将代码清单 15-2 的 <code>List</code> 枚举定义及代码清单 15-3 中的 <code>List</code> 用法修改为代码清单 15-5 的形式，即可成功编译。</p>
<figure class="listing" id="listing-15-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<figcaption><a href="#listing-15-5">Listing 15-5</a>: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in order to have a known size 使用 <code>Box&lt;T&gt;</code> 以确定大小的 <code>List</code> 定义</figcaption>
</figure>
<p>The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the
box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space
on the stack than the <code>Cons</code> variant. We now know that any <code>List</code> value will
take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a
box, we’ve broken the infinite, recursive chain, so the compiler can figure out
the size it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code>
variant looks like now.</p>
<p><code>Cons</code> 变体需要 <code>i32</code> 大小加上 box 指针数据的空间。<code>Nil</code> 变体不存储值，故栈上空间需求小于 <code>Cons</code> 变体。现在可知任何 <code>List</code> 值将占用 <code>i32</code> 大小加上 box 指针数据的空间。通过使用 box，我们打破了无限递归链，编译器得以确定存储 <code>List</code> 值所需大小。图 15-2 展示了当前 <code>Cons</code> 变体的形态。</p>
<img alt="" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized
because <code>Cons</code> holds a <code>Box</code> 非无限大小的 <code>List</code>（因 <code>Cons</code> 持有 <code>Box</code>）</span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have the performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 18.</p>
<p>Box 仅提供间接性和堆分配功能，不具备其他智能指针类型的特殊能力（后续将介绍）。它们也没有这些特殊能力带来的性能开销，因此在仅需间接性的场景（如 cons 列表）中非常实用。第 18 章将介绍更多 box 应用场景。</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. These two traits will be
even more important to the functionality provided by the other smart pointer
types we’ll discuss in the rest of this chapter. Let’s explore these two traits
in more detail.</p>
<p><code>Box&lt;T&gt;</code> 类型因实现 <code>Deref</code> 特征而成为智能指针，该特征允许 <code>Box&lt;T&gt;</code> 值被视作引用。当 <code>Box&lt;T&gt;</code> 值离开作用域时，得益于 <code>Drop</code> 特征实现，其所指的堆数据也会被清理。这两个特征对本章将讨论的其他智能指针功能更为重要。下面我们将深入探讨这两个特征。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-00-smart-pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-02-deref.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-00-smart-pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-02-deref.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
