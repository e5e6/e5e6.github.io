<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced Traits 高级特性 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="advanced-traits-高级特性"><a class="header" href="#advanced-traits-高级特性">Advanced Traits 高级特性</a></h2>
<p>We first covered traits in “Traits: Defining Shared
Behavior” in Chapter 10, but we
didn’t discuss the more advanced details. Now that you know more about Rust, we
can get into the nitty-gritty.</p>
<p>我们首次在第10章的“特性：定义共享行为“中介绍了特性，但未讨论更高级的细节。既然你对Rust有了更多了解，现在可以深入细节了。</p>
<h3 id="associated-types-关联类型"><a class="header" href="#associated-types-关联类型">Associated Types 关联类型</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used instead of the
placeholder type for the particular implementation. That way, we can define a
trait that uses some types without needing to know exactly what those types are
until the trait is implemented.</p>
<p><em>关联类型</em> 将类型占位符与特性连接起来，使得特性方法定义能在签名中使用这些占位符类型。特性的实现者会为特定实现指定用于替代占位符类型的具体类型。这样，我们可以定义一个使用某些类型的特性，而无需在实现该特性前确切知道这些类型是什么。</p>
<p>We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>本章描述的大多数高级功能都很少需要使用。关联类型介于中间位置：它们的使用频率低于本书其他部分介绍的功能，但高于本章讨论的许多其他功能。</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. The definition of the <code>Iterator</code> trait is as shown in Listing
20-13.</p>
<p><span class="highlight">[note]带有关联类型的特性示例是标准库提供的<code>Iterator</code>特性。</span>其关联类型名为<code>Item</code>，代表实现<code>Iterator</code>特性的类型所迭代值的类型。<code>Iterator</code>特性的定义如代码清单20-13所示。</p>
<figure class="listing" id="listing-20-13">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<figcaption><a href="#listing-20-13">Listing 20-13</a>: The definition of the <code>Iterator</code> trait that has an associated type <code>Item</code> 包含关联类型<code>Item</code>的<code>Iterator</code>特性定义</figcaption>
</figure>
<p>The type <code>Item</code> is a placeholder, and the <code>next</code> method’s definition shows that
it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p><code>Item</code>类型是一个占位符，<code>next</code>方法的定义表明它将返回<code>Option&lt;Self::Item&gt;</code>类型的值。<code>Iterator</code>特性的实现者将为<code>Item</code>指定具体类型，<code>next</code>方法将返回包含该具体类型值的<code>Option</code>。</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. To examine the difference between the two concepts, we’ll look at an
implementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies
the <code>Item</code> type is <code>u32</code>:</p>
<p>关联类型看起来与泛型类似，因为后者允许我们在不指定处理类型的情况下定义函数。为研究两者的区别，我们将查看在名为<code>Counter</code>的类型上实现<code>Iterator</code>特性，指定<code>Item</code>类型为<code>u32</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 20-14?</p>
<p>这种语法似乎与泛型相当。那么为什么不直接使用泛型定义<code>Iterator</code>特性，如代码清单20-14所示？</p>
<figure class="listing" id="listing-20-14">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<figcaption><a href="#listing-20-14">Listing 20-14</a>: A hypothetical definition of the <code>Iterator</code> trait using generics 使用泛型的<code>Iterator</code>特性假设定义</figcaption>
</figure>
<p>The difference is that when using generics, as in Listing 20-14, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>区别在于使用泛型时（如代码清单20-14），我们必须在每个实现中标注类型；因为我们也可以为<code>Counter</code>实现<code>Iterator&lt;String&gt;</code>或任何其他类型，所以对<code>Counter</code>可以有多个<code>Iterator</code>实现。<span class="highlight">[note]换句话说，当特性具有泛型参数时，可以为同一类型多次实现该特性，每次更改泛型类型参数的具体类型。当我们在<code>Counter</code>上使用<code>next</code>方法时，必须提供类型标注以指明要使用哪个<code>Iterator</code>实现。</span></p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 20-13 with the
definition that uses associated types, we can choose what the type of <code>Item</code>
will be only once because there can be only one <code>impl Iterator for Counter</code>. We
don’t have to specify that we want an iterator of <code>u32</code> values everywhere we
call <code>next</code> on <code>Counter</code>.</p>
<p>使用关联类型时，我们不需要标注类型，因为<span class="highlight">[note]无法在同一个类型上多次实现特性</span>。在代码清单20-13使用关联类型的定义中，我们只能选择一次<code>Item</code>的类型，因为只能存在一个<code>impl Iterator for Counter</code>。在<code>Counter</code>上调用<code>next</code>时，无需到处指定需要<code>u32</code>值的迭代器。</p>
<p>Associated types also become part of the trait’s contract: implementors of the
trait must provide a type to stand in for the associated type placeholder.
Associated types often have a name that describes how the type will be used,
and documenting the associated type in the API documentation is a good practice.</p>
<p>关联类型也成为特性契约的一部分：特性的实现者必须提供一个类型来替代关联类型占位符。关联类型通常具有描述其用途的名称，在API文档中记录关联类型是良好实践。</p>
<h3 id="default-generic-type-parameters-and-operator-overloading-默认泛型类型参数与运算符重载"><a class="header" href="#default-generic-type-parameters-and-operator-overloading-默认泛型类型参数与运算符重载">Default Generic Type Parameters and Operator Overloading 默认泛型类型参数与运算符重载</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. You specify a default type
when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>使用泛型类型参数时，可以为泛型类型指定默认的具体类型。如果默认类型适用，这消除了特性实现者指定具体类型的需要。<span class="highlight">[note]声明泛型类型时使用<code>&lt;PlaceholderType=ConcreteType&gt;</code>语法来指定默认类型</span>。</p>
<p>A great example of a situation where this technique is useful is with <em>operator
overloading</em>, in which you customize the behavior of an operator (such as <code>+</code>)
in particular situations.</p>
<p>这种技术的一个典型应用场景是_运算符重载_，即在特定情况下自定义运算符（如<code>+</code>）的行为。</p>
<p>Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 20-15 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct.</p>
<p>Rust不允许创建自定义运算符或重载任意运算符。但可以通过实现与运算符相关的特性来重载<code>std::ops</code>中列出的操作和相应特性。例如，在代码清单20-15中，我们重载<code>+</code>运算符来将两个<code>Point</code>实例相加。这是通过在<code>Point</code>结构体上实现<code>Add</code>特性完成的。</p>
<figure class="listing" id="listing-20-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<figcaption><a href="#listing-20-15">Listing 20-15</a>: Implementing the <code>Add</code> trait to overload the <code>+</code> operator for <code>Point</code> instances 实现<code>Add</code>特性以重载<code>Point</code>实例的<code>+</code>运算符</figcaption>
</figure>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p><code>add</code>方法将两个<code>Point</code>实例的<code>x</code>值和<code>y</code>值相加来创建新<code>Point</code>。<code>Add</code>特性有一个名为<code>Output</code>的关联类型，决定<code>add</code>方法返回的类型。</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<p>此代码中的默认泛型类型在<code>Add</code>特性内部。其定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>Rhs</code> generic type parameter (short for “right-hand
side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t
specify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type
of <code>Rhs</code> will default to <code>Self</code>, which will be the type we’re implementing
<code>Add</code> on.</p>
<p>此代码应大致熟悉：这是一个包含一个方法和一个关联类型的特性。新部分是<code>Rhs=Self</code>：此语法称为 <em>默认类型参数</em>。<code>Rhs</code>泛型类型参数（“right-hand side“的缩写）定义了<code>add</code>方法中<code>rhs</code>参数的类型。如果我们在实现<code>Add</code>特性时未为<code>Rhs</code>指定具体类型，则<code>Rhs</code>的类型将默认为<code>Self</code>，即我们实现<code>Add</code>的类型。</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we
wanted to add two <code>Point</code> instances. Let’s look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the
default.</p>
<p>当为<code>Point</code>实现<code>Add</code>时，我们使用了<code>Rhs</code>的默认值，因为要相加两个<code>Point</code>实例。现在看一个自定义<code>Rhs</code>类型而非使用默认值的<code>Add</code>特性实现示例。</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. This thin wrapping of an existing type in another struct is known as the
<em>newtype pattern</em>, which we describe in more detail in the “Using the Newtype
Pattern to Implement External Traits” section. We want to add values in millimeters to values in meters and have
the implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code>
for <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 20-16.</p>
<p>我们有两个结构体<code>Millimeters</code>和<code>Meters</code>，以不同单位保存值。这种在另一个结构体中对现有类型进行薄包装的模式称为 <em>newtype模式</em>，我们将在“使用Newtype模式实现外部特性“部分详细说明。我们希望将以毫米为单位的值与以米为单位的值相加，并让<code>Add</code>的实现正确处理单位转换。如代码清单20-16所示，我们可以为<code>Millimeters</code>实现<code>Add</code>，并以<code>Meters</code>作为<code>Rhs</code>。</p>
<figure class="listing" id="listing-20-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<figcaption><a href="#listing-20-16">Listing 20-16</a>: Implementing the <code>Add</code> trait on <code>Millimeters</code> to add <code>Millimeters</code> and <code>Meters</code> 在<code>Millimeters</code>上实现<code>Add</code>特性以将<code>Millimeters</code>和<code>Meters</code>相加</figcaption>
</figure>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>为将<code>Millimeters</code>和<code>Meters</code>相加，我们指定<code>impl Add&lt;Meters&gt;</code>来设置<code>Rhs</code>类型参数的值，而非使用默认的<code>Self</code>。</p>
<p>You’ll use default type parameters in two main ways:</p>
<p>主要在两种情况下使用默认类型参数：</p>
<ol>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ol>
<!-- -->
<ol>
<li>扩展类型而不破坏现有代码</li>
<li>允许在大多数用户不需要的特定情况下进行自定义</li>
</ol>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose:
usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.</p>
<p>标准库的<code>Add</code>特性是第二个目的的示例：通常你会将两个相同类型相加，但<code>Add</code>特性提供了超越此的自定义能力。在<code>Add</code>特性定义中使用默认类型参数意味着大多数时候无需指定额外参数。换句话说，无需编写额外的样板实现代码，使特性更易于使用。</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<p>第一个目的与第二个类似但方向相反：如果想给现有特性添加类型参数，可为其提供默认值以允许扩展特性功能，而不破坏现有实现代码。</p>
<h3 id="disambiguating-between-methods-with-the-same-name-消除同名方法歧义"><a class="header" href="#disambiguating-between-methods-with-the-same-name-消除同名方法歧义">Disambiguating Between Methods with the Same Name 消除同名方法歧义</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>Rust不阻止特性拥有与其他特性方法同名的方法，也不阻止在同一个类型上实现这两个特性。也可以直接在类型上实现与特性方法同名的方法。</p>
<p>When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 20-17 where we’ve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p>调用同名方法时，需要告诉Rust你要使用哪一个。参考代码清单20-17，我们定义了两个特性<code>Pilot</code>和<code>Wizard</code>，它们都有名为<code>fly</code>的方法。然后在已实现<code>fly</code>方法的<code>Human</code>类型上实现这两个特性。每个<code>fly</code>方法执行不同操作。</p>
<figure class="listing" id="listing-20-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-20-17">Listing 20-17</a>: Two traits are defined to have a <code>fly</code> method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is implemented on <code>Human</code> directly. 定义两个包含<code>fly</code>方法的特性并在<code>Human</code>类型上实现，同时直接在<code>Human</code>上实现<code>fly</code>方法</figcaption>
</figure>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 20-18.</p>
<p>当在<code>Human</code>实例上调用<code>fly</code>时，<span class="highlight">[note]编译器默认调用直接实现在类型上的方法</span>，如代码清单20-18所示。</p>
<figure class="listing" id="listing-20-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<figcaption><a href="#listing-20-18">Listing 20-18</a>: Calling <code>fly</code> on an instance of <code>Human</code> 在<code>Human</code>实例上调用<code>fly</code></figcaption>
</figure>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>运行此代码将打印<code>*waving arms furiously*</code>，表明Rust调用了直接在<code>Human</code>上实现的<code>fly</code>方法。</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 20-19 demonstrates this syntax.</p>
<p>要调用<code>Pilot</code>特性或<code>Wizard</code>特性的<code>fly</code>方法，需要使用更明确的语法来指定目标方法。代码清单20-19演示了此语法。</p>
<figure class="listing" id="listing-20-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<figcaption><a href="#listing-20-19">Listing 20-19</a>: Specifying which trait’s <code>fly</code> method we want to call 指定要调用的特性<code>fly</code>方法</figcaption>
</figure>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 20-19, but this is a bit longer to write if we don’t need to
disambiguate.</p>
<p>在方法名前指定特性名可向Rust澄清要调用哪个<code>fly</code>实现。也<span class="highlight">[note]可以写为<code>Human::fly(&amp;person)</code></span>，这等效于代码清单20-19使用的<code>person.fly()</code>，但如果不需要消除歧义则稍长。</p>
<p>Running this code prints the following:</p>
<p>运行此代码打印如下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>因为<code>fly</code>方法接受<code>self</code>参数，如果有两个类型都实现了同一个特性，Rust能根据<code>self</code>的类型判断使用哪个特性实现。</p>
<p>However, associated functions that are not methods don’t have a <code>self</code>
parameter. When there are multiple types or traits that define non-method
functions with the same function name, Rust doesn’t always know which type you
mean unless you use fully qualified syntax. For example, in Listing 20-20 we
create a trait for an animal shelter that wants to name all baby dogs Spot. We
make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>. The
<code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also provide an
associated non-method function <code>baby_name</code> directly.</p>
<p>但是，非方法的关联函数没有<code>self</code>参数。当多个类型或特性定义了同名的非方法函数时，除非使用完全限定语法，否则Rust无法始终知道你要指的类型。例如在代码清单20-20中，我们为动物收容所创建特性，希望将所有小狗命名为Spot。定义<code>Animal</code>特性包含关联非方法函数<code>baby_name</code>。<code>Animal</code>特性在结构体<code>Dog</code>上实现，同时我们直接在<code>Dog</code>上提供关联非方法函数<code>baby_name</code>。</p>
<figure class="listing" id="listing-20-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
<figcaption><a href="#listing-20-20">Listing 20-20</a>: A trait with an associated function and a type with an associated function of the same name that also implements the trait 包含关联函数的特性，以及一个实现了该特性且拥有同名关联函数的类型</figcaption>
</figure>
<p>We implement the code for naming all puppies Spot in the <code>baby_name</code> associated
function that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait
<code>Animal</code>, which describes characteristics that all animals have. Baby dogs are
called puppies, and that is expressed in the implementation of the <code>Animal</code>
trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>我们在直接定义于<code>Dog</code>的<code>baby_name</code>关联函数中实现将所有幼犬命名为Spot的代码。<code>Dog</code>类型也实现了<code>Animal</code>特性，该特性描述了所有动物共有的特征。幼犬称为puppy，这体现在<code>Dog</code>的<code>Animal</code>特性实现中与<code>Animal</code>特性关联的<code>baby_name</code>函数中。</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<p>在<code>main</code>中，调用<code>Dog::baby_name</code>函数直接调用定义于<code>Dog</code>的关联函数。此代码打印如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>This output isn’t what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 20-19 doesn’t help here; if we change <code>main</code> to the code in
Listing 20-21, we’ll get a compilation error.</p>
<p>此输出不符合预期。我们想调用实现在<code>Dog</code>上的<code>Animal</code>特性的<code>baby_name</code>函数，以打印<code>A baby dog is called a puppy</code>。代码清单20-19使用的指定特性名技术在此无效；如果将<code>main</code>改为代码清单20-21的代码，将导致编译错误。</p>
<figure class="listing" id="listing-20-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<figcaption><a href="#listing-20-21">Listing 20-21</a>: Attempting to call the <code>baby_name</code> function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to use 尝试调用<code>Animal</code>特性的<code>baby_name</code>函数，但Rust不知道要使用哪个实现</figcaption>
</figure>
<p>Because <code>Animal::baby_name</code> doesn’t have a <code>self</code> parameter, and there could be
other types that implement the <code>Animal</code> trait, Rust can’t figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<p>因为<code>Animal::baby_name</code>没有<code>self</code>参数，且可能存在其他实现<code>Animal</code>特性的类型，Rust无法判断我们要哪个<code>Animal::baby_name</code>实现。会得到以下编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other
type, we need to use fully qualified syntax. Listing 20-22 demonstrates how to
use fully qualified syntax.</p>
<p>为消除歧义并告诉Rust我们要使用<code>Animal</code>在<code>Dog</code>上的实现而非其他类型的实现，需使用完全限定语法。代码清单20-22演示了如何使用完全限定语法。</p>
<figure class="listing" id="listing-20-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<figcaption><a href="#listing-20-22">Listing 20-22</a>: Using fully qualified syntax to specify that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as implemented on <code>Dog</code> 使用完全限定语法指定要调用实现在<code>Dog</code>上的<code>Animal</code>特性的<code>baby_name</code>函数</figcaption>
</figure>
<p>We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<p>我们在尖括号内为Rust提供类型标注，指明要从实现在<code>Dog</code>上的<code>Animal</code>特性调用<code>baby_name</code>方法，通过指定将<code>Dog</code>类型视为<code>Animal</code>来进行此函数调用。此代码现在打印预期内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<p>通常，<span class="highlight">[note]完全限定语法定义如下：</span></p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>For associated functions that aren’t methods, there would not be a <code>receiver</code>:
there would only be the list of other arguments. You could use fully qualified
syntax everywhere that you call functions or methods. However, you’re allowed
to omit any part of this syntax that Rust can figure out from other information
in the program. You only need to use this more verbose syntax in cases where
there are multiple implementations that use the same name and Rust needs help
to identify which implementation you want to call.</p>
<p>对于非方法的关联函数，则没有接收者：只有其他参数列表。你可以在所有调用函数或方法的地方使用完全限定语法。但是，如果Rust能从程序其他信息推断出部分语法，允许省略这些部分。仅当存在多个同名实现且Rust需要帮助识别目标实现时，才需要使用这种更详细的语法。</p>
<h3 id="using-supertraits-使用超级特性"><a class="header" href="#using-supertraits-使用超级特性">Using Supertraits 使用超级特性</a></h3>
<p>Sometimes you might write a trait definition that depends on another trait: for
a type to implement the first trait, you want to require that type to also
implement the second trait. You would do this so that your trait definition can
make use of the associated items of the second trait. The trait your trait
definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>有时可能需要编写依赖另一个特性的特性定义：要使类型实现第一个特性，需要求该类型也实现第二个特性。这样做可使特性定义利用第二个特性的关联项。特性定义所依赖的特性称为你的特性的超特性。</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a given value formatted so that it’s
framed in asterisks. That is, given a <code>Point</code> struct that implements the
standard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call
<code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it
should print the following:</p>
<p>例如，假设我们想创建<code>OutlinePrint</code>特性，其<code>outline_print</code>方法将格式化打印给定值并添加星号边框。即，对于实现标准库特性<code>Display</code>结果为<code>(x, y)</code>的<code>Point</code>结构体，当在<code>x=1</code>、<code>y=3</code>的<code>Point</code>实例上调用<code>outline_print</code>时，应打印如下内容：</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the
<code>Display</code> trait’s functionality. Therefore, we need to specify that the
<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. This technique is
similar to adding a trait bound to the trait. Listing 20-23 shows an
implementation of the <code>OutlinePrint</code> trait.</p>
<p>在<code>outline_print</code>方法的实现中，我们希望利用<code>Display</code>特性的功能。因此需指定<code>OutlinePrint</code>特性仅适用于也实现了<code>Display</code>的类型，并提供<code>OutlinePrint</code>所需的功能。<span class="highlight">[note]我们可以在特性定义中通过指定<code>OutlinePrint: Display</code>来实现。此技术类似于为特性添加特性约束。</span>代码清单20-23展示了<code>OutlinePrint</code>特性的实现。</p>
<figure class="listing" id="listing-20-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-20-23">Listing 20-23</a>: Implementing the <code>OutlinePrint</code> trait that requires the functionality from <code>Display</code> 实现需要<code>Display</code>功能的<code>OutlinePrint</code>特性</figcaption>
</figure>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>因为我们指定了<code>OutlinePrint</code>需要<code>Display</code>特性，所以可以使用为任何实现<code>Display</code>的类型自动实现的<code>to_string</code>函数。如果未在特性名后添加冒号和<code>Display</code>特性就尝试使用<code>to_string</code>，会收到错误提示：在当前作用域中找不到名为<code>to_string</code>的方法。</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p>现在尝试在未实现<code>Display</code>的类型（如<code>Point</code>结构体）上实现<code>OutlinePrint</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<p>会收到要求<code>Display</code>但未实现的错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p>为修复此问题，我们在<code>Point</code>上实现<code>Display</code>以满足<code>OutlinePrint</code>的约束，如下所示：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>Then, implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<p>这样，在<code>Point</code>上实现<code>OutlinePrint</code>特性将能成功编译，我们可以在<code>Point</code>实例上调用<code>outline_print</code>来在星号边框内显示它。</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-使用newtype模式实现外部特性"><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-使用newtype模式实现外部特性">Using the Newtype Pattern to Implement External Traits 使用Newtype模式实现外部特性</a></h3>
<p>In “Implementing a Trait on a Type” in Chapter 10, we mentioned the orphan rule that states we’re only
allowed to implement a trait on a type if either the trait or the type, or
both, are local to our crate. It’s possible to get around this restriction
using the <em>newtype pattern</em>, which involves creating a new type in a tuple
struct. (We covered tuple structs in “Using Tuple Structs Without Named Fields
to Create Different Types” in Chapter 5.) The
tuple struct will have one field and be a thin wrapper around the type for
which we want to implement a trait. Then the wrapper type is local to our
crate, and we can implement the trait on the wrapper. <em>Newtype</em> is a term that
originates from the Haskell programming language. There is no runtime
performance penalty for using this pattern, and the wrapper type is elided at
compile time.</p>
<p>在第10章“在类型上实现特性“中，我们提到孤儿规则：<span class="highlight">[note]仅当特性或类型（或两者）本地属于当前crate时，才允许在类型上实现特性。可通过 newtype 模式绕过此限制</span>，即在元组结构体中创建新类型。（我们在第5章“使用元组结构体创建无名字段的不同类型“中介绍过元组结构体。）元组结构体将包含一个字段，是目标类型的薄包装。这样包装类型对当前crate是本地类型，我们可以在包装器上实现特性。<em>Newtype</em> 是源自Haskell编程语言的术语。使用此模式没有运行时性能损失，且包装类型在编译时会被省略。</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 20-24.</p>
<p>例如，假设要在<code>Vec&lt;T&gt;</code>上实现<code>Display</code>，孤儿规则会直接阻止我们，因为<code>Display</code>特性和<code>Vec&lt;T&gt;</code>类型都定义在外部crate。可以创建包含<code>Vec&lt;T&gt;</code>实例的<code>Wrapper</code>结构体；然后在<code>Wrapper</code>上实现<code>Display</code>并使用<code>Vec&lt;T&gt;</code>值，如代码清单20-24所示。</p>
<figure class="listing" id="listing-20-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
<figcaption><a href="#listing-20-24">Listing 20-24</a>: Creating a <code>Wrapper</code> type around <code>Vec&lt;String&gt;</code> to implement <code>Display</code> 创建围绕<code>Vec&lt;String&gt;</code>的<code>Wrapper</code>类型以实现<code>Display</code></figcaption>
</figure>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> trait on <code>Wrapper</code>.</p>
<p><code>Display</code>的实现使用<code>self.0</code>访问内部的<code>Vec&lt;T&gt;</code>，因为<code>Wrapper</code>是元组结构体且<code>Vec&lt;T&gt;</code>是元组索引0处的项。这样我们就可以在<code>Wrapper</code>上使用<code>Display</code>特性的功能。</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would
be a solution (we discussed implementing the <code>Deref</code> trait in “Treating Smart
Pointers Like Regular References with <code>Deref</code>” in Chapter 15). If we didn’t want the <code>Wrapper</code> type to have all the
methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s
behavior—we would have to implement just the methods we do want manually.</p>
<p>此技术的缺点是<code>Wrapper</code>是新型类型，因此不包含其持有值的方法。必须在<code>Wrapper</code>上直接实现<code>Vec&lt;T&gt;</code>的所有方法，并将方法委托给<code>self.0</code>，这样才能像对待<code>Vec&lt;T&gt;</code>一样使用<code>Wrapper</code>。如果希望新类型拥有内部类型的所有方法，在<code>Wrapper</code>上实现<code>Deref</code>特性返回内部类型是解决方案（我们在第15章“使用<code>Deref</code>将智能指针视作常规引用“中讨论过实现<code>Deref</code>特性）。如果不希望<code>Wrapper</code>类型拥有内部类型的所有方法（例如为限制<code>Wrapper</code>类型的行为），则必须手动实现所需的方法。</p>
<p>This newtype pattern is also useful even when traits are not involved. Let’s
switch focus and look at some advanced ways to interact with Rust’s type system.</p>
<p>即使不涉及特性，这种newtype模式也很有用。现在让我们转换焦点，看看与Rust类型系统交互的一些高级方式。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-03-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-03-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
