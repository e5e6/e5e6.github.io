<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Message Passing to Transfer Data Between Threads 使用消息传递在线程间传输数据 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="using-message-passing-to-transfer-data-between-threads-使用消息传递在线程间传输数据"><a class="header" href="#using-message-passing-to-transfer-data-between-threads-使用消息传递在线程间传输数据">Using Message Passing to Transfer Data Between Threads 使用消息传递在线程间传输数据</a></h2>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message
passing</em>, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from <a href="https://golang.org/doc/effective_go.html#concurrency">the Go language documentation</a>:
“Do not communicate by sharing memory; instead, share memory by communicating.”</p>
<p>确保安全并发日益流行的方法是<strong>消息传递</strong>，线程或参与者通过相互发送包含数据的消息通信。以下是 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 语言文档</a> 的口号精髓：“不要通过共享内存来通信；相反，通过通信来共享内存。”</p>
<p>To accomplish message-sending concurrency, Rust’s standard library provides an
implementation of channels. A <em>channel</em> is a general programming concept by
which data is sent from one thread to another.</p>
<p>为实现消息发送并发，Rust 标准库提供了通道实现。<strong>通道</strong>是通用编程概念，数据通过其从一个线程发送到另一个线程。</p>
<p>You can imagine a channel in programming as being like a directional channel of
water, such as a stream or a river. If you put something like a rubber duck
into a river, it will travel downstream to the end of the waterway.</p>
<p>可将编程中的通道想象为单向水道（如溪流或河流）。若将橡皮鸭放入河流，它会顺流而下到水道终点。</p>
<p>A channel has two halves: a transmitter and a receiver. The transmitter half is
the upstream location where you put the rubber duck into the river, and the
receiver half is where the rubber duck ends up downstream. One part of your
code calls methods on the transmitter with the data you want to send, and
another part checks the receiving end for arriving messages. A channel is said
to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
<p>通道有两端：发送端和接收端。发送端是上游（放入橡皮鸭处），接收端是下游（橡皮鸭终点）。代码一部分调用发送端方法发送数据，另一部分检查接收端到达的消息。若发送端或接收端被丢弃，则称通道<strong>关闭</strong>。</p>
<p>Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels for any threads that need to communicate with each other, such as
a chat system or a system where many threads perform parts of a calculation and
send the parts to one thread that aggregates the results.</p>
<p>我们将编写一个程序：一个线程生成值并通过通道发送，另一个线程接收值并打印。使用通道发送简单值以演示特性。熟悉此技术后，可将通道用于任何需相互通信的线程（如聊天系统或多线程执行部分计算并将结果发送到聚合线程的系统）。</p>
<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.</p>
<p>首先在示例 16-6 <span class="highlight">[note]创建通道</span>但不操作。注意此代码尚不能编译，因 Rust 无法推断通道要发送的值类型。</p>
<figure class="listing" id="listing-16-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<figcaption><a href="#listing-16-6">Listing 16-6</a>: Creating a channel and assigning the two halves to <code>tx</code> and <code>rx</code> 创建通道并将两端赋值给 <code>tx</code> 和 <code>rx</code></figcaption>
</figure>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for
<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library
implements channels means a channel can have multiple <em>sending</em> ends that
produce values but only one <em>receiving</em> end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.</p>
<p>用 <code>mpsc::channel</code> 函数创建新通道；<code>mpsc</code> 表示<strong>多生产者，单消费者</strong>。简言之，Rust 标准库的通道实现允许多个<strong>发送端</strong>产生值，但仅一个<strong>接收端</strong>消费值。想象多条溪流汇入大河：任何溪流发送的内容都会在终点汇入同一条河。现在从单生产者开始，待此例运行后再添加多生产者。</p>
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the
sending end—the transmitter—and the second element of which is the receiving
end—the receiver. The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in
many fields for <em>transmitter</em> and <em>receiver</em>, respectively, so we name our
variables as such to indicate each end. We’re using a <code>let</code> statement with a
pattern that destructures the tuples; we’ll discuss the use of patterns in
<code>let</code> statements and destructuring in Chapter 19. For now, know that using a
<code>let</code> statement in this way is a convenient approach to extract the pieces of
the tuple returned by <code>mpsc::channel</code>.</p>
<p><code>mpsc::channel</code> 返回元组，第一元素是发送端（发送器），第二元素是接收端（接收器）。<span class="highlight">[note]传统上 <code>tx</code> 和 <code>rx</code> 分别缩写表示<strong>发送器</strong>和<strong>接收器</strong></span>，因此如此命名变量以区分两端。这里使用 <code>let</code> 语句和模式解构元组（第 19 章讨论）；目前只需知此方式可方便提取 <code>mpsc::channel</code> 返回元组的各部分。</p>
<p>Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.</p>
<p>将发送端移入派生线程并发送字符串，使派生线程与主线程通信，如示例 16-7 所示。这如同将橡皮鸭放入上游或线程间发送聊天消息。</p>
<figure class="listing" id="listing-16-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<figcaption><a href="#listing-16-7">Listing 16-7</a>: Moving <code>tx</code> to a spawned thread and sending <code>"hi"</code> 移动 <code>tx</code> 到派生线程并发送 <code>"hi"</code></figcaption>
</figure>
<p>Again, we’re using <code>thread::spawn</code> to create a new thread and then using <code>move</code>
to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code>. The spawned
thread needs to own the transmitter to be able to send messages through the
channel.</p>
<p>再次使用 <code>thread::spawn</code> 创建新线程并用 <code>move</code> 将 <code>tx</code> 移入闭包，使派生线程拥有 <code>tx</code>。派生线程需拥有发送器才能通过通道发送消息。</p>
<p>The transmitter has a <code>send</code> method that takes the value we want to send. The
<code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiver has already
been dropped and there’s nowhere to send a value, the send operation will
return an error. In this example, we’re calling <code>unwrap</code> to panic in case of an
error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.</p>
<p><span class="highlight">[note]发送器有 <code>send</code> 方法，接收要发送的值。<code>send</code> 返回 <code>Result&lt;T, E&gt;</code> 类型，因此若接收端已被丢弃且无处发送值，发送操作将返回错误。</span>本例中调用 <code>unwrap</code> 在错误时 panic。实际应用中应正确处理：回顾第 9 章的错误处理策略。</p>
<p><span class="highlight">[note]注：<code>send</code>不因无接收动作而阻塞。</span></p>
<p>In Listing 16-8, we’ll get the value from the receiver in the main thread. This
is like retrieving the rubber duck from the water at the end of the river or
receiving a chat message.</p>
<p>在示例 16-8，主线程从接收端获取值。这如同从终点取出橡皮鸭或接收聊天消息。</p>
<figure class="listing" id="listing-16-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
<figcaption><a href="#listing-16-8">Listing 16-8</a>: Receiving the value <code>"hi"</code> in the main thread and printing it 在主线程接收值 <code>"hi"</code> 并打印</figcaption>
</figure>
<p>The receiver has two useful methods: <code>recv</code> and <code>try_recv</code>. We’re using <code>recv</code>,
short for <em>receive</em>, which will block the main thread’s execution and wait
until a value is sent down the channel. Once a value is sent, <code>recv</code> will
return it in a <code>Result&lt;T, E&gt;</code>. When the transmitter closes, <code>recv</code> will return
an error to signal that no more values will be coming.</p>
<p><span class="highlight">[note]接收端有两个实用方法：<code>recv</code> 和 <code>try_recv</code>。这里用 <code>recv</code>（receive 缩写）会阻塞主线程直到通道发送值。值发送后，<code>recv</code> 返回 <code>Result&lt;T, E&gt;</code>。发送器关闭时，<code>recv</code> 返回错误表示不再有值。</span></p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&lt;T, E&gt;</code>
immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code>
value if there aren’t any messages this time. Using <code>try_recv</code> is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls <code>try_recv</code> every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.</p>
<p><span class="highlight">[note]<code>try_recv</code> 方法不阻塞</span>，而是立即返回 <code>Result&lt;T, E&gt;</code>：若有消息则为包含消息的 <code>Ok</code>，若无则为 <code>Err</code>。若线程需在等待消息时执行其他工作，<code>try_recv</code> 很有用：可编写循环定期调用 <code>try_recv</code>，处理消息（若有），否则执行其他工作直到下次检查。</p>
<p>We’ve used <code>recv</code> in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.</p>
<p>此例为简化使用 <code>recv</code>；主线程除等待消息外无其他工作，因此阻塞主线程合适。</p>
<p>When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:</p>
<p>运行示例 16-8 的代码，主线程打印值：</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<p>完美！</p>
<h3 id="channels-and-ownership-transference-通道与所有权转移"><a class="header" href="#channels-and-ownership-transference-通道与所有权转移">Channels and Ownership Transference 通道与所有权转移</a></h3>
<p>The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a <code>val</code> value in the spawned thread <em>after</em> we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed.</p>
<p>所有权规则在消息传递中至关重要，因其助你编写安全的并发代码。在 Rust 程序中全面考虑所有权可防止并发错误。我们通过实验展示通道和所有权如何协同防止问题：尝试在发送值后于派生线程中使用 <code>val</code> 值。尝试编译示例 16-9 的代码以解其不被允许的原因。</p>
<figure class="listing" id="listing-16-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
<figcaption><a href="#listing-16-9">Listing 16-9</a>: Attempting to use <code>val</code> after we’ve sent it down the channel 尝试在值发送后使用 <code>val</code></figcaption>
</figure>
<p>Here, we try to print <code>val</code> after we’ve sent it down the channel via <code>tx.send</code>.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:</p>
<p>此处尝试在通过 <code>tx.send</code> 发送后打印 <code>val</code>。允许此操作是坏主意：因值发送到另一线程后，该线程可能在我们重用前修改或丢弃它。另一线程的修改可能导致数据不一致或不存在而产生错误或意外结果。但 Rust 在编译示例 16-9 时会报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Our concurrency mistake has caused a compile-time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<p>并发错误导致了编译时错误。<code>send</code> 函数获取参数的所有权，值移动时接收端获取所有权。这防止我们意外重用发送后的值；所有权系统确保一切正常。</p>
<h3 id="sending-multiple-values-and-seeing-the-receiver-waiting-发送多值并观察接收端等待"><a class="header" href="#sending-multiple-values-and-seeing-the-receiver-waiting-发送多值并观察接收端等待">Sending Multiple Values and Seeing the Receiver Waiting 发送多值并观察接收端等待</a></h3>
<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel.</p>
<p>示例 16-8 的代码可编译运行，但未清晰展示两线程通过通道通信。</p>
<p>In Listing 16-10 we’ve made some modifications that will prove the code in
Listing 16-8 is running concurrently: the spawned thread will now send multiple
messages and pause for a second between each message.</p>
<p>示例 16-10 的修改将证明示例 16-8 并发运行：派生线程现在发送多条消息，每条间隔一秒。</p>
<figure class="listing" id="listing-16-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
<figcaption><a href="#listing-16-10">Listing 16-10</a>: Sending multiple messages and pausing between each one 发送多条消息，每条间隔一秒</figcaption>
</figure>
<p>This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
one second.</p>
<p>派生线程现有一个字符串向量要发送到主线程。我们逐个发送，每条间隔一秒（通过 <code>thread::sleep</code> 和 <code>Duration</code> 值实现）。</p>
<p>In the main thread, we’re not calling the <code>recv</code> function explicitly anymore:
instead, we’re treating <code>rx</code> as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.</p>
<p>主线程不再显式调用 <code>recv</code>：而是<span class="highlight">[note]将 <code>rx</code> 视为迭代器。对每个接收值打印。通道关闭时迭代结束。</span></p>
<p>When running the code in Listing 16-10, you should see the following output
with a one-second pause in between each line:</p>
<p>运行示例 16-10 的代码，应在每行输出间看到一秒停顿：</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don’t have any code that pauses or delays in the <code>for</code> loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.</p>
<p>因主线程的 <code>for</code> 循环无暂停或延迟代码，可知主线程在等待派生线程发送值。</p>
<h3 id="creating-multiple-producers-by-cloning-the-transmitter-克隆发送端以创建多生产者"><a class="header" href="#creating-multiple-producers-by-cloning-the-transmitter-克隆发送端以创建多生产者">Creating Multiple Producers by Cloning the Transmitter 克隆发送端以创建多生产者</a></h3>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple producer,
single consumer</em>. Let’s put <code>mpsc</code> to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitter, as shown in Listing 16-11.</p>
<p>前文提到 <code>mpsc</code> 表示<strong>多生产者，单消费者</strong>。现使用 <code>mpsc</code> 扩展示例 16-10 的代码，创建多线程向同一接收端发送值。如示例 16-11 所示，通过克隆发送端实现。</p>
<figure class="listing" id="listing-16-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-16-11">Listing 16-11</a>: Sending multiple messages from multiple producers 从多生产者发送多条消息</figcaption>
</figure>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
transmitter. This will give us a new transmitter we can pass to the first
spawned thread. We pass the original transmitter to a second spawned thread.
This gives us two threads, each sending different messages to the one receiver.</p>
<p>此次在创建第一个派生线程前，<span class="highlight">[note]对发送端调用 <code>clone</code></span>。这提供新发送端传递给第一个派生线程。原始发送端传递给第二个派生线程。这产生两个线程，各自向同一接收端发送不同消息。</p>
<p>When you run the code, your output should look something like this:</p>
<p>运行代码，输出类似如下：</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order, depending on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
<code>thread::sleep</code>, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.</p>
<p>值顺序可能因系统而异。这正是并发有趣且困难之处。若用 <code>thread::sleep</code> 在不同线程设置不同值，每次运行将更不确定且输出不同。</p>
<p>Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.</p>
<p>了解通道工作原理后，再看另一种并发方法。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-01-threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-03-shared-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-01-threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-03-shared-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
