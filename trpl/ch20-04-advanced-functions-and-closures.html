<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced Functions and Closures 高级函数与闭包 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="advanced-functions-and-closures-高级函数与闭包"><a class="header" href="#advanced-functions-and-closures-高级函数与闭包">Advanced Functions and Closures 高级函数与闭包</a></h2>
<p>This section explores some advanced features related to functions and closures,
including function pointers and returning closures.</p>
<p>本节探讨一些与函数和闭包相关的高级特性，包括函数指针和返回闭包。</p>
<h3 id="function-pointers--函数指针"><a class="header" href="#function-pointers--函数指针">Function Pointers  函数指针</a></h3>
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Functions
coerce to the type <code>fn</code> (with a lowercase <em>f</em>), not to be confused with the
<code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. Passing
functions with function pointers will allow you to use functions as arguments
to other functions.</p>
<p>我们已经讨论过如何将闭包传递给函数；你也可以将常规函数传递给函数！当你想要传递一个已定义的函数而不是定义一个新的闭包时，这项技术很有用。<span class="highlight">[note]函数会被强制转换为 <code>fn</code> 类型</span>（小写的 <em>f</em>），不要与<code>Fn</code> 闭包特质（trait）混淆。<code>fn</code> 类型被称为 <em>函数指针</em>。使用函数指针传递函数将允许你将函数用作其他函数的参数。</p>
<p>The syntax for specifying that a parameter is a function pointer is similar to
that of closures, as shown in Listing 20-28, where we’ve defined a function
<code>add_one</code> that adds 1 to its parameter. The function <code>do_twice</code> takes two
parameters: a function pointer to any function that takes an <code>i32</code> parameter
and returns an <code>i32</code>, and one <code>i32</code> value. The <code>do_twice</code> function calls the
function <code>f</code> twice, passing it the <code>arg</code> value, then adds the two function call
results together. The <code>main</code> function calls <code>do_twice</code> with the arguments
<code>add_one</code> and <code>5</code>.</p>
<p>指定参数为函数指针的语法与闭包的类似，如代码清单 20-28 所示，其中我们定义了一个函数<code>add_one</code>，它将其参数加 1。函数 <code>do_twice</code> 接受两个参数：一个指向任何接受 <code>i32</code> 参数并返回 <code>i32</code> 的函数的函数指针，以及一个 <code>i32</code> 值。<code>do_twice</code> 函数调用函数 <code>f</code> 两次，将 <code>arg</code> 值传递给它，然后将两次函数调用的结果相加。<code>main</code> 函数以参数<code>add_one</code> 和 <code>5</code> 调用 <code>do_twice</code>。</p>
<figure class="listing" id="listing-20-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<figcaption><a href="#listing-20-28">Listing 20-28</a>: Using the <code>fn</code> type to accept a function pointer as an argument 使用 <code>fn</code> 类型接受函数指针作为参数</figcaption>
</figure>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>此代码打印 <code>The answer is: 12</code>。我们指定 <code>do_twice</code> 中的参数 <code>f</code> 是一个 <code>fn</code>，它接受一个类型为 <code>i32</code> 的参数并返回一个<code>i32</code>。然后我们可以在 <code>do_twice</code> 的函数体中调用 <code>f</code>。在 <code>main</code> 中，我们可以传递函数名 <code>add_one</code> 作为第一个参数给 <code>do_twice</code>。</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>与闭包不同，<code>fn</code> 是一个类型而不是一个特质（trait），因此我们直接指定 <code>fn</code> 作为参数类型，而不是声明一个使用某个 <code>Fn</code> 特质作为特质约束的泛型类型参数。</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), meaning you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.</p>
<p>函数指针实现了所有三个闭包特质（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），这意味着你总是可以将函数指针作为参数传递给期望闭包的函数。最好使用泛型类型和某个闭包特质来编写函数，这样你的函数就可以接受函数或闭包。</p>
<p>That said, one example of where you would want to only accept <code>fn</code> and not
closures is when interfacing with external code that doesn’t have closures: C
functions can accept functions as arguments, but C doesn’t have closures.</p>
<p>话虽如此，一个你可能只想接受 <code>fn</code> 而不接受闭包的例子是与没有闭包的外部代码交互时：C 函数可以接受函数作为参数，但 C 没有闭包。</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of the <code>map</code> method provided by the <code>Iterator</code>
trait in the standard library. To use the <code>map</code> method to turn a vector of
numbers into a vector of strings, we could use a closure, as in Listing 20-29.</p>
<p>作为既可以使用内联定义的闭包也可以使用命名函数的一个例子，我们来看一下标准库中 <code>Iterator</code> 特质提供的 <code>map</code> 方法的使用。要使用 <code>map</code> 方法将数字向量转换为字符串向量，我们可以使用闭包，如代码清单 20-29 所示。</p>
<figure class="listing" id="listing-20-29">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-29">Listing 20-29</a>: Using a closure with the <code>map</code> method to convert numbers to strings 将闭包与 <code>map</code> 方法结合使用以将数字转换为字符串</figcaption>
</figure>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure.
Listing 20-30 shows what this would look like.</p>
<p>或者，我们可以将一个命名函数作为参数传递给 <code>map</code> 来代替闭包。代码清单 20-30 展示了这种情况的样子。</p>
<figure class="listing" id="listing-20-30">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-30">Listing 20-30</a>: Using the <code>String::to_string</code> function with the <code>map</code> method method to convert numbers to strings 将 <code>String::to_string</code> 函数与 <code>map</code> 方法结合使用以将数字转换为字符串</figcaption>
</figure>
<p>Note that we must use the fully qualified syntax that we talked about in
“Advanced Traits” because there are multiple
functions available named <code>to_string</code>.</p>
<p>注意我们必须使用我们在“高级特质”一节中讨论过的完全限定语法（fully qualified syntax），因为有多个可用的名为 <code>to_string</code> 的函数。</p>
<p>Here, we’re using the <code>to_string</code> function defined in the <code>ToString</code> trait,
which the standard library has implemented for any type that implements
<code>Display</code>.</p>
<p>这里，我们使用的是 <code>ToString</code> 特质中定义的 <code>to_string</code> 函数，标准库为任何实现了 <code>Display</code> 的类型实现了该特质。</p>
<p>Recall from “Enum Values” in Chapter 6 that the
name of each enum variant that we define also becomes an initializer function.
We can use these initializer functions as function pointers that implement the
closure traits, which means we can specify the initializer functions as
arguments for methods that take closures, as seen in Listing 20-31.</p>
<p>回忆第 6 章“枚举值”一节，我们定义的每个枚举变体的名称也会成为一个初始化函数。我们可以将这些初始化函数用作实现了闭包特质的函数指针，这意味着我们可以将初始化函数指定为接受闭包的方法的参数，如代码清单 20-31 所示。</p>
<figure class="listing" id="listing-20-31">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-31">Listing 20-31</a>: Using an enum initializer with the <code>map</code> method to create a <code>Status</code> instance from numbers将枚举初始化函数与 <code>map</code> 方法结合使用以从数字创建 <code>Status</code> 实例</figcaption>
</figure>
<p>Here, we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
<p>这里，我们通过使用 <code>Status::Value</code> 的初始化函数，利用 <code>map</code> 调用范围内的每个 <code>u32</code> 值创建 <code>Status::Value</code> 实例。有些人更喜欢这种风格，有些人则更喜欢使用闭包。它们编译后的代码是相同的，因此使用你觉得更清晰的风格即可。</p>
<h3 id="returning-closures-返回闭包"><a class="header" href="#returning-closures-返回闭包">Returning Closures 返回闭包</a></h3>
<p>Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. However, you can’t usually do that with closures because they don’t
have a concrete type that is returnable; you’re not allowed to use the function
pointer <code>fn</code> as a return type if the closure captures any values from its
scope, for example.</p>
<p>闭包由特质表示，这意味着你不能直接返回闭包。在大多数你可能想要返回一个特质的情况下，你可以改为使用实现了该特质的具体类型作为函数的返回值。然而，对于闭包，你通常不能这样做，因为它们没有可返回的具体类型；例如，如果闭包从其作用域捕获了任何值，就不允许使用函数指针 <code>fn</code> 作为返回类型。</p>
<p>Instead, you will normally use the <code>impl Trait</code> syntax we learned about in
Chapter 10. You can return any function type, using <code>Fn</code>, <code>FnOnce</code> and <code>FnMut</code>.
For example, the code in Listing 20-32 will compile just fine.</p>
<p>相反，你通常会使用我们在第 10 章中学到的 <code>impl Trait</code> 语法。你可以返回任何函数类型，使用 <code>Fn</code>、<code>FnOnce</code> 和 <code>FnMut</code>。例如，代码清单 20-32 中的代码可以顺利编译。</p>
<figure class="listing" id="listing-20-32">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-20-32">Listing 20-32</a>: Returning a closure from a function using the <code>impl Trait</code> syntax 使用 <code>impl Trait</code> 语法从函数返回闭包</figcaption>
</figure>
<p>However, as we noted in “Closure Type Inference and
Annotation” in Chapter 13, each closure is also
its own distinct type. If you need to work with multiple functions that have the
same signature but different implementations, you will need to use a trait
object for them. Consider what happens if you write code like that shown in
Listing 20-33.</p>
<p>然而，正如我们在第 13 章“闭包类型推断和注解”一节中指出的，每个闭包也是其自身独特（distinct）的类型。如果你需要处理多个具有相同签名但不同实现的函数，你将需要对它们使用特质对象（trait object）。考虑如果你编写如代码清单 20-33 所示的代码会发生什么。</p>
<figure class="listing" id="listing-20-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre>
<figcaption><a href="#listing-20-33">Listing 20-33</a>: Creating a <code>Vec&lt;T&gt;</code> of closures defined by functions that return <code>impl Fn</code> types 创建一个 <code>Vec&lt;T&gt;</code>，其元素是由返回 <code>impl Fn</code> 类型的函数定义的闭包</figcaption>
</figure>
<p>Here we have two functions, <code>returns_closure</code> and <code>returns_initialized_closure</code>,
which both return <code>impl Fn(i32) -&gt; i32</code>. Notice that the closures that they
return are different, even though they implement the same type. If we try to
compile this, Rust lets us know that it won’t work:</p>
<p>这里我们有两个函数，<code>returns_closure</code> 和 <code>returns_initialized_closure</code>，它们都返回 <code>impl Fn(i32) -&gt; i32</code>。注意它们返回的闭包是不同的，尽管它们实现了相同的类型。如果我们尝试编译此代码，Rust 会告诉我们这行不通：</p>
<pre><code class="language-text">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --&gt; src/main.rs:2:44
   |
2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
9  | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:9:25&gt;)
              found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:13:46&gt;)
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>The error message tells us that whenever we return an <code>impl Trait</code>, Rust
creates a unique <em>opaque type</em>, a type where we cannot see into the details of
what Rust constructs for us, nor can we guess the type Rust will generate to
write ourselves. So even though these functions return closures that implement
the same trait, <code>Fn(i32) -&gt; i32</code>, the opaque types Rust generates for each are
distinct. (This is similar to how Rust produces different concrete types for
distinct async blocks even when they have the same output type, as we saw in
“Working with Any Number of Futures” in
Chapter 17.) We have seen a solution to this problem a few times now: we can
use a trait object, as in Listing 20-34.</p>
<p>错误信息告诉我们，每当我们<span class="highlight">[note]返回一个 <code>impl Trait</code> 时，Rust 会创建一个唯一的不透明类型（opaque type）</span>，一种我们无法看到 Rust 为我们构造的细节的类型，我们也无法猜测 Rust 将生成什么类型以便我们自己编写。因此，即使这些函数返回实现了相同特质 <code>Fn(i32) -&gt; i32</code> 的闭包，Rust 为每个生成的不透明类型也是不同的。（这类似于 Rust 如何为不同的异步块生成不同的具体类型，即使它们具有相同的输出类型，正如我们在第 17 章“处理任意数量的 Future”一节中所见。）我们现在已经多次看到这个问题的解决方案：我们可以使用特质对象，如代码清单 20-34 所示。</p>
<figure class="listing" id="listing-20-34">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<figcaption><a href="#listing-20-34">Listing 20-34</a>: Creating a <code>Vec&lt;T&gt;</code> of closures defined by functions that return <code>Box&lt;dyn Fn&gt;</code> so they have the same type 创建一个 <code>Vec&lt;T&gt;</code>，其元素是由返回 <code>Box&lt;dyn Fn&gt;</code> 的函数定义的闭包，以便它们具有相同的类型</figcaption>
</figure>
<p>This code will compile just fine. For more about trait objects, refer to the
section “Using Trait Objects That Allow for Values of Different
Types” in Chapter 18.</p>
<p>这段代码将顺利编译。有关特质对象的更多信息，请参阅第 18 章“使用允许不同类型值的特质对象”一节。</p>
<p>Next, let’s look at macros!</p>
<p>接下来，让我们看看宏（macros）！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-03-advanced-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-05-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-03-advanced-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-05-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
