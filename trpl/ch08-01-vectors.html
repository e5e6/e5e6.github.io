<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storing Lists of Values with Vectors 用向量存储值列表 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="storing-lists-of-values-with-vectors-用向量存储值列表"><a class="header" href="#storing-lists-of-values-with-vectors-用向量存储值列表">Storing Lists of Values with Vectors 用向量存储值列表</a></h2>
<p>The first collection type we’ll look at is <code>Vec&lt;T&gt;</code>, also known as a <em>vector</em>.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.</p>
<p>我们将探讨的第一种集合类型是 <code>Vec&lt;T&gt;</code>，也称为<em>向量</em>。向量允许在单一数据结构中存储多个值，这些值在内存中彼此相邻排列。向量只能存储相同类型的值，适用于处理项目列表的场景，例如文件中的文本行或购物车中的商品价格。</p>
<h3 id="creating-a-new-vector-创建新向量"><a class="header" href="#creating-a-new-vector-创建新向量">Creating a New Vector 创建新向量</a></h3>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown in
Listing 8-1.</p>
<p>如示例 8-1 所示，可通过<span class="highlight">[note]调用 <code>Vec::new</code> 函数创建新的空向量</span>。</p>
<figure class="listing" id="listing-8-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-1">Listing 8-1</a>: Creating a new, empty vector to hold values of type <code>i32</code> 创建一个新的空向量用于存储 <code>i32</code> 类型的值</figcaption>
</figure>
<p>Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type.
When we create a vector to hold a specific type, we can specify the type within
angle brackets. In Listing 8-1, we’ve told Rust that the <code>Vec&lt;T&gt;</code> in <code>v</code> will
hold elements of the <code>i32</code> type.</p>
<p>注意此处添加了类型注解。由于未向向量插入任何值，Rust 无法推断我们打算存储的元素类型。这一点很重要：向量通过泛型实现，我们将在第 10 章学习如何为自定义类型使用泛型。目前只需知道，标准库提供的 <code>Vec&lt;T&gt;</code> 类型可容纳任意类型。创建特定类型向量时，可在尖括号内指定类型。示例 8-1 中我们向 Rust 表明，变量 <code>v</code> 中的 <code>Vec&lt;T&gt;</code> 将存储 <code>i32</code> 类型元素。</p>
<p>More often, you’ll create a <code>Vec&lt;T&gt;</code> with initial values and Rust will infer
the type of value you want to store, so you rarely need to do this type
annotation. Rust conveniently provides the <code>vec!</code> macro, which will create a
new vector that holds the values you give it. Listing 8-2 creates a new
<code>Vec&lt;i32&gt;</code> that holds the values <code>1</code>, <code>2</code>, and <code>3</code>. The integer type is <code>i32</code>
because that’s the default integer type, as we discussed in the “Data
Types” section of Chapter 3.</p>
<p>更常见的情况是创建带初始值的 <code>Vec&lt;T&gt;</code>，此时 Rust 能自动推断存储类型，因此很少需要显式注解。<span class="highlight">[note]Rust 提供了便捷的 <code>vec!</code> 宏</span>，它能创建包含指定值的新向量。示例 8-2 创建了存储值 <code>1</code>、<code>2</code> 和 <code>3</code> 的 <code>Vec&lt;i32&gt;</code>，整数类型为 <code>i32</code>（这是默认整型，如第 3 章“数据类型“部分所述）。</p>
<figure class="listing" id="listing-8-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-2">Listing 8-2</a>: Creating a new vector containing values 创建包含值的新向量</figcaption>
</figure>
<p>Because we’ve given initial <code>i32</code> values, Rust can infer that the type of <code>v</code>
is <code>Vec&lt;i32&gt;</code>, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.</p>
<p>由于提供了初始 <code>i32</code> 值，Rust 可推断 <code>v</code> 的类型为 <code>Vec&lt;i32&gt;</code>，无需类型注解。接下来我们将学习如何修改向量。</p>
<h3 id="updating-a-vector-更新向量"><a class="header" href="#updating-a-vector-更新向量">Updating a Vector 更新向量</a></h3>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method,
as shown in Listing 8-3.</p>
<p>如示例 8-3 所示，创建向量后可用 <code>push</code> 方法添加元素。</p>
<figure class="listing" id="listing-8-3">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-3">Listing 8-3</a>: Using the <code>push</code> method to add values to a vector 使用 <code>push</code> 方法向向量添加值</figcaption>
</figure>
<p>As with any variable, if we want to be able to change its value, we need to
make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3. The numbers
we place inside are all of type <code>i32</code>, and Rust infers this from the data, so
we don’t need the <code>Vec&lt;i32&gt;</code> annotation.</p>
<p>如第 3 章所述，若需修改变量值，必须使用 <code>mut</code> 关键字使其可变。放入向量的数字均为 <code>i32</code> 类型，Rust 会根据数据自动推断类型，因此不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h3 id="reading-elements-of-vectors-读取向量元素"><a class="header" href="#reading-elements-of-vectors-读取向量元素">Reading Elements of Vectors 读取向量元素</a></h3>
<p>There are two ways to reference a value stored in a vector: via indexing or by
using the <code>get</code> method. In the following examples, we’ve annotated the types of
the values that are returned from these functions for extra clarity.</p>
<p><span class="highlight">[note]有两种方式引用向量中存储的值：索引访问或 <code>get</code> 方法。</span>以下示例中，我们特别标注了这些函数返回值的类型以增强可读性。</p>
<p>Listing 8-4 shows both methods of accessing a value in a vector, with indexing
syntax and the <code>get</code> method.</p>
<p>示例 8-4 展示了通过索引语法和 <code>get</code> 方法访问向量值的两种方式。</p>
<figure class="listing" id="listing-8-4">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-4">Listing 8-4</a>: Using indexing syntax and using the <code>get</code> method to access an item in a vector 使用索引语法和 <code>get</code> 方法访问向量中的元素</figcaption>
</figure>
<p>Note a few details here. We use the index value of <code>2</code> to get the third element
because vectors are indexed by number, starting at zero. Using <code>&amp;</code> and <code>[]</code>
gives us a reference to the element at the index value. When we use the <code>get</code>
method with the index passed as an argument, we get an <code>Option&lt;&amp;T&gt;</code> that we can
use with <code>match</code>.</p>
<p>注意几个细节：向量使用数字索引且从零开始，因此索引值 <code>2</code> 表示获取第三个元素。使用 <code>&amp;</code> 和 <code>[]</code> 会返回索引位置元素的引用。当使用 <code>get</code> 方法并传入索引参数时，会返回一个可与 <code>match</code> 搭配使用的 <code>Option&lt;&amp;T&gt;</code> 类型。</p>
<p>Rust provides these two ways to reference an element so you can choose how the
program behaves when you try to use an index value outside the range of
existing elements. As an example, let’s see what happens when we have a vector
of five elements and then we try to access an element at index 100 with each
technique, as shown in Listing 8-5.</p>
<p>Rust 提供这两种引用元素的方式，是为了让程序在尝试访问超出范围的索引时能有不同的行为。例如示例 8-5 展示了当向量只有五个元素时，尝试访问索引 100 的两种情况。</p>
<figure class="listing" id="listing-8-5">
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-5">Listing 8-5</a>: Attempting to access the element at index 100 in a vector containing five elements 尝试访问包含五个元素的向量中索引为 100 的元素</figcaption>
</figure>
<p>When we run this code, the first <code>[]</code> method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there’s an attempt to access an element past the
end of the vector.</p>
<p>运行此代码时，第一种 <code>[]</code> 方法将导致程序崩溃（panic），因为它引用了不存在的元素。此方法适用于希望在访问越界元素时程序立即终止的场景。</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns
<code>None</code> without panicking. You would use this method if accessing an element
beyond the range of the vector may happen occasionally under normal
circumstances. Your code will then have logic to handle having either
<code>Some(&amp;element)</code> or <code>None</code>, as discussed in Chapter 6. For example, the index
could be coming from a person entering a number. If they accidentally enter a
number that’s too large and the program gets a <code>None</code> value, you could tell the
user how many items are in the current vector and give them another chance to
enter a valid value. That would be more user-friendly than crashing the program
due to a typo!</p>
<p>当 <code>get</code> 方法收到超范围索引时，它会返回 <code>None</code> 而不会崩溃。若在正常情况下偶尔可能发生越界访问，应使用此方法。此时代码可逻辑处理 <code>Some(&amp;element)</code> 或 <code>None</code>（如第 6 章所述）。例如，索引可能来自用户输入的数字。若用户意外输入过大数字导致程序获得 <code>None</code> 值，可以提示当前向量的项目数量，并让用户重新输入有效值。这比因输入错误导致程序崩溃更友好！</p>
<p>When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-6, where we hold an immutable reference
to the first element in a vector and try to add an element to the end. This
program won’t work if we also try to refer to that element later in the
function.</p>
<p>当程序持有有效引用时，借用检查器会强制执行所有权和借用规则（见第 4 章），确保该引用及对向量内容的其他引用保持有效。回顾“同一作用域中不能同时存在可变和不可变引用“的规则，该规则在示例 8-6 中适用：<span class="highlight">[note]当我们持有向量首元素的不可变引用时，尝试向尾部添加元素会导致程序无法编译。</span></p>
<figure class="listing" id="listing-8-6">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("The first element is: {first}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-8-6">Listing 8-6</a>: Attempting to add an element to a vector while holding a reference to an item 在持有元素引用的同时尝试向向量添加元素</figcaption>
</figure>
<p>Compiling this code will result in this error:</p>
<p>编译此代码将产生错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>The code in Listing 8-6 might look like it should work: why should a reference
to the first element care about changes at the end of the vector? This error is
due to the way vectors work: because vectors put the values next to each other
in memory, adding a new element onto the end of the vector might require
allocating new memory and copying the old elements to the new space, if there
isn’t enough room to put all the elements next to each other where the vector
is currently stored. In that case, the reference to the first element would be
pointing to deallocated memory. The borrowing rules prevent programs from
ending up in that situation.</p>
<p>示例 8-6 的代码看似应能运行：为何首元素的引用要关注向量尾部的修改？此错误源于向量的工作原理：向量将值连续存储在内存中，若当前空间不足，向尾部添加新元素可能需要分配新内存并将旧元素复制到新空间。这种情况下，指向首元素的引用将指向已释放内存。借用规则正是为了防止程序陷入此类情况。</p>
<section class="note" aria-role="note">
<p>Note: For more on the implementation details of the <code>Vec&lt;T&gt;</code> type, see “The
Rustonomicon”.</p>
<p>注意：有关 <code>Vec&lt;T&gt;</code> 类型的实现细节，请参阅《Rust 秘典（The Rustonomicon）》。</p>
</section>
<h3 id="iterating-over-the-values-in-a-vector-遍历向量中的值"><a class="header" href="#iterating-over-the-values-in-a-vector-遍历向量中的值">Iterating Over the Values in a Vector 遍历向量中的值</a></h3>
<p>To access each element in a vector in turn, we would iterate through all of the
elements rather than use indices to access one at a time. Listing 8-7 shows how
to use a <code>for</code> loop to get immutable references to each element in a vector of
<code>i32</code> values and print them.</p>
<p>要依次访问向量中的每个元素，应遍历所有元素而非使用索引逐个访问。<span class="highlight">[note]示例 8-7 展示了如何用 <code>for</code> 循环获取 <code>i32</code> 向量中每个元素的不可变引用并打印。</span></p>
<figure class="listing" id="listing-8-7">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-7">Listing 8-7</a>: Printing each element in a vector by iterating over the elements using a <code>for</code> loop 通过 <code>for</code> 循环遍历元素来打印向量中的每个值</figcaption>
</figure>
<p>We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The <code>for</code> loop in Listing 8-8
will add <code>50</code> to each element.</p>
<p><span class="highlight">[note]对于可变向量，我们也可以遍历可变引用来修改所有元素</span>。示例 8-8 中的 <code>for</code> 循环将为每个元素加 50。</p>
<figure class="listing" id="listing-8-8">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-8">Listing 8-8</a>: Iterating over mutable references to elements in a vector 遍历向量元素的可变引用</figcaption>
</figure>
<p>To change the value that the mutable reference refers to, we have to use the
<code>*</code> dereference operator to get to the value in <code>i</code> before we can use the <code>+=</code>
operator. We’ll talk more about the dereference operator in the “Following the
Reference to the Value” section of Chapter 15.</p>
<p>要修改可变引用指向的值，需先用 <code>*</code> 解引用运算符获取 <code>i</code> 中的值，才能使用 <code>+=</code> 运算符。我们将在第 15 章的“跟随指针到值“章节深入讨论解引用运算符。</p>
<p>Iterating over a vector, whether immutably or mutably, is safe because of the
borrow checker’s rules. If we attempted to insert or remove items in the <code>for</code>
loop bodies in Listing 8-7 and Listing 8-8, we would get a compiler error
similar to the one we got with the code in Listing 8-6. The reference to the
vector that the <code>for</code> loop holds prevents simultaneous modification of the
whole vector.</p>
<p>得益于借用检查器的规则，无论以不可变还是可变方式遍历向量都是安全的。<span class="highlight">[note]若在示例 8-7 和 8-8 的循环体内尝试插入或删除项目，会得到与示例 8-6 类似的编译错误。因为 <code>for</code> 循环持有的向量引用会阻止同时修改整个向量。</span></p>
<h3 id="using-an-enum-to-store-multiple-types-使用枚举存储多种类型"><a class="header" href="#using-an-enum-to-store-multiple-types-使用枚举存储多种类型">Using an Enum to Store Multiple Types 使用枚举存储多种类型</a></h3>
<p>Vectors can only store values that are of the same type. This can be
inconvenient; there are definitely use cases for needing to store a list of
items of different types. Fortunately, the variants of an enum are defined
under the same enum type, so when we need one type to represent elements of
different types, we can define and use an enum!</p>
<p>向量只能存储相同类型的值，这有时会带来不便——实际应用中常需存储不同类型元素的列表。幸运的是，枚举的所有变体都归于同一枚举类型下，因此当需要表示不同类型元素时，可以定义并使用枚举！</p>
<p>For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and all the enum variants will be considered the same type: that
of the enum. Then we can create a vector to hold that enum and so, ultimately,
hold different types. We’ve demonstrated this in Listing 8-9.</p>
<p>例如，假设需要从电子表格行中获取值，其中某些列含整数、浮点数或字符串。可以定义枚举，其变体将持有不同类型的值，且所有枚举变体被视为同类型（即枚举自身类型）。随后创建存储此枚举的向量，最终实现存储不同类型的目标。示例 8-9 演示了此方法。</p>
<figure class="listing" id="listing-8-9">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-9">Listing 8-9</a>: Defining an <code>enum</code> to store values of different types in one vector 定义枚举以在单个向量中存储不同类型的值</figcaption>
</figure>
<p>Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. We
must also be explicit about what types are allowed in this vector. If Rust
allowed a vector to hold any type, there would be a chance that one or more of
the types would cause errors with the operations performed on the elements of
the vector. Using an enum plus a <code>match</code> expression means that Rust will ensure
at compile time that every possible case is handled, as discussed in Chapter 6.</p>
<p>Rust 需在编译时知晓向量中的类型，以精确计算堆上存储每个元素所需内存。同时必须明确允许哪些类型。若允许向量存储任意类型，某些类型可能在元素操作时引发错误。使用枚举配合 <code>match</code> 表达式可确保 Rust 在编译时处理所有可能情况（如第 6 章所述）。</p>
<p>If you don’t know the exhaustive set of types a program will get at runtime to
store in a vector, the enum technique won’t work. Instead, you can use a trait
object, which we’ll cover in Chapter 18.</p>
<p>若无法在编译时穷尽程序运行时会存储在向量中的所有类型，则枚举技术不适用。此时可使用 trait 对象（第 18 章介绍）。</p>
<p>Now that we’ve discussed some of the most common ways to use vectors, be sure
to review the API documentation for all of the many
useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For example, in
addition to <code>push</code>, a <code>pop</code> method removes and returns the last element.</p>
<p>现在我们已经讨论了向量的常见用法，请务必查阅标准库中 <code>Vec&lt;T&gt;</code> 的所有实用方法。例如，除 <code>push</code> 外，<code>pop</code> 方法会移除并返回最后一个元素。</p>
<h3 id="dropping-a-vector-drops-its-elements-向量离开作用域时其元素会被丢弃"><a class="header" href="#dropping-a-vector-drops-its-elements-向量离开作用域时其元素会被丢弃">Dropping a Vector Drops Its Elements 向量离开作用域时其元素会被丢弃</a></h3>
<p>Like any other <code>struct</code>, a vector is freed when it goes out of scope, as
annotated in Listing 8-10.</p>
<p>如示例 8-10 所示，向量与任何其他 <code>struct</code> 一样，离开作用域时会被释放。</p>
<figure class="listing" id="listing-8-10">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-8-10">Listing 8-10</a>: Showing where the vector and its elements are dropped 展示向量及其元素被丢弃的位置</figcaption>
</figure>
<p>When the vector gets dropped, all of its contents are also dropped, meaning the
integers it holds will be cleaned up. The borrow checker ensures that any
references to contents of a vector are only used while the vector itself is
valid.</p>
<p>当向量被丢弃时，其所有内容也会被丢弃，意味着它存储的整数会被清理。借用检查器确保仅在向量有效期间使用对其内容的引用。</p>
<p>Let’s move on to the next collection type: <code>String</code>!</p>
<p>接下来让我们学习下一个集合类型：<code>String</code>！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-00-common-collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-02-strings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-00-common-collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-02-strings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
