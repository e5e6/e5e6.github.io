<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Controlling How Tests Are Run 控制测试的运行方式 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="controlling-how-tests-are-run-控制测试的运行方式"><a class="header" href="#controlling-how-tests-are-run-控制测试的运行方式">Controlling How Tests Are Run 控制测试的运行方式</a></h2>
<p>Just as <code>cargo run</code> compiles your code and then runs the resultant binary,
<code>cargo test</code> compiles your code in test mode and runs the resultant test
binary. The default behavior of the binary produced by <code>cargo test</code> is to run
all the tests in parallel and capture output generated during test runs,
preventing the output from being displayed and making it easier to read the
output related to the test results. You can, however, specify command line
options to change this default behavior.</p>
<p>正如 <code>cargo run</code> 会编译代码并运行生成的二进制文件，<code>cargo test</code> 会在测试模式下编译代码并运行生成的测试二进制文件。<code>cargo test</code> 生成的二进制文件<span class="highlight">[note]默认行为是并行运行所有测试</span>，并捕获测试运行期间的输出，防止输出显示在终端上，从而更易于阅读与测试结果相关的输出。但您也可以通过命令行选项更改此默认行为。</p>
<p>Some command line options go to <code>cargo test</code>, and some go to the resultant test
binary. To separate these two types of arguments, you list the arguments that
go to <code>cargo test</code> followed by the separator <code>--</code> and then the ones that go to
the test binary. Running <code>cargo test --help</code> displays the options you can use
with <code>cargo test</code>, and running <code>cargo test -- --help</code> displays the options you
can use after the separator. Those options are also documented in the “Tests”
section of the the rustc book.</p>
<p><span class="highlight">[note]部分命令行选项传递给 <code>cargo test</code>，部分则传递给生成的测试二进制文件。为区分这两类参数，需先列出传递给 <code>cargo test</code> 的参数，后跟分隔符 <code>--</code>，再列出传递给测试二进制文件的参数。</span>运行 <code>cargo test --help</code> 可查看 <code>cargo test</code> 支持的选项，运行 <code>cargo test -- --help</code> 则显示分隔符后可用的选项。这些选项也记录在 rustc 文档的 “Tests” 部分。</p>
<h3 id="running-tests-in-parallel-or-consecutively-并行或串行运行测试"><a class="header" href="#running-tests-in-parallel-or-consecutively-并行或串行运行测试">Running Tests in Parallel or Consecutively 并行或串行运行测试</a></h3>
<p>When you run multiple tests, by default they run in parallel using threads,
meaning they finish running faster and you get feedback quicker. Because the
tests are running at the same time, you must make sure your tests don’t depend
on each other or on any shared state, including a shared environment, such as
the current working directory or environment variables.</p>
<p>当运行多个测试时，默认会使用线程并行执行，这意味着它们能更快完成并提供更快的反馈。由于测试同时运行，必须确保测试不相互依赖，也不依赖任何共享状态（包括共享环境，如当前工作目录或环境变量）。</p>
<p>For example, say each of your tests runs some code that creates a file on disk
named <em>test-output.txt</em> and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file in the time between another test writing and
reading the file. The second test will then fail, not because the code is
incorrect but because the tests have interfered with each other while running
in parallel. One solution is to make sure each test writes to a different file;
another solution is to run the tests one at a time.</p>
<p>例如，假设每个测试都执行创建磁盘文件 <em>test-output.txt</em> 并写入数据的代码，随后读取该文件并断言其包含特定值（各测试的值不同）。由于测试并行运行，一个测试可能在另一个测试写入后读取前覆盖该文件，导致后者失败——并非代码有误，而是并行运行时测试相互干扰。解决方案之一是确保每个测试写入不同文件；另一种方案是每次只运行一个测试。</p>
<p>If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the <code>--test-threads</code> flag
and the number of threads you want to use to the test binary. Take a look at
the following example:</p>
<p>若不想并行运行测试，或需更精细控制线程数，可<span class="highlight">[note]向测试二进制文件传递 <code>--test-threads</code> 标志及所需线程数</span>。示例如下：</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to <code>1</code>, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.</p>
<p>将测试线程数设为 <code>1</code> 表示禁用并行。单线程运行测试虽比并行耗时更长，但能避免共享状态时的相互干扰。</p>
<h3 id="showing-function-output-显示函数输出"><a class="header" href="#showing-function-output-显示函数输出">Showing Function Output 显示函数输出</a></h3>
<p>By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call <code>println!</code> in a test and the test
passes, we won’t see the <code>println!</code> output in the terminal; we’ll see only the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.</p>
<p>默认情况下，若测试通过，Rust 测试库会捕获所有标准输出。例如，测试中调用 <code>println!</code> 且测试通过时，终端不会显示 <code>println!</code> 的输出，仅显示测试通过的提示行。若测试失败，则会在失败信息中显示标准输出的内容。</p>
<p>As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.</p>
<p>例如，示例 11-10 包含一个输出参数值并返回 10 的简单函数，以及一个通过测试和一个失败测试。</p>
<figure class="listing" id="listing-11-10">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
<figcaption><a href="#listing-11-10">Listing 11-10</a>: Tests for a function that calls <code>println!</code> 调用 <code>println!</code> 的函数的测试</figcaption>
</figure>
<p>When we run these tests with <code>cargo test</code>, we’ll see the following output:</p>
<p>使用 <code>cargo test</code> 运行这些测试时，输出如下：</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is
printed when the test that passes runs. That output has been captured. The
output from the test that failed, <code>I got the value 8</code>, appears in the section
of the test summary output, which also shows the cause of the test failure.</p>
<p>注意输出中未出现 <code>I got the value 4</code>（通过测试时的打印内容），该输出已被捕获。失败测试的输出 <code>I got the value 8</code> 出现在测试摘要中，并显示了失败原因。</p>
<p>If we want to see printed values for passing tests as well, we can tell Rust to
also show the output of successful tests with <code>--show-output</code>:</p>
<p>若需查看通过测试的打印值，可<span class="highlight">[note]通过 <code>--show-output</code> 标志让 Rust 显示成功测试的输出</span>：</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>When we run the tests in Listing 11-10 again with the <code>--show-output</code> flag, we
see the following output:</p>
<p>使用 <code>--show-output</code> 标志再次运行示例 11-10 的测试，输出如下：</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="running-a-subset-of-tests-by-name-按名称运行测试子集"><a class="header" href="#running-a-subset-of-tests-by-name-按名称运行测试子集">Running a Subset of Tests by Name 按名称运行测试子集</a></h3>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>cargo test</code> the name
or names of the test(s) you want to run as an argument.</p>
<p>完整测试套件可能耗时较长。若仅需测试特定代码，可向 <code>cargo test</code> 传递要运行的测试名称作为参数。</p>
<p>To demonstrate how to run a subset of tests, we’ll first create three tests for
our <code>add_two</code> function, as shown in Listing 11-11, and choose which ones to run.</p>
<p>为演示如何运行测试子集，我们先为 <code>add_two</code> 函数创建三个测试（如示例 11-11 所示），并选择运行部分测试。</p>
<figure class="listing" id="listing-11-11">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
<figcaption><a href="#listing-11-11">Listing 11-11</a>: Three tests with three different names 三个不同名称的测试</figcaption>
</figure>
<p>If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:</p>
<p>不传递参数运行测试时，所有测试会并行执行：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="running-single-tests-运行单个测试"><a class="header" href="#running-single-tests-运行单个测试">Running Single Tests 运行单个测试</a></h4>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<p>向 <code>cargo test</code> 传递单个测试函数名可仅运行该测试：</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Only the test with the name <code>one_hundred</code> ran; the other two tests didn’t match
that name. The test output lets us know we had more tests that didn’t run by
displaying <code>2 filtered out</code> at the end.</p>
<p>仅名为 <code>one_hundred</code> 的测试运行，其他测试因名称不匹配而被跳过。输出末尾的 <code>2 filtered out</code> 提示有两个测试未执行。</p>
<p>We can’t specify the names of multiple tests in this way; only the first value
given to <code>cargo test</code> will be used. But there is a way to run multiple tests.</p>
<p>此方式不能指定多个测试名，只有 <code>cargo test</code> 接收的第一个参数有效。但仍有方法运行多个测试。</p>
<h4 id="filtering-to-run-multiple-tests-过滤运行多个测试"><a class="header" href="#filtering-to-run-multiple-tests-过滤运行多个测试">Filtering to Run Multiple Tests 过滤运行多个测试</a></h4>
<p>We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain <code>add</code>, we can
run those two by running <code>cargo test add</code>:</p>
<p>指定测试名的部分匹配值，所有名称包含该值的测试都会运行。例如，有两个测试名含 <code>add</code>，可通过 <code>cargo test add</code> 运行它们：</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>This command ran all tests with <code>add</code> in the name and filtered out the test
named <code>one_hundred</code>. Also note that the module in which a test appears becomes
part of the test’s name, so we can run all the tests in a module by filtering
on the module’s name.</p>
<p>此命令运行了所有名称含 <code>add</code> 的测试，并过滤了名为 <code>one_hundred</code> 的测试。注意：<span class="highlight">[note]测试所在模块名会成为测试全名的一部分，因此可通过模块名过滤运行该模块所有测试。</span></p>
<h3 id="ignoring-some-tests-unless-specifically-requested-忽略特定测试除非显式要求"><a class="header" href="#ignoring-some-tests-unless-specifically-requested-忽略特定测试除非显式要求">Ignoring Some Tests Unless Specifically Requested 忽略特定测试（除非显式要求）</a></h3>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>cargo test</code>. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown
here:</p>
<p>某些测试执行非常耗时，可能需要在大多数 <code>cargo test</code> 运行中排除。无需列出所有要运行的测试，可<span class="highlight">[note]使用 <code>ignore</code> 属性标记耗时测试以排除它们</span>，如下所示：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>After <code>#[test]</code>, we add the <code>#[ignore]</code> line to the test we want to exclude.
Now when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<p>在 <code>#[test]</code> 后为需排除的测试添加 <code>#[ignore]</code> 行。现在运行测试时，<code>it_works</code> 执行而 <code>expensive_test</code> 被忽略：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The <code>expensive_test</code> function is listed as <code>ignored</code>. If we want to run only
the ignored tests, we can use <code>cargo test -- --ignored</code>:</p>
<p><code>expensive_test</code> 被标记为 <code>ignored</code>。若需<span class="highlight">[note]仅运行被忽略的测试，可使用 <code>cargo test -- --ignored</code></span>：</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results
will be returned quickly. When you’re at a point where it makes sense to check
the results of the <code>ignored</code> tests and you have time to wait for the results,
you can run <code>cargo test -- --ignored</code> instead. If you want to run all tests
whether they’re ignored or not, you can run <code>cargo test -- --include-ignored</code>.</p>
<p>通过控制测试执行范围，可确保 <code>cargo test</code> 快速返回结果。当需要检查被忽略测试且有时间等待结果时，可运行 <code>cargo test -- --ignored</code>。若要<span class="highlight">[note]运行所有测试（无论是否忽略），可执行 <code>cargo test -- --include-ignored</code>。</span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-01-writing-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-03-test-organization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-01-writing-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-03-test-organization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
