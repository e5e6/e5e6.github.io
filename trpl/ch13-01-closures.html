<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures: Anonymous Functions that Capture Their Environment 闭包：可捕获环境的匿名函数 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="closures-anonymous-functions-that-capture-their-environment-闭包可捕获环境的匿名函数"><a class="header" href="#closures-anonymous-functions-that-capture-their-environment-闭包可捕获环境的匿名函数">Closures: Anonymous Functions That Capture Their Environment 闭包：可捕获环境的匿名函数</a></h2>
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure elsewhere to evaluate it in a different context. Unlike
functions, closures can capture values from the scope in which they’re defined.
We’ll demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<p>Rust 的闭包是可存储在变量中或作为参数传递给其他函数的匿名函数。你可以在一处创建闭包，然后在另一处调用闭包以在不同上下文中求值。与函数不同，闭包能捕获其定义作用域中的值。我们将展示这些闭包特性如何实现代码复用和行为定制。</p>
<h3 id="capturing-the-environment-with-closures-使用闭包捕获环境"><a class="header" href="#capturing-the-environment-with-closures-使用闭包捕获环境">Capturing the Environment with Closures 使用闭包捕获环境</a></h3>
<p>We’ll first examine how we can use closures to capture values from the
environment they’re defined in for later use. Here’s the scenario: every so
often, our T-shirt company gives away an exclusive, limited-edition shirt to
someone on our mailing list as a promotion. People on the mailing list can
optionally add their favorite color to their profile. If the person chosen for
a free shirt has their favorite color set, they get that color shirt. If the
person hasn’t specified a favorite color, they get whatever color the company
currently has the most of.</p>
<p>首先我们探究如何用闭包捕获其定义环境中的值以供后续使用。假设场景：我们的 T 恤公司定期向邮件列表用户赠送独家限量版 T 恤作为促销。邮件列表用户可选择在个人资料中添加喜爱的颜色。若中奖用户设置了喜爱颜色，将获得该颜色的 T 恤；若未指定，则获得公司当前库存最多的颜色。</p>
<p>There are many ways to implement this. For this example, we’re going to use an
enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the
number of colors available for simplicity). We represent the company’s
inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that
contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.
The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt
color preference of the free-shirt winner, and returns the shirt color the
person will get. This setup is shown in Listing 13-1.</p>
<p>实现方式多种多样。本例中，我们将使用名为 <code>ShirtColor</code> 的枚举，包含 <code>Red</code> 和 <code>Blue</code> 变体（为简化限制可选颜色）。用 <code>Inventory</code> 结构体表示公司库存，其 <code>shirts</code> 字段包含表示当前库存颜色的 <code>Vec&lt;ShirtColor&gt;</code>。<code>Inventory</code> 上定义的 <code>giveaway</code> 方法获取中奖者的可选颜色偏好，并返回该用户将获得的颜色。如示例 13-1 所示。</p>
<figure class="listing" id="listing-13-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
<figcaption><a href="#listing-13-1">Listing 13-1</a>: Shirt company giveaway situation T恤公司赠送场景</figcaption>
</figure>
<p>The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt remaining
to distribute for this limited-edition promotion. We call the <code>giveaway</code> method
for a user with a preference for a red shirt and a user without any preference.</p>
<p><code>main</code> 中定义的 <code>store</code> 有两件蓝 T 恤和一件红 T 恤可用于此次限量促销。我们为有红 T 恤偏好和无偏好的用户调用 <code>giveaway</code> 方法。</p>
<p>Again, this code could be implemented in many ways, and here, to focus on
closures, we’ve stuck to concepts you’ve already learned, except for the body of
the <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the
user preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the
<code>unwrap_or_else</code> method on <code>user_preference</code>. The  is defined by the standard library.
It takes one argument: a closure without any arguments that returns a value <code>T</code>
(the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case
<code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code>
returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code>
variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by
the closure.</p>
<p>重申：此代码有多种实现方式。此处为聚焦闭包，除 <code>giveaway</code> 方法体内使用了闭包外，我们仅使用已学概念。在 <code>giveaway</code> 方法中，我们获取 <code>Option&lt;ShirtColor&gt;</code> 类型的用户偏好，并在 <code>user_preference</code> 上调用 <code>unwrap_or_else</code> 方法。此方法由标准库定义，接收一个参数：无参数且返回值 <code>T</code> 的闭包（与 <code>Option&lt;T&gt;</code> 中 <code>Some</code> 变体存储的类型相同，此处为 <code>ShirtColor</code>）。若 <code>Option&lt;T&gt;</code> 为 <code>Some</code> 变体，<code>unwrap_or_else</code> 返回其内部值；若为 <code>None</code> 变体，则调用闭包并返回其结果。</p>
<p>We specify the closure expression <code>|| self.most_stocked()</code> as the argument to
<code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the
closure had parameters, they would appear between the two vertical pipes). The
body of the closure calls <code>self.most_stocked()</code>. We’re defining the closure
here, and the implementation of <code>unwrap_or_else</code> will evaluate the closure
later if the result is needed.</p>
<p>我们指定闭包表达式 <code>|| self.most_stocked()</code> 作为 <code>unwrap_or_else</code> 的参数。这是一个无参闭包（若有参数，将出现在两个竖线之间）。闭包体调用 <code>self.most_stocked()</code>。我们在此定义闭包，而 <code>unwrap_or_else</code> 的实现会在需要结果时求值该闭包。</p>
<p>Running this code prints the following:</p>
<p>运行此代码输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>One interesting aspect here is that we’ve passed a closure that calls
<code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library
didn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we
defined, or the logic we want to use in this scenario. The closure captures an
immutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the
code we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand,
are not able to capture their environment in this way.</p>
<p>此处值得注意的是：我们传递了调用当前 <code>Inventory</code> 实例上 <code>self.most_stocked()</code> 的闭包。标准库无需知晓我们定义的 <code>Inventory</code> 或 <code>ShirtColor</code> 类型，也无需知晓此场景的业务逻辑。闭包捕获了 <code>self</code>（即 <code>Inventory</code> 实例）的不可变引用，并将其与我们指定的代码一同传递给 <code>unwrap_or_else</code> 方法。而普通函数无法以这种方式捕获环境。</p>
<h3 id="closure-type-inference-and-annotation-闭包类型推断与注解"><a class="header" href="#closure-type-inference-and-annotation-闭包类型推断与注解">Closure Type Inference and Annotation 闭包类型推断与注解</a></h3>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>函数与闭包还有更多差异。闭包通常不像 <code>fn</code> 函数那样要求标注参数或返回值类型。函数需要类型标注是因为类型是暴露给用户的显式接口的一部分，严格定义此接口对于确保函数使用的值类型和返回类型达成共识至关重要。闭包则不会暴露在此类接口中：它们存储在变量中，使用时无需命名或暴露给库用户。</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>闭包通常简短且仅适用于狭窄的上下文。在此有限上下文中，编译器可推断参数和返回类型，类似于推断大多数变量类型的方式（极少数情况也需要闭包类型注解）。</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 13-2. In this example, we’re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument, as we did in Listing 13-1.</p>
<p>与变量类似，我们<span class="highlight">[note]可为闭包添加类型注解以提升明确性</span>，代价是比严格必要的更冗长。注解闭包类型如示例 13-2 所示。此例中，我们定义闭包并将其存储在变量中，而非如示例 13-1 在传参处定义。</p>
<figure class="listing" id="listing-13-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-13-2">Listing 13-2</a>: Adding optional type annotations of the parameter and return value types in the closure 在闭包中添加可选的参数和返回值类型注解</figcaption>
</figure>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here, we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<p>添加类型注解后，闭包语法更接近函数语法。下面对比了参数加 1 的函数和相同行为的闭包（添加空格对齐相关部分）。这展示了闭包语法与函数语法的相似性（除管道符和可选语法量外）：</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>The first line shows a function definition and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let v = Vec::new();</code> needing either type annotations or values of
some type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>
<p>第一行是函数定义，第二行是完整注解的闭包定义。第三行移除闭包定义的类型注解。第四行移除大括号（因闭包体仅有一个表达式而可选）。这些都是调用时行为相同的有效定义。<code>add_one_v3</code> 和 <code>add_one_v4</code> 行需在编译时求值闭包，因为类型将通过使用场景推断（类似于 <code>let v = Vec::new();</code> 需要类型注解或向 <code>Vec</code> 插入值供 Rust 推断类型）。</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 13-3 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with <code>String</code> the first time. If we then try to call
<code>example_closure</code> with an integer, we’ll get an error.</p>
<p>对于闭包定义，编译器会为其每个参数和返回值推断一个具体类型。例如示例 13-3 定义了一个仅返回接收参数的短闭包（此闭包除演示外并不实用）。注意定义中未添加任何类型注解。因无类型注解，我们可用任意类型调用闭包（此处首次用 <code>String</code>）。若尝试用整数再次调用 <code>example_closure</code>，将报错。</p>
<figure class="listing" id="listing-13-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-13-3">Listing 13-3</a>: Attempting to call a closure whose types are inferred with two different types 尝试用两种不同类型调用类型推断的闭包</figcaption>
</figure>
<p>The compiler gives us this error:</p>
<p>编译器报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
<p>首次用 <code>String</code> 值调用 <code>example_closure</code> 时，编译器推断 <code>x</code> 和闭包返回类型为 <code>String</code>。这些类型随后被锁定在 <code>example_closure</code> 中，导致下次用不同类型调用同一闭包时产生类型错误。</p>
<h3 id="capturing-references-or-moving-ownership-捕获引用或转移所有权"><a class="header" href="#capturing-references-or-moving-ownership-捕获引用或转移所有权">Capturing References or Moving Ownership 捕获引用或转移所有权</a></h3>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: borrowing
immutably, borrowing mutably, and taking ownership. The closure will decide
which of these to use based on what the body of the function does with the
captured values.</p>
<p>闭包可通过三种方式从环境中捕获值，直接对应函数获取参数的三种方式：不可变借用、可变借用和获取所有权。闭包将根据函数体如何处理捕获值来决定使用哪种方式。</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to
the vector named <code>list</code> because it only needs an immutable reference to print
the value.</p>
<p>示例 13-4 中，定义了一个捕获向量 <code>list</code> 不可变引用的闭包，因其仅需不可变引用打印值。</p>
<figure class="listing" id="listing-13-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-4">Listing 13-4</a>: Defining and calling a closure that captures an immutable reference 定义并调用捕获不可变引用的闭包</figcaption>
</figure>
<p>This example also illustrates that a variable can bind to a closure definition,
and we can later call the closure by using the variable name and parentheses as
if the variable name were a function name.</p>
<p>此例还说明：变量可绑定到闭包定义，之后可通过变量名加括号调用闭包（如同函数名）。</p>
<p>Because we can have multiple immutable references to <code>list</code> at the same time,
<code>list</code> is still accessible from the code before the closure definition, after
the closure definition but before the closure is called, and after the closure
is called. This code compiles, runs, and prints:</p>
<p>因可同时存在多个 <code>list</code> 的不可变引用，在闭包定义前、定义后但调用前、调用后均可访问 <code>list</code>。此代码编译运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to
the <code>list</code> vector. The closure now captures a mutable reference.</p>
<p>接下来在示例 13-5 中，修改闭包体使其向 <code>list</code> 向量添加元素。此时闭包捕获可变引用。</p>
<figure class="listing" id="listing-13-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-5">Listing 13-5</a>: Defining and calling a closure that captures a mutable reference 定义并调用捕获可变引用的闭包</figcaption>
</figure>
<p>This code compiles, runs, and prints:</p>
<p>此代码编译运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Note that there’s no longer a <code>println!</code> between the definition and the call of
the <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a
mutable reference to <code>list</code>. We don’t use the closure again after the closure
is called, so the mutable borrow ends. Between the closure definition and the
closure call, an immutable borrow to print isn’t allowed because no other
borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code>
there to see what error message you get!</p>
<p>注意定义和调用 <code>borrows_mutably</code> 闭包之间无 <code>println!</code>：当 <code>borrows_mutably</code> 定义时，它捕获了 <code>list</code> 的可变引用。闭包调用后不再使用，故可变借用结束。在闭包定义和调用之间，不可变借用打印不被允许（因存在可变借用时不允许其他借用）。尝试在此处添加 <code>println!</code> 查看错误信息！</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment even though the body of the closure doesn’t strictly need
ownership, you can use the <code>move</code> keyword before the parameter list.</p>
<p>若需强制闭包获取其使用值的所有权（即使闭包体并不严格需要所有权），可在参数列表前使用 <code>move</code> 关键字。</p>
<p>This technique is mostly useful when passing a closure to a new thread to move
the data so that it’s owned by the new thread. We’ll discuss threads and why
you would want to use them in detail in Chapter 16 when we talk about
concurrency, but for now, let’s briefly explore spawning a new thread using a
closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified
to print the vector in a new thread rather than in the main thread.</p>
<p>此技术主要用于将闭包传递给新线程以转移数据所有权。我们将在第 16 章讨论并发时详细解释线程及其用途。现在，我们简要探索使用需要 <code>move</code> 关键字的闭包生成新线程。示例 13-6 修改自示例 13-4，改为在新线程而非主线程打印向量。</p>
<figure class="listing" id="listing-13-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<figcaption><a href="#listing-13-6">Listing 13-6</a>: Using <code>move</code> to force the closure for the thread to take ownership of <code>list</code> 使用 <code>move</code> 强制线程闭包获取 <code>list</code> 的所有权</figcaption>
</figure>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The
closure body prints out the list. In Listing 13-4, the closure only captured
<code>list</code> using an immutable reference because that’s the least amount of access
to <code>list</code> needed to print it. In this example, even though the closure body
still only needs an immutable reference, we need to specify that <code>list</code> should
be moved into the closure by putting the <code>move</code> keyword at the beginning of the
closure definition. If the main thread performed more operations before calling
<code>join</code> on the new thread, the new thread might finish before the rest of the
main thread finishes, or the main thread might finish first. If the main thread
maintained ownership of <code>list</code> but ended before the new thread and drops
<code>list</code>, the immutable reference in the thread would be invalid. Therefore, the
compiler requires that <code>list</code> be moved into the closure given to the new thread
so the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code>
in the main thread after the closure is defined to see what compiler errors you
get!</p>
<p>我们生成新线程，将闭包作为参数传递给线程运行。闭包体打印 <code>list</code>。在示例 13-4 中，闭包仅通过不可变引用捕获 <code>list</code>（这是打印所需的最小访问权限）。本例中，即使闭包体仍只需不可变引用，仍需在闭包定义开头添加 <code>move</code> 关键字指定将 <code>list</code> 移入闭包。若主线程在调用新线程的 <code>join</code> 前执行更多操作，新线程可能在主线程结束前完成，或主线程先结束。若主线程保留 <code>list</code> 所有权但先于新线程结束并丢弃 <code>list</code>，线程中的不可变引用将失效。因此，编译器要求将 <code>list</code> 移入给新线程的闭包以保证引用有效。尝试移除 <code>move</code> 关键字或在定义闭包后于主线程使用 <code>list</code>，观察编译器错误！</p>
<h3 id="moving-captured-values-out-of-closures-and-the-fn-traits-将捕获值移出闭包与-fn-特质"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits-将捕获值移出闭包与-fn-特质">Moving Captured Values Out of Closures and the <code>Fn</code> Traits 将捕获值移出闭包与 <code>Fn</code> 特质</a></h3>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure).</p>
<p>当闭包从定义环境中捕获引用或值所有权后（影响值<strong>移入</strong>闭包的方式），闭包体中的代码决定了后续求值时如何处理这些引用或值（影响值<strong>移出</strong>闭包的方式）。</p>
<p>A closure body can do any of the following: move a captured value out of the
closure, mutate the captured value, neither move nor mutate the value, or
capture nothing from the environment to begin with.</p>
<p>闭包体可执行以下操作：将捕获值移出闭包、改变捕获值、既不移动也不改变值，或根本不从环境捕获值。</p>
<p>The way a closure captures and handles values from the environment affects
which traits the closure implements, and traits are how functions and structs
can specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<p>闭包从环境中捕获和处理值的方式决定了其实现哪些特质。特质是函数和结构体指定可使用哪些闭包的方式。根据闭包体处理值的方式，闭包会自动实现一个、两个或全部三个 <code>Fn</code> 特质（以叠加方式）：</p>
<ul>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement
at least this trait because all closures can be called. A closure that moves
captured values out of its body will only implement <code>FnOnce</code> and none of the
other <code>Fn</code> traits because it can only be called once.</li>
<li><span class="highlight">[note]<code>FnOnce</code> 适用于可调用一次的闭包。所有闭包至少实现此特质（因所有闭包均可调用）。将捕获值移出体的闭包<strong>仅</strong>实现 <code>FnOnce</code>（因只能调用一次）。</span></li>
<li><code>FnMut</code> applies to closures that don’t move captured values out of their
body, but that might mutate the captured values. These closures can be
called more than once.</li>
<li><span class="highlight">[note]<code>FnMut</code> 适用于不移出捕获值但可能修改值的闭包。这些闭包可多次调用。</span></li>
<li><code>Fn</code> applies to closures that don’t move captured values out of their body
and that don’t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.</li>
<li><span class="highlight">[note]<code>Fn</code> 适用于不移出捕获值、不修改捕获值的闭包，以及不捕获任何环境值的闭包。这些闭包可多次调用且不改变环境（这在并发多次调用闭包时很重要）。</span></li>
</ul>
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that
we used in Listing 13-1:</p>
<p>回顾示例 13-1 中 <code>Option&lt;T&gt;</code> 的 <code>unwrap_or_else</code> 方法定义：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the
<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the
<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an
<code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>
<p>回想 <code>T</code> 是表示 <code>Option</code> 的 <code>Some</code> 变体值类型的泛型。该类型 <code>T</code> 也是 <code>unwrap_or_else</code> 的返回类型：例如在 <code>Option&lt;String&gt;</code> 上调用 <code>unwrap_or_else</code> 将返回 <code>String</code>。</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type
parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is
the closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>注意 <code>unwrap_or_else</code> 函数有额外的泛型参数 <code>F</code>。类型 <code>F</code> 是参数 <code>f</code> 的类型（即调用 <code>unwrap_or_else</code> 时提供的闭包）。</p>
<p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which
means <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>.
Using <code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of
<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be
called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all
closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all three kinds of
closures and is as flexible as it can be.</p>
<p>泛型 <code>F</code> 的特质限定为 <code>FnOnce() -&gt; T</code>，表示 <code>F</code> 必须可调用一次、无参数且返回 <code>T</code>。在特质限定中使用 <code>FnOnce</code> 表达了 <code>unwrap_or_else</code> 最多调用 <code>f</code> 一次的约束。在 <code>unwrap_or_else</code> 体中可见：若 <code>Option</code> 为 <code>Some</code>，<code>f</code> 不会被调用；若为 <code>None</code>，<code>f</code> 会被调用一次。因所有闭包都实现 <code>FnOnce</code>，<code>unwrap_or_else</code> 接受所有三类闭包，具有最大灵活性。</p>
<section class="note" aria-role="note">
<p>Note: If what we want to do doesn’t require capturing a value from the
environment, we can use the name of a function rather than a closure where we
need something that implements one of the <code>Fn</code> traits. For example, on an
<code>Option&lt;Vec&lt;T&gt;&gt;</code> value, we could call <code>unwrap_or_else(Vec::new)</code> to get a
new, empty vector if the value is <code>None</code>. The compiler automatically
implements whichever of the <code>Fn</code> traits is applicable for a function
definition.</p>
<p>注意：若操作无需从环境捕获值，可在需要实现 <code>Fn</code> 特质的地方使用函数名而非闭包。例如在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 值上，可调用 <code>unwrap_or_else(Vec::new)</code> 在值为 <code>None</code> 时获取新的空向量。编译器会自动为函数定义实现适用的 <code>Fn</code> 特质。</p>
</section>
<p>Now let’s look at the standard library method <code>sort_by_key</code>, defined on slices,
to see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses
<code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument
in the form of a reference to the current item in the slice being considered,
and returns a value of type <code>K</code> that can be ordered. This function is useful
when you want to sort a slice by a particular attribute of each item. In
Listing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code>
to order them by their <code>width</code> attribute from low to high.</p>
<p>现在查看标准库中切片定义的 <code>sort_by_key</code> 方法，探究其与 <code>unwrap_or_else</code> 的差异及使用 <code>FnMut</code> 而非 <code>FnOnce</code> 的原因。该闭包接收一个参数（即切片当前项的引用），并返回可排序的 <code>K</code> 类型值。当你需要按某项特定属性排序切片时，此函数非常有用。示例 13-7 中，我们使用 <code>sort_by_key</code> 将矩形列表按宽度属性从低到高排序。</p>
<figure class="listing" id="listing-13-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<figcaption><a href="#listing-13-7">Listing 13-7</a>: Using <code>sort_by_key</code> to order rectangles by width 使用 <code>sort_by_key</code> 按宽度排序矩形</figcaption>
</figure>
<p>This code prints:</p>
<p>此代码输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls
the closure multiple times: once for each item in the slice. The closure <code>|r|  r.width</code> doesn’t capture, mutate, or move anything out from its environment, so
it meets the trait bound requirements.</p>
<p><code>sort_by_key</code> 定义为接收 <code>FnMut</code> 闭包的原因是它会多次调用闭包（对切片中每个项调用一次）。闭包 <code>|r| r.width</code> 未捕获、修改或移出环境中的任何值，故满足特质限定要求。</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just
the <code>FnOnce</code> trait, because it moves a value out of the environment. The
compiler won’t let us use this closure with <code>sort_by_key</code>.</p>
<p>相反，示例 13-8 展示了仅实现 <code>FnOnce</code> 特质的闭包（因其从环境中移出值）。编译器不允许此闭包与 <code>sort_by_key</code> 一起使用。</p>
<figure class="listing" id="listing-13-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
<figcaption><a href="#listing-13-8">Listing 13-8</a>: Attempting to use an <code>FnOnce</code> closure with <code>sort_by_key</code> 尝试将 <code>FnOnce</code> 闭包用于 <code>sort_by_key</code></figcaption>
</figure>
<p>This is a contrived, convoluted way (that doesn’t work) to try and count the
number of times <code>sort_by_key</code> calls the closure when sorting <code>list</code>. This code
attempts to do this counting by pushing <code>value</code>—a <code>String</code> from the closure’s
environment—into the <code>sort_operations</code> vector. The closure captures <code>value</code> and
then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to
the <code>sort_operations</code> vector. This closure can be called once; trying to call
it a second time wouldn’t work because <code>value</code> would no longer be in the
environment to be pushed into <code>sort_operations</code> again! Therefore, this closure
only implements <code>FnOnce</code>. When we try to compile this code, we get this error
that <code>value</code> can’t be moved out of the closure because the closure must
implement <code>FnMut</code>:</p>
<p>这是一种人为设计的复杂方式（无效）尝试统计 <code>sort_by_key</code> 排序 <code>list</code> 时调用闭包的次数。此代码尝试通过将闭包环境中的 <code>value</code>（<code>String</code> 类型）推入 <code>sort_operations</code> 向量来实现计数。闭包捕获 <code>value</code> 后，通过转移 <code>value</code> 所有权到 <code>sort_operations</code> 向量将其移出闭包。此闭包只能调用一次！再次调用将失败（因 <code>value</code> 已不在环境中无法再次推入 <code>sort_operations</code>）。因此，该闭包仅实现 <code>FnOnce</code>。编译时产生 “<code>value</code> 无法移出闭包” 的错误（因闭包必须实现 <code>FnMut</code>）：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the
environment. To fix this, we need to change the closure body so that it doesn’t
move values out of the environment. Keeping a counter in the environment and
incrementing its value in the closure body is a more straightforward way to
count the number of times the closure is called. The closure in Listing 13-9
works with <code>sort_by_key</code> because it is only capturing a mutable reference to the
<code>num_sort_operations</code> counter and can therefore be called more than once:</p>
<p>错误指向闭包体中移出 <code>value</code> 的代码行。修复需更改闭包体使其不移出环境中的值。更直接的方式是在环境中维护计数器并在闭包体中递增其值。示例 13-9 的闭包可与 <code>sort_by_key</code> 协作（因仅捕获 <code>num_sort_operations</code> 计数器的可变引用，可多次调用）：</p>
<figure class="listing" id="listing-13-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
<figcaption><a href="#listing-13-9">Listing 13-9</a>: Using an <code>FnMut</code> closure with <code>sort_by_key</code> is allowed 允许将 <code>FnMut</code> 闭包用于 <code>sort_by_key</code></figcaption>
</figure>
<p>The <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
<p><code>Fn</code> 特质在定义或使用涉及闭包的函数或类型时至关重要。下一节我们将讨论迭代器。许多迭代器方法接收闭包参数，请牢记这些闭包细节！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
