<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Working With Any Number of Futures 处理任意数量的 Future - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="working-with-any-number-of-futures-处理任意数量的-future"><a class="header" href="#working-with-any-number-of-futures-处理任意数量的-future">Working with Any Number of Futures 处理任意数量的 Future</a></h2>
<p>When we switched from using two futures to three in the previous section, we
also had to switch from using <code>join</code> to using <code>join3</code>. It would be annoying to
have to call a different function every time we changed the number of futures we
wanted to join. Happily, we have a macro form of <code>join</code> to which we can pass an
arbitrary number of arguments. It also handles awaiting the futures itself.
Thus, we could rewrite the code from Listing 17-13 to use <code>join!</code> instead of
<code>join3</code>, as in Listing 17-14.</p>
<p>在上一节中，当我们将使用的 Future 数量从两个增加到三个时，我们也不得不从使用 <code>join</code> 切换到使用 <code>join3</code>。每次改变我们想要合并的 Future 数量时都必须调用不同的函数会很烦人。幸运的是，我们有一个<span class="highlight">[note]宏形式的 <code>join</code>，可以向它传递任意数量的参数。它还会自己处理对 Future 的等待</span>。因此，我们可以重写代码清单 17-13 中的代码，使用 <code>join!</code> 代替 <code>join3</code>，如代码清单 17-14 所示。</p>
<p><span class="highlight">[note]注：<code>use futures::join;</code></span></p>
<figure class="listing" id="listing-17-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-14">Listing 17-14</a>: Using <code>join!</code> to wait for multiple futures 使用 <code>join!</code> 等待多个 Future</figcaption>
</figure>
<p>This is definitely an improvement over swapping between <code>join</code> and
<code>join3</code> and <code>join4</code> and so on! However, even this macro form only works
when we know the number of futures ahead of time. In real-world Rust,
though, pushing futures into a collection and then waiting on some or
all the futures of them to complete is a common pattern.</p>
<p>这绝对比在 <code>join</code>、<code>join3</code>、<code>join4</code> 等之间切换要好得多！然而，即使这种宏形式也仅在我们事先知道 Future 数量时才有效。在现实世界的 Rust 中，将 Future 推入一个集合，然后等待其中部分或全部 Future 完成是一种常见模式。</p>
<p>To check all the futures in some collection, we’ll need to iterate over and
join on <em>all</em> of them. The <code>trpl::join_all</code> function accepts any type that
implements the <code>Iterator</code> trait, which you learned about back in The Iterator
Trait and the <code>next</code> Method Chapter 13, so
it seems like just the ticket. Let’s try putting our futures in a vector and
replacing <code>join!</code> with <code>join_all</code> as shown in Listing 17-15.</p>
<p>要检查某个集合中的所有 Future，我们需要对<em>所有</em>它们进行迭代并合并（join）。<code>trpl::join_all</code> 函数接受任何实现了 <code>Iterator</code> 特征的类型（你在第 13 章“Iterator 特征和 <code>next</code> 方法”中学习过），所以它看起来正合适。让我们尝试将我们的 Future 放入一个向量（vector）中，并用 <code>join_all</code> 替换 <code>join!</code>，如代码清单 17-15 所示。</p>
<p><span class="highlight">[note]注：<code>use futures::future::join_all;</code></span></p>
<figure class="listing" id="listing-17-15">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-15">Listing 17-15</a>: Storing anonymous futures in a vector and calling <code>join_all</code> 将匿名 Future 存储在向量中并调用 <code>join_all</code></figcaption>
</figure>
<p>Unfortunately, this code doesn’t compile. Instead, we get this error:</p>
<p>不幸的是，这段代码无法编译。相反，我们得到这个错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>This might be surprising. After all, none of the async blocks returns anything,
so each one produces a <code>Future&lt;Output = ()&gt;</code>. Remember that <code>Future</code> is a trait,
though, and that the compiler creates a unique enum for each async block. You
can’t put two different hand-written structs in a <code>Vec</code>, and the same rule
applies to the different enums generated by the compiler.</p>
<p>这可能令人惊讶。毕竟，没有一个异步块返回任何东西，所以每个都产生一个 <code>Future&lt;Output = ()&gt;</code>。但请记住，<code>Future</code> 是一个特征（trait），<span class="highlight">[note]编译器会为每个异步块创建一个唯一的枚举</span>。你不能将两个不同手写的结构体放入 <code>Vec</code> 中，同样的规则也适用于编译器生成的不同枚举。</p>
<p>To make this work, we need to use <em>trait objects</em>, just as we did in “Returning
Errors from the run function” in Chapter 12. (We’ll cover
trait objects in detail in Chapter 18.) Using trait objects lets us treat each
of the anonymous futures produced by these types as the same type, because all
of them implement the <code>Future</code> trait.</p>
<p>为了使这个工作，我们需要使用<em>特征对象</em>（trait objects），就像我们在第 12 章“从 run 函数返回错误”中所做的那样。（我们将在第 18 章详细讨论特征对象。）使用特征对象让我们可以将这些类型产生的每个匿名 Future 视为相同的类型，因为它们都实现了 <code>Future</code> 特征。</p>
<section class="note" aria-role="note">
<p>Note: In Using an Enum to Store Multiple Values in
Chapter 8, we discussed another way to include multiple types in a <code>Vec</code>:
using an enum to represent each type that can appear in the vector. We can’t
do that here, though. For one thing, we have no way to name the different
types, because they are anonymous. For another, the reason we reached for a
vector and <code>join_all</code> in the first place was to be able to work with a dynamic
collection of futures where we only care that they have the same output type.</p>
<p>注意：在第 8 章“使用枚举存储多个值”中，我们讨论了在 <code>Vec</code> 中包含多种类型的另一种方法：使用枚举（enum）来表示向量中可以出现的每种类型。然而，我们在这里不能这样做。一方面，我们无法命名这些不同的类型，因为它们是匿名的。另一方面，我们最初选择使用向量和 <code>join_all</code> 的原因，是为了能够处理一个动态的 Future 集合，而我们只关心它们具有相同的输出类型。</p>
</section>
<p>We start by wrapping each future in the <code>vec!</code> in a <code>Box::new</code>, as shown in
Listing 17-16.</p>
<p>我们首先在 <code>vec!</code> 中用 <code>Box::new</code> 包装每个 Future，如代码清单 17-16 所示。</p>
<figure class="listing" id="listing-17-16">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-16">Listing 17-16</a>: Using <code>Box::new</code> to align the types of the futures in a <code>Vec</code> 使用 <code>Box::new</code> 对齐 <code>Vec</code> 中 Future 的类型</figcaption>
</figure>
<p>Unfortunately, this code still doesn’t compile. In fact, we get the same basic
error we got before for both the second and third <code>Box::new</code> calls, as well as
new errors referring to the <code>Unpin</code> trait. We’ll come back to the <code>Unpin</code> errors
in a moment. First, let’s fix the type errors on the <code>Box::new</code> calls by
explicitly annotating the type of the <code>futures</code> variable (see Listing 17-17).</p>
<p>不幸的是，这段代码仍然无法编译。实际上，对于第二个和第三个 <code>Box::new</code> 调用，我们得到了与之前基本相同的错误，同时还出现了引用 <code>Unpin</code> 特征的新错误。我们稍后会回到 <code>Unpin</code> 错误。首先，让我们通过显式<span class="highlight">[note]注解 <code>futures</code> 变量的类型</span>来修复 <code>Box::new</code> 调用的类型错误（见代码清单 17-17）。</p>
<figure class="listing" id="listing-17-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-17">Listing 17-17</a>: Fixing the rest of the type mismatch errors by using an explicit type declaration 使用显式类型声明修复剩余的类型不匹配错误</figcaption>
</figure>
<p>This type declaration is a little involved, so let’s walk through it:</p>
<p>这个类型声明有点复杂，让我们逐步分析一下：</p>
<ol>
<li>
<p>The innermost type is the future itself. We note explicitly that the output
of the future is the unit type <code>()</code> by writing <code>Future&lt;Output = ()&gt;</code>.</p>
</li>
<li>
<p>Then we annotate the trait with <code>dyn</code> to mark it as dynamic.</p>
</li>
<li>
<p>The entire trait reference is wrapped in a <code>Box</code>.</p>
</li>
<li>
<p>Finally, we state explicitly that <code>futures</code> is a <code>Vec</code> containing these
items.</p>
</li>
<li>
<p>最内层的类型是 Future 本身。我们通过写 <code>Future&lt;Output = ()&gt;</code> 显式注解 Future 的输出是单元类型 <code>()</code>。</p>
</li>
<li>
<p>然后我们用 <code>dyn</code> 注解特征，将其标记为动态的（dynamic）。</p>
</li>
<li>
<p>整个特征引用被包装在一个 <code>Box</code> 中。</p>
</li>
<li>
<p>最后，我们显式声明 <code>futures</code> 是一个包含这些项的 <code>Vec</code>。</p>
</li>
</ol>
<p>That already made a big difference. Now when we run the compiler, we get only
the errors mentioning <code>Unpin</code>. Although there are three of them, their contents
are very similar.</p>
<p>这已经带来了很大的改变。现在当我们运行编译器时，我们只得到提及 <code>Unpin</code> 的错误。虽然有三个错误，但它们的内容非常相似。</p>
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
   --&gt; src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `async_await` (bin "async_await") due to 3 previous errors
</code></pre>
<p>That is a <em>lot</em> to digest, so let’s pull it apart. The first part of the message
tell us that the first async block (<code>src/main.rs:8:23: 20:10</code>) does not
implement the <code>Unpin</code> trait and suggests using <code>pin!</code> or <code>Box::pin</code> to resolve
it. Later in the chapter, we’ll dig into a few more details about <code>Pin</code> and
<code>Unpin</code>. For the moment, though, we can just follow the compiler’s advice to get
unstuck. In Listing 17-18, we start by importing <code>Pin</code> from <code>std::pin</code>. Next we
update the type annotation for <code>futures</code>, with a <code>Pin</code> wrapping each <code>Box</code>.
Finally, we use <code>Box::pin</code> to pin the futures themselves.</p>
<p>这有<em>很多</em>信息需要消化，所以让我们分解一下。消息的第一部分告诉我们第一个异步块（<code>src/main.rs:8:23: 20:10</code>）没有实现 <code>Unpin</code> 特征，并建议使用 <code>pin!</code> 或 <code>Box::pin</code> 来解决它。在本章后面，我们将更深入地探讨一些关于 <code>Pin</code> 和 <code>Unpin</code> 的细节。不过现在，我们可以直接遵循编译器的建议来解决问题。在代码清单 17-18 中，我们<span class="highlight">[note]首先从 <code>std::pin</code> 导入 <code>Pin</code>。接下来我们更新 <code>futures</code> 的类型注解，用 <code>Pin</code> 包装每个 <code>Box</code>。最后，我们使用 <code>Box::pin</code> 来固定（pin）Future 本身。</span></p>
<figure class="listing" id="listing-17-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::Pin;

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-18">Listing 17-18</a>: Using <code>Pin</code> and <code>Box::pin</code> to make the <code>Vec</code> type check 使用 <code>Pin</code> 和 <code>Box::pin</code> 使 <code>Vec</code> 通过类型检查</figcaption>
</figure>
<p>If we compile and run this, we finally get the output we hoped for:</p>
<p>如果我们编译并运行这个，我们终于得到了我们期望的输出：</p>
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>Phew!</p>
<p>呼！</p>
<p>There’s a bit more to explore here. For one thing, using <code>Pin&lt;Box&lt;T&gt;&gt;</code> adds a
small amount of overhead from putting these futures on the heap with <code>Box</code>—and
we’re only doing that to get the types to line up. We don’t actually <em>need</em> the
heap allocation, after all: these futures are local to this particular function.
As noted before, <code>Pin</code> is itself a wrapper type, so we can get the benefit of
having a single type in the <code>Vec</code>—the original reason we reached for
<code>Box</code>—without doing a heap allocation. We can use <code>Pin</code> directly with each
future, using the <code>std::pin::pin</code> macro.</p>
<p><span class="highlight">[note]这里还有更多可以探索的地方。首先，使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 会带来一点开销，这源于用 <code>Box</code> 把这些 future 对象放到堆上——而我们这么做仅仅是为了让类型能够匹配。毕竟，我们实际上<em>并不需要</em>堆分配：这些 Future 是特定于此函数的局部变量。如前所述，<code>Pin</code> 本身是一个包装类型，因此我们可以在 <code>Vec</code> 中拥有单一类型——这是我们最初选择 <code>Box</code> 的原因——而无需进行堆分配。我们可以使用 <code>std::pin::pin</code> 宏直接在每个 Future 上使用 <code>Pin</code>。</span></p>
<p>However, we must still be explicit about the type of the pinned reference;
otherwise, Rust will still not know to interpret these as dynamic trait objects,
which is what we need them to be in the <code>Vec</code>. We therefore add <code>pin</code> to our
list of imports from <code>std::pin</code>. Then we can <code>pin!</code> each future when we define
it and define <code>futures</code> as a <code>Vec</code> containing pinned mutable references to the
dynamic future type, as in Listing 17-19.</p>
<p><span class="highlight">[note]然而，我们仍然必须显式声明固定引用的类型；否则，Rust 仍然不会知道将这些解释为动态特征对象，而这正是我们在 <code>Vec</code> 中需要的。因此，我们将 <code>pin</code> 添加到从 <code>std::pin</code> 导入的列表中。然后我们可以在定义每个 Future 时使用 <code>pin!</code> 宏固定它，并将 <code>futures</code> 定义为一个包含固定可变引用（指向动态 Future 类型）的 <code>Vec</code>，如代码清单 17-19 所示。</span></p>
<figure class="listing" id="listing-17-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::{Pin, pin};

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-19">Listing 17-19</a>: Using <code>Pin</code> directly with the <code>pin!</code> macro to avoid unnecessary heap allocations 直接使用 <code>Pin</code> 和 <code>pin!</code> 宏避免不必要的堆分配</figcaption>
</figure>
<p>We got this far by ignoring the fact that we might have different <code>Output</code>
types. For example, in Listing 17-20, the anonymous future for <code>a</code> implements
<code>Future&lt;Output = u32&gt;</code>, the anonymous future for <code>b</code> implements <code>Future&lt;Output =  &amp;str&gt;</code>, and the anonymous future for <code>c</code> implements <code>Future&lt;Output = bool&gt;</code>.</p>
<p>我们通过忽略我们可能有不同的 <code>Output</code> 类型这一事实才走到这一步。例如，在代码清单 17-20 中，<code>a</code> 的匿名 Future 实现了 <code>Future&lt;Output = u32&gt;</code>，<code>b</code> 的匿名 Future 实现了 <code>Future&lt;Output = &amp;str&gt;</code>，而 <code>c</code> 的匿名 Future 实现了 <code>Future&lt;Output = bool&gt;</code>。</p>
<figure class="listing" id="listing-17-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-20">Listing 17-20</a>: Three futures with distinct types 三个具有不同类型的 Future</figcaption>
</figure>
<p>We can use <code>trpl::join!</code> to await them, because it allows us to pass in multiple
future types and produces a tuple of those types. We <em>cannot</em> use
<code>trpl::join_all</code>, because it requires all of the futures passed in to have the
same type. Remember, that error is what got us started on this adventure with
<code>Pin</code>!</p>
<p>我们可以使用 <code>trpl::join!</code> 来等待它们，因为它允许我们传入多种 Future 类型，并产生这些类型组成的元组。我们<em>不能</em>使用 <code>trpl::join_all</code>，因为它要求传入的所有 Future 具有相同的类型。记住，正是这个错误让我们开始了这段关于 <code>Pin</code> 的冒险！</p>
<p>This is a fundamental tradeoff: we can either deal with a dynamic number of
futures with <code>join_all</code>, as long as they all have the same type, or we can deal
with a set number of futures with the <code>join</code> functions or the <code>join!</code> macro,
even if they have different types. This is the same scenario we’d face when
working with any other types in Rust. Futures are not special, even though we
have some nice syntax for working with them, and that’s a good thing.</p>
<p>这是一个根本性的权衡：我们<span class="highlight">[note]可以使用 <code>join_all</code> 处理动态数量的 Future，只要它们都具有相同的类型；或者我们可以使用 <code>join</code> 系列函数或 <code>join!</code> 宏处理固定数量的 Future，即使它们具有不同的类型。</span>这与我们在 Rust 中处理任何其他类型时面临的情况相同。Future 并不特殊，尽管我们有一些很好的语法来处理它们，这是一件好事。</p>
<h3 id="racing-futures-future-竞速"><a class="header" href="#racing-futures-future-竞速">Racing Futures Future 竞速</a></h3>
<p>When we “join” futures with the <code>join</code> family of functions and macros, we
require <em>all</em> of them to finish before we move on. Sometimes, though, we only
need <em>some</em> future from a set to finish before we move on—kind of similar to
racing one future against another.</p>
<p>当我们使用 <code>join</code> 系列函数和宏“合并” Future 时，我们要求它们都完成才能继续。然而，有时我们只需要集合中的<em>某个</em> Future 完成就可以继续——有点像让一个 Future 与另一个 Future 赛跑（race）。</p>
<p>In Listing 17-21, we once again use <code>trpl::race</code> to run two futures, <code>slow</code> and
<code>fast</code>, against each other.</p>
<p>在代码清单 17-21 中，我们再次使用 <code>trpl::race</code> 来让两个 Future <code>slow</code> 和 <code>fast</code> 相互竞争。</p>
<figure class="listing" id="listing-17-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-21">Listing 17-21</a>: Using <code>race</code> to get the result of whichever future finishes first 使用 <code>race</code> 获取最先完成的 Future 的结果</figcaption>
</figure>
<p>Each future prints a message when it starts running, pauses for some amount of
time by calling and awaiting <code>sleep</code>, and then prints another message when it
finishes. Then we pass both <code>slow</code> and <code>fast</code> to <code>trpl::race</code> and wait for one
of them to finish. (The outcome here isn’t too surprising: <code>fast</code> wins.) Unlike
when we used <code>race</code> back in “Our First Async Program”, we just ignore the <code>Either</code> instance it returns here, because all of
the interesting behavior happens in the body of the async blocks.</p>
<p>每个 Future 在开始运行时打印一条消息，通过调用并等待 <code>sleep</code> 暂停一段时间，然后在完成时打印另一条消息。然后我们将 <code>slow</code> 和 <code>fast</code> 都传递给 <code>trpl::race</code> 并等待其中一个完成。（这里的结果并不太令人惊讶：<code>fast</code> 获胜。）与我们之前在“第一个异步程序”中使用 <code>race</code> 不同，这里我们只是忽略它返回的 <code>Either</code> 实例，因为所有有趣的行为都发生在异步块的主体中。</p>
<p>Notice that if you flip the order of the arguments to <code>race</code>, the order of the
“started” messages changes, even though the <code>fast</code> future always completes
first. That’s because the implementation of this particular <code>race</code> function is
not fair. It always runs the futures passed in as arguments in the order in
which they’re passed. Other implementations <em>are</em> fair and will randomly choose
which future to poll first. Regardless of whether the implementation of race
we’re using is fair, though, <em>one</em> of the futures will run up to the first
<code>await</code> in its body before another task can start.</p>
<p>请注意，如果你翻转传递给 <code>race</code> 的参数顺序，“started”消息的顺序也会改变，即使 <code>fast</code> Future 总是最先完成。这是因为<span class="highlight">[note]这个特定 <code>race</code> 函数的实现是不公平的。它总是按照参数传递的顺序运行 Future。其他实现是公平的，会随机选择首先轮询（poll）哪个 Future。</span>不过，无论我们使用的 race 实现是否公平，<em>总有一个</em> Future 会在其主体中运行到第一个 <code>await</code> 点，然后另一个任务才能开始。</p>
<p>Recall from Our First Async Program that at each
await point, Rust gives a runtime a chance to pause the task and switch to
another one if the future being awaited isn’t ready. The inverse is also true:
Rust <em>only</em> pauses async blocks and hands control back to a runtime at an await
point. Everything between await points is synchronous.</p>
<p>回想一下“第一个异步程序”，在每个 await 点，Rust 都会给运行时（runtime）一个机会来暂停当前任务，如果被等待的 Future 还没准备好，就切换到另一个任务。反之亦然：<span class="highlight">[note]Rust <em>只</em>在 await 点暂停异步块并将控制权交还给运行时</span>。await 点之间的所有代码都是同步执行的。</p>
<p>That means if you do a bunch of work in an async block without an await point,
that future will block any other futures from making progress. You may sometimes
hear this referred to as one future <em>starving</em> other futures. In some cases,
that may not be a big deal. However, if you are doing some kind of expensive
setup or long-running work, or if you have a future that will keep doing some
particular task indefinitely, you’ll need to think about when and where to hand
control back to the runtime.</p>
<p><span class="highlight">[note]这意味着如果你在一个异步块中做了一堆工作而没有 await 点，那么这个 Future 将阻塞其他 Future 的进展。</span>你有时可能会听到这被称为一个 Future <em>饿死</em>（starving）其他 Future。在某些情况下，这可能不是什么大问题。但是，如果你正在进行某种昂贵的设置或长时间运行的工作，或者如果你有一个 Future 将无限期地持续执行某个特定任务，你就需要考虑何时何地将控制权交还给运行时。</p>
<p>By the same token, if you have long-running blocking operations, async can be a
useful tool for providing ways for different parts of the program to relate to
each other.</p>
<p>同样地，如果你有长时间运行的阻塞操作，异步可以成为一个有用的工具，用于提供程序不同部分之间相互关联的方式。</p>
<p>But <em>how</em> would you hand control back to the runtime in those cases?</p>
<p>但是，在这些情况下，你<em>如何</em>将控制权交还给运行时呢？</p>
<h3 id="yielding-control-to-the-runtime-向运行时让出控制权"><a class="header" href="#yielding-control-to-the-runtime-向运行时让出控制权">Yielding Control to the Runtime 向运行时让出控制权</a></h3>
<p>Let’s simulate a long-running operation. Listing 17-22 introduces a <code>slow</code>
function.</p>
<p>让我们模拟一个长时间运行的操作。代码清单 17-22 引入了一个 <code>slow</code> 函数。</p>
<figure class="listing" id="listing-17-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
<figcaption><a href="#listing-17-22">Listing 17-22</a>: Using <code>thread::sleep</code> to simulate slow operations 使用 <code>thread::sleep</code> 模拟慢操作</figcaption>
</figure>
<p>This code uses <code>std::thread::sleep</code> instead of <code>trpl::sleep</code> so that calling
<code>slow</code> will block the current thread for some number of milliseconds. We can use
<code>slow</code> to stand in for real-world operations that are both long-running and
blocking.</p>
<p>这段代码使用 <code>std::thread::sleep</code> 而不是 <code>trpl::sleep</code>，因此调用 <code>slow</code> 将在当前线程上阻塞指定的毫秒数。我们可以使用 <code>slow</code> 来代表现实世界中既长时间运行又阻塞的操作。</p>
<p>In Listing 17-23, we use <code>slow</code> to emulate doing this kind of CPU-bound work in
a pair of futures.</p>
<p>在代码清单 17-23 中，我们使用 <code>slow</code> 来模拟在一对 Future 中执行这种 CPU 密集型工作。</p>
<figure class="listing" id="listing-17-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-23">Listing 17-23</a>: Using <code>thread::sleep</code> to simulate slow operations 使用 <code>thread::sleep</code> 模拟慢操作</figcaption>
</figure>
<p>To begin, each future only hands control back to the runtime <em>after</em> carrying
out a bunch of slow operations. If you run this code, you will see this output:</p>
<p>开始时，每个 Future 只有在执行了一堆慢操作之后才会将控制权交还给运行时。如果你运行这段代码，你将看到这样的输出：</p>
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>As with our earlier example, <code>race</code> still finishes as soon as <code>a</code> is done.
There’s no interleaving between the two futures, though. The <code>a</code> future does all
of its work until the <code>trpl::sleep</code> call is awaited, then the <code>b</code> future does
all of its work until its own <code>trpl::sleep</code> call is awaited, and finally the <code>a</code>
future completes. To allow both futures to make progress between their slow
tasks, we need await points so we can hand control back to the runtime. That
means we need something we can await!</p>
<p>与我们之前的例子类似，<code>race</code> 仍然在 <code>a</code> 完成后立即结束。但是，两个 Future 之间没有交错执行。<code>a</code> Future 完成了它所有的工作，直到 <code>trpl::sleep</code> 调用被等待，然后 <code>b</code> Future 完成了它所有的工作，直到它自己的 <code>trpl::sleep</code> 调用被等待，最后 <code>a</code> Future 完成。为了允许两个 Future 在它们的慢任务之间交替取得进展，我们需要 await 点，以便我们可以将控制权交还给运行时。这意味着我们需要一些我们可以 await 的东西！</p>
<p>We can already see this kind of handoff happening in Listing 17-23: if we
removed the <code>trpl::sleep</code> at the end of the <code>a</code> future, it would complete
without the <code>b</code> future running <em>at all</em>. Let’s try using the <code>sleep</code> function as
a starting point for letting operations switch off making progress, as shown in
Listing 17-24.</p>
<p>我们已经在代码清单 17-23 中看到了这种控制权移交的发生：如果我们移除 <code>a</code> Future 末尾的 <code>trpl::sleep</code>，它将在 <code>b</code> Future <em>根本</em>没有运行的情况下完成。让我们尝试使用 <code>sleep</code> 函数作为起点，让操作交替取得进展，如代码清单 17-24 所示。</p>
<figure class="listing" id="listing-17-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-24">Listing 17-24</a>: Using <code>sleep</code> to let operations switch off making progress 使用 <code>sleep</code> 让操作交替取得进展</figcaption>
</figure>
<p>In Listing 17-24, we add <code>trpl::sleep</code> calls with await points between each call
to <code>slow</code>. Now the two futures’ work is interleaved:</p>
<p>在代码清单 17-24 中，我们在每次调用 <code>slow</code> 之间添加了带 await 点的 <code>trpl::sleep</code> 调用。现在两个 Future 的工作是交错进行的：</p>
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>The <code>a</code> future still runs for a bit before handing off control to <code>b</code>, because
it calls <code>slow</code> before ever calling <code>trpl::sleep</code>, but after that the futures
swap back and forth each time one of them hits an await point. In this case, we
have done that after every call to <code>slow</code>, but we could break up the work in
whatever way makes the most sense to us.</p>
<p><code>a</code> Future 在将控制权交给 <code>b</code> 之前仍然运行了一会儿，因为它先调用了 <code>slow</code> 然后才调用 <code>trpl::sleep</code>，但在此之后，每当其中一个 Future 遇到 await 点时，它们就会来回交换。在这种情况下，我们在每次调用 <code>slow</code> 之后都这样做了，但我们可以用对我们最有意义的方式来拆分工作。</p>
<p>We don’t really want to <em>sleep</em> here, though: we want to make progress as fast
as we can. We just need to hand back control to the runtime. We can do that
directly, using the <code>yield_now</code> function. In Listing 17-25, we replace all those
<code>sleep</code> calls with <code>yield_now</code>.</p>
<p>然而，我们在这里并不是真的想<em>休眠</em>（sleep）：我们想尽可能快地取得进展。我们只需要<span class="highlight">[note]将控制权交还给运行时。我们可以直接使用 <code>yield_now</code> 函数</span>来实现这一点。在代码清单 17-25 中，我们用 <code>yield_now</code> 替换所有那些 <code>sleep</code> 调用。</p>
<p><span class="highlight">[note]注：<code>use tokio::task::yield_now;</code></span></p>
<figure class="listing" id="listing-17-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-25">Listing 17-25</a>: Using <code>yield_now</code> to let operations switch off making progress 使用 <code>yield_now</code> 让操作交替取得进展</figcaption>
</figure>
<p>This code is both clearer about the actual intent and can be significantly
faster than using <code>sleep</code>, because timers such as the one used by <code>sleep</code> often
have limits on how granular they can be. The version of <code>sleep</code> we are using,
for example, will always sleep for at least a millisecond, even if we pass it a
<code>Duration</code> of one nanosecond. Again, modern computers are <em>fast</em>: they can do a
lot in one millisecond!</p>
<p>这段代码在表达实际意图上更清晰，并且可能比使用 <code>sleep</code> 快得多，因为像 <code>sleep</code> 使用的计时器通常有最小粒度的限制。例如，<span class="highlight">[note]我们使用的 <code>sleep</code> 版本，即使我们传递一纳秒的 <code>Duration</code>，也总是会至少休眠一毫秒。</span>再说一次，现代计算机<em>非常快</em>：它们在一毫秒内可以做很多事情！</p>
<p>You can see this for yourself by setting up a little benchmark, such as the one
in Listing 17-26. (This isn’t an especially rigorous way to do performance
testing, but it suffices to show the difference here.)</p>
<p>你可以通过设置一个小型基准测试自己看到这一点，例如代码清单 17-26 中的测试。（这不是进行性能测试的特别严谨的方法，但足以显示此处的差异。）</p>
<figure class="listing" id="listing-17-26">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-26">Listing 17-26</a>: Comparing the performance of <code>sleep</code> and <code>yield_now</code> 比较 <code>sleep</code> 和 <code>yield_now</code> 的性能</figcaption>
</figure>
<p>Here, we skip all the status printing, pass a one-nanosecond <code>Duration</code> to
<code>trpl::sleep</code>, and let each future run by itself, with no switching between the
futures. Then we run for 1,000 iterations and see how long the future using
<code>trpl::sleep</code> takes compared to the future using <code>trpl::yield_now</code>.</p>
<p>在这里，我们跳过所有状态打印，将一纳秒的 <code>Duration</code> 传递给 <code>trpl::sleep</code>，并让每个 Future 自己运行，没有 Future 之间的切换。然后我们运行 1000 次迭代，看看使用 <code>trpl::sleep</code> 的 Future 与使用 <code>trpl::yield_now</code> 的 Future 相比需要多长时间。</p>
<p>The version with <code>yield_now</code> is <em>way</em> faster!</p>
<p>使用 <code>yield_now</code> 的版本<em>快得多</em>！</p>
<p>This means that async can be useful even for compute-bound tasks, depending on
what else your program is doing, because it provides a useful tool for
structuring the relationships between different parts of the program. This is a
form of <em>cooperative multitasking</em>, where each future has the power to determine
when it hands over control via await points. Each future therefore also has the
responsibility to avoid blocking for too long. In some Rust-based embedded
operating systems, this is the <em>only</em> kind of multitasking!</p>
<p>这意味着异步对于计算密集型任务也可能有用，这取决于你的程序还在做什么，因为它为构建程序不同部分之间的关系提供了一个有用的工具。这是一种<em>协作式多任务处理</em>（cooperative multitasking），其中每个 Future 都有权通过 await 点决定何时交出控制权。因此，每个 Future 也有责任避免阻塞太久。在一些基于 Rust 的嵌入式操作系统中，这是<em>唯一</em>的多任务处理方式！</p>
<p>In real-world code, you won’t usually be alternating function calls with await
points on every single line, of course. While yielding control in this way is
relatively inexpensive, it’s not free. In many cases, trying to break up a
compute-bound task might make it significantly slower, so sometimes it’s better
for <em>overall</em> performance to let an operation block briefly. Always
measure to see what your code’s actual performance bottlenecks are. The
underlying dynamic is important to keep in mind, though, if you <em>are</em> seeing a
lot of work happening in serial that you expected to happen concurrently!</p>
<p>在真实世界的代码中，你通常不会在每一行都交替进行函数调用和 await 点。虽然以这种方式让出控制权相对便宜，但它并非免费。<span class="highlight">[note]在许多情况下，尝试拆分一个计算密集型任务可能会使其显著变慢，因此有时为了<em>整体</em>性能，让一个操作短暂阻塞会更好。</span>始终测量以查看代码的实际性能瓶颈是什么。但是，如果你<em>确实</em>看到大量你期望并发发生的工作在串行进行，那么了解底层的动态特性非常重要！</p>
<h3 id="building-our-own-async-abstractions-构建我们自己的异步抽象"><a class="header" href="#building-our-own-async-abstractions-构建我们自己的异步抽象">Building Our Own Async Abstractions 构建我们自己的异步抽象</a></h3>
<p>We can also compose futures together to create new patterns. For example, we can
build a <code>timeout</code> function with async building blocks we already have. When
we’re done, the result will be another building block we could use to create
still more async abstractions.</p>
<p>我们也可以将 Future 组合在一起创建新的模式。例如，我们可以使用已有的异步构建块来构建一个 <code>timeout</code> 函数。完成后，结果将是另一个构建块，我们可以用它来创建更多的异步抽象。</p>
<p>Listing 17-27 shows how we would expect this <code>timeout</code> to work with a slow
future.</p>
<p>代码清单 17-27 展示了我们期望这个 <code>timeout</code> 如何与一个慢 Future 一起工作。</p>
<figure class="listing" id="listing-17-27">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-27">Listing 17-27</a>: Using our imagined <code>timeout</code> to run a slow operation with a time limit 使用我们设想的 <code>timeout</code> 在时间限制内运行慢操作</figcaption>
</figure>
<p>Let’s implement this! To begin, let’s think about the API for <code>timeout</code>:</p>
<p>让我们来实现它！首先，让我们思考一下 <code>timeout</code> 的 API：</p>
<ul>
<li>
<p>It needs to be an async function itself so we can await it.</p>
</li>
<li>
<p>Its first parameter should be a future to run. We can make it generic to allow
it to work with any future.</p>
</li>
<li>
<p>Its second parameter will be the maximum time to wait. If we use a <code>Duration</code>,
that will make it easy to pass along to <code>trpl::sleep</code>.</p>
</li>
<li>
<p>It should return a <code>Result</code>. If the future completes successfully, the
<code>Result</code> will be <code>Ok</code> with the value produced by the future. If the timeout
elapses first, the <code>Result</code> will be <code>Err</code> with the duration that the timeout
waited for.</p>
</li>
<li>
<p>它本身需要是一个异步函数，以便我们可以 await 它。</p>
</li>
<li>
<p>它的第一个参数应该是一个要运行的 Future。我们可以将其设为泛型，以允许它与任何 Future 一起工作。</p>
</li>
<li>
<p>它的第二个参数将是最大等待时间。如果我们使用 <code>Duration</code>，这将使其易于传递给 <code>trpl::sleep</code>。</p>
</li>
<li>
<p>它应该返回一个 <code>Result</code>。如果 Future 成功完成，<code>Result</code> 将是 <code>Ok</code>，其值是该 Future 产生的值。如果超时首先发生，<code>Result</code> 将是 <code>Err</code>，其值是超时等待的时长。</p>
</li>
</ul>
<p>Listing 17-28 shows this declaration.</p>
<p>代码清单 17-28 显示了这个声明。</p>
<figure class="listing" id="listing-17-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
<figcaption><a href="#listing-17-28">Listing 17-28</a>: Defining the signature of <code>timeout</code> 定义 <code>timeout</code> 的签名</figcaption>
</figure>
<p>That satisfies our goals for the types. Now let’s think about the <em>behavior</em> we
need: we want to race the future passed in against the duration. We can use
<code>trpl::sleep</code> to make a timer future from the duration, and use <code>trpl::race</code> to
run that timer with the future the caller passes in.</p>
<p>这满足了我们对类型的目标。现在让我们思考我们需要的行为：我们希望将传入的 Future 与给定的时长进行竞速（race）。我们可以使用 <code>trpl::sleep</code> 从该时长创建一个计时器 Future，并使用 <code>trpl::race</code> 来运行这个计时器和调用者传递的 Future。</p>
<p>We also know that <code>race</code> is not fair, polling arguments in the order in which
they are passed. Thus, we pass <code>future_to_try</code> to <code>race</code> first so it gets a
chance to complete even if <code>max_time</code> is a very short duration. If
<code>future_to_try</code> finishes first, <code>race</code> will return <code>Left</code> with the output from
<code>future_to_try</code>. If <code>timer</code> finishes first, <code>race</code> will return <code>Right</code> with the
timer’s output of <code>()</code>.</p>
<p>我们还知道 <code>race</code> 是不公平的，按照参数传递的顺序轮询它们。因此，我们首先将 <code>future_to_try</code> 传递给 <code>race</code>，这样即使 <code>max_time</code> 非常短，它也有机会完成。如果 <code>future_to_try</code> 先完成，<code>race</code> 将返回 <code>Left</code>，其值是 <code>future_to_try</code> 的输出。如果 <code>timer</code> 先完成，<code>race</code> 将返回 <code>Right</code>，其值是计时器的输出 <code>()</code>。</p>
<p>In Listing 17-29, we match on the result of awaiting <code>trpl::race</code>.</p>
<p>在代码清单 17-29 中，我们匹配等待 <code>trpl::race</code> 的结果。</p>
<figure class="listing" id="listing-17-29">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-29">Listing 17-29</a>: Defining <code>timeout</code> with <code>race</code> and <code>sleep</code> 用 <code>race</code> 和 <code>sleep</code> 定义 <code>timeout</code></figcaption>
</figure>
<p>If the <code>future_to_try</code> succeeds and we get a <code>Left(output)</code>, we return
<code>Ok(output)</code>. If the sleep timer elapses instead and we get a <code>Right(())</code>, we
ignore the <code>()</code> with <code>_</code> and return <code>Err(max_time)</code> instead.</p>
<p>如果 <code>future_to_try</code> 成功并且我们得到 <code>Left(output)</code>，我们就返回 <code>Ok(output)</code>。如果睡眠计时器先结束而我们得到 <code>Right(())</code>，我们用 <code>_</code> 忽略 <code>()</code>，然后返回 <code>Err(max_time)</code>。</p>
<p>With that, we have a working <code>timeout</code> built out of two other async helpers. If
we run our code, it will print the failure mode after the timeout:</p>
<p>就这样，我们有了一个由另外两个异步辅助函数构建的工作中的 <code>timeout</code>。如果我们运行我们的代码，它将在超时后打印失败模式：</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>Because futures compose with other futures, you can build really powerful tools
using smaller async building blocks. For example, you can use this same approach
to combine timeouts with retries, and in turn use those with operations such as
network calls (one of the examples from the beginning of the chapter).</p>
<p>因为 Future 可以与其他 Future 组合，你可以使用较小的异步构建块构建非常强大的工具。例如，你可以使用相同的方法将超时与重试结合起来，反过来又可以将这些用于网络调用等操作（本章开头提到的例子之一）。</p>
<p>In practice, you’ll usually work directly with <code>async</code> and <code>await</code>, and
secondarily with functions and macros such as <code>join</code>, <code>join_all</code>, <code>race</code>, and so
on. You’ll only need to reach for <code>pin</code> now and again to use futures with those
APIs.</p>
<p>在实践中，你通常会直接使用 <code>async</code> 和 <code>await</code>，其次使用像 <code>join</code>、<code>join_all</code>、<code>race</code> 等函数和宏。你只需要偶尔使用 <code>pin</code> 来配合这些 API 使用 Future。</p>
<p>We’ve now seen a number of ways to work with multiple futures at the same
time. Up next, we’ll look at how we can work with multiple futures in a
sequence over time with <em>streams</em>. Here are a couple more things you might want
to consider first, though:</p>
<p>我们现在已经看到了多种同时处理多个 Future 的方法。接下来，我们将看看如何使用<em>流</em>（streams）按时间顺序处理多个 Future。不过，这里还有几件事你可能想先考虑一下：</p>
<ul>
<li>We used a <code>Vec</code> with <code>join_all</code> to wait for all of the futures in some group
to finish. How could you use a <code>Vec</code> to process a group of futures in
sequence instead? What are the tradeoffs of doing that?</li>
<li>我们使用带有 <code>join_all</code> 的 <code>Vec</code> 来等待某个组中的所有 Future 完成。你如何使用 <code>Vec</code> 来<em>按顺序</em>处理一组 Future？这样做的权衡是什么？</li>
<li>Take a look at the <code>futures::stream::FuturesUnordered</code> type from the <code>futures</code>
crate. How would using it be different from using a <code>Vec</code>? (Don’t worry about
the fact that it’s from the <code>stream</code> part of the crate; it works just fine
with any collection of futures.)</li>
<li>看看 <code>futures</code> crate 中的 <code>futures::stream::FuturesUnordered</code> 类型。使用它与使用 <code>Vec</code> 有什么不同？（不用担心它来自 crate 的 <code>stream</code> 部分；它与任何 Future 集合一起工作得很好。）</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
