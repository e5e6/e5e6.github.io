<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros 宏 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="macros-宏"><a class="header" href="#macros-宏">Macros 宏</a></h2>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds
of <em>procedural</em> macros:</p>
<p>我们在本书中一直使用像 <code>println!</code> 这样的宏，但还没有深入探讨宏是什么以及它是如何工作的。术语 <em>宏</em> 指的是 Rust 中的一系列功能：使用 <code>macro_rules!</code> 的 <em>声明式</em> 宏，以及三种 <em>过程式</em> 宏：</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<!-- -->
<ul>
<li>自定义 <code>#[derive]</code> 宏：用于在结构体和枚举上通过 <code>derive</code> 属性指定添加的代码</li>
<li>类属性宏：可定义适用于任意项目的自定义属性</li>
<li>类函数宏：外观类似函数调用，但作用于作为参数指定的令牌</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<p>我们将依次讨论这些宏，但首先，让我们看看既然已有函数，为什么还需要宏。</p>
<h3 id="the-difference-between-macros-and-functions-宏与函数的区别"><a class="header" href="#the-difference-between-macros-and-functions-宏与函数的区别">The Difference Between Macros and Functions 宏与函数的区别</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We’ve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you’ve written manually.</p>
<p>从根本上说，宏是一种编写代码来生成其他代码的方式，这被称为 <em>元编程</em>。在附录 C 中，我们讨论了 <code>derive</code> 属性，它会为你生成各种 trait 的实现。我们在书中也使用了 <code>println!</code> 和 <code>vec!</code> 宏。所有这些宏都会通过 <em>展开</em> 生成比你手动编写的代码更多的代码。</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t have.</p>
<p>元编程有助于减少需要编写和维护的代码量，这也是函数的作用之一。然而，宏具备一些函数所没有的额外能力。</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!("hello")</code> with one argument or
<code>println!("hello {}", name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>函数的签名必须声明其参数的个数和类型。而宏可以接受可变数量的参数：我们可以用一个参数调用 <code>println!("hello")</code>，也可以用两个参数调用 <code>println!("hello {}", name)</code>。此外，宏在编译器解释代码含义之前就已展开，因此宏可以在给定类型上实现 trait。函数则无法做到这一点，因为它是在运行时被调用的，而 trait 需要在编译时实现。</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>与函数相比，实现宏的缺点在于宏定义比函数定义更复杂，因为你需要编写生成 Rust 代码的 Rust 代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<p>宏与函数的另一个重要区别是：在文件中调用宏之前，必须先定义宏或将其引入作用域；而函数则可以在任意位置定义并在任意位置调用。</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming-使用-macro_rules-的声明式宏进行通用元编程"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming-使用-macro_rules-的声明式宏进行通用元编程">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming 使用 <code>macro_rules!</code> 的声明式宏进行通用元编程</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These
are also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,”
or just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resultant value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.</p>
<p>Rust 中最广泛使用的宏形式是 <em>声明式宏</em>。它们有时也被称为“示例宏”、“<code>macro_rules!</code> 宏”或简称为“宏”。声明式宏的核心是允许你编写类似于 Rust <code>match</code> 表达式的结构。如第 6 章所述，<code>match</code> 表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也会将值与特定代码的模式进行比较：在这种情况下，值是将传递给宏的原始 Rust 源代码；模式与该源代码的结构进行比较；当匹配时，与每个模式关联的代码将替换传递给宏的代码。这一切都发生在编译期间。</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:</p>
<p>要定义宏，需要使用 <code>macro_rules!</code> 结构。让我们通过了解 <code>vec!</code> 宏的定义方式来探索如何使用 <code>macro_rules!</code>。第 8 章介绍了如何使用 <code>vec!</code> 宏创建包含特定值的新向量。例如，以下宏创建了一个包含三个整数的新向量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.</p>
<p>我们也可以用 <code>vec!</code> 宏创建包含两个整数的向量或包含五个字符串切片的向量。我们无法使用函数实现相同的功能，因为无法提前知道值的数量或类型。</p>
<p>Listing 20-35 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<p>代码清单 20-35 展示了 <code>vec!</code> 宏的一个略微简化的定义。</p>
<figure class="listing" id="listing-20-35">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<figcaption><a href="#listing-20-35">Listing 20-35</a>: A simplified version of the <code>vec!</code> macro definition <code>vec!</code> 宏定义的简化版本</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to pre-allocate the correct amount of memory up front. That code
is an optimization that we don’t include here, to make the example simpler.</p>
<p>注意：标准库中 <code>vec!</code> 宏的实际定义包含预先分配正确内存量的代码。这段代码是优化措施，为使示例简单，此处未包含。</p>
</section>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.</p>
<p><code>#[macro_export]</code> 注解表示每当定义宏的 crate 被引入作用域时，此宏都应可用。没有此注解，宏将无法被引入作用域。</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we’re defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>接着我们以 <code>macro_rules!</code> 和要定义的宏名称（<em>不带</em> 感叹号）开始宏定义。这里的名称是 <code>vec</code>，后面跟着表示宏定义主体的花括号。</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.</p>
<p><code>vec!</code> 主体中的结构类似于 <code>match</code> 表达式的结构。这里我们有一个模式为 <code>( $( $x:expr ),* )</code> 的分支，后跟 <code>=&gt;</code> 和与此模式关联的代码块。如果模式匹配，将生成关联的代码块。鉴于这是此宏中唯一的模式，只有一种有效的匹配方式；任何其他模式都将导致错误。更复杂的宏会有多个分支。</p>
<p>Valid pattern syntax in macro definitions is different from the pattern syntax
covered in Chapter 19 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 20-29 mean; for the full macro pattern syntax, see the Rust
Reference.</p>
<p>宏定义中的有效模式语法与第 19 章介绍的模式语法不同，因为宏模式是针对 Rust 代码结构进行匹配，而不是针对值。让我们逐步分析代码清单 20-29 中模式各部分的意义；完整的宏模式语法请参阅 Rust 参考手册。</p>
<p>First we use a set of parentheses to encompass the whole pattern. We use a
dollar sign (<code>$</code>) to declare a variable in the macro system that will contain
the Rust code matching the pattern. The dollar sign makes it clear this is a
macro variable as opposed to a regular Rust variable. Next comes a set of
parentheses that captures values that match the pattern within the parentheses
for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any
Rust expression and gives the expression the name <code>$x</code>.</p>
<p>首先，我们使用一对括号包裹整个模式。我们在宏系统中使用美元符号 (<code>$</code>) 声明一个变量，该变量将包含与模式匹配的 Rust 代码。美元符号明确表示这是一个宏变量，而非普通的 Rust 变量。接下来是一对括号，用于捕获括号内与模式匹配的值，以便在替换代码中使用。在 <code>$()</code> 内部是 <code>$x:expr</code>，它匹配任何 Rust 表达式并将该表达式命名为 <code>$x</code>。</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
must appear between each instance of the code that matches the code in <code>$()</code>.
The <code>*</code> specifies that the pattern matches zero or more of whatever precedes
the <code>*</code>.</p>
<p><code>$()</code> 后面的逗号表示在匹配 <code>$()</code> 中代码的每个实例之间必须出现一个字面逗号分隔符。<code>*</code> 指定该模式匹配零次或多次 <code>*</code> 前面的内容。</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>当我们用 <code>vec![1, 2, 3];</code> 调用此宏时，<code>$x</code> 模式会匹配三次，分别对应表达式 <code>1</code>、<code>2</code> 和 <code>3</code>。</p>
<p>Now let’s look at the pattern in the body of the code associated with this arm:
<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>
in the pattern zero or more times depending on how many times the pattern
matches. The <code>$x</code> is replaced with each expression matched. When we call this
macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call
will be the following:</p>
<p>现在让我们看与此分支主体中模式关联的代码：<code>$()*</code> 内的 <code>temp_vec.push()</code> 会根据模式匹配 <code>$()</code> 的次数生成零次或多次。<code>$x</code> 被替换为每个匹配的表达式。当我们用 <code>vec![1, 2, 3];</code> 调用此宏时，替换此宏调用的生成代码将如下：</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>我们定义了一个可以接受任意数量、任意类型参数，并能生成代码来创建包含指定元素的向量的宏。</p>
<p>To learn more about how to write macros, consult the online documentation or
other resources, such as “The Little Book of Rust Macros” started by
Daniel Keep and continued by Lukas Wirth.</p>
<p>要了解更多关于编写宏的信息，请查阅在线文档或其他资源，例如由 Daniel Keep 发起、Lukas Wirth 继续维护的“The Little Book of Rust Macros”。</p>
<h3 id="procedural-macros-for-generating-code-from-attributes-用于从属性生成代码的过程式宏"><a class="header" href="#procedural-macros-for-generating-code-from-attributes-用于从属性生成代码的过程式宏">Procedural Macros for Generating Code from Attributes 用于从属性生成代码的过程式宏</a></h3>
<p>The second form of macros is the procedural macro, which acts more like a
function (and is a type of procedure). <em>Procedural macros</em> accept some code as
an input, operate on that code, and produce some code as an output rather than
matching against patterns and replacing the code with other code as declarative
macros do. The three kinds of procedural macros are custom <code>derive</code>,
attribute-like, and function-like, and all work in a similar fashion.</p>
<p>第二种宏形式是过程式宏，它的行为更像函数（并且是一种过程）。<em>过程式宏</em> 接受一些代码作为输入，对这些代码进行操作，然后生成一些代码作为输出，而不是像声明式宏那样匹配模式并用其他代码替换代码。过程式宏的三种类型是自定义 <code>derive</code>、类属性和类函数宏，它们的工作方式相似。</p>
<p>When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. In Listing 20-36, we show how to define a
procedural macro, where <code>some_attribute</code> is a placeholder for using a specific
macro variety.</p>
<p>创建过程式宏时，其定义必须位于具有特殊 crate 类型的独立 crate 中。这是出于复杂的技术原因，我们希望将来能消除此限制。在代码清单 20-36 中，我们展示了如何定义过程式宏，其中 <code>some_attribute</code> 是使用特定宏变体的占位符。</p>
<figure class="listing" id="listing-20-36">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<figcaption><a href="#listing-20-36">Listing 20-36</a>: An example of defining a procedural macro 定义过程式宏的示例</figcaption>
</figure>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input
and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by
the <code>proc_macro</code> crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input <code>TokenStream</code>, and the code the macro produces
is the output <code>TokenStream</code>. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.</p>
<p>定义过程式宏的函数接受一个 <code>TokenStream</code> 作为输入，并生成一个 <code>TokenStream</code> 作为输出。<code>TokenStream</code> 类型由 Rust 附带的 <code>proc_macro</code> crate 定义，表示一系列令牌。这是宏的核心：宏操作所针对的源代码构成输入 <code>TokenStream</code>，而宏生成的代码则是输出 <code>TokenStream</code>。该函数还附加了一个属性，用于指定我们正在创建的过程式宏的类型。我们可以在同一个 crate 中包含多种过程式宏。</p>
<p>Let’s look at the different kinds of procedural macros. We’ll start with a
custom <code>derive</code> macro and then explain the small dissimilarities that make the
other forms different.</p>
<p>让我们看看不同类型的过程式宏。我们将从自定义 <code>derive</code> 宏开始，然后解释其他形式的不同之处。</p>
<h3 id="how-to-write-a-custom-derive-macro-如何编写自定义-derive-宏"><a class="header" href="#how-to-write-a-custom-derive-macro-如何编写自定义-derive-宏">How to Write a Custom <code>derive</code> Macro 如何编写自定义 <code>derive</code> 宏</a></h3>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our users implement the <code>HelloMacro</code> trait for each of their types,
we’ll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 20-37 using our crate.</p>
<p>让我们创建一个名为 <code>hello_macro</code> 的 crate，其中定义了一个名为 <code>HelloMacro</code> 的 trait，该 trait 有一个名为 <code>hello_macro</code> 的关联函数。我们不是让用户为每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程式宏，以便用户可以通过 <code>#[derive(HelloMacro)]</code> 注解其类型，从而获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如代码清单 20-37 所示的代码。</p>
<figure class="listing" id="listing-20-37">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-37">Listing 20-37</a>: The code a user of our crate will be able to write when using our procedural macro 用户在使用我们的过程式宏时可编写的代码</figcaption>
</figure>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The
first step is to make a new library crate, like this:</p>
<p>完成后，此代码将打印 <code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库 crate，如下所示：</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, in Listing 20-38, we’ll define the <code>HelloMacro</code> trait and its associated
function.</p>
<p>接下来，在代码清单 20-38 中，我们将定义 <code>HelloMacro</code> trait 及其关联函数。</p>
<figure class="listing" id="listing-20-38">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-38">Listing 20-38</a>: A simple trait that we will use with the <code>derive</code> macro 我们将与 <code>derive</code> 宏一起使用的简单 trait</figcaption>
</figure>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, as in Listing 20-39.</p>
<p>我们定义了一个 trait 及其函数。此时，我们的 crate 用户可以通过实现该 trait 来实现所需功能，如代码清单 20-39 所示。</p>
<figure class="listing" id="listing-20-39">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-39">Listing 20-39</a>: How it would look if users wrote a manual implementation of the <code>HelloMacro</code> trait 如果用户手动实现 <code>HelloMacro</code> trait 时的代码</figcaption>
</figure>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>但是，他们需要为他们希望与 <code>hello_macro</code> 一起使用的每个类型编写实现块；我们想让他们省去这项工作。</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.</p>
<p>此外，我们还无法为 <code>hello_macro</code> 函数提供默认实现来打印实现该 trait 的类型的名称：Rust 不具备反射能力，因此无法在运行时查找类型的名称。我们需要一个在编译时生成代码的宏。</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom <code>derive</code> procedural macro crate is
called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<p>下一步是定义过程式宏。在撰写本文时，过程式宏需要位于它们自己的 crate 中。最终，此限制可能会被取消。组织 crate 和宏 crate 的约定如下：对于名为 <code>foo</code> 的 crate，自定义 <code>derive</code> 过程式宏 crate 称为 <code>foo_derive</code>。让我们在 <code>hello_macro</code> 项目中启动一个名为 <code>hello_macro_derive</code> 的新 crate：</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we’ll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don’t want the
<code>derive</code> functionality.</p>
<p>我们的两个 crate 紧密相关，因此我们在 <code>hello_macro</code> crate 的目录中创建过程式宏 crate。如果我们更改 <code>hello_macro</code> 中的 trait 定义，也必须更改 <code>hello_macro_derive</code> 中过程式宏的实现。这两个 crate 需要单独发布，使用这些 crate 的程序员需要将两者都添加为依赖项并引入作用域。或者，我们可以让 <code>hello_macro</code> crate 使用 <code>hello_macro_derive</code> 作为依赖项并重新导出过程式宏代码。然而，我们构建项目的方式使得程序员即使不需要 <code>derive</code> 功能也可以使用 <code>hello_macro</code>。</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p>我们需要将 <code>hello_macro_derive</code> crate 声明为过程式宏 crate。我们还需要 <code>syn</code> 和 <code>quote</code> crate 的功能，稍后你会看到，因此需要将它们添加为依赖项。将以下内容添加到 <code>hello_macro_derive</code> 的 <em>Cargo.toml</em> 文件中：</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/Cargo.toml</span>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</figure>
<p>To start defining the procedural macro, place the code in Listing 20-40 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p>要开始定义过程式宏，请将代码清单 20-40 中的代码放入 <code>hello_macro_derive</code> crate 的 <em>src/lib.rs</em> 文件中。请注意，在添加 <code>impl_hello_macro</code> 函数的定义之前，此代码不会编译。</p>
<figure class="listing" id="listing-20-40">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&amp;ast)
}</code></pre>
<figcaption><a href="#listing-20-40">Listing 20-40</a>: Code that most procedural macro crates will require in order to process Rust code 大多数过程式宏 crate 处理 Rust 代码所需的代码</figcaption>
</figure>
<p>Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which
is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(<code>hello_macro_derive</code> in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (<code>impl_hello_macro</code> in this case) will be different
depending on your procedural macro’s purpose.</p>
<p>请注意，我们将代码拆分为 <code>hello_macro_derive</code> 函数（负责解析 <code>TokenStream</code>）和 <code>impl_hello_macro</code> 函数（负责转换语法树）：这使得编写过程式宏更加方便。外部函数（此处为 <code>hello_macro_derive</code>）的代码几乎与你看到或创建的每个过程式宏 crate 相同。内部函数（此处为 <code>impl_hello_macro</code>）主体中指定的代码将根据过程式宏的目的而有所不同。</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <code>syn</code>,
and <code>quote</code>. The <code>proc_macro</code> crate comes with Rust,
so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. The
<code>proc_macro</code> crate is the compiler’s API that allows us to read and manipulate
Rust code from our code.</p>
<p>我们引入了三个新的 crate：<code>proc_macro</code>、<code>syn</code> 和 <code>quote</code>。<code>proc_macro</code> crate 随 Rust 一起提供，因此无需将其添加到 <em>Cargo.toml</em> 的依赖项中。<code>proc_macro</code> crate 是编译器的 API，允许我们从代码中读取和操作 Rust 代码。</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we
can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.</p>
<p><code>syn</code> crate 将 Rust 代码从字符串解析为我们可以执行操作的数据结构。<code>quote</code> crate 将 <code>syn</code> 数据结构转换回 Rust 代码。这些 crate 极大地简化了解析我们可能希望处理的任何类型的 Rust 代码：为 Rust 代码编写完整的解析器并非易事。</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve
annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and
specified the name <code>HelloMacro</code>, which matches our trait name; this is the
convention most procedural macros follow.</p>
<p>当库用户在类型上指定 <code>#[derive(HelloMacro)]</code> 时，将调用 <code>hello_macro_derive</code> 函数。这是可行的，因为我们在此处用 <code>proc_macro_derive</code> 注解了 <code>hello_macro_derive</code> 函数，并指定了名称 <code>HelloMacro</code>，这与我们的 trait 名称相匹配；这是大多数过程式宏遵循的约定。</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a
<code>TokenStream</code> to a data structure that we can then interpret and perform
operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in
<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the
parsed Rust code. Listing 20-41 shows the relevant parts of the <code>DeriveInput</code>
struct we get from parsing the <code>struct Pancakes;</code> string.</p>
<p><code>hello_macro_derive</code> 函数首先将 <code>input</code> 从 <code>TokenStream</code> 转换为我们可以解释和执行操作的数据结构。这就是 <code>syn</code> 发挥作用的地方。<code>syn</code> 中的 <code>parse</code> 函数接受 <code>TokenStream</code> 并返回一个表示已解析 Rust 代码的 <code>DeriveInput</code> 结构体。代码清单 20-41 展示了通过解析 <code>struct Pancakes;</code> 字符串得到的 <code>DeriveInput</code> 结构体的相关部分。</p>
<figure class="listing" id="listing-20-41">
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<figcaption><a href="#listing-20-41">Listing 20-41</a>: The <code>DeriveInput</code> instance we get when parsing the code that has the macro’s attribute in Listing 20-37 解析包含代码清单 20-37 中宏属性的代码时得到的 <code>DeriveInput</code> 实例</figcaption>
</figure>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (<em>identifier</em>, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <code>syn</code>
documentation for <code>DeriveInput</code> for more information.</p>
<p>此结构体的字段表明我们解析的 Rust 代码是一个单元结构体，其 <code>ident</code>（标识符，即名称）为 <code>Pancakes</code>。此结构体上还有更多字段用于描述各种 Rust 代码；有关更多信息，请参阅 <code>syn</code> 文档中关于 <code>DeriveInput</code> 的部分。</p>
<p>Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our <code>derive</code> macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
<code>TokenStream</code>.</p>
<p>稍后我们将定义 <code>impl_hello_macro</code> 函数，用于构建我们希望包含的新 Rust 代码。但在此之前，请注意我们的 <code>derive</code> 宏的输出也是一个 <code>TokenStream</code>。返回的 <code>TokenStream</code> 会添加到 crate 用户编写的代码中，因此当他们编译其 crate 时，将获得我们在修改后的 <code>TokenStream</code> 中提供的额外功能。</p>
<p>You might have noticed that we’re calling <code>unwrap</code> to cause the
<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function
fails here. It’s necessary for our procedural macro to panic on errors because
<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to
conform to the procedural macro API. We’ve simplified this example by using
<code>unwrap</code>; in production code, you should provide more specific error messages
about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>你可能注意到我们调用了 <code>unwrap</code>，如果对 <code>syn::parse</code> 函数的调用在此处失败，会导致 <code>hello_macro_derive</code> 函数 panic。过程式宏在出错时 panic 是必要的，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> 以符合过程式宏 API。我们通过使用 <code>unwrap</code> 简化了此示例；在生产代码中，应使用 <code>panic!</code> 或 <code>expect</code> 提供关于出错原因的更具体错误消息。</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let’s generate the code that implements the
<code>HelloMacro</code> trait on the annotated type, as shown in Listing 20-42.</p>
<p>现在我们有了将带注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们在带注解的类型上生成实现 <code>HelloMacro</code> trait 的代码，如代码清单 20-42 所示。</p>
<figure class="listing" id="listing-20-42">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}</code></pre>
<figcaption><a href="#listing-20-42">Listing 20-42</a>: Implementing the <code>HelloMacro</code> trait using the parsed Rust code 使用解析后的 Rust 代码实现 <code>HelloMacro</code> trait</figcaption>
</figure>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 20-41 shows that when
we run the <code>impl_hello_macro</code> function on the code in Listing 20-37, the
<code>ident</code> we get will have the <code>ident</code> field with a value of <code>"Pancakes"</code>. Thus
the <code>name</code> variable in Listing 20-42 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>"Pancakes"</code>, the name of the struct in
Listing 20-37.</p>
<p>我们使用 <code>ast.ident</code> 获取包含带注解类型名称（标识符）的 <code>Ident</code> 结构体实例。代码清单 20-41 中的结构体表明，当我们在代码清单 20-37 中的代码上运行 <code>impl_hello_macro</code> 函数时，得到的 <code>ident</code> 的 <code>ident</code> 字段值为 <code>"Pancakes"</code>。因此，代码清单 20-42 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时将是字符串 <code>"Pancakes"</code>，即代码清单 20-37 中结构体的名称。</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the <code>quote!</code>
macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by
calling the <code>into</code> method, which consumes this intermediate representation and
returns a value of the required <code>TokenStream</code> type.</p>
<p><code>quote!</code> 宏让我们能够定义希望返回的 Rust 代码。编译器期望的内容与 <code>quote!</code> 宏执行的直接结果不同，因此我们需要将其转换为 <code>TokenStream</code>。我们通过调用 <code>into</code> 方法来实现，该方法会使用此中间表示并返回所需类型 <code>TokenStream</code> 的值。</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can
enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
<code>name</code>. You can even do some repetition similar to the way regular macros work.
Check out the <code>quote</code> crate’s docs for a thorough introduction.</p>
<p><code>quote!</code> 宏还提供了一些非常酷的模板机制：我们可以输入 <code>#name</code>，<code>quote!</code> 将用变量 <code>name</code> 中的值替换它。你甚至可以执行类似于常规宏工作的重复操作。有关完整介绍，请查看 <code>quote</code> crate 的文档。</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has the one function <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>我们希望过程式宏为用户注解的类型生成 <code>HelloMacro</code> trait 的实现，我们可以通过 <code>#name</code> 获取该类型。trait 实现有一个函数 <code>hello_macro</code>，其主体包含我们希望提供的功能：打印 <code>Hello, Macro! My name is</code>，然后是带注解类型的名称。</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>"1 + 2"</code>. This is different from <code>format!</code> or
<code>println!</code>, macros which evaluate the expression and then turn the result into
a <code>String</code>. There is a possibility that the <code>#name</code> input might be an
expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also
saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>这里使用的 <code>stringify!</code> 宏是 Rust 内置的。它接受一个 Rust 表达式（例如 <code>1 + 2</code>），并在编译时将该表达式转换为字符串字面量（例如 <code>"1 + 2"</code>）。这与 <code>format!</code> 或 <code>println!</code> 宏不同，后者会计算表达式然后将结果转换为 <code>String</code>。<code>#name</code> 输入可能是一个要逐字打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省一次内存分配。</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing
20-37 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they
would be regular dependencies; if not, you can specify them as <code>path</code>
dependencies as follows:</p>
<p>此时，在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 中，<code>cargo build</code> 应该都能成功完成。让我们将这些 crate 与代码清单 20-37 中的代码连接起来，看看过程式宏的实际效果！使用 <code>cargo new pancakes</code> 在你的 <em>projects</em> 目录中创建一个新的二进制项目。我们需要在 <code>pancakes</code> crate 的 <em>Cargo.toml</em> 中将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 添加为依赖项。如果你要将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/">crates.io</a>，它们将是常规依赖项；否则，可以将它们指定为 <code>path</code> 依赖项，如下所示：</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Put the code in Listing 20-37 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>将代码清单 20-37 中的代码放入 <em>src/main.rs</em>，然后运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code>。来自过程式宏的 <code>HelloMacro</code> trait 实现已被包含，而 <code>pancakes</code> crate 无需实现它；<code>#[derive(HelloMacro)]</code> 添加了 trait 实现。</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom
<code>derive</code> macros.</p>
<p>接下来，让我们探讨其他类型的过程式宏与自定义 <code>derive</code> 宏的区别。</p>
<h3 id="attribute-like-macros-类属性宏"><a class="header" href="#attribute-like-macros-类属性宏">Attribute-Like Macros 类属性宏</a></h3>
<p>Attribute-like macros are similar to custom <code>derive</code> macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They’re also more flexible: <code>derive</code> only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro. Say you have an attribute
named <code>route</code> that annotates functions when using a web application framework:</p>
<p>类属性宏类似于自定义 <code>derive</code> 宏，但它们不是为 <code>derive</code> 属性生成代码，而是允许你创建新属性。它们也更灵活：<code>derive</code> 仅适用于结构体和枚举；属性也可应用于其他项目，例如函数。以下是使用类属性宏的示例。假设在使用 Web 应用程序框架时，你有一个名为 <code>route</code> 的属性用于注解函数：</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:</p>
<p>此 <code>#[route]</code> 属性将由框架定义为过程式宏。宏定义函数的签名如下所示：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the
contents of the attribute: the <code>GET, "/"</code> part. The second is the body of the
item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest
of the function’s body.</p>
<p>这里，我们有两个 <code>TokenStream</code> 类型的参数。第一个用于属性的内容：<code>GET, "/"</code> 部分。第二个是属性所附加项目的主体：在本例中是 <code>fn index() {}</code> 和函数的其余主体。</p>
<p>Other than that, attribute-like macros work the same way as custom <code>derive</code>
macros: you create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<p>除此之外，类属性宏的工作方式与自定义 <code>derive</code> 宏相同：创建一个具有 <code>proc-macro</code> crate 类型的 crate，并实现一个生成所需代码的函数！</p>
<h3 id="function-like-macros-类函数宏"><a class="header" href="#function-like-macros-类函数宏">Function-Like Macros 类函数宏</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can only
be defined using the match-like syntax we discussed in “Declarative Macros with
<code>macro_rules!</code> for General Metaprogramming” earlier.
Function-like macros take a <code>TokenStream</code> parameter, and their definition
manipulates that <code>TokenStream</code> using Rust code as the other two types of
procedural macros do. An example of a function-like macro is an <code>sql!</code> macro
that might be called like so:</p>
<p>类函数宏定义了外观类似函数调用的宏。与 <code>macro_rules!</code> 宏类似，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code> 宏只能使用前面“使用 <code>macro_rules!</code> 的声明式宏进行通用元编程”中讨论的类匹配语法来定义。类函数宏接受一个 <code>TokenStream</code> 参数，其定义使用 Rust 代码操作该 <code>TokenStream</code>，就像其他两种过程式宏一样。类函数宏的一个例子是 <code>sql!</code> 宏，它可能被这样调用：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<p>此宏会解析其内部的 SQL 语句并检查其语法是否正确，这比 <code>macro_rules!</code> 宏能做的处理复杂得多。<code>sql!</code> 宏的定义如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>This definition is similar to the custom <code>derive</code> macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<p>此定义类似于自定义 <code>derive</code> 宏的签名：我们接收括号内的令牌，并返回希望生成的代码。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use
often, but you’ll know they’re available in very particular circumstances.
We’ve introduced several complex topics so that when you encounter them in
error message suggestions or in other people’s code, you’ll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>呼！现在你的工具箱中有一些 Rust 功能，可能不会经常使用，但你会知道它们在特定情况下是可用的。我们介绍了几个复杂的主题，以便当你在错误消息建议或他人代码中遇到它们时，能够识别这些概念和语法。使用本章作为参考来指导你找到解决方案。</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
<p>接下来，我们将把全书讨论的所有内容付诸实践，并再做一个项目！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
