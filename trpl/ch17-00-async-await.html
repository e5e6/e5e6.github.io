<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams 异步编程基础 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fundamentals-of-asynchronous-programming-async-await-futures-and-streams-异步编程基础"><a class="header" href="#fundamentals-of-asynchronous-programming-async-await-futures-and-streams-异步编程基础">Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams 异步编程基础</a></h1>
<p>Many operations we ask the computer to do can take a while to finish. It would
be nice if we could do something else while we are waiting for those
long-running processes to complete. Modern computers offer two techniques for
working on more than one operation at a time: parallelism and concurrency. Once
we start writing programs that involve parallel or concurrent operations,
though, we quickly encounter new challenges inherent to <em>asynchronous
programming</em>, where operations may not finish sequentially in the order they
were started. This chapter builds on Chapter 16’s use of threads for parallelism
and concurrency by introducing an alternative approach to asynchronous
programming: Rust’s Futures, Streams, the <code>async</code> and <code>await</code> syntax that
supports them, and the tools for managing and coordinating between asynchronous
operations.</p>
<p>我们要求计算机执行的许多操作可能需要一段时间才能完成。如果在等待这些长时间运行的过程完成时能做其他事情就好了。现代计算机提供了两种同时处理多个操作的技术：<strong>并行</strong>和<strong>并发</strong>。然而，一旦我们开始编写涉及并行或并发操作的程序，很快就会遇到<strong>异步编程</strong>固有的新挑战——操作可能不会按照启动顺序依次完成。本章在第16章使用线程实现并行与并发的基础上，介绍另一种异步编程方法：Rust 的 Future、Stream、支持它们的 <code>async</code> 和 <code>await</code> 语法，以及管理和协调异步操作的工具。</p>
<p>Let’s consider an example. Say you’re exporting a video you’ve created of a
family celebration, an operation that could take anywhere from minutes to hours.
The video export will use as much CPU and GPU power as it can. If you had only
one CPU core and your operating system didn’t pause that export until it
completed—that is, if it executed the export <em>synchronously</em>—you couldn’t do
anything else on your computer while that task was running. That would be a
pretty frustrating experience. Fortunately, your computer’s operating system
can, and does, invisibly interrupt the export often enough to let you get other
work done simultaneously.</p>
<p>考虑一个例子。假设你正在导出家庭庆祝活动的视频，该操作可能需要几分钟到几小时。视频导出会尽可能占用 CPU 和 GPU 资源。如果只有一个 CPU 核心，且操作系统在导出完成前不暂停（即<strong>同步</strong>执行导出），那么任务运行时你将无法在计算机上执行其他操作。这种体验相当令人沮丧。幸运的是，计算机操作系统能够（且确实）频繁地透明中断导出，让你同时完成其他工作。</p>
<p>Now say you’re downloading a video shared by someone else, which can also take a
while but does not take up as much CPU time. In this case, the CPU has to wait
for data to arrive from the network. While you can start reading the data once
it starts to arrive, it might take some time for all of it to show up. Even once
the data is all present, if the video is quite large, it could take at least a
second or two to load it all. That might not sound like much, but it’s a very
long time for a modern processor, which can perform billions of operations every
second. Again, your operating system will invisibly interrupt your program to
allow the CPU to perform other work while waiting for the network call to
finish.</p>
<p>再假设你正在下载他人分享的视频，这也需要时间但占用较少 CPU 时间。此时 CPU 需等待网络数据传输。虽然数据开始到达后即可读取，但全部数据到达可能需要时间。即使数据全部到位，若视频很大，加载也可能耗时一两秒。这对现代处理器来说很长（每秒可执行数十亿次操作）。同样，操作系统会透明中断程序，让 CPU 在等待网络调用完成时执行其他工作。</p>
<p>The video export is an example of a <em>CPU-bound</em> or <em>compute-bound</em> operation.
It’s limited by the computer’s potential data processing speed within the CPU or
GPU, and how much of that speed it can dedicate to the operation. The video
download is an example of an <em>IO-bound</em> operation, because it’s limited by the
speed of the computer’s <em>input and output</em>; it can only go as fast as the data
can be sent across the network.</p>
<p>视频导出是 <strong>CPU 密集型</strong>（或<strong>计算密集型</strong>）操作的例子，其性能受限于 CPU/GPU 的数据处理能力及分配给该操作的资源。视频下载则是 <strong>I/O 密集型</strong>操作的例子，因为它受限于计算机的<strong>输入/输出速度</strong>，只能以网络传输数据的速度进行。</p>
<p>In both of these examples, the operating system’s invisible interrupts provide a
form of concurrency. That concurrency happens only at the level of the entire
program, though: the operating system interrupts one program to let other
programs get work done. In many cases, because we understand our programs at a
much more granular level than the operating system does, we can spot
opportunities for concurrency that the operating system can’t see.</p>
<p>这两个例子中，操作系统的透明中断提供了并发性。但这种并发仅在程序级别发生：操作系统中断一个程序以让其他程序工作。通常，由于我们比操作系统更细致地理解程序，能发现操作系统无法察觉的并发机会。</p>
<p>For example, if we’re building a tool to manage file downloads, we should be
able to write our program so that starting one download won’t lock up the UI,
and users should be able to start multiple downloads at the same time. Many
operating system APIs for interacting with the network are <em>blocking</em>, though;
that is, they block the program’s progress until the data they’re processing is
completely ready.</p>
<p>例如，构建文件下载管理工具时，程序应支持启动下载时不锁定 UI，且用户应能同时启动多个下载。但许多与网络交互的操作系统 API 是<strong>阻塞的</strong>——即它们会阻塞程序进度，直到处理的数据完全就绪。</p>
<section class="note" aria-role="note">
<p>Note: This is how <em>most</em> function calls work, if you think about it. However,
the term <em>blocking</em> is usually reserved for function calls that interact with
files, the network, or other resources on the computer, because those are the
cases where an individual program would benefit from the operation being
<em>non</em>-blocking.</p>
<p>注意：细想之下，<strong>大多数</strong>函数调用都是如此。但术语<strong>阻塞</strong>通常专用于与文件、网络或其他计算机资源交互的函数调用，因为这些情况下单个程序会受益于<strong>非阻塞</strong>操作。</p>
</section>
<p>We could avoid blocking our main thread by spawning a dedicated thread to
download each file. However, the overhead of those threads would eventually
become a problem. It would be preferable if the call didn’t block in the first
place. It would also be better if we could write in the same direct style we use
in blocking code, similar to this:</p>
<p>可通过为每个文件下载生成专用线程来避免阻塞主线程。但线程开销最终会成为问题。理想情况下，调用本身应是非阻塞的，且能以类似阻塞代码的直接风格编写：</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>That is exactly what Rust’s <em>async</em> (short for <em>asynchronous</em>) abstraction gives
us. In this chapter, you’ll learn all about async as we cover the following
topics:</p>
<p>这正是 Rust 的<strong>异步</strong>（async）抽象提供的功能。本章将涵盖以下主题：</p>
<ul>
<li>
<p>How to use Rust’s <code>async</code> and <code>await</code> syntax</p>
</li>
<li>
<p>How to use the async model to solve some of the same challenges we looked at
in Chapter 16</p>
</li>
<li>
<p>How multithreading and async provide complementary solutions, that you can
combine in many cases</p>
</li>
<li>
<p>如何使用 Rust 的 <code>async</code> 和 <code>await</code> 语法</p>
</li>
<li>
<p>如何用异步模型解决第16章中的相同挑战</p>
</li>
<li>
<p>多线程与异步如何提供互补解决方案，并可在许多情况下结合使用</p>
</li>
</ul>
<p>Before we see how async works in practice, though, we need to take a short
detour to discuss the differences between parallelism and concurrency.</p>
<p>在实践异步之前，需简要讨论并行与并发的区别。</p>
<h3 id="parallelism-and-concurrency-并行与并发"><a class="header" href="#parallelism-and-concurrency-并行与并发">Parallelism and Concurrency 并行与并发</a></h3>
<p>We’ve treated parallelism and concurrency as mostly interchangeable so far. Now
we need to distinguish between them more precisely, because the differences will
show up as we start working.</p>
<p>此前我们几乎将并行与并发视为同义词。现在需要更精确区分，因为差异会在实际工作中显现。</p>
<p>Consider the different ways a team could split up work on a software project.
You could assign a single member multiple tasks, assign each member one task, or
use a mix of the two approaches.</p>
<p>考虑团队分工的不同方式：可分配单人多任务、每人单任务或混合模式。个人在任务完成前处理多个不同任务是<strong>并发</strong>。例如你在计算机上检出两个项目，当对一个项目感到厌倦或卡住时切换到另一个。作为个体，你无法同时推进两项任务，但可通过切换进行多任务处理（见图17-1）。</p>
<p>When an individual works on several different tasks before any of them is
complete, this is <em>concurrency</em>. Maybe you have two different projects checked
out on your computer, and when you get bored or stuck on one project, you switch
to the other. You’re just one person, so you can’t make progress on both tasks
at the exact same time, but you can multi-task, making progress on one at a time
by switching between them (see Figure 17-1).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="" />
<figcaption>Figure 17-1: A concurrent workflow, switching between Task A and Task B 在任务A和B之间切换的并发工作流</figcaption>
</figure>
<p>When the team splits up a group of tasks by having each member take one task and
work on it alone, this is <em>parallelism</em>. Each person on the team can make
progress at the exact same time (see Figure 17-2).</p>
<p>团队通过每人独立处理单一任务来分配工作是<strong>并行</strong>。团队成员可同时推进工作（见图17-2）。</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="" />
<figcaption>Figure 17-2: A parallel workflow, where work happens on Task A and Task B independently 任务A和B独立执行的并行工作流</figcaption>
</figure>
<p>In both of these workflows, you might have to coordinate between different
tasks. Maybe you <em>thought</em> the task assigned to one person was totally
independent from everyone else’s work, but it actually requires another person
on the team to finish their task first. Some of the work could be done in
parallel, but some of it was actually <em>serial</em>: it could only happen in a
series, one task after the other, as in Figure 17-3.</p>
<p>这两种工作流均需任务间协调。可能你以为分配给某人的任务完全独立，实则需等待他人完成任务。部分工作可并行，但部分实际是<strong>串行</strong>的——只能按顺序依次执行（见图17-3）。</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="" />
<figcaption>Figure 17-3: A partially parallel workflow, where work happens on Task A and Task B independently until Task A3 is blocked on the results of Task B3. 部分并行的工作流，任务A和B独立执行，直到任务A3被任务B3的结果阻塞</figcaption>
</figure>
<p>Likewise, you might realize that one of your own tasks depends on another of
your tasks. Now your concurrent work has also become serial.</p>
<p>同理，你可能发现自己的某个任务依赖于另一任务，此时并发工作也变为串行。</p>
<p>Parallelism and concurrency can intersect with each other, too. If you learn
that a colleague is stuck until you finish one of your tasks, you’ll probably
focus all your efforts on that task to “unblock” your colleague. You and your
coworker are no longer able to work in parallel, and you’re also no longer able
to work concurrently on your own tasks.</p>
<p>并行与并发也会交织。若得知同事因等待你的某项任务而受阻，你可能会全力完成该任务以“解锁“同事。此时你与同事无法并行工作，你自身也无法并发处理任务。</p>
<p>The same basic dynamics come into play with software and hardware. On a machine
with a single CPU core, the CPU can perform only one operation at a time, but it
can still work concurrently. Using tools such as threads, processes, and async,
the computer can pause one activity and switch to others before eventually
cycling back to that first activity again. On a machine with multiple CPU cores,
it can also do work in parallel. One core can be performing one task while
another core performs a completely unrelated one, and those operations actually
happen at the same time.</p>
<p>软件和硬件遵循相同原理。单核机器上，CPU 一次只能执行一个操作，但仍可并发工作。通过线程、进程和异步等工具，计算机可暂停活动并切换到其他任务，最终再切回。多核机器上还能并行工作——一个核心执行任务时，另一核心可执行完全不相关的任务，这些操作真正同时发生。</p>
<p>When working with async in Rust, we’re always dealing with concurrency.
Depending on the hardware, the operating system, and the async runtime we are
using (more on async runtimes shortly), that concurrency may also use parallelism
under the hood.</p>
<p>在 Rust 中使用异步时，我们始终处理并发。根据硬件、操作系统和使用的异步运行时（稍后详述），这种并发在底层也可能利用并行性。</p>
<p>Now, let’s dive into how async programming in Rust actually works.</p>
<p>现在深入探讨 Rust 异步编程的实际工作原理。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
