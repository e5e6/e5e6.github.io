<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Streams: Futures in Sequence 流：按顺序处理的 Future - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="streams-futures-in-sequence-流按顺序处理的-future"><a class="header" href="#streams-futures-in-sequence-流按顺序处理的-future">Streams: Futures in Sequence 流：按顺序处理的 Future</a></h2>
<p>So far in this chapter, we’ve mostly stuck to individual futures. The one big
exception was the async channel we used. Recall how we used the receiver for our
async channel earlier in this chapter in the “Message
Passing” section. The async <code>recv</code> method
produces a sequence of items over time. This is an instance of a much more
general pattern known as a <em>stream</em>.</p>
<p>本章到目前为止，我们主要专注于单个 Future。一个重要的例外是使用过的异步通道。回顾本章在“消息传递“部分使用异步通道接收器的方式：异步 <code>recv</code> 方法会随时间产生一系列项。这是更通用模式——<strong>流（stream）</strong>——的一个实例。</p>
<p>We saw a sequence of items back in Chapter 13, when we looked at the <code>Iterator</code>
trait in The Iterator Trait and the <code>next</code> Method section, but there are two differences between iterators and the async
channel receiver. The first difference is time: iterators are synchronous, while
the channel receiver is asynchronous. The second is the API. When working
directly with <code>Iterator</code>, we call its synchronous <code>next</code> method. With the
<code>trpl::Receiver</code> stream in particular, we called an asynchronous <code>recv</code> method
instead. Otherwise, these APIs feel very similar, and that similarity
isn’t a coincidence. A stream is like an asynchronous form of iteration. Whereas
the <code>trpl::Receiver</code> specifically waits to receive messages, though, the
general-purpose stream API is much broader: it provides the next item the
way <code>Iterator</code> does, but asynchronously.</p>
<p>我们在第13章讨论<code>Iterator</code>特性时就见过项的序列，但迭代器与异步通道接收器有两点区别。第一点是时间性：迭代器是同步的，而通道接收器是异步的。第二点是 API：直接使用 <code>Iterator</code> 时，我们调用其同步的 <code>next</code> 方法；而对于 <code>trpl::Receiver</code> 流，我们调用的是异步的 <code>recv</code> 方法。除此之外，这些 API 非常相似，这种相似性并非偶然。流就像是异步版本的迭代。虽然 <code>trpl::Receiver</code> 专门用于等待接收消息，但通用流 API 更为广泛：它像 <code>Iterator</code> 一样提供下一项，但采用异步方式。</p>
<p>The similarity between iterators and streams in Rust means we can actually
create a stream from any iterator. As with an iterator, we can work with a
stream by calling its <code>next</code> method and then awaiting the output, as in Listing
17-30.</p>
<p>Rust 中迭代器与流的相似性意味着我们实际上可以从任何迭代器创建流。如迭代器一样，我们可以通过调用流的 <code>next</code> 方法并等待其输出来处理流，如代码清单 17-30 所示。</p>
<p><span class="highlight">[note]注：<code>use tokio_stream::iter;</code></span></p>
<figure class="listing" id="listing-17-30">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-30">Listing 17-30</a>: Creating a stream from an iterator and printing its values 从迭代器创建流并打印其值</figcaption>
</figure>
<p>We start with an array of numbers, which we convert to an iterator and then call
<code>map</code> on to double all the values. Then we convert the iterator into a stream
using the <code>trpl::stream_from_iter</code> function. Next, we loop over the items in the
stream as they arrive with the <code>while let</code> loop.</p>
<p>我们从一个数字数组开始，将其转换为迭代器，然后调用 <code>map</code> 将所有值加倍。接着使用 <code>trpl::stream_from_iter</code> 函数将迭代器转换为流。然后使用 <code>while let</code> 循环遍历流中到达的项。</p>
<p>Unfortunately, when we try to run the code, it doesn’t compile, but instead it
reports that there’s no <code>next</code> method available:</p>
<p>遗憾的是，尝试运行此代码时无法编译，而是报告找不到 <code>next</code> 方法：</p>
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async-await/target/debug/deps/async_await-575db3dd3197d257.long-type-14490787947592691573.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>As this output explains, the reason for the compiler error is that we need the
right trait in scope to be able to use the <code>next</code> method. Given our discussion
so far, you might reasonably expect that trait to be <code>Stream</code>, but it’s actually
<code>StreamExt</code>. Short for <em>extension</em>, <code>Ext</code> is a common pattern in the
Rust community for extending one trait with another.</p>
<p>如输出所示，编译器报错的原因是需要将正确的特性引入作用域才能使用 <code>next</code> 方法。根据目前的讨论，你可能合理预期该特性是 <code>Stream</code>，但实际上是 <code>StreamExt</code>。<code>Ext</code> 是“扩展“（extension）的缩写，在 Rust 社区中是扩展特性的常见模式。</p>
<p>We’ll explain the <code>Stream</code> and <code>StreamExt</code> traits in a bit more detail at the
end of the chapter, but for now all you need to know is that the <code>Stream</code> trait
defines a low-level interface that effectively combines the <code>Iterator</code> and
<code>Future</code> traits. <code>StreamExt</code> supplies a higher-level set of APIs on top of
<code>Stream</code>, including the <code>next</code> method as well as other utility methods similar
to those provided by the <code>Iterator</code> trait. <code>Stream</code> and <code>StreamExt</code> are not yet
part of Rust’s standard library, but most ecosystem crates use the same
definition.</p>
<p>本章末尾会更详细解释 <code>Stream</code> 和 <code>StreamExt</code> 特性，目前只需知道：<span class="highlight">[note]<code>Stream</code> 特性定义了一个底层接口，有效结合了 <code>Iterator</code> 和 <code>Future</code> 特性；<code>StreamExt</code> 在 <code>Stream</code> 之上提供了一套高级 API，包括 <code>next</code> 方法以及其他类似 <code>Iterator</code> 特性的实用方法。</span><code>Stream</code> 和 <code>StreamExt</code> 尚未成为 Rust 标准库的一部分，但大多数生态库使用相同的定义。</p>
<p>The fix to the compiler error is to add a <code>use</code> statement for <code>trpl::StreamExt</code>,
as in Listing 17-31.</p>
<p>修复编译错误的方法是添加 <code>use trpl::StreamExt;</code> 语句，如代码清单 17-31 所示。</p>
<p><span class="highlight">[note]注：<code>use tokio_stream::StreamExt;</code></span></p>
<figure class="listing" id="listing-17-31">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption><a href="#listing-17-31">Listing 17-31</a>: Successfully using an iterator as the basis for a stream 成功使用迭代器作为流的基础</figcaption>
</figure>
<p>With all those pieces put together, this code works the way we want! What’s
more, now that we have <code>StreamExt</code> in scope, we can use all of its utility
methods, just as with iterators. For example, in Listing 17-32, we use the
<code>filter</code> method to filter out everything but multiples of three and five.</p>
<p>所有部分组合后，代码按预期工作！更重要的是，现在 <code>StreamExt</code> 在作用域中，我们可以使用其所有实用方法，就像使用迭代器一样。例如，在代码清单 17-32 中，我们使用 <code>filter</code> 方法过滤掉非 3 或 5 的倍数。</p>
<figure class="listing" id="listing-17-32">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption><a href="#listing-17-32">Listing 17-32</a>: Filtering a stream with the <code>StreamExt::filter</code> method 使用 <code>StreamExt::filter</code> 方法过滤流</figcaption>
</figure>
<p>Of course, this isn’t very interesting, since we could do the same with normal
iterators and without any async at all. Let’s look at what
we can do that <em>is</em> unique to streams.</p>
<p>当然，这并不有趣，因为用普通迭代器无需异步也能实现。现在来看<strong>流独有的功能</strong>。</p>
<h3 id="composing-streams-组合流"><a class="header" href="#composing-streams-组合流">Composing Streams 组合流</a></h3>
<p>Many concepts are naturally represented as streams: items becoming available in
a queue, chunks of data being pulled incrementally from the filesystem when the
full data set is too large for the computer’s memory, or data arriving over the
network over time. Because streams are futures, we can use them with any other
kind of future and combine them in interesting ways. For example, we can batch
up events to avoid triggering too many network calls, set timeouts on sequences
of long-running operations, or throttle user interface events to avoid doing
needless work.</p>
<p>许多概念天然适合用流表示：队列中可用的项、当数据集过大无法载入内存时从文件系统分块增量拉取的数据，或随时间到达的网络数据。由于流就是 Future，我们可以将它们与其他 Future 结合使用，实现有趣组合。例如：批量处理事件以减少网络调用、为长操作序列设置超时、或节流用户界面事件以避免冗余工作。</p>
<p>Let’s start by building a little stream of messages as a stand-in for a stream
of data we might see from a WebSocket or another real-time communication
protocol, as shown in Listing 17-33.</p>
<p>首先构建一个消息流作为 WebSocket 或其他实时通信协议的替身，如代码清单 17-33 所示。</p>
<p><span class="highlight">[note]注：<code>tokio_stream::wrappers::UnboundedReceiverStream</code></span></p>
<figure class="listing" id="listing-17-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="#listing-17-33">Listing 17-33</a>: Using the <code>rx</code> receiver as a <code>ReceiverStream</code> 将接收器 <code>rx</code> 用作 <code>ReceiverStream</code></figcaption>
</figure>
<p>First, we create a function called <code>get_messages</code> that returns <code>impl Stream&lt;Item  = String&gt;</code>. For its implementation, we create an async channel, loop over the
first 10 letters of the English alphabet, and send them across the channel.</p>
<p>首先创建返回 <code>impl Stream&lt;Item = String&gt;</code> 的函数 <code>get_messages</code>。在实现中，创建异步通道，遍历英文字母表前 10 个字母并通过通道发送。</p>
<p>We also use a new type: <code>ReceiverStream</code>, which converts the <code>rx</code> receiver from
the <code>trpl::channel</code> into a <code>Stream</code> with a <code>next</code> method. Back in <code>main</code>, we use
a <code>while let</code> loop to print all the messages from the stream.</p>
<p>这里使用了<span class="highlight">[note]新类型 <code>ReceiverStream</code>，它将 <code>trpl::channel</code> 的 <code>rx</code> 接收器转换为带 <code>next</code> 方法的 <code>Stream</code>。</span>在 <code>main</code> 中，使用 <code>while let</code> 循环打印流中的所有消息。</p>
<p>When we run this code, we get exactly the results we would expect:</p>
<p>运行代码将得到预期结果：</p>
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>Again, we could do this with the regular <code>Receiver</code> API or even the regular
<code>Iterator</code> API, though, so let’s add a feature that requires streams: adding a
timeout that applies to every item in the stream, and a delay on the items we
emit, as shown in Listing 17-34.</p>
<p>虽然常规 <code>Receiver</code> API 或 <code>Iterator</code> API 也能实现此功能，现在添加流独有的特性：为流中每个项添加超时和延迟，如代码清单 17-34 所示。</p>
<figure class="listing" id="listing-17-34">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-34">Listing 17-34</a>: Using the <code>StreamExt::timeout</code> method to set a time limit on the items in a stream 使用 <code>StreamExt::timeout</code> 为流中的项设置时间限制</figcaption>
</figure>
<p>We start by adding a timeout to the stream with the <code>timeout</code> method, which
comes from the <code>StreamExt</code> trait. Then we update the body of the <code>while let</code>
loop, because the stream now returns a <code>Result</code>. The <code>Ok</code> variant indicates a
message arrived in time; the <code>Err</code> variant indicates that the timeout elapsed
before any message arrived. We <code>match</code> on that result and either print the
message when we receive it successfully or print a notice about the timeout.
Finally, notice that we pin the messages after applying the timeout to them,
because the timeout helper produces a stream that needs to be pinned to be
polled.</p>
<p>首先<span class="highlight">[note]使用 <code>StreamExt</code> 的 <code>timeout</code> 方法为流添加超时</span>。接着更新 <code>while let</code> 循环体，因为流现在返回 <code>Result</code>：<code>Ok</code> 变体表示消息及时到达；<code>Err</code> 变体表示超时后无消息到达。通过 <code>match</code> 处理结果：成功接收时打印消息，超时则打印通知。最后注意：<span class="highlight">[note]应用超时后需固定</span>（pin）消息，因为超时辅助器生成的流需要固定才能轮询（poll）。</p>
<p>However, because there are no delays between messages, this timeout does not
change the behavior of the program. Let’s add a variable delay to the messages
we send, as shown in Listing 17-35.</p>
<p>但由于消息间无延迟，超时不会改变程序行为。现在为发送的消息添加可变延迟，如代码清单 17-35 所示。</p>
<figure class="listing" id="listing-17-35">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="#listing-17-35">Listing 17-35</a>: Sending messages through <code>tx</code> with an async delay without making <code>get_messages</code> an async function 通过 <code>tx</code> 发送带异步延迟的消息（不将 <code>get_messages</code> 改为异步函数）</figcaption>
</figure>
<p>In <code>get_messages</code>, we use the <code>enumerate</code> iterator method with the <code>messages</code>
array so that we can get the index of each item we’re sending along with the
item itself. Then we apply a 100-millisecond delay to even-index items and a
300-millisecond delay to odd-index items to simulate the different delays we
might see from a stream of messages in the real world. Because our timeout is
for 200 milliseconds, this should affect half of the messages.</p>
<p>在 <code>get_messages</code> 中，对 <code>messages</code> 数组使用 <code>enumerate</code> 迭代器方法以获取索引。然后为偶数索引项添加 100 毫秒延迟，为奇数索引项添加 300 毫秒延迟，模拟真实消息流的差异延迟。由于超时为 200 毫秒，这将影响半数消息。</p>
<p>To sleep between messages in the <code>get_messages</code> function without blocking, we
need to use async. However, we can’t make <code>get_messages</code> itself into an async
function, because then we’d return a <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code>
instead of a <code>Stream&lt;Item = String&gt;&gt;</code>. The caller would have to await
<code>get_messages</code> itself to get access to the stream. But remember: everything in a
given future happens linearly; concurrency happens <em>between</em> futures. Awaiting
<code>get_messages</code> would require it to send all the messages, including the sleep
delay between each message, before returning the receiver stream. As a result,
the timeout would be useless. There would be no delays in the stream itself;
they would all happen before the stream was even available.</p>
<p>要在 <code>get_messages</code> 中非阻塞地睡眠，需使用异步。但<strong>不能</strong>将 <code>get_messages</code> 改为异步函数，否则将返回 <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> 而非 <code>Stream&lt;Item = String&gt;</code>。调用方需先等待 <code>get_messages</code> 才能获取流。注意：给定 Future 中的所有操作是线性的；并发发生在 Future <strong>之间</strong>。等待 <code>get_messages</code> 会要求其在返回接收器流前发送所有消息（含延迟），导致超时失效（流中无延迟）。</p>
<p>Instead, we leave <code>get_messages</code> as a regular function that returns a stream,
and we spawn a task to handle the async <code>sleep</code> calls.</p>
<p>因此，保持 <code>get_messages</code> 为返回流的常规函数，并生成任务处理异步 <code>sleep</code> 调用。</p>
<section class="note" aria-role="note">
<p>Note: Calling <code>spawn_task</code> in this way works because we already set up our
runtime; had we not, it would cause a panic. Other implementations choose
different tradeoffs: they might spawn a new runtime and avoid the panic but
end up with a bit of extra overhead, or they may simply not provide a
standalone way to spawn tasks without reference to a runtime. Make sure you
know what tradeoff your runtime has chosen and write your code accordingly!</p>
<p>注意：此方式调用 <code>spawn_task</code> 有效是因为已设置运行时；否则会 panic。其他实现可能选择不同权衡：生成新运行时（避免 panic 但增加开销），或不提供独立于运行时的任务生成方式。请根据所用运行时的设计编写代码！</p>
</section>
<p>Now our code has a much more interesting result. Between every other pair of
messages, a <code>Problem: Elapsed(())</code> error.</p>
<p>现在程序结果更有趣：在每对消息之间会出现 <code>Problem: Elapsed(())</code> 错误。</p>
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>The timeout doesn’t prevent the messages from arriving in the end. We still get
all of the original messages, because our channel is <em>unbounded</em>: it can hold as
many messages as we can fit in memory. If the message doesn’t arrive before the
timeout, our stream handler will account for that, but when it polls the stream
again, the message may now have arrived.</p>
<p>超时<strong>不会</strong>阻止消息最终到达。由于通道是<strong>无界</strong>的（可容纳任意多消息），所有原始消息仍会到达。若消息在超时前未到达，流处理器会处理该情况，但再次轮询流时消息可能已到达。</p>
<p>You can get different behavior if needed by using other kinds of channels or
other kinds of streams more generally. Let’s see one of those in practice by
combining a stream of time intervals with this stream of messages.</p>
<p>通过使用其他通道或流类型，可获得不同行为。现在通过将时间间隔流与消息流结合来实践这一点。</p>
<h3 id="merging-streams-合并流"><a class="header" href="#merging-streams-合并流">Merging Streams 合并流</a></h3>
<p>First, let’s create another stream, which will emit an item every millisecond if
we let it run directly. For simplicity, we can use the <code>sleep</code> function to send
a message on a delay and combine it with the same approach we used in
<code>get_messages</code> of creating a stream from a channel. The difference is that this
time, we’re going to send back the count of intervals that have elapsed, so the
return type will be <code>impl Stream&lt;Item = u32&gt;</code>, and we can call the function
<code>get_intervals</code> (see Listing 17-36).</p>
<p>首先创建另一个流：若直接运行，该流每毫秒发射一个项。简化为：使用 <code>sleep</code> 函数在延迟后发送消息，并采用与 <code>get_messages</code> 相同的通道流方法。区别在于：此次发送已过去的时间间隔计数，因此返回类型为 <code>impl Stream&lt;Item = u32&gt;</code>，函数命名为 <code>get_intervals</code>（见代码清单 17-36）。</p>
<figure class="listing" id="listing-17-36">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="#listing-17-36">Listing 17-36</a>: Creating a stream with a counter that will be emitted once every millisecond 创建每毫秒发射计数器的流</figcaption>
</figure>
<p>We start by defining a <code>count</code> in the task. (We could define it outside the
task, too, but it’s clearer to limit the scope of any given variable.) Then we
create an infinite loop. Each iteration of the loop asynchronously sleeps for
one millisecond, increments the count, and then sends it over the channel.
Because this is all wrapped in the task created by <code>spawn_task</code>, all of
it—including the infinite loop—will get cleaned up along with the runtime.</p>
<p>首先在任务中定义 <code>count</code>（也可定义在任务外，但限定变量作用域更清晰）。然后创建无限循环：每次迭代异步睡眠 1 毫秒，增加计数并通过通道发送。由于所有操作封装在 <code>spawn_task</code> 生成的任务中，包括无限循环在内的内容都会随运行时清理。</p>
<p>This kind of infinite loop, which ends only when the whole runtime gets torn
down, is fairly common in async Rust: many programs need to keep running
indefinitely. With async, this doesn’t block anything else, as long as there is
at least one await point in each iteration through the loop.</p>
<p>此类无限循环（仅在整个运行时关闭时结束）在异步 Rust 中很常见：许多程序需永久运行。只要有 await 点，异步就不会阻塞其他操作。</p>
<p>Now, back in our main function’s async block, we can attempt to merge the
<code>messages</code> and <code>intervals</code> streams, as shown in Listing 17-37.</p>
<p>现在回到主函数的异步块，尝试合并 <code>messages</code> 和 <code>intervals</code> 流（见代码清单 17-37）。</p>
<figure class="listing" id="listing-17-37">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);

        while let Some(result) = merged.next().await {
<span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-37">Listing 17-37</a>: Attempting to merge the <code>messages</code> and <code>intervals</code> streams 尝试合并 <code>messages</code> 和 <code>intervals</code> 流</figcaption>
</figure>
<p>We start by calling <code>get_intervals</code>. Then we merge the <code>messages</code> and
<code>intervals</code> streams with the <code>merge</code> method, which combines multiple streams
into one stream that produces items from any of the source streams as soon as
the items are available, without imposing any particular ordering. Finally, we
loop over that combined stream instead of over <code>messages</code>.</p>
<p>首先调用 <code>get_intervals</code>，然后<span class="highlight">[note]使用 <code>merge</code> 方法合并</span> <code>messages</code> 和 <code>intervals</code> 流。该方法将多个流合并为一个流，在源流项可用时立即生成（不强制特定顺序）。最后遍历合并后的流而非 <code>messages</code>。</p>
<p>At this point, neither <code>messages</code> nor <code>intervals</code> needs to be pinned or mutable,
because both will be combined into the single <code>merged</code> stream. However, this
call to <code>merge</code> doesn’t compile! (Neither does the <code>next</code> call in the <code>while  let</code> loop, but we’ll come back to that.) This is because the two streams have
different types. The <code>messages</code> stream has the type <code>Timeout&lt;impl Stream&lt;Item =  String&gt;&gt;</code>, where <code>Timeout</code> is the type that implements <code>Stream</code> for a <code>timeout</code>
call. The <code>intervals</code> stream has the type <code>impl Stream&lt;Item = u32&gt;</code>. To merge
these two streams, we need to transform one of them to match the other. We’ll
rework the intervals stream, because messages is already in the basic format we
want and has to handle timeout errors (see Listing 17-38).</p>
<p>此时，<code>messages</code> 和 <code>intervals</code> 都无需固定或可变，因为它们将合并到单个 <code>merged</code> 流中。但此 <code>merge</code> 调用无法编译！（<code>while let</code> 循环中的 <code>next</code> 调用也不能编译，稍后处理。）原因是两个流类型不同：<code>messages</code> 是 <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code>（<code>Timeout</code> 是实现 <code>timeout</code> 调用的流类型）；<code>intervals</code> 是 <code>impl Stream&lt;Item = u32&gt;</code>。要合并需转换其中一个流。我们将重构 <code>intervals</code> 流，因为 <code>messages</code> 已是所需格式且需处理超时错误（见代码清单 17-38）。</p>
<figure class="listing" id="listing-17-38">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);

        while let Some(result) = stream.next().await {
<span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-38">Listing 17-38</a>: Aligning the type of the the <code>intervals</code> stream with the type of the <code>messages</code> stream 对齐 <code>intervals</code> 流与 <code>messages</code> 流的类型</figcaption>
</figure>
<p>First, we can use the <code>map</code> helper method to transform the <code>intervals</code> into a
string. Second, we need to match the <code>Timeout</code> from <code>messages</code>. Because we don’t
actually <em>want</em> a timeout for <code>intervals</code>, though, we can just create a timeout
which is longer than the other durations we are using. Here, we create a
10-second timeout with <code>Duration::from_secs(10)</code>. Finally, we need to make
<code>stream</code> mutable, so that the <code>while let</code> loop’s <code>next</code> calls can iterate
through the stream, and pin it so that it’s safe to do so. That gets us <em>almost</em>
to where we need to be. Everything type checks. If you run this, though, there
will be two problems. First, it will never stop! You’ll need to stop it with
<span class="keystroke">ctrl-c</span>. Second, the messages from the English
alphabet will be buried in the midst of all the interval counter messages:</p>
<p>首先使用 <code>map</code> 方法将 <code>intervals</code> 转换为字符串。其次需匹配 <code>messages</code> 的 <code>Timeout</code>。由于我们<strong>不需要</strong> <code>intervals</code> 的超时，可创建比其他持续时间更长的超时（此处为 10 秒）。最后需将 <code>stream</code> 设为可变以便 <code>while let</code> 循环调用 <code>next</code>，并固定它以保证安全。这<strong>几乎</strong>达到要求：类型检查通过。但运行时会遇到两个问题：1) 永不停止（需按 <span class="keystroke">ctrl-c</span> 终止）；2) 字母消息淹没在间隔计数消息中：</p>
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>Listing 17-39 shows one way to solve these last two problems.</p>
<p>代码清单 17-39 展示最后两个问题的解决方案。</p>
<figure class="listing" id="listing-17-39">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-39">Listing 17-39</a>: Using <code>throttle</code> and <code>take</code> to manage the merged streams 使用 <code>throttle</code> 和 <code>take</code> 管理合并流</figcaption>
</figure>
<p>First, we use the <code>throttle</code> method on the <code>intervals</code> stream so that it doesn’t
overwhelm the <code>messages</code> stream. <em>Throttling</em> is a way of limiting the rate at
which a function will be called—or, in this case, how often the stream will be
polled. Once every 100 milliseconds should do, because that’s roughly how often
our messages arrive.</p>
<p>首先在 <code>intervals</code> 流上<span class="highlight">[note]使用 <code>throttle</code> 方法，避免其淹没</span> <code>messages</code> 流。<strong>节流</strong>（throttling）用于限制函数调用频率（此处限制流轮询频率）。设为每 100 毫秒一次（接近消息到达频率）。</p>
<p>To limit the number of items we will accept from a stream, we apply the <code>take</code>
method to the <code>merged</code> stream, because we want to limit the final output, not
just one stream or the other.</p>
<p><span class="highlight">[note]为限制流的总处理量，对 <code>merged</code> 流应用 <code>take</code> 方法</span>（需限制最终输出而非单个流）。</p>
<p>Now when we run the program, it stops after pulling 20 items from the stream,
and the intervals don’t overwhelm the messages. We also don’t get <code>Interval:  100</code> or <code>Interval: 200</code> or so on, but instead get <code>Interval: 1</code>, <code>Interval: 2</code>,
and so on—even though we have a source stream that <em>can</em> produce an event every
millisecond. That’s because the <code>throttle</code> call produces a new stream that wraps
the original stream so that the original stream gets polled only at the throttle
rate, not its own “native” rate. We don’t have a bunch of unhandled interval
messages we’re choosing to ignore. Instead, we never produce those interval
messages in the first place! This is the inherent “laziness” of Rust’s futures
at work again, allowing us to choose our performance characteristics.</p>
<p>现在程序在从流中拉取 20 项后停止，且间隔消息不再淹没字母消息。虽然源流每毫秒可生成事件，但我们得到的是 <code>Interval: 1</code>、<code>Interval: 2</code> 等（而非 <code>Interval: 100</code>）。这是因为 <code>throttle</code> 调用产生的新流包装了原始流，使原始流仅按节流速率为轮询，而非“原生“速率。我们并非忽略未处理的间隔消息，而是<strong>从不生成</strong>这些消息！这再次体现了 Rust Future 固有的“惰性“，允许我们选择性能特征。</p>
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>There’s one last thing we need to handle: errors! With both of these
channel-based streams, the <code>send</code> calls could fail when the other side of the
channel closes—and that’s just a matter of how the runtime executes the futures
that make up the stream. Up until now, we’ve ignored this possibility by calling
<code>unwrap</code>, but in a well-behaved app, we should explicitly handle the error, at
minimum by ending the loop so we don’t try to send any more messages. Listing
17-40 shows a simple error strategy: print the issue and then <code>break</code> from the
loops.</p>
<p>最后需处理错误！这两个<span class="highlight">[note]基于通道的流中，当通道另一端关闭时 <code>send</code> 调用可能失败</span>（这取决于运行时执行 Future 的方式）。此前我们通过 <code>unwrap</code> 忽略此可能性，但在健壮应用中应显式处理错误（至少终止循环以避免继续发送消息）。代码清单 17-40 展示简单错误策略：打印问题并 <code>break</code> 跳出循环。</p>
<figure class="listing" id="listing-17-40">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="#listing-17-40">Listing 17-40</a>: Handling errors and shutting down the loops 处理错误并终止循环</figcaption>
</figure>
<p>As usual, the correct way to handle a message send error will vary; just make
sure you have a strategy.</p>
<p>通常，处理消息发送错误的方式因场景而异；关键是制定策略。</p>
<p>Now that we’ve seen a bunch of async in practice, let’s take a step back and dig
into a few of the details of how <code>Future</code>, <code>Stream</code>, and the other key traits
Rust uses to make async work.</p>
<p>实践大量异步操作后，现在深入探讨 <code>Future</code>、<code>Stream</code> 等 Rust 异步核心特性的细节。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-03-more-futures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-03-more-futures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
