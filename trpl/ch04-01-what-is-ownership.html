<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is Ownership? 什么是所有权 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="what-is-ownership-什么是所有权"><a class="header" href="#what-is-ownership-什么是所有权">What Is Ownership? 什么是所有权？</a></h2>
<p><em>Ownership</em> is a set of rules that govern how a Rust program manages memory.
All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that regularly looks for no-longer-used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks. If
any of the rules are violated, the program won’t compile. None of the features
of ownership will slow down your program while it’s running.</p>
<p><strong>所有权</strong>（<em>Ownership</em>）是一套管理 Rust 程序如何管理内存的规则。所有程序在运行时都必须管理其使用计算机内存的方式。某些语言通过垃圾回收机制在程序运行时定期寻找不再使用的内存；在其他语言中，程序员必须显式分配和释放内存。Rust 采用了第三种方法：内存通过所有权系统进行管理，该系统包含一组编译器检查的规则。如果违反任何规则，程序将无法编译。所有权的特性在程序运行时不会降低其速度。</p>
<p>Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the easier you’ll find it to naturally
develop code that is safe and efficient. Keep at it!</p>
<p>由于所有权对许多程序员来说是一个新概念，确实需要一些时间来适应。好消息是，随着你对 Rust 和所有权系统规则的熟悉程度提高，你会发现自己能更自然地编写安全高效的代码。坚持学习！</p>
<p>When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.</p>
<p>当你理解了所有权，就为理解 Rust 的独特特性奠定了坚实基础。在本章中，你将通过一些专注于常见数据结构（字符串）的示例来学习所有权。</p>
<section class="note" aria-role="note">
<h3 id="the-stack-and-the-heap-栈与堆"><a class="header" href="#the-stack-and-the-heap-栈与堆">The Stack and the Heap 栈与堆</a></h3>
<p>Many programming languages don’t require you to think about the stack and the
heap very often. But in a systems programming language like Rust, whether a
value is on the stack or the heap affects how the language behaves and why
you have to make certain decisions. Parts of ownership will be described in
relation to the stack and the heap later in this chapter, so here is a brief
explanation in preparation.</p>
<p>许多编程语言不常要求你考虑栈和堆。但在像 Rust 这样的系统编程语言中，值位于栈上还是堆上会影响语言的行为以及你为何必须做出某些决策。所有权的部分内容将在本章稍后结合栈和堆进行描述，因此这里先做一个简要说明以备后续理解。</p>
<p>Both the stack and the heap are parts of memory available to your code to use
at runtime, but they are structured in different ways. The stack stores
values in the order it gets them and removes the values in the opposite
order. This is referred to as <em>last in, first out</em>. Think of a stack of
plates: when you add more plates, you put them on top of the pile, and when
you need a plate, you take one off the top. Adding or removing plates from
the middle or bottom wouldn’t work as well! Adding data is called <em>pushing
onto the stack</em>, and removing data is called <em>popping off the stack</em>. All
data stored on the stack must have a known, fixed size. Data with an unknown
size at compile time or a size that might change must be stored on the heap
instead.</p>
<p>栈和堆都是代码在运行时可以使用的内存部分，但它们的结构方式不同。栈按照获取值的顺序存储值，并按相反顺序移除值。这被称为 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一叠盘子：添加更多盘子时放在顶部，需要盘子时从顶部取走。从中间或底部添加或移除盘子效果不佳！添加数据称为 <strong>压栈</strong>（<em>pushing onto the stack</em>），移除数据称为 <strong>出栈</strong>（<em>popping off the stack</em>）。存储在栈上的所有数据必须具有已知的固定大小。编译时大小未知或大小可能变化的数据必须存储在堆上。</p>
<p>The heap is less organized: when you put data on the heap, you request a
certain amount of space. The memory allocator finds an empty spot in the heap
that is big enough, marks it as being in use, and returns a <em>pointer</em>, which
is the address of that location. This process is called <em>allocating on the
heap</em> and is sometimes abbreviated as just <em>allocating</em> (pushing values onto
the stack is not considered allocating). Because the pointer to the heap is a
known, fixed size, you can store the pointer on the stack, but when you want
the actual data, you must follow the pointer. Think of being seated at a
restaurant. When you enter, you state the number of people in your group, and
the host finds an empty table that fits everyone and leads you there. If
someone in your group comes late, they can ask where you’ve been seated to
find you.</p>
<p>堆的组织性较差：当你将数据放入堆时，会请求一定大小的空间。内存分配器在堆中找到足够大的空位，将其标记为正在使用，并返回一个 <strong>指针</strong>（<em>pointer</em>），即该位置的地址。此过程称为 <strong>在堆上分配</strong>（<em>allocating on the heap</em>），有时简称为 <strong>分配</strong>（<em>allocating</em>）（将值压入栈不被视为分配）。由于指向堆的指针是已知且固定大小的，你可以将指针存储在栈上，但当需要实际数据时，必须跟随指针。想象在餐厅入座：进入时说明人数，接待员找到合适的空桌并带你过去。如果有人迟到，他们可以询问你的位置找到你。</p>
<p>Pushing to the stack is faster than allocating on the heap because the
allocator never has to search for a place to store new data; that location is
always at the top of the stack. Comparatively, allocating space on the heap
requires more work because the allocator must first find a big enough space
to hold the data and then perform bookkeeping to prepare for the next
allocation.</p>
<p>压栈比在堆上分配更快，因为分配器无需搜索存储新数据的位置；该位置始终在栈顶。相比之下，在堆上分配空间需要更多工作，因为分配器必须先找到足够大的空间存放数据，然后执行簿记工作为下次分配做准备。</p>
<p>Accessing data in the heap is generally slower than accessing data on the
stack because you have to follow a pointer to get there. Contemporary
processors are faster if they jump around less in memory. Continuing the
analogy, consider a server at a restaurant taking orders from many tables.
It’s most efficient to get all the orders at one table before moving on to
the next table. Taking an order from table A, then an order from table B,
then one from A again, and then one from B again would be a much slower
process. By the same token, a processor can usually do its job better if it
works on data that’s close to other data (as it is on the stack) rather than
farther away (as it can be on the heap).</p>
<p>访问堆中的数据通常比访问栈中数据慢，因为必须跟随指针。当代处理器在内存中跳跃越少，速度越快。延续类比：餐厅服务员从多桌接收点单。最有效的方式是在移动到下一桌之前获取完一桌的所有订单。从 A 桌点单，然后 B 桌，再回到 A 桌，再到 B 桌，这将是一个慢得多的过程。同理，处理器处理彼此靠近的数据（如在栈上）通常比处理较远的数据（如在堆上）效果更好。</p>
<p>When your code calls a function, the values passed into the function
(including, potentially, pointers to data on the heap) and the function’s
local variables get pushed onto the stack. When the function is over, those
values get popped off the stack.</p>
<p>当代码调用函数时，传入函数的值（可能包括指向堆数据的指针）和函数的局部变量会被压入栈。函数结束时，这些值会出栈。</p>
<p>Keeping track of what parts of code are using what data on the heap,
minimizing the amount of duplicate data on the heap, and cleaning up unused
data on the heap so you don’t run out of space are all problems that ownership
addresses. Once you understand ownership, you won’t need to think about the
stack and the heap very often, but knowing that the main purpose of ownership
is to manage heap data can help explain why it works the way it does.</p>
<p>跟踪代码的哪些部分在使用堆上的哪些数据、最小化堆上的重复数据量以及清理堆上未使用的数据以免空间耗尽，这些都是所有权要解决的问题。一旦理解了所有权，就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据有助于理解其工作方式。</p>
</section>
<h3 id="ownership-rules-所有权规则"><a class="header" href="#ownership-rules-所有权规则">Ownership Rules 所有权规则</a></h3>
<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:</p>
<p>首先，我们来看所有权规则。在阅读说明这些规则的示例时，请牢记这些规则：</p>
<ul>
<li>Each value in Rust has an <em>owner</em>.</li>
<li>Rust 中的每个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>There can only be one owner at a time.</li>
<li>同一时间只能有一个所有者。</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
<li>当所有者离开作用域时，该值将被丢弃。</li>
</ul>
<h3 id="variable-scope-变量作用域"><a class="header" href="#variable-scope-变量作用域">Variable Scope 变量作用域</a></h3>
<p>Now that we’re past basic Rust syntax, we won’t include all the <code>fn main() {</code>
code in examples, so if you’re following along, make sure to put the following
examples inside a <code>main</code> function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.</p>
<p>现在我们已经掌握了 Rust 的基本语法，示例中将不再包含所有 <code>fn main() {</code> 代码，因此如果你要动手操作，请确保手动将以下示例放入 <code>main</code> 函数中。这样我们的示例会更简洁，让我们专注于实际细节而非样板代码。</p>
<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:</p>
<p>作为所有权的第一个示例，我们将观察一些变量的<strong>作用域</strong>（<em>scope</em>）。作用域是程序中一个项目有效的范围。以下面的变量为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>The variable <code>s</code> refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 4-1 shows a
program with comments annotating where the variable <code>s</code> would be valid.</p>
<p>变量 <code>s</code> 引用了一个字符串字面值，其值被硬编码到程序文本中。该变量从声明点开始有效，直到当前<strong>作用域</strong>结束。代码清单 4-1 展示了一个程序，其中注释标明了变量 <code>s</code> 的有效范围。</p>
<figure class="listing" id="listing-4-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, since it's not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-4-1">Listing 4-1</a>: A variable and the scope in which it is valid 一个变量及其有效的作用域</figcaption>
</figure>
<p>In other words, there are two important points in time here:</p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>当 <code>s</code> <strong>进入</strong>作用域时，它有效。</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
<li>它持续有效，直到<strong>离开</strong>作用域。</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the <code>String</code> type.</p>
<p>此时，作用域和变量有效性之间的关系与其他编程语言类似。现在我们将通过引入 <code>String</code> 类型在此理解基础上展开。</p>
<h3 id="the-string-type-string-类型"><a class="header" href="#the-string-type-string-类型">The <code>String</code> Type <code>String</code> 类型</a></h3>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the “Data Types” section
of Chapter 3. The types covered previously are of a known size, can be stored
on the stack and popped off the stack when their scope is over, and can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data, and the <code>String</code> type is a great example.</p>
<p>为了说明所有权规则，我们需要一个比第 3 章“数据类型”部分所涉及更复杂的数据类型。之前介绍的类型大小已知，可以存储在栈上并在作用域结束时弹出，如果代码的其他部分需要在不同作用域中使用相同的值，可以快速简单地复制以创建新的独立实例。但我们希望查看存储在堆上的数据，并探索 Rust 如何知道何时清理这些数据，而 <code>String</code> 类型就是一个很好的例子。</p>
<p>We’ll concentrate on the parts of <code>String</code> that relate to ownership. These
aspects also apply to other complex data types, whether they are provided by
the standard library or created by you. We’ll discuss <code>String</code> in more depth in
Chapter 8.</p>
<p>我们将专注于与所有权相关的 <code>String</code> 部分。这些方面也适用于其他复杂数据类型，无论是标准库提供的还是你创建的。我们将在第 8 章更深入地讨论 <code>String</code>。</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, <code>String</code>. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a <code>String</code> from a string
literal using the <code>from</code> function, like so:</p>
<p>我们已经见过字符串字面值，其值被硬编码到程序中。字符串字面值很方便，但并不适用于所有需要使用文本的场景。原因之一是它们不可变。另一个原因是我们编写代码时无法知道所有字符串值：例如，如果我们想获取用户输入并存储呢？对于这些情况，Rust 提供了第二种字符串类型 <code>String</code>。此类型管理在堆上分配的数据，因此能够存储编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值创建 <code>String</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>The double colon <code>::</code> operator allows us to namespace this particular <code>from</code>
function under the <code>String</code> type rather than using some sort of name like
<code>string_from</code>. We’ll discuss this syntax more in the “Method
Syntax” section of Chapter 5, and when we talk
about namespacing with modules in “Paths for Referring to an Item in the
Module Tree” in Chapter 7.</p>
<p>双冒号 <code>::</code> 运算符允许我们将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间下，而不是使用类似 <code>string_from</code> 的名称。我们将在第 5 章的“方法语法”部分讨论此语法，并在第 7 章的“模块树中引用项目的路径”部分讨论模块命名空间。</p>
<p>This kind of string <em>can</em> be mutated:</p>
<p>这种字符串<strong>可以</strong>被改变：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // this will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>So, what’s the difference here? Why can <code>String</code> be mutated but literals
cannot? The difference is in how these two types deal with memory.</p>
<p>那么，这里的区别是什么？为什么 <code>String</code> 可被改变而字面值不能？区别在于这两种类型处理内存的方式。</p>
<h3 id="memory-and-allocation-内存与分配"><a class="header" href="#memory-and-allocation-内存与分配">Memory and Allocation 内存与分配</a></h3>
<p>In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.</p>
<p>对于字符串字面值，我们在编译时就知道其内容，因此文本直接硬编码到最终可执行文件中。这就是字符串字面值快速高效的原因。但这些特性仅源于字符串字面值的不可变性。不幸的是，我们无法在二进制文件中为每一段编译时大小未知或运行时大小可能变化的文本放入一块内存。</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:</p>
<p>对于 <code>String</code> 类型，为了支持可变的、可增长的文本片段，我们需要在堆上分配一块编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>The memory must be requested from the memory allocator at runtime.</li>
<li>必须在运行时向内存分配器请求内存。</li>
<li>We need a way of returning this memory to the allocator when we’re done with
our <code>String</code>.</li>
<li>当使用完 <code>String</code> 时，需要一种方式将此内存返回给分配器。</li>
</ul>
<p>That first part is done by us: when we call <code>String::from</code>, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.</p>
<p>第一部分由我们完成：调用 <code>String::from</code> 时，其实现会请求所需内存。这在编程语言中几乎是通用的。</p>
<p>However, the second part is different. In languages with a <em>garbage collector
(GC)</em>, the GC keeps track of and cleans up memory that isn’t being used
anymore, and we don’t need to think about it. In most languages without a GC,
it’s our responsibility to identify when memory is no longer being used and to
call code to explicitly free it, just as we did to request it. Doing this
correctly has historically been a difficult programming problem. If we forget,
we’ll waste memory. If we do it too early, we’ll have an invalid variable. If
we do it twice, that’s a bug too. We need to pair exactly one <code>allocate</code> with
exactly one <code>free</code>.</p>
<p>然而，第二部分不同。在有<strong>垃圾回收器（GC）</strong>（<em>garbage collector (GC)</em>）的语言中，GC 会跟踪并清理不再使用的内存，我们无需关心。在没有 GC 的大多数语言中，我们有责任识别内存何时不再使用并调用代码显式释放它，就像我们请求时那样。历史上，正确执行此操作一直是个难题。如果忘记释放，会浪费内存；过早释放，会产生无效变量；重复释放，同样是个错误。我们需要精确地一次 <code>allocate</code> 配对一次 <code>free</code>。</p>
<p>Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a <code>String</code> instead of a string literal:</p>
<p>Rust 选择了不同的路径：一旦拥有内存的变量离开作用域，内存就会自动返回。以下是使用 <code>String</code> 替代字符串字面值的代码清单 4-1 的作用域示例变体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}</span></code></pre></pre>
<p>There is a natural point at which we can return the memory our <code>String</code> needs
to the allocator: when <code>s</code> goes out of scope. When a variable goes out of
scope, Rust calls a special function for us. This function is called
<code>drop</code>, and it’s where the author of <code>String</code> can put
the code to return the memory. Rust calls <code>drop</code> automatically at the closing
curly bracket.</p>
<p>这里有一个自然的时机可以将 <code>String</code> 所需的内存返回给分配器：当 <code>s</code> 离开作用域时。当变量离开作用域时，Rust 会为我们调用一个特殊的函数。此函数名为 <code>drop</code>，<code>String</code> 的作者可以在此放置返回内存的代码。Rust 在右花括号处自动调用 <code>drop</code>。</p>
<section class="note" aria-role="note">
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s
lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>.
The <code>drop</code> function in Rust will be familiar to you if you’ve used RAII
patterns.</p>
<p>注意：<span class="highlight">[note]在 C++ 中，这种在项目生命周期结束时释放资源的模式有时称为 <strong>资源获取即初始化（RAII）</strong>。</span>如果你使用过 RAII 模式，Rust 中的 <code>drop</code> 函数会让你感到熟悉。</p>
</section>
<p>This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.</p>
<p>这种模式对 Rust 代码的编写方式有着深远影响。现在看起来简单，但在更复杂的情况下（当我们希望多个变量使用堆上分配的数据时），代码的行为可能出乎意料。现在让我们探讨其中一些情况。</p>
<h4 id="variables-and-data-interacting-with-move-变量与数据的交互移动move"><a class="header" href="#variables-and-data-interacting-with-move-变量与数据的交互移动move">Variables and Data Interacting with Move 变量与数据的交互：移动（Move）</a></h4>
<p>Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.</p>
<p>在 Rust 中，多个变量可以通过不同方式与同一数据交互。让我们看一个使用整数的示例（部分如代码清单 4-2 所示）。</p>
<figure class="listing" id="listing-4-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-4-2">Listing 4-2</a>: Assigning the integer value of variable <code>x</code> to <code>y</code> 将变量 <code>x</code> 的整数值赋给 <code>y</code></figcaption>
</figure>
<p>We can probably guess what this is doing: “bind the value <code>5</code> to <code>x</code>; then make
a copy of the value in <code>x</code> and bind it to <code>y</code>.” We now have two variables, <code>x</code>
and <code>y</code>, and both equal <code>5</code>. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two <code>5</code> values are pushed
onto the stack.</p>
<p>我们可能猜到它的作用：“将值 <code>5</code> 绑定到 <code>x</code>；然后复制 <code>x</code> 中的值并绑定到 <code>y</code>。”现在有两个变量 <code>x</code> 和 <code>y</code>，都等于 <code>5</code>。确实如此，因为整数是具有已知固定大小的简单值，这两个 <code>5</code> 值都被压入栈。</p>
<p>Now let’s look at the <code>String</code> version:</p>
<p>现在来看 <code>String</code> 版本：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>This looks very similar, so we might assume that the way it works would be the
same: that is, the second line would make a copy of the value in <code>s1</code> and bind
it to <code>s2</code>. But this isn’t quite what happens.</p>
<p>这看起来非常相似，因此我们可能认为其工作方式相同：即第二行复制 <code>s1</code> 中的值并绑定到 <code>s2</code>。但实际并非如此。</p>
<p>Take a look at Figure 4-1 to see what is happening to <code>String</code> under the
covers. A <code>String</code> is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.</p>
<p>查看图 4-1 了解底层 <code>String</code> 的情况。<code>String</code> 由三部分组成，如左侧所示：指向存放字符串内容内存的指针、长度和容量。这组数据存储在栈上。右侧是存放内容的堆内存。</p>
<img alt="" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representation in memory of a <code>String</code>
holding the value <code>"hello"</code> bound to <code>s1</code> 绑定到 <code>s1</code> 的持有值 <code>"hello"</code> 的 <code>String</code> 在内存中的表示</span></p>
<p>The length is how much memory, in bytes, the contents of the <code>String</code> are
currently using. The capacity is the total amount of memory, in bytes, that the
<code>String</code> has received from the allocator. The difference between length and
capacity matters, but not in this context, so for now, it’s fine to ignore the
capacity.</p>
<p>长度是 <code>String</code> 内容当前使用的内存量（字节）。容量是 <code>String</code> 从分配器获得的总内存量（字节）。长度和容量的区别很重要，但在此上下文中无关，目前可以忽略容量。</p>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.</p>
<p>当我们将 <code>s1</code> 赋给 <code>s2</code> 时，会复制 <code>String</code> 数据，即复制栈上的指针、长度和容量。我们不会复制指针所指向的堆上数据。换句话说，内存中的数据表示如图 4-2 所示。</p>
<img alt="" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representation in memory of the variable <code>s2</code>
that has a copy of the pointer, length, and capacity of <code>s1</code> 拥有 <code>s1</code> 指针、长度和容量副本的变量 <code>s2</code> 在内存中的表示</span></p>
<p>The representation does <em>not</em> look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation <code>s2 = s1</code> could be very expensive in terms of runtime performance if
the data on the heap were large.</p>
<p>其表示<strong>并非</strong>图 4-3 所示（如果 Rust 同时复制堆数据，内存会呈现此状态）。如果 Rust 这样做，当堆数据很大时，操作 <code>s2 = s1</code> 的运行时性能成本会非常高。</p>
<img alt="" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Another possibility for what <code>s2 = s1</code> might
do if Rust copied the heap data as well 如果 Rust 同时复制堆数据，<code>s2 = s1</code> 可能的另一种行为</span></p>
<p>Earlier, we said that when a variable goes out of scope, Rust automatically
calls the <code>drop</code> function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the
same memory. This is known as a <em>double free</em> error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.</p>
<p>之前提到，当变量离开作用域时，Rust 会自动调用 <code>drop</code> 函数清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一位置。这会带来问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域时，它们都会尝试释放相同的内存。这称为<strong>二次释放</strong>（<em>double free</em>）错误，是之前提到的内存安全问题之一。重复释放内存可能导致内存损坏，进而可能引发安全漏洞。</p>
<p>To ensure memory safety, after the line <code>let s2 = s1;</code>, Rust considers <code>s1</code> as
no longer valid. Therefore, Rust doesn’t need to free anything when <code>s1</code> goes
out of scope. Check out what happens when you try to use <code>s1</code> after <code>s2</code> is
created; it won’t work:</p>
<p>为确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效。因此，当 <code>s1</code> 离开作用域时，Rust 无需释放任何内容。尝试在创建 <code>s2</code> 后使用 <code>s1</code> 会发生什么？它将无法工作：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>You’ll get an error like this because Rust prevents you from using the
invalidated reference:</p>
<p>你会收到类似错误，因为 Rust 阻止你使用无效引用：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a <em>move</em>. In this example, we would say that <code>s1</code>
was <em>moved</em> into <code>s2</code>. So, what actually happens is shown in Figure 4-4.</p>
<p>如果你在使用其他语言时听说过<strong>浅拷贝</strong>（<em>shallow copy</em>）和<strong>深拷贝</strong>（<em>deep copy</em>），复制指针、长度和容量而不复制数据的概念可能听起来像是浅拷贝。但由于 Rust 同时使第一个变量无效，它被称为<strong>移动</strong>（<em>move</em>）而非浅拷贝。在此示例中，我们说 <code>s1</code> 被<strong>移动</strong>（<em>moved</em>）到了 <code>s2</code> 中。实际发生的情况如图 4-4 所示。</p>
<img alt="" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: Representation in memory after <code>s1</code> has been
invalidated <code>s1</code> 失效后的内存表示</span></p>
<p>That solves our problem! With only <code>s2</code> valid, when it goes out of scope it
alone will free the memory, and we’re done.</p>
<p>这解决了我们的问题！只有 <code>s2</code> 有效，当其离开作用域时，它会单独释放内存，问题解决。</p>
<p>In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any <em>automatic</em>
copying can be assumed to be inexpensive in terms of runtime performance.</p>
<p>此外，这隐含了一个设计选择：Rust 永远不会自动创建数据的“深”拷贝。因此，任何<strong>自动</strong>复制在运行时性能上都可以认为是低成本的。</p>
<h4 id="scope-and-assignment-作用域与赋值"><a class="header" href="#scope-and-assignment-作用域与赋值">Scope and Assignment 作用域与赋值</a></h4>
<p>The inverse of this is true for the relationship between scoping, ownership, and
memory being freed via the <code>drop</code> function as well. When you assign a completely
new value to an existing variable, Rust will call <code>drop</code> and free the original
value’s memory immediately. Consider this code, for example:</p>
<p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系，其逆命题同样成立。当你为现有变量分配一个全新的值时，Rust 会立即调用 <code>drop</code> 并释放原值的内存。例如考虑以下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>We initially declare a variable <code>s</code> and bind it to a <code>String</code> with the value
<code>"hello"</code>. Then we immediately create a new <code>String</code> with the value <code>"ahoy"</code> and
assign it to <code>s</code>. At this point, nothing is referring to the original value on
the heap at all.</p>
<p>我们最初声明变量 <code>s</code> 并将其绑定到值为 <code>"hello"</code> 的 <code>String</code>。然后我们立即创建一个值为 <code>"ahoy"</code> 的新 <code>String</code> 并将其赋给 <code>s</code>。此时，没有任何东西引用堆上的原始值。</p>
<img alt="" src="img/trpl04-05.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-5: Representation in memory after the initial
value has been replaced in its entirety. 初始值被完全替换后的内存表示</span></p>
<p>The original string thus immediately goes out of scope. Rust will run the <code>drop</code>
function on it and its memory will be freed right away. When we print the value
at the end, it will be <code>"ahoy, world!"</code>.</p>
<p>因此原始字符串立即离开作用域。Rust 将对其运行 <code>drop</code> 函数，其内存将立即被释放。当我们最后打印值时，它将是 <code>"ahoy, world!"</code>。</p>
<h4 id="variables-and-data-interacting-with-clone-变量与数据的交互克隆clone"><a class="header" href="#variables-and-data-interacting-with-clone-变量与数据的交互克隆clone">Variables and Data Interacting with Clone 变量与数据的交互：克隆（Clone）</a></h4>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the
stack data, we can use a common method called <code>clone</code>. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.</p>
<p>如果我们<strong>确实</strong>想深度复制 <code>String</code> 的堆数据，而不仅仅是栈数据，可以使用一个名为 <code>clone</code> 的常用方法。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言的常见特性，你可能以前见过它们。</p>
<p>Here’s an example of the <code>clone</code> method in action:</p>
<p>以下是 <code>clone</code> 方法的实际示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data <em>does</em> get copied.</p>
<p>这种方法完全可行，并明确产生了图 4-3 所示的行为，堆数据<strong>确实</strong>被复制了。</p>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.</p>
<p><span class="highlight">[note]当你看到 <code>clone</code> 调用时，就知道正在执行某些可能开销较大的代码。</span>这是一个视觉指示器，表明发生了某些不同的事情。</p>
<h4 id="stack-only-data-copy-仅栈数据复制copy"><a class="header" href="#stack-only-data-copy-仅栈数据复制copy">Stack-Only Data: Copy 仅栈数据：复制（Copy）</a></h4>
<p>There’s another wrinkle we haven’t talked about yet. This code using
integers—part of which was shown in Listing 4-2—works and is valid:</p>
<p>还有另一个我们尚未讨论的细节。这段使用整数的代码（部分如代码清单 4-2 所示）是有效且可工作的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>But this code seems to contradict what we just learned: we don’t have a call to
<code>clone</code>, but <code>x</code> is still valid and wasn’t moved into <code>y</code>.</p>
<p>但这段代码似乎与我们刚刚学到的内容矛盾：我们没有调用 <code>clone</code>，但 <code>x</code> 仍然有效且未被移动到 <code>y</code>。</p>
<p>The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent <code>x</code> from being
valid after we create the variable <code>y</code>. In other words, there’s no difference
between deep and shallow copying here, so calling <code>clone</code> wouldn’t do anything
different from the usual shallow copying, and we can leave it out.</p>
<p>原因在于整数等类型在编译时具有已知大小，完全存储在栈上，复制实际值非常快。这意味着我们没有理由在创建变量 <code>y</code> 后让 <code>x</code> 无效。换句话说，这里深拷贝和浅拷贝没有区别，因此调用 <code>clone</code> 与通常的浅拷贝不会有任何不同，我们可以省略它。</p>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on
types that are stored on the stack, as integers are (we’ll talk more about
traits in Chapter 10). If a type implements the <code>Copy</code>
trait, variables that use it do not move, but rather are trivially copied,
making them still valid after assignment to another variable.</p>
<p><span class="highlight">[note]Rust 有一个称为 <code>Copy</code> trait 的特殊注解，可以用于存储在栈上的类型（如整数）。如果类型实现了 <code>Copy</code> trait，使用它的变量在赋值给另一个变量时不会移动，而是被简单地复制，使得它们在赋值后仍然有效。</span></p>
<p>Rust won’t let us annotate a type with <code>Copy</code> if the type, or any of its parts,
has implemented the <code>Drop</code> trait. If the type needs something special to happen
when the value goes out of scope and we add the <code>Copy</code> annotation to that type,
we’ll get a compile-time error. To learn about how to add the <code>Copy</code> annotation
to your type to implement the trait, see “Derivable
Traits” in Appendix C.</p>
<p><span class="highlight">[note]如果某个类型或其任何部分实现了 <code>Drop</code> trait，Rust 不允许我们用 <code>Copy</code> 标注该类型。</span>如果该类型在值离开作用域时需要特殊处理，而我们为其添加了 <code>Copy</code> 注解，将导致编译时错误。要了解如何为类型添加 <code>Copy</code> 注解以实现该 trait，请参阅附录 C 中的“可派生的 trait”。</p>
<p>So, what types implement the <code>Copy</code> trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement <code>Copy</code>, and nothing that requires allocation or is some
form of resource can implement <code>Copy</code>. Here are some of the types that
implement <code>Copy</code>:</p>
<p>那么，哪些类型实现了 <code>Copy</code> trait？你可以查阅给定类型的文档确认，但作为一般规则，任何简单标量值组合都可以实现 <code>Copy</code>，而任何需要分配资源或属于某种资源的形式都不能实现 <code>Copy</code>。以下是一些实现 <code>Copy</code> 的类型：</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>所有整数类型，如 <code>u32</code>。</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>布尔类型 <code>bool</code>，值为 <code>true</code> 和 <code>false</code>。</li>
<li>All the floating-point types, such as <code>f64</code>.</li>
<li>所有浮点类型，如 <code>f64</code>。</li>
<li>The character type, <code>char</code>.</li>
<li>字符类型 <code>char</code>。</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>. For example,
<code>(i32, i32)</code> implements <code>Copy</code>, but <code>(i32, String)</code> does not.</li>
<li>元组，当且仅当其包含的所有类型也都实现 <code>Copy</code> 时。例如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 没有。</li>
</ul>
<h3 id="ownership-and-functions-所有权与函数"><a class="header" href="#ownership-and-functions-所有权与函数">Ownership and Functions 所有权与函数</a></h3>
<p>The mechanics of passing a value to a function are similar to those when
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p>将值传递给函数的机制与将值赋给变量类似。向函数传递变量会移动（move）或复制（copy），就像赋值一样。代码清单 4-3 是一个示例，带有注释说明变量进入和离开作用域的位置。</p>
<figure class="listing" id="listing-4-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // Because i32 implements the Copy trait,
                                    // x does NOT move into the function,
                                    // so it's okay to use x afterward.

} // Here, x goes out of scope, then s. However, because s's value was moved,
  // nothing special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<figcaption><a href="#listing-4-3">Listing 4-3</a>: Functions with ownership and scope annotated 带所有权和作用域注释的函数</figcaption>
</figure>
<p>If we tried to use <code>s</code> after the call to <code>takes_ownership</code>, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>s</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<p>如果我们尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code>，Rust 会抛出编译时错误。这些静态检查保护我们免于犯错。尝试在 <code>main</code> 中添加使用 <code>s</code> 和 <code>x</code> 的代码，看看你可以在哪里使用它们，而所有权规则在哪里阻止你这样做。</p>
<h3 id="return-values-and-scope-返回值与作用域"><a class="header" href="#return-values-and-scope-返回值与作用域">Return Values and Scope 返回值与作用域</a></h3>
<p>Returning values can also transfer ownership. Listing 4-4 shows an example of a
function that returns some value, with similar annotations as those in Listing
4-3.</p>
<p>返回值也可以转移所有权。代码清单 4-4 展示了一个返回某个值的函数示例，其注释与代码清单 4-3 类似。</p>
<figure class="listing" id="listing-4-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();        // gives_ownership moves its return
                                       // value into s1

    let s2 = String::from("hello");    // s2 comes into scope

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {       // gives_ownership will move its
                                       // return value into the function
                                       // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                        // some_string is returned and
                                       // moves out to the calling
                                       // function
}

// This function takes a String and returns a String.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string comes into
    // scope

    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<figcaption><a href="#listing-4-4">Listing 4-4</a>: Transferring ownership of return values 返回值的所有权转移</figcaption>
</figure>
<p>The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by <code>drop</code> unless ownership
of the data has been moved to another variable.</p>
<p>变量的所有权每次都遵循相同的模式：将值赋给另一个变量会移动它。当包含堆数据的变量离开作用域时，除非数据的所有权已转移到另一个变量，否则该值将被 <code>drop</code> 清理。</p>
<p>While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It’s quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.</p>
<p>虽然这种方法有效，但每个函数都获取所有权然后又返回所有权有点繁琐。如果我们想让函数使用一个值但不获取所有权呢？我们传入的任何内容还需要传回才能再次使用，这非常烦人，此外可能还需要返回函数体产生的任何数据。</p>
<p>Rust does let us return multiple values using a tuple, as shown in Listing 4-5.</p>
<p>Rust 确实允许我们使用元组返回多个值，如代码清单 4-5 所示。</p>
<figure class="listing" id="listing-4-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<figcaption><a href="#listing-4-5">Listing 4-5</a>: Returning ownership of parameters 返回参数的所有权</figcaption>
</figure>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for using a value without
transferring ownership, called <em>references</em>.</p>
<p>但对于一个本应常见的概念来说，这仪式感太强且工作量太大。幸运的是，Rust 有一个特性用于使用值而不转移所有权，称为<strong>引用</strong>（<em>references</em>）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
