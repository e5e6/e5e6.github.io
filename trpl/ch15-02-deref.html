<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Treating Smart Pointers Like Regular References with Deref 通过 Deref 将智能指针视作常规引用 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="treating-smart-pointers-like-regular-references-with-deref-通过-deref-将智能指针视作常规引用"><a class="header" href="#treating-smart-pointers-like-regular-references-with-deref-通过-deref-将智能指针视作常规引用">Treating Smart Pointers Like Regular References with <code>Deref</code> 通过 <code>Deref</code> 将智能指针视作常规引用</a></h2>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the
<em>dereference operator</em> <code>*</code> (not to be confused with the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.</p>
<p><span class="highlight">[note]实现 <code>Deref</code> 特征可自定义解引用运算符</span> <code>*</code>（区别于乘法或通配符运算符）的行为。通过实现 <code>Deref</code> 使智能指针能像常规引用一样使用，可编写操作引用的代码并使其同时兼容智能指针。</p>
<p>Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for
smart pointers to work in ways similar to references. Then we’ll look at
Rust’s <em>deref coercion</em> feature and how it lets us work with either references
or smart pointers.</p>
<p>首先观察解引用运算符如何与常规引用协作。随后尝试定义行为类似 <code>Box&lt;T&gt;</code> 的自定义类型，探究解引用运算符为何不能像引用一样工作。通过实现 <code>Deref</code> 特征，可使智能指针以类似引用的方式工作。接着探讨 Rust 的<strong>解引用强制转换</strong>特性及其如何实现引用与智能指针的通用编程。</p>
<h3 id="following-the-reference-to-the-value-通过引用追踪值"><a class="header" href="#following-the-reference-to-the-value-通过引用追踪值">Following the Reference to the Value 通过引用追踪值</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the value.</p>
<p>常规引用是一种指针，可将其视为指向存储在其他位置值的箭头。代码清单 15-6 创建了指向 <code>i32</code> 值的引用，并通过解引用运算符追踪引用至值。</p>
<figure class="listing" id="listing-15-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption><a href="#listing-15-6">Listing 15-6</a>: Using the dereference operator to follow a reference to an <code>i32</code> value 使用解引用运算符追踪指向 <code>i32</code> 值的引用</figcaption>
</figure>
<p>The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>) so the compiler can compare
the actual value. Once we dereference <code>y</code>, we have access to the integer value
<code>y</code> is pointing to that we can compare with <code>5</code>.</p>
<p>变量 <code>x</code> 持有 <code>i32</code> 值 <code>5</code>。设 <code>y</code> 为指向 <code>x</code> 的引用。可断言 <code>x</code> 等于 <code>5</code>。但若要对 <code>y</code> 的值断言，需使用 <code>*y</code> 追踪引用至其指向的值（即<strong>解引用</strong>），编译器才能比较实际值。解引用 <code>y</code> 后，即可访问 <code>y</code> 指向的整数值并与 <code>5</code> 比较。</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<p>若尝试写 <code>assert_eq!(5, y);</code> 替代，将得到编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.</p>
<p><span class="highlight">[note]比较数字和数字引用因类型不同被禁止</span>。必须使用解引用运算符追踪引用至其指向的值。</p>
<h3 id="using-boxt-like-a-reference-像引用一样使用-boxt"><a class="header" href="#using-boxt-like-a-reference-像引用一样使用-boxt">Using <code>Box&lt;T&gt;</code> Like a Reference 像引用一样使用 <code>Box&lt;T&gt;</code></a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7
functions in the same way as the dereference operator used on the reference in
Listing 15-6.</p>
<p>我们可重写代码清单 15-6，用 <code>Box&lt;T&gt;</code> 替代引用。代码清单 15-7 中对 <code>Box&lt;T&gt;</code> 使用的解引用运算符与代码清单 15-6 中引用的用法功能相同。</p>
<figure class="listing" id="listing-15-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption><a href="#listing-15-7">Listing 15-7</a>: Using the dereference operator on a <code>Box&lt;i32&gt;</code> 在 <code>Box&lt;i32&gt;</code> 上使用解引用运算符</figcaption>
</figure>
<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to a copied value of <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<p>代码清单 15-7 与 15-6 的主要区别在于，此处设 <code>y</code> 为指向 <code>x</code> 值副本的 box 实例，而非指向 <code>x</code> 值的引用。在最后的断言中，我们可像 <code>y</code> 为引用时一样使用解引用运算符追踪 box 的指针。接下来，我们将通过自定义 box 类型探究 <code>Box&lt;T&gt;</code> 的特殊之处。</p>
<h3 id="defining-our-own-smart-pointer-自定义智能指针"><a class="header" href="#defining-our-own-smart-pointer-自定义智能指针">Defining Our Own Smart Pointer 自定义智能指针</a></h3>
<p>Let’s build a wrapper type similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointer types behave differently from
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>我们构建一个与标准库提供的 <code>Box&lt;T&gt;</code> 类型类似的封装类型，体验智能指针类型与引用的默认行为差异。随后学习如何添加解引用运算符支持。</p>
<section class="note" aria-role="note">
<p>Note: There’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to
build and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap.
We are focusing this example on <code>Deref</code>, so where the data is actually stored
is less important than the pointer-like behavior.</p>
<p>注意：我们将构建的 <code>MyBox&lt;T&gt;</code> 类型与真正的 <code>Box&lt;T&gt;</code> 存在重大差异：我们的版本不将数据存储在堆上。本例聚焦于 <code>Deref</code>，因此数据实际存储位置不如类指针行为重要。</p>
</section>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<p><code>Box&lt;T&gt;</code> 类型本质上是含单个元素的元组结构体，故代码清单 15-8 以相同方式定义 <code>MyBox&lt;T&gt;</code> 类型。同时定义匹配 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函数。</p>
<figure class="listing" id="listing-15-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-15-8">Listing 15-8</a>: Defining a <code>MyBox&lt;T&gt;</code> type 定义 <code>MyBox&lt;T&gt;</code> 类型</figcaption>
</figure>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code> because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>定义名为 <code>MyBox</code> 的结构体并声明泛型参数 <code>T</code>，以使类型能容纳任意类型的值。<code>MyBox</code> 类型是含单个 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数接收一个 <code>T</code> 类型参数，返回持有传入值的 <code>MyBox</code> 实例。</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>.</p>
<p>尝试将代码清单 15-7 的 <code>main</code> 函数加入代码清单 15-8，并修改为使用刚定义的 <code>MyBox&lt;T&gt;</code> 类型替代 <code>Box&lt;T&gt;</code>。代码清单 15-9 无法编译，因为 Rust 不知如何解引用 <code>MyBox</code>。</p>
<figure class="listing" id="listing-15-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<figcaption><a href="#listing-15-9">Listing 15-9</a>: Attempting to use <code>MyBox&lt;T&gt;</code> in the same way we used references and <code>Box&lt;T&gt;</code> 尝试以使用引用和 <code>Box&lt;T&gt;</code> 的相同方式使用 <code>MyBox&lt;T&gt;</code></figcaption>
</figure>
<p>Here’s the resultant compilation error:</p>
<p>编译错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<p><code>MyBox&lt;T&gt;</code> 类型因未实现解引用能力而无法解引用。为实现 <code>*</code> 运算符的解引用功能，需实现 <code>Deref</code> 特征。</p>
<h3 id="implementing-the-deref-trait-实现-deref-特征"><a class="header" href="#implementing-the-deref-trait-实现-deref-特征">Implementing the <code>Deref</code> Trait 实现 <code>Deref</code> 特征</a></h3>
<p>As discussed in “Implementing a Trait on a Type” in
Chapter 10, to implement a trait we need to provide implementations for the
trait’s required methods. The <code>Deref</code> trait, provided by the standard library,
requires us to implement one method named <code>deref</code> that borrows <code>self</code> and
returns a reference to the inner data. Listing 15-10 contains an implementation
of <code>Deref</code> to add to the definition of <code>MyBox&lt;T&gt;</code>.</p>
<p>如第 10 章<a href="#implementing-a-trait-on-a-type">“为类型实现特征”</a>所述，实现特征需提供特征必需方法的实现。标准库提供的 <code>Deref</code> 特征要求实现名为 <code>deref</code> 的方法：该方法借用 <code>self</code> 并返回内部数据的引用。代码清单 15-10 展示了添加到 <code>MyBox&lt;T&gt;</code> 定义的 <code>Deref</code> 实现。</p>
<figure class="listing" id="listing-15-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-15-10">Listing 15-10</a>: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code> 在 <code>MyBox&lt;T&gt;</code> 上实现 <code>Deref</code></figcaption>
</figure>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code>
trait to use. Associated types are a slightly different way of declaring a
generic parameter, but you don’t need to worry about them for now; we’ll cover
them in more detail in Chapter 20.</p>
<p><code>type Target = T;</code> 语法为 <code>Deref</code> 特征定义关联类型。关联类型是声明泛型参数的稍异方式，此处无需深究；第 20 章将详细讨论。</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator; recall from
“Using Tuple Structs Without Named Fields to Create Different
Types” in Chapter 5 that <code>.0</code> accesses the first
value in a tuple struct. The <code>main</code> function in Listing 15-9 that calls <code>*</code> on
the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>
<p><code>deref</code> 方法体填入 <code>&amp;self.0</code> 使其返回需通过 <code>*</code> 运算符访问值的引用；回顾第 5 章“使用无名字段元组结构体创建不同类型”，<code>.0</code> 访问元组结构体的首元素。现在代码清单 15-9 中调用 <code>MyBox&lt;T&gt;</code> 值 <code>*</code> 的 <code>main</code> 函数可编译，断言通过！</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get an <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>若无 <code>Deref</code> 特征，编译器仅能解引用 <code>&amp;</code> 引用。<code>deref</code> 方法赋予编译器能力：对任何实现 <code>Deref</code> 类型的值调用 <code>deref</code> 方法，获取其知晓如何解引用的 <code>&amp;</code> 引用。</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<p>在代码清单 15-9 中<span class="highlight">[note]输入 <code>*y</code> 时，Rust 底层实际执行：</span></p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so we don’t have to think about whether or not we need to
call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>Rust 将 <code>*</code> 运算符替换为 <code>deref</code> 方法调用及普通解引用，因此我们无需考虑是否需调用 <code>deref</code> 方法。此 Rust 特性让我们编写的代码无论使用常规引用还是实现 <code>Deref</code> 的类型均表现一致。</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the
plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary,
has to do with the ownership system. If the <code>deref</code> method returned the value
directly instead of a reference to the value, the value would be moved out of
<code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in
this case or in most cases where we use the dereference operator.</p>
<p><span class="highlight">[note]<code>deref</code> 方法返回值的引用，且 <code>*(y.deref())</code> 外层的普通解引用仍必要的原因与所有权系统相关。若 <code>deref</code> 方法直接返回值而非其引用，值将从 <code>self</code> 移出。</span>在此场景（及多数使用解引用运算符的场景）中，我们无意获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<p><span class="highlight">[note]注意 <code>*</code> 运算符仅被替换为一次 <code>deref</code> 方法调用及一次 <code>*</code> 运算符调用。因 <code>*</code> 运算符替换不会无限递归</span>，最终我们得到与代码清单 15-9 中 <code>assert_eq!</code> 的 <code>5</code> 匹配的 <code>i32</code> 类型数据。</p>
<h3 id="implicit-deref-coercions-with-functions-and-methods-函数和方法的隐式解引用强制转换"><a class="header" href="#implicit-deref-coercions-with-functions-and-methods-函数和方法的隐式解引用强制转换">Implicit Deref Coercions with Functions and Methods 函数和方法的隐式解引用强制转换</a></h3>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code>
trait into a reference to another type. For example, deref coercion can convert
<code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it
returns <code>&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to
functions and methods, and works only on types that implement the <code>Deref</code>
trait. It happens automatically when we pass a reference to a particular type’s
value as an argument to a function or method that doesn’t match the parameter
type in the function or method definition. A sequence of calls to the <code>deref</code>
method converts the type we provided into the type the parameter needs.</p>
<p><strong>解引用强制转换</strong>将实现了 <code>Deref</code> 特征的类型的引用转换为另一种类型的引用。例如，<span class="highlight">[note]解引用强制转换可将 <code>&amp;String</code> 转为 <code>&amp;str</code>，因 <code>String</code> 实现了返回 <code>&amp;str</code> 的 <code>Deref</code> 特征。</span>解引用强制转换是 Rust 为函数和方法参数提供的便利机制，且仅适用于实现 <code>Deref</code> 特征的类型。<span class="highlight">[note]当我们将特定类型值的引用传递给与函数或方法定义中形参类型不匹配的实参时，该转换自动发生。一系列 <code>deref</code> 方法调用将我们提供的类型转换为形参所需类型。</span></p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>Rust 引入解引用强制转换后，编写函数和方法调用时无需大量显式添加 <code>&amp;</code> 和 <code>*</code> 引用及解引用。该特性还让我们编写的代码可同时兼容引用和智能指针。</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter.</p>
<p>为观察解引用强制转换的实际效果，我们使用代码清单 15-8 定义的 <code>MyBox&lt;T&gt;</code> 类型及代码清单 15-10 添加的 <code>Deref</code> 实现。代码清单 15-11 展示了含字符串切片形参的函数定义。</p>
<figure class="listing" id="listing-15-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-15-11">Listing 15-11</a>: A <code>hello</code> function that has the parameter <code>name</code> of type <code>&amp;str</code> 含 <code>&amp;str</code> 类型形参 <code>name</code> 的 <code>hello</code> 函数</figcaption>
</figure>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello("Rust");</code>, for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12.</p>
<p>我们可用字符串切片调用 <code>hello</code> 函数，如 <code>hello("Rust");</code>。解引用强制转换使得用 <code>MyBox&lt;String&gt;</code> 类型值的引用调用 <code>hello</code> 成为可能，如代码清单 15-12 所示。</p>
<figure class="listing" id="listing-15-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<figcaption><a href="#listing-15-12">Listing 15-12</a>: Calling <code>hello</code> with a reference to a <code>MyBox&lt;String&gt;</code> value, which works because of deref coercion 通过解引用强制转换实现对 <code>MyBox&lt;String&gt;</code> 值引用调用 <code>hello</code></figcaption>
</figure>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, and this is in the API documentation
for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>此处我们以 <code>&amp;m</code> 为参数调用 <code>hello</code> 函数，这是指向 <code>MyBox&lt;String&gt;</code> 值的引用。因我们在代码清单 15-10 中为 <code>MyBox&lt;T&gt;</code> 实现了 <code>Deref</code> 特征，Rust 可通过调用 <code>deref</code> 将 <code>&amp;MyBox&lt;String&gt;</code> 转为 <code>&amp;String</code>。标准库为 <code>String</code> 提供了返回字符串切片的 <code>Deref</code> 实现（见 API 文档）。Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 转为 <code>&amp;str</code>，从而匹配 <code>hello</code> 函数的定义。</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p>若 Rust 未实现解引用强制转换，则需编写代码清单 15-13 的代码（替代代码清单 15-12）以实现对 <code>&amp;MyBox&lt;String&gt;</code> 类型值的 <code>hello</code> 调用。</p>
<figure class="listing" id="listing-15-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<figcaption><a href="#listing-15-13">Listing 15-13</a>: The code we would have to write if Rust didn’t have deref coercion 若 Rust 无解引用强制转换需编写的代码</figcaption>
</figure>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. This code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。随后 <code>&amp;</code> 和 <code>[..]</code> 获取整个 <code>String</code> 的字符串切片以匹配 <code>hello</code> 的签名。无解引用强制转换的代码因涉及符号而更难读写理解。解引用强制转换让 Rust 自动处理这些转换。</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<p>当为相关类型定义 <code>Deref</code> 特征后，Rust 会分析类型并视需要多次调用 <code>Deref::deref</code> 以获取匹配形参类型的引用。<code>Deref::deref</code> 的插入次数在编译时解析，因此利用解引用强制转换无运行时开销！</p>
<h3 id="how-deref-coercion-interacts-with-mutability-解引用强制转换如何与可变性交互"><a class="header" href="#how-deref-coercion-interacts-with-mutability-解引用强制转换如何与可变性交互">How Deref Coercion Interacts with Mutability 解引用强制转换如何与可变性交互</a></h3>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on
immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>
operator on mutable references.</p>
<p>类似于使用 <code>Deref</code> 特征覆盖不可变引用的 <code>*</code> 运算符，<span class="highlight">[note]可用 <code>DerefMut</code> 特征覆盖可变引用的 <code>*</code> 运算符</span>。</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<p><span class="highlight">[note]Rust 在以下三种情况中执行解引用强制转换：</span></p>
<ol>
<li>
<p>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></p>
</li>
<li>
<p>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;T</code> 到 <code>&amp;U</code></p>
</li>
<li>
<p>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code></p>
</li>
<li>
<p>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;U</code></p>
</li>
</ol>
<p>The first two cases are the same except that the second implements mutability.
The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to
some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The second case states that the
same deref coercion happens for mutable references.</p>
<p>前两种情况除可变性外相同。第一种表明若存在 <code>&amp;T</code> 且 <code>T</code> 实现了到某类型 <code>U</code> 的 <code>Deref</code>，则可透明获得 <code>&amp;U</code>。第二种表明相同解引用强制转换适用于可变引用。</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules don’t guarantee that. Therefore, Rust can’t make the
assumption that converting an immutable reference to a mutable reference is
possible.</p>
<p>第三种情况更微妙：Rust 也会将可变引用强制转换为不可变引用。但反之则<strong>不成立</strong>：不可变引用永远不会强制转换为可变引用。根据借用规则，若持有可变引用，该引用必须是数据的唯一引用（否则程序无法编译）。<span class="highlight">[note]将可变引用转为不可变引用永不违反借用规则。</span>而将不可变引用转为可变引用则要求初始不可变引用是该数据的唯一不可变引用，但借用规则无法保证此点。因此 Rust 无法假设不可变引用到可变引用的转换成立。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-01-box.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-03-drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-01-box.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-03-drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
