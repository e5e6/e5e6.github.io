<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bringing Paths Into Scope with the use Keyword 使用 use 关键字将路径引入作用域 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="bringing-paths-into-scope-with-the-use-keyword-使用-use-关键字将路径引入作用域"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword-使用-use-关键字将路径引入作用域">Bringing Paths into Scope with the <code>use</code> Keyword 使用 <code>use</code> 关键字将路径引入作用域</a></h2>
<p>Having to write out the paths to call functions can feel inconvenient and
repetitive. In Listing 7-7, whether we chose the absolute or relative path to
the <code>add_to_waitlist</code> function, every time we wanted to call <code>add_to_waitlist</code>
we had to specify <code>front_of_house</code> and <code>hosting</code> too. Fortunately, there’s a
way to simplify this process: we can create a shortcut to a path with the <code>use</code>
keyword once, and then use the shorter name everywhere else in the scope.</p>
<p>反复写出调用函数的路径既不方便又显得重复。在示例 7-7 中，无论选择绝对路径还是相对路径来调用 <code>add_to_waitlist</code> 函数，每次调用时都必须同时指定 <code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种简化方法：我们可以使用 <code>use</code> 关键字创建路径的快捷方式，然后在作用域内其他位置使用短名称。</p>
<p>In Listing 7-11, we bring the <code>crate::front_of_house::hosting</code> module into the
scope of the <code>eat_at_restaurant</code> function so we only have to specify
<code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入 <code>eat_at_restaurant</code> 函数的作用域，因此在函数内调用 <code>add_to_waitlist</code> 只需指定 <code>hosting::add_to_waitlist</code>。</p>
<figure class="listing" id="listing-7-11">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-11">Listing 7-11</a>: Bringing a module into scope with <code>use</code> 使用 <code>use</code> 将模块引入作用域</figcaption>
</figure>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding <code>use crate::front_of_house::hosting</code> in the crate
root, <code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code>
module had been defined in the crate root. Paths brought into scope with <code>use</code>
also check privacy, like any other paths.</p>
<p>在作用域中添加 <code>use</code> 和路径类似于在文件系统中创建符号链接。通过在 crate 根中添加 <code>use crate::front_of_house::hosting</code>，<code>hosting</code> 在该作用域内成为有效名称，就像 <code>hosting</code> 模块直接定义在 crate 根中一样。使用 <code>use</code> 引入作用域的路径也会像其他路径一样进行私有性检查。</p>
<p>Note that <code>use</code> only creates the shortcut for the particular scope in which the
<code>use</code> occurs. Listing 7-12 moves the <code>eat_at_restaurant</code> function into a new
child module named <code>customer</code>, which is then a different scope than the <code>use</code>
statement, so the function body won’t compile.</p>
<p><span class="highlight">[note]注意 <code>use</code> 仅在其出现的作用域内创建快捷方式。</span>示例 7-12 将 <code>eat_at_restaurant</code> 函数移至名为 <code>customer</code> 的新子模块中，该子模块与 <code>use</code> 语句处于不同作用域，因此函数体无法编译。</p>
<figure class="listing" id="listing-7-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<figcaption><a href="#listing-7-12">Listing 7-12</a>: A <code>use</code> statement only applies in the scope it’s in. <code>use</code> 语句仅在其所在作用域内生效</figcaption>
</figure>
<p>The compiler error shows that the shortcut no longer applies within the
<code>customer</code> module:</p>
<p>编译器错误表明快捷方式在 <code>customer</code> 模块内不再有效：</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Notice there’s also a warning that the <code>use</code> is no longer used in its scope! To
fix this problem, move the <code>use</code> within the <code>customer</code> module too, or reference
the shortcut in the parent module with <code>super::hosting</code> within the child
<code>customer</code> module.</p>
<p>注意还有一个警告提示 <code>use</code> 在其作用域内未使用！要解决此问题，可将 <code>use</code> 也移至 <code>customer</code> 模块内，或在子模块中通过 <code>super::hosting</code> 引用父模块的快捷方式。</p>
<h3 id="creating-idiomatic-use-paths-创建符合语言习惯的-use-路径"><a class="header" href="#creating-idiomatic-use-paths-创建符合语言习惯的-use-路径">Creating Idiomatic <code>use</code> Paths 创建符合语言习惯的 <code>use</code> 路径</a></h3>
<p>In Listing 7-11, you might have wondered why we specified <code>use  crate::front_of_house::hosting</code> and then called <code>hosting::add_to_waitlist</code> in
<code>eat_at_restaurant</code>, rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing 7-13.</p>
<p>在示例 7-11 中，您可能好奇为何我们指定 <code>use crate::front_of_house::hosting</code> 然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code>，而不是像示例 7-13 那样直接指定到 <code>add_to_waitlist</code> 函数的完整路径。</p>
<figure class="listing" id="listing-7-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-13">Listing 7-13</a>: Bringing the <code>add_to_waitlist</code> function into scope with <code>use</code>, which is unidiomatic 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域（不符合语言习惯）</figcaption>
</figure>
<p>Although both Listing 7-11 and Listing 7-13 accomplish the same task, Listing
7-11 is the idiomatic way to bring a function into scope with <code>use</code>. Bringing
the function’s parent module into scope with <code>use</code> means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn’t locally defined
while still minimizing repetition of the full path. The code in Listing 7-13 is
unclear as to where <code>add_to_waitlist</code> is defined.</p>
<p>虽然示例 7-11 和 7-13 都能完成任务，但示例 7-11 是使用 <code>use</code> 引入函数的惯用方式。通过 <code>use</code> 引入函数的父模块意味着调用时需指定父模块。这样能清晰表明函数非本地定义，同时避免重复完整路径。示例 7-13 的代码无法明确看出 <code>add_to_waitlist</code> 的定义位置。</p>
<p>On the other hand, when bringing in structs, enums, and other items with <code>use</code>,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s <code>HashMap</code> struct into the scope of a binary
crate.</p>
<p><span class="highlight">[note]相反地，当引入结构体、枚举等类型时，习惯上指定完整路径。</span>示例 7-14 展示了将标准库的 <code>HashMap</code> 结构体引入二进制 crate 作用域的惯用方式。</p>
<figure class="listing" id="listing-7-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<figcaption><a href="#listing-7-14">Listing 7-14</a>: Bringing <code>HashMap</code> into scope in an idiomatic way 以符合语言习惯的方式将 <code>HashMap</code> 引入作用域</figcaption>
</figure>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>此惯例没有特别原因，仅是社区形成的共识，开发者已习惯以此方式读写 Rust 代码。</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two <code>Result</code> types into scope that have the same name but
different parent modules, and how to refer to them.</p>
<p>例外情况是当引入两个同名项时，因为 Rust 不允许这样做。示例 7-15 展示了如何引入两个同名但父模块不同的 <code>Result</code> 类型及其引用方式。</p>
<figure class="listing" id="listing-7-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="#listing-7-15">Listing 7-15</a>: Bringing two types with the same name into the same scope requires using their parent modules. 将同名类型引入同一作用域需使用父模块区分</figcaption>
</figure>
<p>As you can see, using the parent modules distinguishes the two <code>Result</code> types.
If instead we specified <code>use std::fmt::Result</code> and <code>use std::io::Result</code>, we’d
have two <code>Result</code> types in the same scope, and Rust wouldn’t know which one we
meant when we used <code>Result</code>.</p>
<p>可见使用父模块能区分两个 <code>Result</code> 类型。若指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，则同一作用域会出现两个 <code>Result</code> 类型，Rust 无法确定使用 <code>Result</code> 时的具体指向。</p>
<h3 id="providing-new-names-with-the-as-keyword-使用-as-关键字提供新名称"><a class="header" href="#providing-new-names-with-the-as-keyword-使用-as-关键字提供新名称">Providing New Names with the <code>as</code> Keyword 使用 <code>as</code> 关键字提供新名称</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or <em>alias</em>, for the type. Listing 7-16 shows another way to write
the code in Listing 7-15 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<p>解决同名类型冲突的另一种方案：在路径后指定 <code>as</code> 及新本地名称（即别名）。示例 7-16 通过 <code>as</code> 重命名其中一个 <code>Result</code> 类型，提供了另一种实现方式。</p>
<figure class="listing" id="listing-7-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="#listing-7-16">Listing 7-16</a>: Renaming a type when it’s brought into scope with the <code>as</code> keyword 使用 <code>as</code> 关键字在引入作用域时重命名类型</figcaption>
</figure>
<p>In the second <code>use</code> statement, we chose the new name <code>IoResult</code> for the
<code>std::io::Result</code> type, which won’t conflict with the <code>Result</code> from <code>std::fmt</code>
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!</p>
<p>第二个 <code>use</code> 语句中，我们将 <code>std::io::Result</code> 重命名为 <code>IoResult</code>，避免与已引入的 <code>std::fmt::Result</code> 冲突。示例 7-15 和 7-16 均符合语言习惯，可自由选择！</p>
<h3 id="re-exporting-names-with-pub-use-使用-pub-use-重导出名称"><a class="header" href="#re-exporting-names-with-pub-use-使用-pub-use-重导出名称">Re-exporting Names with <code>pub use</code> 使用 <code>pub use</code> 重导出名称</a></h3>
<p>When we bring a name into scope with the <code>use</code> keyword, the name is private to
the scope into which we imported it. To enable code outside that scope to refer
to that name as if it had been defined in that scope, we can combine <code>pub</code> and
<code>use</code>. This technique is called <em>re-exporting</em> because we’re bringing an item
into scope but also making that item available for others to bring into their
scope.</p>
<p>使用 <code>use</code> 关键字引入作用域的名称默认私有。若要让外部代码像访问本地定义一样访问该名称，可结合 <code>pub</code> 和 <code>use</code>，此技术称为重导出（re-exporting），因为我们既将项引入作用域，又允许其他代码导入该项。</p>
<p>Listing 7-17 shows the code in Listing 7-11 with <code>use</code> in the root module
changed to <code>pub use</code>.</p>
<p>示例 7-17 将示例 7-11 中根模块的 <code>use</code> 改为 <code>pub use</code>。</p>
<figure class="listing" id="listing-7-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-17">Listing 7-17</a>: Making a name available for any code to use from a new scope with <code>pub use</code> 使用 <code>pub use</code> 使名称可从新作用域公开访问</figcaption>
</figure>
<p>Before this change, external code would have to call the <code>add_to_waitlist</code>
function by using the path
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>, which also would have
required the <code>front_of_house</code> module to be marked as <code>pub</code>. Now that this <code>pub  use</code> has re-exported the <code>hosting</code> module from the root module, external code
can use the path <code>restaurant::hosting::add_to_waitlist()</code> instead.</p>
<p>修改前，外部代码需通过路径 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 调用函数，且 <code>front_of_house</code> 模块需标记为 <code>pub</code>。现在通过 <code>pub use</code> 从根模块重导出 <code>hosting</code> 后，外部代码可使用路径 <code>restaurant::hosting::add_to_waitlist()</code>。</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With <code>pub  use</code>, we can write our code with one structure but expose a different structure.
Doing so makes our library well organized for programmers working on the library
and programmers calling the library. We’ll look at another example of <code>pub use</code>
and how it affects your crate’s documentation in “Exporting a Convenient Public
API with <code>pub use</code>” in Chapter 14.</p>
<p>当代码内部结构与调用者理解的领域模型不同时，重导出非常有用。例如在餐厅隐喻中，经营者考虑的是“前厅”和“后厨”，但顾客可能不会这样区分。通过 <code>pub use</code>，我们可以用一种结构编写代码，却暴露另一种结构。这样既便于库开发者组织代码，也便于库使用者调用。第 14 章将通过“使用 <code>pub use</code> 导出便捷的公共 API”展示另一个案例及其对文档的影响。</p>
<h3 id="using-external-packages-使用外部包"><a class="header" href="#using-external-packages-使用外部包">Using External Packages 使用外部包</a></h3>
<p>In Chapter 2, we programmed a guessing game project that used an external
package called <code>rand</code> to get random numbers. To use <code>rand</code> in our project, we
added this line to <em>Cargo.toml</em>:</p>
<p>在第 2 章的猜数字项目中，我们使用名为 <code>rand</code> 的外部包获取随机数。要在项目中使用 <code>rand</code>，需在 <em>Cargo.toml</em> 中添加：</p>
<figure class="listing">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</figure>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the
<code>rand</code> package and any dependencies from <a href="https://crates.io/">crates.io</a> and
make <code>rand</code> available to our project.</p>
<p>在 <em>Cargo.toml</em> 中添加 <code>rand</code> 依赖会指示 Cargo 从 <a href="https://crates.io/">crates.io</a> 下载该包及其依赖，并使 <code>rand</code> 对我们的项目可用。</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a
<code>use</code> line starting with the name of the crate, <code>rand</code>, and listed the items we
wanted to bring into scope. Recall that in “Generating a Random
Number” in Chapter 2, we brought the <code>Rng</code> trait into
scope and called the <code>rand::thread_rng</code> function:</p>
<p>接着通过以 crate 名 <code>rand</code> 开头的 <code>use</code> 行将定义引入作用域。回顾第 2 章“生成随机数”部分，我们将 <code>Rng</code> 特质引入作用域并调用 <code>rand::thread_rng</code> 函数：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>Members of the Rust community have made many packages available at
<a href="https://crates.io/">crates.io</a>, and pulling any of them into your package
involves these same steps: listing them in your package’s <em>Cargo.toml</em> file and
using <code>use</code> to bring items from their crates into scope.</p>
<p>Rust 社区成员在 <a href="https://crates.io/">crates.io</a> 提供了大量包，将它们引入项目都遵循相同步骤：在 <em>Cargo.toml</em> 列出依赖，并通过 <code>use</code> 将项从它们的 crate 引入作用域。</p>
<p>Note that the standard <code>std</code> library is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change <em>Cargo.toml</em> to include <code>std</code>. But we do need to refer to
it with <code>use</code> to bring items from there into our package’s scope. For example,
with <code>HashMap</code> we would use this line:</p>
<p>注意标准库 <code>std</code> 也是外部 crate。因其随 Rust 语言一同分发，无需修改 <em>Cargo.toml</em> 来包含 <code>std</code>，但仍需通过 <code>use</code> 将其项引入项目作用域。例如引入 <code>HashMap</code> 需使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library
crate.</p>
<p>这是以标准库 crate 名 <code>std</code> 开头的绝对路径。</p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists-使用嵌套路径简化大量-use-列表"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists-使用嵌套路径简化大量-use-列表">Using Nested Paths to Clean Up Large <code>use</code> Lists 使用嵌套路径简化大量 <code>use</code> 列表</a></h3>
<p>If we’re using multiple items defined in the same crate or same module, listing
each item on its own line can take up a lot of vertical space in our files. For
example, these two <code>use</code> statements we had in the guessing game in Listing 2-4
bring items from <code>std</code> into scope:</p>
<p>当使用同一 crate 或模块中定义的多个项时，逐行列出的方式会占用大量垂直空间。例如示例 2-4 猜数字游戏中这两个从 <code>std</code> 引入项的语句：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.</p>
<p>我们可以改用嵌套路径在一行内引入相同项。具体做法是指定路径的共同部分，后跟双冒号和花括号包裹的不同部分列表，如示例 7-18 所示。</p>
<figure class="listing" id="listing-7-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-18">Listing 7-18</a>: Specifying a nested path to bring multiple items with the same prefix into scope 使用嵌套路径将具有相同前缀的多个项引入作用域</figcaption>
</figure>
<p>In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate <code>use</code> statements
needed by a lot!</p>
<p>在大型程序中，使用嵌套路径从同一 crate 或模块引入多项能显著减少单独的 <code>use</code> 语句数量！</p>
<p>We can use a nested path at any level in a path, which is useful when combining
two <code>use</code> statements that share a subpath. For example, Listing 7-19 shows two
<code>use</code> statements: one that brings <code>std::io</code> into scope and one that brings
<code>std::io::Write</code> into scope.</p>
<p>嵌套路径可在路径的任何层级使用，这在合并共享子路径的两个 <code>use</code> 语句时特别有用。例如示例 7-19 的两个语句：一个引入 <code>std::io</code>，另一个引入 <code>std::io::Write</code>。</p>
<figure class="listing" id="listing-7-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<figcaption><a href="#listing-7-19">Listing 7-19</a>: Two <code>use</code> statements where one is a subpath of the other 两个 <code>use</code> 语句，其中一个是另一个的子路径</figcaption>
</figure>
<p>The common part of these two paths is <code>std::io</code>, and that’s the complete first
path. To merge these two paths into one <code>use</code> statement, we can use <code>self</code> in
the nested path, as shown in Listing 7-20.</p>
<p>这两个路径的共同部分是 <code>std::io</code>（即第一个完整路径）。要合并为一个 <code>use</code> 语句，可在嵌套路径中使用 <code>self</code>，如示例 7-20 所示。</p>
<figure class="listing" id="listing-7-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<figcaption><a href="#listing-7-20">Listing 7-20</a>: Combining the paths in Listing 7-19 into one <code>use</code> statement 将示例 7-19 的路径合并为单个 <code>use</code> 语句</figcaption>
</figure>
<p>This line brings <code>std::io</code> and <code>std::io::Write</code> into scope.</p>
<p>此行将 <code>std::io</code> 和 <code>std::io::Write</code> 同时引入作用域。</p>
<h3 id="the-glob-operator-全局运算符"><a class="header" href="#the-glob-operator-全局运算符">The Glob Operator 全局运算符</a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by the <code>*</code> glob operator:</p>
<p>若要将路径中所有公共项引入作用域，可在路径后添加 <code>*</code> 全局运算符：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>std::collections</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined. Additionally, if the dependency changes its definitions, what
you’ve imported changes as well, which may lead to compiler errors when you
upgrade the dependency if the dependency adds a definition with the same name
as a definition of yours in the same scope, for example.</p>
<p>此 <code>use</code> 语句将 <code>std::collections</code> 内定义的所有公共项引入当前作用域。使用全局运算符需谨慎！它可能导致作用域内的名称来源不清晰。此外，若依赖项更新定义（例如添加了与您代码中同名的项），升级依赖时可能引发冲突错误。</p>
<p>The glob operator is often used when testing to bring everything under test into
the <code>tests</code> module; we’ll talk about that in “How to Write
Tests” in Chapter 11. The glob operator is also
sometimes used as part of the prelude pattern: see the standard library
documentation for more
information on that pattern.</p>
<p>全局运算符常用于测试场景（将测试模块的所有内容引入 <code>tests</code> 模块），第 11 章“如何编写测试”将详细讨论。它有时也作为预导入模式的一部分使用，详见标准库文档中的模式说明。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
