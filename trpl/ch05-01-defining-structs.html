<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining and Instantiating Structs 定义和实例化结构体 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="defining-and-instantiating-structs-定义和实例化结构体"><a class="header" href="#defining-and-instantiating-structs-定义和实例化结构体">Defining and Instantiating Structs 定义和实例化结构体</a></h2>
<p>Structs are similar to tuples, discussed in “The Tuple Type” section, in that both hold multiple related values. Like tuples, the
pieces of a struct can be different types. Unlike with tuples, in a struct
you’ll name each piece of data so it’s clear what the values mean. Adding these
names means that structs are more flexible than tuples: you don’t have to rely
on the order of the data to specify or access the values of an instance.</p>
<p>结构体与元组（在“元组类型”章节讨论过）的相似之处在于它们都持有多个关联值。与元组类似，结构体的各个部分可以是不同类型。但与元组不同的是，在结构体中你需要为每个数据片段命名，以明确值的含义。添加这些名称意味着结构体比元组更灵活：无需依赖数据顺序来指定或访问实例的值。</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a
struct that stores information about a user account.</p>
<p>定义结构体时，需输入关键字 <code>struct</code> 并为整个结构体命名。结构体名称应描述所组合数据片段的意义。随后，在大括号内定义数据片段的名称和类型，这些称为<strong>字段</strong>。例如，示例5-1展示了一个存储用户账户信息的结构体。</p>
<figure class="listing" id="listing-5-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="#listing-5-1">Listing 5-1</a>: A <code>User</code> struct definition <code>User</code> 结构体定义</figcaption>
</figure>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing <em><code>key:  value</code></em> pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.</p>
<p>定义结构体后，通过为每个字段指定具体值来创建该结构体的<strong>实例</strong>。创建实例时，先声明结构体名称，然后添加包含 <strong><code>键: 值</code></strong> 对的大括号，其中键是字段名，值是要存储的数据。字段的顺序无需与结构体声明时的顺序一致。换言之，结构体定义像是类型的通用模板，而实例则用具体数据填充该模板以创建类型的值。例如，我们可以如示例5-2所示声明特定用户。</p>
<figure class="listing" id="listing-5-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-2">Listing 5-2</a>: Creating an instance of the <code>User</code> struct 创建 <code>User</code> 结构体实例</figcaption>
</figure>
<p>To get a specific value from a struct, we use dot notation. For example, to
access this user’s email address, we use <code>user1.email</code>. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field. Listing 5-3 shows how to change the value in the <code>email</code>
field of a mutable <code>User</code> instance.</p>
<p>要从结构体获取特定值，需使用点号表示法。例如，访问此用户的邮箱地址使用 <code>user1.email</code>。若实例可变，可通过点号表示法赋值给特定字段来修改值。示例5-3展示了如何修改可变 <code>User</code> 实例的 <code>email</code> 字段值。</p>
<figure class="listing" id="listing-5-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<figcaption><a href="#listing-5-3">Listing 5-3</a>: Changing the value in the <code>email</code> field of a <code>User</code> instance 修改 <code>User</code> 实例的 <code>email</code> 字段值</figcaption>
</figure>
<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.</p>
<p>注意：整个实例必须是可变的；Rust不允许仅将某些字段标记为可变。与其他表达式类似，我们可以在函数体末尾将结构体的新实例作为最后一个表达式来隐式返回该实例。</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with
the given email and username. The <code>active</code> field gets the value of <code>true</code>, and
the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<p>示例5-4展示了一个 <code>build_user</code> 函数，它返回具有指定邮箱和用户名的 <code>User</code> 实例。<code>active</code> 字段值为 <code>true</code>，<code>sign_in_count</code> 值为 <code>1</code>。</p>
<figure class="listing" id="listing-5-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-5-4">Listing 5-4</a>: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance 接收邮箱和用户名并返回 <code>User</code> 实例的 <code>build_user</code> 函数</figcaption>
</figure>
<p>It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the <code>email</code> and <code>username</code> field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<p>将函数参数命名为与结构体字段同名是合理的，但重复 <code>email</code> 和 <code>username</code> 的字段名和变量名略显繁琐。若结构体字段更多，重复每个名称会更令人厌烦。幸运的是，存在便捷的简写方式！</p>
<h3 id="using-the-field-init-shorthand-使用字段初始化简写语法"><a class="header" href="#using-the-field-init-shorthand-使用字段初始化简写语法">Using the Field Init Shorthand 使用字段初始化简写语法</a></h3>
<p>Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the <em>field init shorthand</em> syntax to rewrite
<code>build_user</code> so it behaves exactly the same but doesn’t have the repetition of
<code>username</code> and <code>email</code>, as shown in Listing 5-5.</p>
<p>由于示例5-4中<span class="highlight">[note]参数名与结构体字段名完全相同，我们可以使用<strong>字段初始化简写语法</strong></span>重写 <code>build_user</code>，其行为完全相同但避免了 <code>username</code> 和 <code>email</code> 的重复，如示例5-5所示。</p>
<figure class="listing" id="listing-5-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-5-5">Listing 5-5</a>: A <code>build_user</code> function that uses field init shorthand because the <code>username</code> and <code>email</code> parameters have the same name as struct fields 使用字段初始化简写的 <code>build_user</code> 函数（因 <code>username</code> 和 <code>email</code> 参数与结构体字段同名）</figcaption>
</figure>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field
named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the
<code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather
than <code>email: email</code>.</p>
<p>这里我们创建了 <code>User</code> 结构体的新实例，该结构体有名为 <code>email</code> 的字段。我们希望将 <code>email</code> 字段的值设置为 <code>build_user</code> 函数中 <code>email</code> 参数的值。因为 <code>email</code> 字段和 <code>email</code> 参数同名，只需写 <code>email</code> 而非 <code>email: email</code>。</p>
<h3 id="creating-instances-from-other-instances-with-struct-update-syntax-使用结构体更新语法从其他实例创建"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax-使用结构体更新语法从其他实例创建">Creating Instances from Other Instances with Struct Update Syntax 使用结构体更新语法从其他实例创建</a></h3>
<p>It’s often useful to create a new instance of a struct that includes most of
the values from another instance of the same type, but changes some. You can do
this using <em>struct update syntax</em>.</p>
<p>创建一个结构体的新实例，其中包含来自同类型另一实例的大部分值但修改部分字段，通常很有用。这可以通过<strong>结构体更新语法</strong>实现。</p>
<p>First, in Listing 5-6 we show how to create a new <code>User</code> instance in <code>user2</code>
regularly, without the update syntax. We set a new value for <code>email</code> but
otherwise use the same values from <code>user1</code> that we created in Listing 5-2.</p>
<p>首先，示例5-6展示了如何在不使用更新语法的情况下常规创建 <code>user2</code> 的新 <code>User</code> 实例。我们为 <code>email</code> 设置新值，其余值沿用示例5-2中创建的 <code>user1</code>。</p>
<figure class="listing" id="listing-5-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-6">Listing 5-6</a>: Creating a new <code>User</code> instance using all but one of the values from <code>user1</code> 使用 <code>user1</code> 中除一个值外的所有值创建新 <code>User</code> 实例</figcaption>
</figure>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.</p>
<p>使用结构体更新语法，我们可以用更少的代码实现相同效果，如示例5-7所示。<span class="highlight">[note]<code>..</code> 语法指定未显式设置的剩余字段应与给定实例中的字段同值。</span></p>
<figure class="listing" id="listing-5-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<figcaption><a href="#listing-5-7">Listing 5-7</a>: Using struct update syntax to set a new <code>email</code> value for a <code>User</code> instance but to use the rest of the values from <code>user1</code> 使用结构体更新语法为 <code>User</code> 实例设置新 <code>email</code> 值，其余值沿用 <code>user1</code></figcaption>
</figure>
<p>The code in Listing 5-7 also creates an instance in <code>user2</code> that has a
different value for <code>email</code> but has the same values for the <code>username</code>,
<code>active</code>, and <code>sign_in_count</code> fields from <code>user1</code>. The <code>..user1</code> must come last
to specify that any remaining fields should get their values from the
corresponding fields in <code>user1</code>, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.</p>
<p>示例5-7中的代码同样创建了 <code>user2</code> 实例，其 <code>email</code> 值不同，但 <code>username</code>、<code>active</code> 和 <code>sign_in_count</code> 字段的值与 <code>user1</code> 相同。<code>..user1</code> 必须置于最后，表示剩余字段从 <code>user1</code> 的对应字段中取值。我们可以在任意顺序中指定任意多字段的值，无需考虑结构体定义中的字段顺序。</p>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because
it moves the data, just as we saw in the “Variables and Data Interacting with
Move” section. In this example, we can no longer use
<code>user1</code> after creating <code>user2</code> because the <code>String</code> in the <code>username</code> field of
<code>user1</code> was moved into <code>user2</code>. If we had given <code>user2</code> new <code>String</code> values for
both <code>email</code> and <code>username</code>, and thus only used the <code>active</code> and <code>sign_in_count</code>
values from <code>user1</code>, then <code>user1</code> would still be valid after creating <code>user2</code>.
Both <code>active</code> and <code>sign_in_count</code> are types that implement the <code>Copy</code> trait, so
the behavior we discussed in the “Stack-Only Data: Copy”
section would apply. We can also still use <code>user1.email</code> in this example,
because its value was not moved out of <code>user1</code>.</p>
<p>注意：<span class="highlight">[note]结构体更新语法使用 <code>=</code> 进行赋值，这是因为它会移动数据</span>，正如我们在“变量与数据的交互：移动”章节所见。此例中，创建 <code>user2</code> 后无法再使用 <code>user1</code>，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>String</code> 已被移动到 <code>user2</code>。若我们为 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都赋予新 <code>String</code> 值，从而仅使用 <code>user1</code> 的 <code>active</code> 和 <code>sign_in_count</code> 值，那么创建 <code>user2</code> 后 <code>user1</code> 仍然有效。因为 <code>active</code> 和 <code>sign_in_count</code> 是实现了 <code>Copy</code> trait 的类型，符合“仅栈数据：拷贝”章节讨论的行为。此例中仍可使用 <code>user1.email</code>，因为其值未被移出 <code>user1</code>。</p>
<h3 id="using-tuple-structs-without-named-fields-to-create-different-types-使用元组结构体创建无名字段的不同类型"><a class="header" href="#using-tuple-structs-without-named-fields-to-create-different-types-使用元组结构体创建无名字段的不同类型">Using Tuple Structs Without Named Fields to Create Different Types 使用元组结构体创建无名字段的不同类型</a></h3>
<p>Rust also supports structs that look similar to tuples, called <em>tuple structs</em>.
Tuple structs have the added meaning the struct name provides but don’t have
names associated with their fields; rather, they just have the types of the
fields. Tuple structs are useful when you want to give the whole tuple a name
and make the tuple a different type from other tuples, and when naming each
field as in a regular struct would be verbose or redundant.</p>
<p>Rust 也支持类似元组的结构体，称为<strong>元组结构体</strong>（tuple structs）。<span class="highlight">[note]元组结构体通过结构体名称提供附加含义，但字段没有关联名称</span>；仅包含字段类型。当你想为整个元组命名并使其区别于其他元组类型，或为每个字段命名（如常规结构体）会显得冗长或多余时，元组结构体非常有用。</p>
<p>To define a tuple struct, start with the <code>struct</code> keyword and the struct name
followed by the types in the tuple. For example, here we define and use two
tuple structs named <code>Color</code> and <code>Point</code>:</p>
<p>定义元组结构体时，以 <code>struct</code> 关键字和结构体名称开头，后跟元组中的类型。例如，此处定义并使用了两个名为 <code>Color</code> 和 <code>Point</code> 的元组结构体：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</figure>
<p>Note that the <code>black</code> and <code>origin</code> values are different types because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct might have the same types. For
example, a function that takes a parameter of type <code>Color</code> cannot take a
<code>Point</code> as an argument, even though both types are made up of three <code>i32</code>
values. Otherwise, tuple struct instances are similar to tuples in that you can
destructure them into their individual pieces, and you can use a <code>.</code> followed
by the index to access an individual value. Unlike tuples, tuple structs
require you to name the type of the struct when you destructure them. For
example, we would write <code>let Point(x, y, z) = origin;</code> to destructure the
values in the <code>origin</code> point into variables named <code>x</code>, <code>y</code>, and <code>z</code>.</p>
<p>注意：<code>black</code> 和 <code>origin</code> 属于不同类型，因为它们是不同元组结构体的实例。即使结构体内字段类型相同，你定义的每个结构体仍是独立类型。例如，接收 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，尽管两者都由三个 <code>i32</code> 值组成。除此之外，元组结构体实例的行为类似于元组：可解构为单独部分，也可用 <code>.</code> 后跟索引访问单个值。与元组不同的是，<span class="highlight">[note]解构元组结构体时需要声明结构体类型</span>。例如，解构 <code>origin</code> 点中的值到变量 <code>x</code>、<code>y</code> 和 <code>z</code> 需写作：<code>let Point(x, y, z) = origin;</code>。</p>
<h3 id="unit-like-structs-without-any-fields-无字段的类单元结构体"><a class="header" href="#unit-like-structs-without-any-fields-无字段的类单元结构体">Unit-Like Structs Without Any Fields 无字段的类单元结构体</a></h3>
<p>You can also define structs that don’t have any fields! These are called
<em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type that
we mentioned in “The Tuple Type” section. Unit-like
structs can be useful when you need to implement a trait on some type but don’t
have any data that you want to store in the type itself. We’ll discuss traits
in Chapter 10. Here’s an example of declaring and instantiating a unit struct
named <code>AlwaysEqual</code>:</p>
<p><span class="highlight">[note]你也可以定义没有任何字段的结构体！它们被称为<strong>类单元结构体</strong>（unit-like structs），因为其行为类似于 <code>()</code>（我们在“元组类型”章节提到的单元类型）。当需要在某类型上实现 trait 但不想在类型本身中存储任何数据时，类单元结构体很有用。</span>我们将在第10章讨论 trait。以下示例声明并实例化了名为 <code>AlwaysEqual</code> 的类单元结构体：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</figure>
<p>To define <code>AlwaysEqual</code>, we use the <code>struct</code> keyword, the name we want, and
then a semicolon. No need for curly brackets or parentheses! Then we can get an
instance of <code>AlwaysEqual</code> in the <code>subject</code> variable in a similar way: using the
name we defined, without any curly brackets or parentheses. Imagine that later
we’ll implement behavior for this type such that every instance of
<code>AlwaysEqual</code> is always equal to every instance of any other type, perhaps to
have a known result for testing purposes. We wouldn’t need any data to
implement that behavior! You’ll see in Chapter 10 how to define traits and
implement them on any type, including unit-like structs.</p>
<p>定义 <code>AlwaysEqual</code> 时，使用 <code>struct</code> 关键字、名称后加分号，无需大括号或圆括号！随后可用类似方式在 <code>subject</code> 变量中获取 <code>AlwaysEqual</code> 实例：使用定义的名称，不加任何大括号或圆括号。假设之后我们会为这种类型实现行为：每个 <code>AlwaysEqual</code> 实例始终等于任何其他类型的实例（可能用于测试目的）。实现该行为不需要任何数据！第10章将介绍如何定义 trait 并在任意类型（包括类单元结构体）上实现它们。</p>
<section class="note" aria-role="note">
<h3 id="ownership-of-struct-data-结构体数据的所有权"><a class="header" href="#ownership-of-struct-data-结构体数据的所有权">Ownership of Struct Data 结构体数据的所有权</a></h3>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code>
type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice
because we want each instance of this struct to own all of its data and for
that data to be valid for as long as the entire struct is valid.</p>
<p>在示例5-1的 <code>User</code> 结构体定义中，我们使用了自有类型 <code>String</code> 而非字符串切片 <code>&amp;str</code>。这是有意为之，因为我们希望此结构体的每个实例都拥有其全部数据，且只要整个结构体有效，其数据就有效。</p>
<p>It’s also possible for structs to store references to data owned by something
else, but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll
discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
is valid for as long as the struct is. Let’s say you try to store a reference
in a struct without specifying lifetimes, like the following; this won’t work:</p>
<p>结构体也可以存储指向其他位置数据的引用，但这需要使用<strong>生命周期</strong>（Rust 的特性，将在第10章讨论）。生命周期确保结构体引用的数据在结构体有效期间持续有效。假设你尝试在结构体中存储未指定生命周期的引用（如下所示），这将无法工作：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</figure>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<p>编译器会提示需要生命周期标识符：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store
references in structs, but for now, we’ll fix errors like these using owned
types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
<p>第10章将讨论如何修复这些错误以在结构体中存储引用，但目前我们使用自有类型（如 <code>String</code>）替代引用（如 <code>&amp;str</code>）来解决此类问题。</p>
</section>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
