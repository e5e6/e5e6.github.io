<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generic Data Types 泛型数据类型 - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="generic-data-types-泛型数据类型"><a class="header" href="#generic-data-types-泛型数据类型">Generic Data Types 泛型数据类型</a></h2>
<p>We use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.</p>
<p>我们使用泛型为函数签名或结构体等项创建定义，随后可搭配多种具体数据类型使用。先看如何用泛型定义函数、结构体、枚举和方法，再讨论泛型对代码性能的影响。</p>
<h3 id="in-function-definitions-函数定义中的泛型"><a class="header" href="#in-function-definitions-函数定义中的泛型">In Function Definitions 函数定义中的泛型</a></h3>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.</p>
<p>定义使用泛型的函数时，将泛型放在函数签名中通常指定参数和返回值类型的位置。这样使代码更灵活，为调用者提供更多功能，同时避免代码重复。</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice. We’ll then combine these into a single
function that uses generics.</p>
<p>延续 <code>largest</code> 函数，示例 10-4 展示两个在切片中查找最大值的函数。随后将它们合并为使用泛型的单一函数。</p>
<figure class="listing" id="listing-10-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("The largest char is {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<figcaption><a href="#listing-10-4">Listing 10-4</a>: Two functions that differ only in their names and in the types in their signatures 仅名称和签名类型不同的两个函数</figcaption>
</figure>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.</p>
<p><code>largest_i32</code> 是示例 10-3 提取的函数，用于查找切片中的最大 <code>i32</code>。<code>largest_char</code> 函数查找切片中的最大 <code>char</code>。由于函数体相同，我们引入泛型类型参数来消除重复。</p>
<p>To parameterize the types in a new single function, we need to name the type
parameter, just as we do for the value parameters to a function. You can use
any identifier as a type parameter name. But we’ll use <code>T</code> because, by
convention, type parameter names in Rust are short, often just one letter, and
Rust’s type-naming convention is CamelCase. Short for <em>type</em>, <code>T</code> is the default
choice of most Rust programmers.</p>
<p>要在新函数中参数化类型，需命名类型参数（如同函数值参数的命名）。可用任意标识符作为类型参数名，但按 Rust 惯例（驼峰命名法），我们使用 <code>T</code>（“type“的缩写）。<code>T</code> 是多数 Rust 程序员的首选。</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, we place type name declarations inside angle brackets,
<code>&lt;&gt;</code>, between the name of the function and the parameter list, like this:</p>
<p>在函数体中使用参数时，需在签名中声明参数名以便编译器理解含义。类似地，在函数签名中使用类型参数名前需先声明。定义泛型 <code>largest</code> 函数时，将类型声明放在函数名与参数列表间的尖括号 <code>&lt;&gt;</code> 中：</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>We read this definition as: the function <code>largest</code> is generic over some type
<code>T</code>. This function has one parameter named <code>list</code>, which is a slice of values
of type <code>T</code>. The <code>largest</code> function will return a reference to a value of the
same type <code>T</code>.</p>
<p>此定义读作：函数 <code>largest</code> 针对类型 <code>T</code> 是泛型的。它有一个 <code>list</code> 参数（类型为 <code>T</code> 的切片），返回同类型 <code>T</code> 值的引用。</p>
<p>Listing 10-5 shows the combined <code>largest</code> function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of <code>i32</code> values or <code>char</code> values. Note that this code won’t
compile yet.</p>
<p>示例 10-5 展示了在签名中使用泛型数据类型的合并 <code>largest</code> 函数定义，以及用 <code>i32</code> 切片或 <code>char</code> 切片调用函数的方式。注意：此代码暂不能编译。</p>
<figure class="listing" id="listing-10-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {result}");
}</code></pre>
<figcaption><a href="#listing-10-5">Listing 10-5</a>: The <code>largest</code> function using generic type parameters; this doesn’t compile 使用泛型类型参数的 <code>largest</code> 函数（暂不能编译）</figcaption>
</figure>
<p>If we compile this code right now, we’ll get this error:</p>
<p>若现在编译，将出现错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The help text mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>, and we’re
going to talk about traits in the next section. For now, know that this error
states that the body of <code>largest</code> won’t work for all possible types that <code>T</code>
could be. Because we want to compare values of type <code>T</code> in the body, we can
only use types whose values can be ordered. To enable comparisons, the standard
library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types
(see Appendix C for more on this trait). To fix Listing 10-5, we can follow the
help text’s suggestion and restrict the types valid for <code>T</code> to only those that
implement <code>PartialOrd</code>. The listing will then compile, because the standard
library implements <code>PartialOrd</code> on both <code>i32</code> and <code>char</code>.</p>
<p>帮助文本提到 <code>std::cmp::PartialOrd</code>（一种<em>特质</em>），下节将讨论特质。目前只需知道：该错误表明 <code>largest</code> 函数体不能适用于 <code>T</code> 的所有可能类型。因为需在函数体中比较 <code>T</code> 类型值，我们只能使用可排序的类型。为实现比较，标准库提供了可针对类型实现的 <code>std::cmp::PartialOrd</code> 特质（附录 C 有详细信息）。修复示例 10-5 的方法是遵循帮助文本建议，限制 <code>T</code> 为实现了 <code>PartialOrd</code> 的类型（标准库已为 <code>i32</code> 和 <code>char</code> 实现该特质）。</p>
<h3 id="in-struct-definitions-结构体定义中的泛型"><a class="header" href="#in-struct-definitions-结构体定义中的泛型">In Struct Definitions 结构体定义中的泛型</a></h3>
<p>We can also define structs to use a generic type parameter in one or more
fields using the <code>&lt;&gt;</code> syntax. Listing 10-6 defines a <code>Point&lt;T&gt;</code> struct to hold
<code>x</code> and <code>y</code> coordinate values of any type.</p>
<p>我们也可用 <code>&lt;&gt;</code> 语法定义结构体，使其一个或多个字段使用泛型类型参数。示例 10-6 定义了 <code>Point&lt;T&gt;</code> 结构体来保存任意类型的 <code>x</code> 和 <code>y</code> 坐标值。</p>
<figure class="listing" id="listing-10-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<figcaption><a href="#listing-10-6">Listing 10-6</a>: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code> values of type <code>T</code> 保存 <code>T</code> 类型 <code>x</code> 和 <code>y</code> 值的 <code>Point&lt;T&gt;</code> 结构体</figcaption>
</figure>
<p>The syntax for using generics in struct definitions is similar to that used in
function definitions. First we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we use the generic
type in the struct definition where we would otherwise specify concrete data
types.</p>
<p>结构体定义中使用泛型的语法类似于函数定义。首先在结构体名后的尖括号内声明类型参数名，然后在结构体定义中使用该泛型类型（替代具体类型）。</p>
<p>Note that because we’ve used only one generic type to define <code>Point&lt;T&gt;</code>, this
definition says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code>, and
the fields <code>x</code> and <code>y</code> are <em>both</em> that same type, whatever that type may be. If
we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in
Listing 10-7, our code won’t compile.</p>
<p>注意：因 <code>Point&lt;T&gt;</code> 只使用一个泛型类型定义，该定义表示 <code>Point&lt;T&gt;</code> 结构体针对类型 <code>T</code> 是泛型的，且字段 <code>x</code> 和 <code>y</code> 均为同一类型（无论具体类型是什么）。若创建包含不同类型值的 <code>Point&lt;T&gt;</code> 实例（如示例 10-7），代码将无法编译。</p>
<figure class="listing" id="listing-10-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<figcaption><a href="#listing-10-7">Listing 10-7</a>: The fields <code>x</code> and <code>y</code> must be the same type because both have the same generic data type <code>T</code>. <code>x</code> 和 <code>y</code> 必须是相同类型，因两者共享泛型数据类型 <code>T</code></figcaption>
</figure>
<p>In this example, when we assign the integer value <code>5</code> to <code>x</code>, we let the
compiler know that the generic type <code>T</code> will be an integer for this instance of
<code>Point&lt;T&gt;</code>. Then when we specify <code>4.0</code> for <code>y</code>, which we’ve defined to have the
same type as <code>x</code>, we’ll get a type mismatch error like this:</p>
<p>此例中，将整数值 <code>5</code> 赋给 <code>x</code> 时，编译器已知该 <code>Point&lt;T&gt;</code> 实例的泛型 <code>T</code> 为整数类型。接着为 <code>y</code> 指定 <code>4.0</code>（定义中要求与 <code>x</code> 同类型）时，会出现类型不匹配错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we change the definition of <code>Point</code> to be generic over types <code>T</code>
and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code>.</p>
<p>要定义 <code>x</code> 和 <code>y</code> 均为泛型但类型可不同的 <code>Point</code> 结构体，可使用多个泛型类型参数。例如示例 10-8 中，将 <code>Point</code> 定义为针对类型 <code>T</code> 和 <code>U</code> 的泛型，其中 <code>x</code> 为 <code>T</code> 类型，<code>y</code> 为 <code>U</code> 类型。</p>
<figure class="listing" id="listing-10-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<figcaption><a href="#listing-10-8">Listing 10-8</a>: A <code>Point&lt;T, U&gt;</code> generic over two types so that <code>x</code> and <code>y</code> can be values of different types 针对两种类型的 <code>Point&lt;T, U&gt;</code> 泛型，使 <code>x</code> 和 <code>y</code> 可为不同类型的值</figcaption>
</figure>
<p>Now all the instances of <code>Point</code> shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. If you’re finding you need lots of generic types in
your code, it could indicate that your code needs restructuring into smaller
pieces.</p>
<p>现在所有 <code>Point</code> 实例均有效！定义中可使用任意数量的泛型类型参数，但过多会使代码难以阅读。若需大量泛型类型，可能意味着需要重构代码为更小的模块。</p>
<h3 id="in-enum-definitions-枚举定义中的泛型"><a class="header" href="#in-enum-definitions-枚举定义中的泛型">In Enum Definitions 枚举定义中的泛型</a></h3>
<p>As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the <code>Option&lt;T&gt;</code> enum that the standard
library provides, which we used in Chapter 6:</p>
<p>如同结构体，我们可定义枚举使其变体持有泛型数据类型。再看标准库的 <code>Option&lt;T&gt;</code> 枚举（第 6 章用过）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>This definition should now make more sense to you. As you can see, the
<code>Option&lt;T&gt;</code> enum is generic over type <code>T</code> and has two variants: <code>Some</code>, which
holds one value of type <code>T</code>, and a <code>None</code> variant that doesn’t hold any value.
By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of an
optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction
no matter what the type of the optional value is.</p>
<p>现在你应更理解此定义了。如你所见，<code>Option&lt;T&gt;</code> 枚举针对类型 <code>T</code> 是泛型的，有两个变体：<code>Some</code>（持有类型 <code>T</code> 的值）和 <code>None</code>（不持有值）。通过 <code>Option&lt;T&gt;</code> 枚举，我们能表达可选值的抽象概念。由于 <code>Option&lt;T&gt;</code> 是泛型的，无论可选值是什么类型都可使用此抽象。</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<p>枚举也可使用多个泛型类型。第 9 章用过的 <code>Result</code> 枚举定义即为一例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>, and has two variants:
<code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (return a value of some type <code>T</code>) or fail
(return an error of some type <code>E</code>). In fact, this is what we used to open a
file in Listing 9-3, where <code>T</code> was filled in with the type <code>std::fs::File</code> when
the file was opened successfully and <code>E</code> was filled in with the type
<code>std::io::Error</code> when there were problems opening the file.</p>
<p><code>Result</code> 枚举针对 <code>T</code> 和 <code>E</code> 两种类型是泛型的，有两个变体：<code>Ok</code>（持有类型 <code>T</code> 的值）和 <code>Err</code>（持有类型 <code>E</code> 的值）。此定义便于在任何可能成功（返回类型 <code>T</code> 的值）或失败（返回类型 <code>E</code> 的错误）的操作中使用 <code>Result</code> 枚举。实际上，这正是示例 9-3 中打开文件的方式：成功打开时 <code>T</code> 为 <code>std::fs::File</code> 类型，出问题时 <code>E</code> 为 <code>std::io::Error</code> 类型。</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.</p>
<p>当发现代码中有多个结构体或枚举定义仅因所持值类型不同而存在时，可用泛型类型避免重复。</p>
<h3 id="in-method-definitions-方法定义中的泛型"><a class="header" href="#in-method-definitions-方法定义中的泛型">In Method Definitions 方法定义中的泛型</a></h3>
<p>We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions too. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it.</p>
<p>我们可在结构体和枚举上实现方法（如第 5 章），并在定义中使用泛型类型。示例 10-9 展示了在示例 10-6 定义的 <code>Point&lt;T&gt;</code> 结构体上实现名为 <code>x</code> 的方法。</p>
<figure class="listing" id="listing-10-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
<figcaption><a href="#listing-10-9">Listing 10-9</a>: Implementing a method named <code>x</code> on the <code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type <code>T</code> 在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，返回类型 <code>T</code> 的 <code>x</code> 字段引用</figcaption>
</figure>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference
to the data in the field <code>x</code>.</p>
<p>此处我们在 <code>Point&lt;T&gt;</code> 上定义了返回字段 <code>x</code> 数据引用的方法 <code>x</code>。</p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use <code>T</code> to specify
that we’re implementing methods on the type <code>Point&lt;T&gt;</code>. By declaring <code>T</code> as a
generic type after <code>impl</code>, Rust can identify that the type in the angle
brackets in <code>Point</code> is a generic type rather than a concrete type. We could
have chosen a different name for this generic parameter than the generic
parameter declared in the struct definition, but using the same name is
conventional. If you write a method within an <code>impl</code> that declares a generic
type, that method will be defined on any instance of the type, no matter what
concrete type ends up substituting for the generic type.</p>
<p><span class="highlight">[note]注意必须在 <code>impl</code> 后声明 <code>T</code></span>，这样才能用 <code>T</code> 指定我们在 <code>Point&lt;T&gt;</code> 类型上实现方法。通过在 <code>impl</code> 后声明 <code>T</code>，Rust 能识别 <code>Point</code> 尖括号中的类型是泛型而非具体类型。本可为该泛型参数选择与结构体定义中不同的名称，但使用相同名称是惯例。若在 <code>impl</code> 块内声明泛型类型的方法，则无论最终替换泛型的具体类型是什么，该方法都将在该类型的所有实例上定义。</p>
<p>We can also specify constraints on generic types when defining methods on the
type. We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances
rather than on <code>Point&lt;T&gt;</code> instances with any generic type. In Listing 10-10 we
use the concrete type <code>f32</code>, meaning we don’t declare any types after <code>impl</code>.</p>
<p>定义类型方法时也可指定泛型类型的约束。例如可仅为 <code>Point&lt;f32&gt;</code> 实例实现方法，而非任意泛型类型的 <code>Point&lt;T&gt;</code> 实例。示例 10-10 使用了具体类型 <code>f32</code>（<code>impl</code> 后未声明任何类型）。</p>
<figure class="listing" id="listing-10-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-10-10">Listing 10-10</a>: An <code>impl</code> block that only applies to a struct with a particular concrete type for the generic type parameter <code>T</code> 仅适用于特定具体类型（泛型类型参数 <code>T</code>）结构体的 <code>impl</code> 块</figcaption>
</figure>
<p>This code means the type <code>Point&lt;f32&gt;</code> will have a <code>distance_from_origin</code>
method; other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of type <code>f32</code> will not
have this method defined. The method measures how far our point is from the
point at coordinates (0.0, 0.0) and uses mathematical operations that are
available only for floating-point types.</p>
<p>此代码意味着 <code>Point&lt;f32&gt;</code> 类型将有 <code>distance_from_origin</code> 方法；而 <code>T</code> 非 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则无此方法。该方法计算点距离坐标 (0.0, 0.0) 的远近，使用了仅浮点类型可用的数学运算。</p>
<p>Generic type parameters in a struct definition aren’t always the same as those
you use in that same struct’s method signatures. Listing 10-11 uses the generic
types <code>X1</code> and <code>Y1</code> for the <code>Point</code> struct and <code>X2</code> <code>Y2</code> for the <code>mixup</code> method
signature to make the example clearer. The method creates a new <code>Point</code>
instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>X1</code>) and the <code>y</code>
value from the passed-in <code>Point</code> (of type <code>Y2</code>).</p>
<p>结构体定义中的泛型类型参数不一定与方法签名中的相同。示例 10-11 中为清晰起见，结构体 <code>Point</code> 使用泛型类型 <code>X1</code> 和 <code>Y1</code>，方法 <code>mixup</code> 的签名使用 <code>X2</code> 和 <code>Y2</code>。该方法用 <code>self</code> 的 <code>Point</code>（类型 <code>X1</code>）的 <code>x</code> 值与传入 <code>Point</code>（类型 <code>Y2</code>）的 <code>y</code> 值创建新 <code>Point</code> 实例。</p>
<figure class="listing" id="listing-10-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
<figcaption><a href="#listing-10-11">Listing 10-11</a>: A method that uses generic types different from its struct’s definition 使用与结构体定义不同的泛型类型的方法</figcaption>
</figure>
<p>In <code>main</code>, we’ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code>)
and an <code>f64</code> for <code>y</code> (with value <code>10.4</code>). The <code>p2</code> variable is a <code>Point</code> struct
that has a string slice for <code>x</code> (with value <code>"Hello"</code>) and a <code>char</code> for <code>y</code>
(with value <code>c</code>). Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>,
which will have an <code>i32</code> for <code>x</code> because <code>x</code> came from <code>p1</code>. The <code>p3</code> variable
will have a <code>char</code> for <code>y</code> because <code>y</code> came from <code>p2</code>. The <code>println!</code> macro
call will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>在 <code>main</code> 中，我们定义了 <code>x</code> 为 <code>i32</code>（值 <code>5</code>）、<code>y</code> 为 <code>f64</code>（值 <code>10.4</code>）的 <code>Point</code>。变量 <code>p2</code> 是 <code>x</code> 为字符串切片（值 <code>"Hello"</code>）、<code>y</code> 为 <code>char</code>（值 <code>c</code>）的 <code>Point</code> 结构体。以 <code>p2</code> 为参数对 <code>p1</code> 调用 <code>mixup</code> 得到 <code>p3</code>，其 <code>x</code> 来自 <code>p1</code> 故为 <code>i32</code> 类型。变量 <code>p3</code> 的 <code>y</code> 来自 <code>p2</code> 故为 <code>char</code> 类型。<code>println!</code> 宏调用将打印 <code>p3.x = 5, p3.y = c</code>。</p>
<p>The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with <code>impl</code> and some are declared with the method
definition. Here, the generic parameters <code>X1</code> and <code>Y1</code> are declared after
<code>impl</code> because they go with the struct definition. The generic parameters <code>X2</code>
and <code>Y2</code> are declared after <code>fn mixup</code> because they’re only relevant to the
method.</p>
<p>此示例旨在展示：部分泛型参数在 <code>impl</code> 中声明，部分在方法定义中声明。此处泛型参数 <code>X1</code> 和 <code>Y1</code> 在 <code>impl</code> 后声明（因它们与结构体定义相关），而 <code>X2</code> 和 <code>Y2</code> 在 <code>fn mixup</code> 后声明（因它们仅与方法相关）。</p>
<h3 id="performance-of-code-using-generics-使用泛型代码的性能"><a class="header" href="#performance-of-code-using-generics-使用泛型代码的性能">Performance of Code Using Generics 使用泛型代码的性能</a></h3>
<p>You might be wondering whether there is a runtime cost when using generic type
parameters. The good news is that using generic types won’t make your program
run any slower than it would with concrete types.</p>
<p>你可能好奇使用泛型类型参数是否会带来运行时开销。好消息是：使用泛型不会比使用具体类型使程序运行得更慢。</p>
<p>Rust accomplishes this by performing monomorphization of the code using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled. In this process, the compiler does the opposite of the steps we used
to create the generic function in Listing 10-5: the compiler looks at all the
places where generic code is called and generates code for the concrete types
the generic code is called with.</p>
<p>Rust 通过在编译时对使用泛型的代码执行<em>单态化</em>（monomorphization）实现这一点。单态化是将泛型代码转换为特定代码的过程，通过填充编译时使用的具体类型实现。在此过程中，编译器执行与示例 10-5 创建泛型函数相反的步骤：查看所有调用泛型代码的位置，并为调用时使用的具体类型生成代码。</p>
<p>Let’s look at how this works by using the standard library’s generic
<code>Option&lt;T&gt;</code> enum:</p>
<p>通过标准库的泛型 <code>Option&lt;T&gt;</code> 枚举来看其工作原理：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code>
instances and identifies two kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code> and the other
is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into two
definitions specialized to <code>i32</code> and <code>f64</code>, thereby replacing the generic
definition with the specific ones.</p>
<p>Rust 编译此代码时会执行单态化。编译器读取 <code>Option&lt;T&gt;</code> 实例中使用的值，识别出两种 <code>Option&lt;T&gt;</code>：一种是 <code>i32</code>，另一种是 <code>f64</code>。因此它将 <code>Option&lt;T&gt;</code> 的泛型定义扩展为针对 <code>i32</code> 和 <code>f64</code> 特化的两个定义，从而用具体定义替换泛型定义。</p>
<p>The monomorphized version of the code looks similar to the following (the
compiler uses different names than what we’re using here for illustration):</p>
<p>单态化后的代码类似于以下形式（编译器实际使用不同名称，此处为说明）：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</figure>
<p>The generic <code>Option&lt;T&gt;</code> is replaced with the specific definitions created by
the compiler. Because Rust compiles generic code into code that specifies the
type in each instance, we pay no runtime cost for using generics. When the code
runs, it performs just as it would if we had duplicated each definition by
hand. The process of monomorphization makes Rust’s generics extremely efficient
at runtime.</p>
<p>泛型 <code>Option&lt;T&gt;</code> 被编译器创建的具体定义替代。由于 Rust 将泛型代码编译为针对每个实例指定类型的代码，使用泛型不会产生运行时开销。代码运行时，其性能如同手动复制每个定义一般。单态化过程使 Rust 的泛型在运行时极其高效。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
