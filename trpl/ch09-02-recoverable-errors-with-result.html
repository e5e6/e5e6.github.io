<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Recoverable Errors with Result 可恢复的错误：Result - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="recoverable-errors-with-result-可恢复的错误result"><a class="header" href="#recoverable-errors-with-result-可恢复的错误result">Recoverable Errors with <code>Result</code> 可恢复的错误：<code>Result</code></a></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes when a function fails it’s for a reason that you can easily interpret
and respond to. For example, if you try to open a file and that operation fails
because the file doesn’t exist, you might want to create the file instead of
terminating the process.</p>
<p>大多数错误并不严重到需要程序完全停止的程度。有时函数失败的原因可以轻松解读并响应。例如，尝试打开文件时因文件不存在而失败，你可能希望创建文件而非终止进程。</p>
<p>Recall from “Handling Potential Failure with <code>Result</code>” in Chapter 2 that the <code>Result</code> enum is defined as having two
variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<p>回忆第2章中 “用 <code>Result</code> 处理潜在失败” 的内容，<code>Result</code> 枚举定义为两个变体 <code>Ok</code> 和 <code>Err</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that <code>T</code> represents
the type of the value that will be returned in a success case within the <code>Ok</code>
variant, and <code>E</code> represents the type of the error that will be returned in a
failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type
parameters, we can use the <code>Result</code> type and the functions defined on it in
many different situations where the success value and error value we want to
return may differ.</p>
<p><code>T</code> 和 <code>E</code> 是泛型类型参数：第10章将详细讨论泛型。现在只需知道：<code>T</code> 代表成功时 <code>Ok</code> 变体返回的值的类型，<code>E</code> 代表失败时 <code>Err</code> 变体返回的错误类型。由于 <code>Result</code> 具有这些泛型参数，我们可以在多种场景中使用 <code>Result</code> 类型及其定义的方法，这些场景中要返回的成功值和错误值可能不同。</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail. In Listing 9-3 we try to open a file.</p>
<p>调用可能失败的函数时会返回 <code>Result</code> 值。示例9-3尝试打开文件：</p>
<figure class="listing" id="listing-9-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
<figcaption><a href="#listing-9-3">Listing 9-3</a>: Opening a file 打开文件</figcaption>
</figure>
<p>The return type of <code>File::open</code> is a <code>Result&lt;T, E&gt;</code>. The generic parameter <code>T</code>
has been filled in by the implementation of <code>File::open</code> with the type of the
success value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in
the error value is <code>std::io::Error</code>. This return type means the call to
<code>File::open</code> might succeed and return a file handle that we can read from or
write to. The function call also might fail: for example, the file might not
exist, or we might not have permission to access the file. The <code>File::open</code>
function needs to have a way to tell us whether it succeeded or failed and at
the same time give us either the file handle or error information. This
information is exactly what the <code>Result</code> enum conveys.</p>
<p><code>File::open</code> 的返回类型是 <code>Result&lt;T, E&gt;</code>。泛型参数 <code>T</code> 由 <code>File::open</code> 的实现填充为成功值类型 <code>std::fs::File</code>（文件句柄）。错误值中使用的 <code>E</code> 类型是 <code>std::io::Error</code>。此返回类型意味着对 <code>File::open</code> 的调用可能成功并返回可读写的文件句柄，也可能失败（例如文件不存在或无访问权限）。<code>File::open</code> 函数需告知成功与否，同时提供文件句柄或错误信息，这正是 <code>Result</code> 枚举所传递的信息。</p>
<p>In the case where <code>File::open</code> succeeds, the value in the variable
<code>greeting_file_result</code> will be an instance of <code>Ok</code> that contains a file handle.
In the case where it fails, the value in <code>greeting_file_result</code> will be an
instance of <code>Err</code> that contains more information about the kind of error that
occurred.</p>
<p>若 <code>File::open</code> 成功，变量 <code>greeting_file_result</code> 的值将是包含文件句柄的 <code>Ok</code> 实例；若失败，则是包含错误信息的 <code>Err</code> 实例。</p>
<p>We need to add to the code in Listing 9-3 to take different actions depending
on the value <code>File::open</code> returns. Listing 9-4 shows one way to handle the
<code>Result</code> using a basic tool, the <code>match</code> expression that we discussed in
Chapter 6.</p>
<p>我们需要扩展示例9-3的代码，根据 <code>File::open</code> 的返回值执行不同操作。示例9-4展示了用 <code>match</code> 表达式处理 <code>Result</code> 的方法：</p>
<figure class="listing" id="listing-9-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem opening the file: {error:?}"),
    };
}</code></pre></pre>
<figcaption><a href="#listing-9-4">Listing 9-4</a>: Using a <code>match</code> expression to handle the <code>Result</code> variants that might be returned 使用 <code>match</code> 表达式处理可能返回的 <code>Result</code> 变体</figcaption>
</figure>
<p>Note that, like the <code>Option</code> enum, the <code>Result</code> enum and its variants have been
brought into scope by the prelude, so we don’t need to specify <code>Result::</code>
before the <code>Ok</code> and <code>Err</code> variants in the <code>match</code> arms.</p>
<p>注意：与 <code>Option</code> 枚举类似，<code>Result</code> 枚举及其变体已通过预导入（prelude）引入作用域，因此 <code>match</code> 分支中无需在 <code>Ok</code> 和 <code>Err</code> 前指定 <code>Result::</code>。</p>
<p>When the result is <code>Ok</code>, this code will return the inner <code>file</code> value out of
the <code>Ok</code> variant, and we then assign that file handle value to the variable
<code>greeting_file</code>. After the <code>match</code>, we can use the file handle for reading or
writing.</p>
<p>当结果为 <code>Ok</code> 时，此代码从 <code>Ok</code> 变体中取出内部 <code>file</code> 值，并将该文件句柄赋给变量 <code>greeting_file</code>。<code>match</code> 之后即可使用此文件句柄进行读写。</p>
<p>The other arm of the <code>match</code> handles the case where we get an <code>Err</code> value from
<code>File::open</code>. In this example, we’ve chosen to call the <code>panic!</code> macro. If
there’s no file named <em>hello.txt</em> in our current directory and we run this
code, we’ll see the following output from the <code>panic!</code> macro:</p>
<p><code>match</code> 的另一分支处理从 <code>File::open</code> 获取 <code>Err</code> 值的情况。本例选择调用 <code>panic!</code> 宏。若当前目录无 <em>hello.txt</em> 文件时运行此代码，将看到 <code>panic!</code> 宏的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>As usual, this output tells us exactly what has gone wrong.</p>
<p>此输出精确指出了问题所在。</p>
<h3 id="matching-on-different-errors-匹配不同错误"><a class="header" href="#matching-on-different-errors-匹配不同错误">Matching on Different Errors 匹配不同错误</a></h3>
<p>The code in Listing 9-4 will <code>panic!</code> no matter why <code>File::open</code> failed.
However, we want to take different actions for different failure reasons. If
<code>File::open</code> failed because the file doesn’t exist, we want to create the file
and return the handle to the new file. If <code>File::open</code> failed for any other
reason—for example, because we didn’t have permission to open the file—we still
want the code to <code>panic!</code> in the same way it did in Listing 9-4. For this, we
add an inner <code>match</code> expression, shown in Listing 9-5.</p>
<p>示例9-4的代码无论 <code>File::open</code> 为何失败都会触发 <code>panic!</code>。但我们需要针对不同失败原因采取不同操作：若因文件不存在失败，则创建文件并返回新文件句柄；若因其他原因（如无权限）失败，仍按示例9-4的方式触发 <code>panic!</code>。为此，我们添加内部 <code>match</code> 表达式（见示例9-5）。</p>
<figure class="listing" id="listing-9-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {e:?}"),
            },
            _ =&gt; {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}</code></pre>
<figcaption><a href="#listing-9-5">Listing 9-5</a>: Handling different kinds of errors in different ways 以不同方式处理不同错误类型</figcaption>
</figure>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is
<code>io::Error</code>, which is a struct provided by the standard library. This struct
has a method <code>kind</code> that we can call to get an <code>io::ErrorKind</code> value. The enum
<code>io::ErrorKind</code> is provided by the standard library and has variants
representing the different kinds of errors that might result from an <code>io</code>
operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates
the file we’re trying to open doesn’t exist yet. So we match on
<code>greeting_file_result</code>, but we also have an inner match on <code>error.kind()</code>.</p>
<p><code>File::open</code> 在 <code>Err</code> 变体中返回的值类型是标准库提供的结构体 <code>io::Error</code>。该结构体有 <code>kind</code> 方法可获取 <code>io::ErrorKind</code> 值。枚举 <code>io::ErrorKind</code> 由标准库提供，其变体表示 <code>io</code> 操作可能导致的不同错误类型。我们需要的变体是 <code>ErrorKind::NotFound</code>，表示要打开的文件尚不存在。因此我们匹配 <code>greeting_file_result</code>，并在 <code>error.kind()</code> 上进行内部匹配。</p>
<p>The condition we want to check in the inner match is whether the value returned
by <code>error.kind()</code> is the <code>NotFound</code> variant of the <code>ErrorKind</code> enum. If it is,
we try to create the file with <code>File::create</code>. However, because <code>File::create</code>
could also fail, we need a second arm in the inner <code>match</code> expression. When the
file can’t be created, a different error message is printed. The second arm of
the outer <code>match</code> stays the same, so the program panics on any error besides
the missing file error.</p>
<p>内部匹配中检查的条件是：<code>error.kind()</code> 返回的值是否为 <code>ErrorKind</code> 枚举的 <code>NotFound</code> 变体。若是，则尝试用 <code>File::create</code> 创建文件。但 <code>File::create</code> 也可能失败，因此内部 <code>match</code> 需要第二个分支处理文件创建失败的情况。外部 <code>match</code> 的第二个分支保持不变，程序对除文件不存在之外的其他错误均触发恐慌。</p>
<section class="note" aria-role="note">
<h4 id="alternatives-to-using-match-with-resultt-e-替代方案resultt-e-的其他处理方法"><a class="header" href="#alternatives-to-using-match-with-resultt-e-替代方案resultt-e-的其他处理方法">Alternatives to Using <code>match</code> with <code>Result&lt;T, E&gt;</code> 替代方案：<code>Result&lt;T, E&gt;</code> 的其他处理方法</a></h4>
<p>That’s a lot of <code>match</code>! The <code>match</code> expression is very useful but also very
much a primitive. In Chapter 13, you’ll learn about closures, which are used
with many of the methods defined on <code>Result&lt;T, E&gt;</code>. These methods can be more
concise than using <code>match</code> when handling <code>Result&lt;T, E&gt;</code> values in your code.</p>
<p><code>match</code> 太多了！<code>match</code> 表达式虽实用但较原始。第13章将学习闭包，其可与 <code>Result&lt;T, E&gt;</code> 的许多方法结合使用。这些方法在处理 <code>Result&lt;T, E&gt;</code> 值时比 <code>match</code> 更简洁。</p>
<p>For example, here’s another way to write the same logic as shown in Listing
9-5, this time using closures and the <code>unwrap_or_else</code> method:</p>
<p>例如，以下是实现与示例9-5相同逻辑的另一种方式（使用闭包和 <code>unwrap_or_else</code> 方法）：</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}</code></pre>
<p>Although this code has the same behavior as Listing 9-5, it doesn’t contain
any <code>match</code> expressions and is cleaner to read. Come back to this example
after you’ve read Chapter 13, and look up the <code>unwrap_or_else</code> method in the
standard library documentation. Many more of these methods can clean up huge
nested <code>match</code> expressions when you’re dealing with errors.</p>
<p>此代码行为与示例9-5相同，但无 <code>match</code> 表达式且更易读。阅读第13章后可回顾此示例，并查阅标准库文档中的 <code>unwrap_or_else</code> 方法。处理错误时，这些方法能大幅简化嵌套的 <code>match</code> 表达式。</p>
</section>
<h4 id="shortcuts-for-panic-on-error-unwrap-and-expect-错误时恐慌的快捷方法unwrap-和-expect"><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect-错误时恐慌的快捷方法unwrap-和-expect">Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code> 错误时恐慌的快捷方法：<code>unwrap</code> 和 <code>expect</code></a></h4>
<p>Using <code>match</code> works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The <code>Result&lt;T, E&gt;</code> type has many helper methods
defined on it to do various, more specific tasks. The <code>unwrap</code> method is a
shortcut method implemented just like the <code>match</code> expression we wrote in
Listing 9-4. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return
the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will
call the <code>panic!</code> macro for us. Here is an example of <code>unwrap</code> in action:</p>
<p><code>match</code> 虽有效但较冗长。<code>Result&lt;T, E&gt;</code> 类型定义了许多辅助方法执行特定任务。<code>unwrap</code> 方法作为快捷方式，其实现类似示例9-4的 <code>match</code>：若 <code>Result</code> 为 <code>Ok</code> 变体，<code>unwrap</code> 返回内部值；若为 <code>Err</code> 变体，则替我们调用 <code>panic!</code> 宏。<code>unwrap</code> 的实例如下：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</figure>
<p>If we run this code without a <em>hello.txt</em> file, we’ll see an error message from
the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<p>若无 <em>hello.txt</em> 文件运行此代码，将看到 <code>unwrap</code> 触发的 <code>panic!</code> 错误信息：</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>Similarly, the <code>expect</code> method lets us also choose the <code>panic!</code> error message.
Using <code>expect</code> instead of <code>unwrap</code> and providing good error messages can convey
your intent and make tracking down the source of a panic easier. The syntax of
<code>expect</code> looks like this:</p>
<p>类似地，<code>expect</code> 方法允许自定义 <code>panic!</code> 错误信息。使用 <code>expect</code> 而非 <code>unwrap</code> 并提供清晰错误信息，能更好表达意图并简化恐慌溯源。<code>expect</code> 语法如下：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}</code></pre></pre>
</figure>
<p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call
the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code>
will be the parameter that we pass to <code>expect</code>, rather than the default
<code>panic!</code> message that <code>unwrap</code> uses. Here’s what it looks like:</p>
<p><code>expect</code> 用法同 <code>unwrap</code>：返回文件句柄或调用 <code>panic!</code> 宏。但 <code>expect</code> 调用 <code>panic!</code> 时使用我们传递的参数而非默认信息。输出如下：</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In production-quality code, most Rustaceans choose <code>expect</code> rather than
<code>unwrap</code> and give more context about why the operation is expected to always
succeed. That way, if your assumptions are ever proven wrong, you have more
information to use in debugging.</p>
<p>在生产级代码中，多数Rust开发者选择 <code>expect</code> 而非 <code>unwrap</code>，以提供更多操作成功预期的上下文。这样在假设错误时，可有更多调试信息。</p>
<h3 id="propagating-errors-传播错误"><a class="header" href="#propagating-errors-传播错误">Propagating Errors 传播错误</a></h3>
<p>When a function’s implementation calls something that might fail, instead of
handling the error within the function itself, you can return the error to the
calling code so that it can decide what to do. This is known as <em>propagating</em>
the error and gives more control to the calling code, where there might be more
information or logic that dictates how the error should be handled than what
you have available in the context of your code.</p>
<p>函数实现调用可能失败的操作时，可不直接处理错误，而将错误返回给调用方决定如何处理。这称为错误传播，赋予调用方更多控制权——相比当前代码上下文，调用方可能掌握更多信息或逻辑来决定错误处理。</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called the function.</p>
<p>例如，示例9-6的函数从文件读取用户名。若文件不存在或读取失败，函数将错误返回给调用方。</p>
<figure class="listing" id="listing-9-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-6">Listing 9-6</a>: A function that returns errors to the calling code using <code>match</code> 使用 <code>match</code> 将错误返回给调用方的函数</figcaption>
</figure>
<p>This function can be written in a much shorter way, but we’re going to start by
doing a lot of it manually in order to explore error handling; at the end,
we’ll show the shorter way. Let’s look at the return type of the function
first: <code>Result&lt;String, io::Error&gt;</code>. This means the function is returning a
value of the type <code>Result&lt;T, E&gt;</code>, where the generic parameter <code>T</code> has been
filled in with the concrete type <code>String</code> and the generic type <code>E</code> has been
filled in with the concrete type <code>io::Error</code>.</p>
<p>此函数可更简洁实现，但为探索错误处理先手动实现，最后展示简洁写法。首先看函数返回类型：<code>Result&lt;String, io::Error&gt;</code>。表示函数返回 <code>Result&lt;T, E&gt;</code> 类型，其中泛型参数 <code>T</code> 替换为具体类型 <code>String</code>，<code>E</code> 替换为 <code>io::Error</code>。</p>
<p>If this function succeeds without any problems, the code that calls this
function will receive an <code>Ok</code> value that holds a <code>String</code>—the <code>username</code> that
this function read from the file. If this function encounters any problems, the
calling code will receive an <code>Err</code> value that holds an instance of <code>io::Error</code>
that contains more information about what the problems were. We chose
<code>io::Error</code> as the return type of this function because that happens to be the
type of the error value returned from both of the operations we’re calling in
this function’s body that might fail: the <code>File::open</code> function and the
<code>read_to_string</code> method.</p>
<p>若函数成功，调用方将收到包含用户名的 <code>Ok</code> 值；若遇到问题，则收到包含 <code>io::Error</code> 实例的 <code>Err</code> 值。选择 <code>io::Error</code> 作为返回类型，因为函数体内可能失败的两个操作（<code>File::open</code> 和 <code>read_to_string</code>）均返回此错误类型。</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then we
handle the <code>Result</code> value with a <code>match</code> similar to the <code>match</code> in Listing 9-4.
If <code>File::open</code> succeeds, the file handle in the pattern variable <code>file</code>
becomes the value in the mutable variable <code>username_file</code> and the function
continues. In the <code>Err</code> case, instead of calling <code>panic!</code>, we use the <code>return</code>
keyword to return early out of the function entirely and pass the error value
from <code>File::open</code>, now in the pattern variable <code>e</code>, back to the calling code as
this function’s error value.</p>
<p>函数体首先调用 <code>File::open</code>，然后用类似示例9-4的 <code>match</code> 处理 <code>Result</code>。若 <code>File::open</code> 成功，模式变量 <code>file</code> 的值将赋给可变变量 <code>username_file</code>，函数继续执行。在 <code>Err</code> 分支中，我们使用 <code>return</code> 关键字提前返回整个函数，并将 <code>File::open</code> 的错误值（现位于模式变量 <code>e</code>）作为函数错误值返回给调用方。</p>
<p>So, if we have a file handle in <code>username_file</code>, the function then creates a
new <code>String</code> in variable <code>username</code> and calls the <code>read_to_string</code> method on
the file handle in <code>username_file</code> to read the contents of the file into
<code>username</code>. The <code>read_to_string</code> method also returns a <code>Result</code> because it
might fail, even though <code>File::open</code> succeeded. So we need another <code>match</code> to
handle that <code>Result</code>: if <code>read_to_string</code> succeeds, then our function has
succeeded, and we return the username from the file that’s now in <code>username</code>
wrapped in an <code>Ok</code>. If <code>read_to_string</code> fails, we return the error value in the
same way that we returned the error value in the <code>match</code> that handled the
return value of <code>File::open</code>. However, we don’t need to explicitly say
<code>return</code>, because this is the last expression in the function.</p>
<p>若 <code>username_file</code> 中有文件句柄，函数在变量 <code>username</code> 中创建新 <code>String</code>，并调用 <code>username_file</code> 的 <code>read_to_string</code> 方法将文件内容读入 <code>username</code>。即使 <code>File::open</code> 成功，<code>read_to_string</code> 也可能失败，故需另一个 <code>match</code> 处理其返回的 <code>Result</code>：若 <code>read_to_string</code> 成功，函数返回包含用户名的 <code>Ok</code>；若失败，则按相同方式返回错误值（此处无需显式 <code>return</code>，因为这是函数最后表达式）。</p>
<p>The code that calls this code will then handle getting either an <code>Ok</code> value
that contains a username or an <code>Err</code> value that contains an <code>io::Error</code>. It’s
up to the calling code to decide what to do with those values. If the calling
code gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.</p>
<p>调用此函数的代码将处理获取用户名（<code>Ok</code>）或 <code>io::Error</code>（<code>Err</code>）。由调用方决定后续操作：可调用 <code>panic!</code> 终止程序、使用默认用户名或从文件外获取用户名等。因无法获知调用方具体意图，故向上传播所有成功或错误信息供其妥善处理。</p>
<p>This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator <code>?</code> to make this easier.</p>
<p>此错误传播模式在Rust中非常常见，因此Rust提供了问号操作符 <code>?</code> 来简化。</p>
<h4 id="a-shortcut-for-propagating-errors-the--operator-传播错误的快捷方式-操作符"><a class="header" href="#a-shortcut-for-propagating-errors-the--operator-传播错误的快捷方式-操作符">A Shortcut for Propagating Errors: The <code>?</code> Operator 传播错误的快捷方式：<code>?</code> 操作符</a></h4>
<p>Listing 9-7 shows an implementation of <code>read_username_from_file</code> that has the
same functionality as in Listing 9-6, but this implementation uses the <code>?</code>
operator.</p>
<p>示例9-7的 <code>read_username_from_file</code> 实现与示例9-6功能相同，但使用了 <code>?</code> 操作符：</p>
<figure class="listing" id="listing-9-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-7">Listing 9-7</a>: A function that returns errors to the calling code using the <code>?</code> operator 使用 <code>?</code> 操作符将错误返回给调用方的函数</figcaption>
</figure>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way
as the <code>match</code> expressions we defined to handle the <code>Result</code> values in Listing
9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will
get returned from this expression, and the program will continue. If the value
is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had
used the <code>return</code> keyword so the error value gets propagated to the calling
code.</p>
<p><code>Result</code> 值后的 <code>?</code> 定义的工作方式几乎与示例9-6中处理 <code>Result</code> 的 <code>match</code> 表达式相同：若 <code>Result</code> 值为 <code>Ok</code>，则返回 <code>Ok</code> 内部值，程序继续；若为 <code>Err</code>，则从整个函数返回 <code>Err</code>（如同使用了 <code>return</code>），错误值传播给调用方。</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 does
and what the <code>?</code> operator does: error values that have the <code>?</code> operator called
on them go through the <code>from</code> function, defined in the <code>From</code> trait in the
standard library, which is used to convert values from one type into another.
When the <code>?</code> operator calls the <code>from</code> function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent
all the ways a function might fail, even if parts might fail for many different
reasons.</p>
<p>示例9-6的 <code>match</code> 与 <code>?</code> 操作符的区别在于：<code>?</code> 操作符调用的错误值会通过标准库中 <code>From</code> trait 定义的 <code>from</code> 函数进行类型转换。<code>?</code> 调用 <code>from</code> 函数时，接收的错误类型会被转换为当前函数返回类型所定义的错误类型。当函数需返回统一错误类型代表所有失败可能（即使各部分失败原因不同）时，此机制非常有用。</p>
<p>For example, we could change the <code>read_username_from_file</code> function in Listing
9-7 to return a custom error type named <code>OurError</code> that we define. If we also
define <code>impl From&lt;io::Error&gt; for OurError</code> to construct an instance of
<code>OurError</code> from an <code>io::Error</code>, then the <code>?</code> operator calls in the body of
<code>read_username_from_file</code> will call <code>from</code> and convert the error types without
needing to add any more code to the function.</p>
<p>例如，可将示例9-7中的 <code>read_username_from_file</code> 改为返回自定义错误类型 <code>OurError</code>。若同时为 <code>OurError</code> 实现 <code>impl From&lt;io::Error&gt; for OurError</code>（从 <code>io::Error</code> 构造 <code>OurError</code>），则 <code>read_username_from_file</code> 中的 <code>?</code> 会自动调用 <code>from</code> 转换错误类型，无需额外代码。</p>
<p>In the context of Listing 9-7, the <code>?</code> at the end of the <code>File::open</code> call will
return the value inside an <code>Ok</code> to the variable <code>username_file</code>. If an error
occurs, the <code>?</code> operator will return early out of the whole function and give
any <code>Err</code> value to the calling code. The same thing applies to the <code>?</code> at the
end of the <code>read_to_string</code> call.</p>
<p>在示例9-7上下文中，<code>File::open</code> 调用末尾的 <code>?</code> 将返回 <code>Ok</code> 内部值给变量 <code>username_file</code>；若出错，则提前返回错误值给调用方。<code>read_to_string</code> 调用末尾的 <code>?</code> 同理。</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the <code>?</code>, as shown in Listing 9-8.</p>
<p><code>?</code> 操作符消除了大量样板代码，使函数实现更简洁。我们还可通过链式方法调用来进一步缩短代码（见示例9-8）。</p>
<figure class="listing" id="listing-9-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-8">Listing 9-8</a>: Chaining method calls after the <code>?</code> operator 在 <code>?</code> 操作符后链式调用方法</figcaption>
</figure>
<p>We’ve moved the creation of the new <code>String</code> in <code>username</code> to the beginning of
the function; that part hasn’t changed. Instead of creating a variable
<code>username_file</code>, we’ve chained the call to <code>read_to_string</code> directly onto the
result of <code>File::open("hello.txt")?</code>. We still have a <code>?</code> at the end of the
<code>read_to_string</code> call, and we still return an <code>Ok</code> value containing <code>username</code>
when both <code>File::open</code> and <code>read_to_string</code> succeed rather than returning
errors. The functionality is again the same as in Listing 9-6 and Listing 9-7;
this is just a different, more ergonomic way to write it.</p>
<p>我们将创建新 <code>String</code> 的代码移到函数开头（此部分未变）。不再创建变量 <code>username_file</code>，而是直接在 <code>File::open("hello.txt")?</code> 的结果上链式调用 <code>read_to_string</code>。<code>read_to_string</code> 调用末尾仍有 <code>?</code>，且当两者均成功时返回包含用户名的 <code>Ok</code>。功能与示例9-6和9-7相同，但写法更符合人体工学。</p>
<p>Listing 9-9 shows a way to make this even shorter using <code>fs::read_to_string</code>.</p>
<p>示例9-9展示了使用 <code>fs::read_to_string</code> 的更简洁实现。</p>
<figure class="listing" id="listing-9-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-9">Listing 9-9</a>: Using <code>fs::read_to_string</code> instead of opening and then reading the file 使用 <code>fs::read_to_string</code> 替代先打开后读取</figcaption>
</figure>
<p>Reading a file into a string is a fairly common operation, so the standard
library provides the convenient <code>fs::read_to_string</code> function that opens the
file, creates a new <code>String</code>, reads the contents of the file, puts the contents
into that <code>String</code>, and returns it. Of course, using <code>fs::read_to_string</code>
doesn’t give us the opportunity to explain all the error handling, so we did it
the longer way first.</p>
<p>将文件读入字符串是常见操作，因此标准库提供了便捷的 <code>fs::read_to_string</code> 函数：打开文件、创建新 <code>String</code>、读取内容并返回。当然，使用 <code>fs::read_to_string</code> 无法展示错误处理，故我们先采用较长实现。</p>
<h4 id="where-the--operator-can-be-used--操作符的使用场景"><a class="header" href="#where-the--operator-can-be-used--操作符的使用场景">Where the <code>?</code> Operator Can Be Used <code>?</code> 操作符的使用场景</a></h4>
<p>The <code>?</code> operator can only be used in functions whose return type is compatible
with the value the <code>?</code> is used on. This is because the <code>?</code> operator is defined
to perform an early return of a value out of the function, in the same manner
as the <code>match</code> expression we defined in Listing 9-6. In Listing 9-6, the
<code>match</code> was using a <code>Result</code> value, and the early return arm returned an
<code>Err(e)</code> value. The return type of the function has to be a <code>Result</code> so that
it’s compatible with this <code>return</code>.</p>
<p><code>?</code> 操作符仅可用于返回类型与 <code>?</code> 所作用值兼容的函数。因为 <code>?</code> 定义为从函数中提前返回值，方式类似示例9-6的 <code>match</code>。在示例9-6中，<code>match</code> 处理 <code>Result</code> 值，提前返回分支返回 <code>Err(e)</code>。函数返回类型必须是 <code>Result</code> 才能兼容此 <code>return</code>。</p>
<p>In Listing 9-10, let’s look at the error we’ll get if we use the <code>?</code> operator
in a <code>main</code> function with a return type that is incompatible with the type of
the value we use <code>?</code> on.</p>
<p>在示例9-10中，若在返回类型不兼容的 <code>main</code> 函数中使用 <code>?</code>，将看到错误。</p>
<figure class="listing" id="listing-9-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
<figcaption><a href="#listing-9-10">Listing 9-10</a>: Attempting to use the <code>?</code> in the <code>main</code> function that returns <code>()</code> won’t compile. 尝试在返回 <code>()</code> 的 <code>main</code> 函数中使用 <code>?</code> 将无法编译</figcaption>
</figure>
<p>This code opens a file, which might fail. The <code>?</code> operator follows the <code>Result</code>
value returned by <code>File::open</code>, but this <code>main</code> function has the return type of
<code>()</code>, not <code>Result</code>. When we compile this code, we get the following error
message:</p>
<p>此代码尝试打开可能失败的文件。<code>?</code> 作用于 <code>File::open</code> 返回的 <code>Result</code>，但 <code>main</code> 函数返回类型为 <code>()</code> 而非 <code>Result</code>。编译时报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>This error points out that we’re only allowed to use the <code>?</code> operator in a
function that returns <code>Result</code>, <code>Option</code>, or another type that implements
<code>FromResidual</code>.</p>
<p>此错误指出：<span class="highlight">[note]只能在返回 <code>Result</code>、<code>Option</code> 或实现了 <code>FromResidual</code> 类型的函数中使用 <code>?</code>。</span></p>
<p>To fix the error, you have two choices. One choice is to change the return type
of your function to be compatible with the value you’re using the <code>?</code> operator
on as long as you have no restrictions preventing that. The other choice is to
use a <code>match</code> or one of the <code>Result&lt;T, E&gt;</code> methods to handle the <code>Result&lt;T, E&gt;</code>
in whatever way is appropriate.</p>
<p>修复方法有两种：若无限制，可更改函数返回类型以兼容 <code>?</code> 所作用的值；使用 <code>match</code> 或 <code>Result&lt;T, E&gt;</code> 的方法以适当方式处理值。</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values
as well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a
function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called
on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>:
if the value is <code>None</code>, the <code>None</code> will be returned early from the function at
that point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the
resultant value of the expression, and the function continues. Listing 9-11 has
an example of a function that finds the last character of the first line in the
given text.</p>
<p>错误信息还提到 <code>?</code> 也可用于 <code>Option&lt;T&gt;</code> 值。与 <code>Result</code> 类似，只能在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>。<code>?</code> 作用于 <code>Option&lt;T&gt;</code> 的行为类似作用于 <code>Result&lt;T, E&gt;</code>：若值为 <code>None</code>，则提前从函数返回 <code>None</code>；若为 <code>Some</code>，则 <code>Some</code> 内部的值作为表达式结果，函数继续执行。示例9-11展示在给定文本中查找首行最后一个字符的函数：</p>
<figure class="listing" id="listing-9-11">
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\nHow are you today?"),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-9-11">Listing 9-11</a>: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code> value 在 <code>Option&lt;T&gt;</code> 值上使用 <code>?</code> 操作符</figcaption>
</figure>
<p>This function returns <code>Option&lt;char&gt;</code> because it’s possible that there is a
character there, but it’s also possible that there isn’t. This code takes the
<code>text</code> string slice argument and calls the <code>lines</code> method on it, which returns
an iterator over the lines in the string. Because this function wants to
examine the first line, it calls <code>next</code> on the iterator to get the first value
from the iterator. If <code>text</code> is the empty string, this call to <code>next</code> will
return <code>None</code>, in which case we use <code>?</code> to stop and return <code>None</code> from
<code>last_char_of_first_line</code>. If <code>text</code> is not the empty string, <code>next</code> will
return a <code>Some</code> value containing a string slice of the first line in <code>text</code>.</p>
<p>此函数返回 <code>Option&lt;char&gt;</code>，因为可能找到字符，也可能找不到。代码接收字符串切片参数 <code>text</code>，调用 <code>lines</code> 方法获取字符串行的迭代器。为检查首行，调用迭代器的 <code>next</code> 方法获取第一个值。若 <code>text</code> 为空，<code>next</code> 返回 <code>None</code>，此时用 <code>?</code> 停止并返回 <code>None</code>；若不为空，则返回包含首行字符串切片的 <code>Some</code>。</p>
<p>The <code>?</code> extracts the string slice, and we can call <code>chars</code> on that string slice
to get an iterator of its characters. We’re interested in the last character in
this first line, so we call <code>last</code> to return the last item in the iterator.
This is an <code>Option</code> because it’s possible that the first line is the empty
string; for example, if <code>text</code> starts with a blank line but has characters on
other lines, as in <code>"\nhi"</code>. However, if there is a last character on the first
line, it will be returned in the <code>Some</code> variant. The <code>?</code> operator in the middle
gives us a concise way to express this logic, allowing us to implement the
function in one line. If we couldn’t use the <code>?</code> operator on <code>Option</code>, we’d
have to implement this logic using more method calls or a <code>match</code> expression.</p>
<p><code>?</code> 解出字符串切片，调用 <code>chars</code> 获取字符迭代器。我们需要首行最后一个字符，故调用 <code>last</code> 返回迭代器末项。返回 <code>Option</code> 是因为首行可能为空（如 <code>"\nhi"</code>）。若首行存在末字符，则返回 <code>Some</code>。中间的 <code>?</code> 操作符简洁表达了此逻辑，单行即可实现函数。若不能对 <code>Option</code> 使用 <code>?</code>，则需更多方法调用或 <code>match</code> 实现。</p>
<p>Note that you can use the <code>?</code> operator on a <code>Result</code> in a function that returns
<code>Result</code>, and you can use the <code>?</code> operator on an <code>Option</code> in a function that
returns <code>Option</code>, but you can’t mix and match. The <code>?</code> operator won’t
automatically convert a <code>Result</code> to an <code>Option</code> or vice versa; in those cases,
you can use methods like the <code>ok</code> method on <code>Result</code> or the <code>ok_or</code> method on
<code>Option</code> to do the conversion explicitly.</p>
<p>注意：可在返回 <code>Result</code> 的函数中对 <code>Result</code> 使用 <code>?</code>，在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>，但不能混用。<code>?</code> 不会自动转换 <code>Result</code> 和 <code>Option</code>，此时可用 <code>Result</code> 的 <code>ok</code> 方法或 <code>Option</code> 的 <code>ok_or</code> 方法显式转换。</p>
<p>So far, all the <code>main</code> functions we’ve used return <code>()</code>. The <code>main</code> function is
special because it’s the entry point and exit point of an executable program,
and there are restrictions on what its return type can be for the program to
behave as expected.</p>
<p>目前所有 <code>main</code> 函数均返回 <code>()</code>。<code>main</code> 函数特殊，因它是可执行程序的入口和出口点，其返回类型受限以保证程序行为符合预期。</p>
<p>Luckily, <code>main</code> can also return a <code>Result&lt;(), E&gt;</code>. Listing 9-12 has the code
from Listing 9-10, but we’ve changed the return type of <code>main</code> to be
<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> and added a return value <code>Ok(())</code> to the end. This
code will now compile.</p>
<p>幸运的是，<span class="highlight">[note]<code>main</code> 也可返回 <code>Result&lt;(), E&gt;</code>。示例9-12修改了示例9-10中 <code>main</code> 的返回类型为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加返回值 <code>Ok(())</code>。</span>此代码可编译：</p>
<figure class="listing" id="listing-9-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
<figcaption><a href="#listing-9-12">Listing 9-12</a>: Changing <code>main</code> to return <code>Result&lt;(), E&gt;</code> allows the use of the <code>?</code> operator on <code>Result</code> values. 修改 <code>main</code> 返回 <code>Result&lt;(), E&gt;</code> 允许对 <code>Result</code> 值使用 <code>?</code> 操作符</figcaption>
</figure>
<p>The <code>Box&lt;dyn Error&gt;</code> type is a <em>trait object</em>, which we’ll talk about in “Using
Trait Objects That Allow for Values of Different Types” in Chapter 18. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean “any
kind of error.” Using <code>?</code> on a <code>Result</code> value in a <code>main</code> function with the
error type <code>Box&lt;dyn Error&gt;</code> is allowed because it allows any <code>Err</code> value to be
returned early. Even though the body of this <code>main</code> function will only ever
return errors of type <code>std::io::Error</code>, by specifying <code>Box&lt;dyn Error&gt;</code>, this
signature will continue to be correct even if more code that returns other
errors is added to the body of <code>main</code>.</p>
<p><code>Box&lt;dyn Error&gt;</code> 是 trait对象（第18章讨论）。目前可将其理解为“任何类型的错误“。在错误类型为 <code>Box&lt;dyn Error&gt;</code> 的 <code>main</code> 函数中对 <code>Result</code> 使用 <code>?</code> 是允许的，因为任何 <code>Err</code> 值均可提前返回。即使此 <code>main</code> 函数仅返回 <code>std::io::Error</code> 类型错误，指定 <code>Box&lt;dyn Error&gt;</code> 后，即使函数体添加返回其他错误的代码，签名仍保持正确。</p>
<p>When a <code>main</code> function returns a <code>Result&lt;(), E&gt;</code>, the executable will exit with
a value of <code>0</code> if <code>main</code> returns <code>Ok(())</code> and will exit with a nonzero value if
<code>main</code> returns an <code>Err</code> value. Executables written in C return integers when
they exit: programs that exit successfully return the integer <code>0</code>, and programs
that error return some integer other than <code>0</code>. Rust also returns integers from
executables to be compatible with this convention.</p>
<p>当 <code>main</code> 返回 <code>Result&lt;(), E&gt;</code> 时，若返回 <code>Ok(())</code> 则程序以 <code>0</code> 退出；若返回 <code>Err</code> 则以非零值退出。C语言程序退出时返回整数：成功返回 <code>0</code>，错误返回非 <code>0</code> 整数。为兼容此约定，Rust可执行程序也返回整数。</p>
<p>The <code>main</code> function may return any types that implement the
<code>std::process::Termination</code> trait, which contains
a function <code>report</code> that returns an <code>ExitCode</code>. Consult the standard library
documentation for more information on implementing the <code>Termination</code> trait for
your own types.</p>
<p><span class="highlight">[note]<code>main</code> 函数可返回任何实现了 <code>std::process::Termination</code> trait 的类型，该 trait 包含返回 <code>ExitCode</code> 的 <code>report</code> 函数。</span>有关为自定义类型实现 <code>Termination</code> trait 的更多信息，请查阅标准库文档。</p>
<p>Now that we’ve discussed the details of calling <code>panic!</code> or returning <code>Result</code>,
let’s return to the topic of how to decide which is appropriate to use in which
cases.</p>
<p>至此，我们已讨论调用 <code>panic!</code> 或返回 <code>Result</code> 的细节。现在回到核心问题：如何决定在何种场景使用何种方式。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
