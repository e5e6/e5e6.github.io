<!DOCTYPE HTML>
<html lang="zh-Hans" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 编程语言</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编程语言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-rust-programming-language"><a class="header" href="#the-rust-programming-language">The Rust Programming Language</a></h1>
<p><em>by Steve Klabnik, Carol Nichols, and Chris Krycho, with contributions from the
Rust Community</em></p>
<p>This version of the text assumes you’re using Rust 1.85.0 (released 2025-02-17)
or later with <code>edition = "2024"</code> in the Cargo.toml file of all projects to
configure them to use Rust 2024 edition idioms. See the “Installation” section
of Chapter 1 to install or update Rust.</p>
<p>本书内容基于 Rust 1.85.0（2025年2月17日发布）或更高版本撰写，要求在所有项目的 Cargo.toml
文件中配置 <code>edition = "2024"</code> 以启用 Rust 2024 版次的惯用语法。如需安装或更新 Rust，
请参阅第 1 章的“安装“章节。</p>
<p>The HTML format is available online at https://doc.rust-lang.org/stable/book/
and offline with installations of Rust made with <code>rustup</code>; run <code>rustup doc  --book</code> to open.</p>
<p>HTML 格式版本可在线访问：https://doc.rust-lang.org/stable/book/
通过 <code>rustup</code> 安装 Rust 的用户可离线查阅，执行命令 <code>rustup doc --book</code> 即可打开。</p>
<p>Several community translations are also available.</p>
<p>另有多个社区翻译版本可供选择。</p>
<p>This text is available in paperback and ebook format from No Starch Press.</p>
<p>本书纸质版及电子版由 No Starch Press 出版社发行。</p>
<blockquote>
<p><strong>🚨 Want a more interactive learning experience? Try out a different version
of the Rust Book, featuring: quizzes, highlighting, visualizations, and
more</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
<p>🚨 想要更互动式的学习体验？请尝试包含习题测验、重点标注、可视化教学等增强功能的 Rust 教材新版：
https://rust-book.cs.brown.edu</p>
</blockquote>
<p><code>beefa247fa1341b7dd1bbb2b0d12861622c5e82a</code> 2025-07-29 20:18:19</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword-前言"><a class="header" href="#foreword-前言">Foreword 前言</a></h1>
<p>It wasn’t always so clear, but the Rust programming language is fundamentally
about <em>empowerment</em>: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.</p>
<p>虽然并非始终如此显而易见，但Rust编程语言的核心在于赋能：无论你当前编写何种代码，Rust都能助你突破边界，在更广阔的领域中进行自信的编程。</p>
<p>Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.</p>
<p>以处理内存管理、数据表示和并发等底层细节的“系统级“工作为例。传统上，这类编程领域被视为晦涩艰深，只有少数投入数年时间学习规避其 notorious 陷阱的人才能掌握。即便是精通此道者也如履薄冰，唯恐代码出现安全漏洞、崩溃或损坏。</p>
<p>Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.</p>
<p>Rust通过消除历史性陷阱并提供一套友好完善工具链，彻底打破了这些壁垒。需要深入底层控制的程序员，能够借助Rust实现目标——既无需承担崩溃或安全漏洞的常规风险，也不必钻研善变工具链的细枝末节。更出色的是，这门语言的设计能自然而然地引导你写出运行高效且内存可靠的代码。</p>
<p>Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.</p>
<p>深耕底层代码的程序员可通过Rust实现更高追求。例如在Rust中引入并行操作风险极低：编译器将自动捕获经典错误。你可以放心进行激进优化，无须担心意外引发崩溃或安全漏洞。</p>
<p>But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.</p>
<p>但Rust的疆域远不止于底层系统编程。其出色的表现力与人机工学设计，使得编写命令行应用、网络服务器等各类代码都变得轻松愉悦——本书后续章节将提供这两种场景的简单示例。使用Rust构建的能力可在不同领域间迁移：你可以通过开发网页应用学习Rust，再将相同技能应用于树莓派项目。</p>
<p>This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!</p>
<p>本书全力拥抱Rust赋予使用者的潜能。作为一本友好易读的著作，它旨在助你不仅提升Rust技能，更将全面拓展编程能力与信心。请即刻启程，准备好学习之旅——欢迎加入Rust社区！</p>
<p>— Nicholas Matsakis and Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-介绍"><a class="header" href="#introduction-介绍">Introduction 介绍</a></h1>
<section class="note" aria-role="note">
<p>Note: This edition of the book is the same as The Rust Programming
Language available in print and ebook format from No Starch
Press.</p>
<p>注意：本书与 No Starch Press 出版的纸质版和电子书版《The Rust Programming Language》内容相同。</p>
</section>
<p>Welcome to <em>The Rust Programming Language</em>, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.</p>
<p>欢迎阅读《Rust程序设计语言》，这是一本关于 Rust 的入门书籍。Rust 编程语言能帮助你编写更快、更可靠的软件。在编程语言设计中，高级语言的易用性与低级控制常常是相互矛盾的；Rust 则直面这一冲突。通过在强大的技术能力和出色的开发者体验之间取得平衡，Rust 让你能够选择控制底层细节（如内存使用），而无需承受传统上与此类控制相关的诸多麻烦。</p>
<h2 id="who-rust-is-for-rust-适合谁"><a class="header" href="#who-rust-is-for-rust-适合谁">Who Rust Is For Rust 适合谁</a></h2>
<p>Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.</p>
<p>由于多种原因，Rust 对许多人来说是理想的选择。让我们来看看其中几个最重要的群体。</p>
<h3 id="teams-of-developers-开发者团队"><a class="header" href="#teams-of-developers-开发者团队">Teams of Developers 开发者团队</a></h3>
<p>Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to various subtle bugs, which in most other languages can be caught
only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.</p>
<p>事实证明，Rust 是一个高效的工具，能够协助拥有不同系统编程知识水平的大型开发者团队进行协作。底层代码容易出现各种难以察觉的错误，在大多数其他语言中，这些错误只能通过广泛的测试和资深开发者的仔细代码审查才能发现。而在 Rust 中，编译器扮演着把关者的角色，它会拒绝编译包含这些难以捉摸的错误（包括并发错误）的代码。通过与编译器协作，团队可以将时间集中在程序的逻辑上，而不是追踪错误上。</p>
<p>Rust also brings contemporary developer tools to the systems programming world:</p>
<p>Rust 还为系统编程领域带来了现代开发者工具：</p>
<ul>
<li>Cargo, the included dependency manager and build tool, makes adding,
compiling, and managing dependencies painless and consistent across the Rust
ecosystem.</li>
<li>Cargo：内置的依赖管理器和构建工具，让添加、编译和管理依赖在整个 Rust 生态系统中变得轻松且一致。</li>
<li>The Rustfmt formatting tool ensures a consistent coding style across
developers.</li>
<li>Rustfmt： 代码格式化工具：确保开发者之间采用一致的编码风格。</li>
<li>The rust-analyzer powers Integrated Development Environment (IDE)
integration for code completion and inline error messages.</li>
<li>rust-analyzer：为集成开发环境（IDE）提供支持，实现代码补全和内联错误提示。</li>
</ul>
<p>By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.</p>
<p>通过使用 Rust 生态系统中的这些及其他工具，开发者可以在编写系统级代码时保持高效。</p>
<h3 id="students-学生"><a class="header" href="#students-学生">Students 学生</a></h3>
<p>Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.</p>
<p>Rust 适合学生以及对学习系统概念感兴趣的人。许多人通过使用 Rust 学习了操作系统开发等主题。社区非常热情，乐于回答学生的问题。通过本书等努力，Rust 团队希望让更多人（尤其是编程新手）更容易理解系统概念。</p>
<h3 id="companies-公司"><a class="header" href="#companies-公司">Companies 公司</a></h3>
<p>Hundreds of companies, large and small, use Rust in production for a variety of
tasks, including command line tools, web services, DevOps tooling, embedded
devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.</p>
<p>数百家大大小小的公司都在生产环境中使用 Rust 来完成各种任务，包括命令行工具、Web 服务、DevOps 工具、嵌入式设备、音视频分析与转码、加密货币、生物信息学、搜索引擎、物联网应用、机器学习，甚至包括 Firefox 网络浏览器的主要部分。</p>
<h3 id="open-source-developers-开源开发者"><a class="header" href="#open-source-developers-开源开发者">Open Source Developers 开源开发者</a></h3>
<p>Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.</p>
<p>Rust 适合那些想要构建 Rust 编程语言本身、社区、开发者工具和库的人。我们非常欢迎你为 Rust 语言做出贡献。</p>
<h3 id="people-who-value-speed-and-stability-重视速度与稳定性的人"><a class="header" href="#people-who-value-speed-and-stability-重视速度与稳定性的人">People Who Value Speed and Stability 重视速度与稳定性的人</a></h3>
<p>Rust is for people who crave speed and stability in a language. By speed, we
mean both how quickly Rust code can run and the speed at which Rust lets you
write programs. The Rust compiler’s checks ensure stability through feature
additions and refactoring. This is in contrast to the brittle legacy code in
languages without these checks, which developers are often afraid to modify. By
striving for zero-cost abstractions—higher-level features that compile to
lower-level code as fast as code written manually—Rust endeavors to make safe
code be fast code as well.</p>
<p>Rust 适合那些在编程语言中追求速度和稳定性的人。所谓速度，我们既指 Rust 代码运行的速度，也指 Rust 让你编写程序的速度。Rust 编译器的检查确保了在添加功能和重构代码时的稳定性。这与那些没有此类检查的语言中遗留的脆弱代码形成对比，开发者常常不敢修改那些代码。通过追求零成本抽象（即编译成与手动编写的底层代码一样高效的高级特性），Rust 努力让安全的代码同时也是快速的代码。</p>
<p>The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety <em>and</em> productivity, speed <em>and</em> ergonomics. Give
Rust a try and see if its choices work for you.</p>
<p>Rust 语言也希望支持许多其他用户；这里提到的只是其中一些最重要的利益相关者。总的来说，Rust 最大的抱负是通过同时提供安全性和生产力，速度和易用性，来消除程序员几十年来不得不接受的权衡取舍。试试 Rust，看看它的选择是否适合你。</p>
<h2 id="who-this-book-is-for-本书适合谁"><a class="header" href="#who-this-book-is-for-本书适合谁">Who This Book Is For 本书适合谁</a></h2>
<p>This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming <em>is</em> or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.</p>
<p>本书假定你曾经使用过其他编程语言编写代码，但不限定具体是哪一种。我们力求使内容能让来自广泛编程背景的人都能理解。我们不会花太多时间讨论编程是什么或如何思考编程。如果你完全是编程新手，阅读一本专门介绍编程入门的书会更有帮助。</p>
<h2 id="how-to-use-this-book-如何使用本书"><a class="header" href="#how-to-use-this-book-如何使用本书">How to Use This Book 如何使用本书</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a particular topic but will revisit
the topic in a later chapter.</p>
<p>一般来说，本书假设你是按顺序从前到后阅读的。后面的章节建立在前面章节的概念之上，而前面的章节可能不会深入探讨某个特定主题的细节，但会在后面的章节中重新讨论该主题。</p>
<p>You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 21 are project chapters; the rest are concept chapters.</p>
<p>您将在本书中发现两种类型的章节：<strong>概念章节</strong>和<strong>项目章节</strong>。在概念章节中，您将学习 Rust 的某个方面。在项目章节中，我们将共同构建小型程序，应用您目前所学的知识。第 2 章、第 12 章和第 21 章属于项目章节；其余均为概念章节。</p>
<p>Chapter 1 explains how to install Rust, how to write a “Hello, world!” program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to writing a program in Rust, having you build up a
number guessing game. Here we cover concepts at a high level, and later
chapters will provide additional detail. If you want to get your hands dirty
right away, Chapter 2 is the place for that. Chapter 3 covers Rust features
that are similar to those of other programming languages, and in Chapter 4
you’ll learn about Rust’s ownership system. If you’re a particularly meticulous
learner who prefers to learn every detail before moving on to the next, you
might want to skip Chapter 2 and go straight to Chapter 3, returning to Chapter
2 when you’d like to work on a project applying the details you’ve learned.</p>
<p>第 1 章讲解如何安装 Rust、如何编写 “Hello, world!” 程序，以及如何使用 Cargo（Rust 的包管理器和构建工具）。第 2 章是通过实践引导您编写 Rust 程序的入门教程，您将构建一个猜数字游戏。此处我们会从高层次介绍概念，后续章节将提供更多细节。如果您想立即动手实践，第 2 章是最佳起点。第 3 章涵盖 Rust 与其他编程语言相似的功能特性，第 4 章则介绍 Rust 的所有权系统。如果您是偏好先掌握所有细节再继续学习的严谨型学习者，可以跳过第 2 章直接阅读第 3 章，待您希望应用所学细节进行项目实践时再回到第 2 章。</p>
<p>Chapter 5 discusses structs and methods, and Chapter 6 covers enums, <code>match</code>
expressions, and the <code>if let</code> control flow construct. You’ll use structs and
enums to make custom types in Rust.</p>
<p>第 5 章讨论结构体和方法，第 6 章涵盖枚举、<code>match</code> 表达式和 <code>if let</code> 控制流结构。您将使用结构体和枚举在 Rust 中创建自定义类型。</p>
<p>In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.</p>
<p>第 7 章中，您将了解 Rust 的模块系统以及用于组织代码及其公共应用程序接口（API）的可见性规则。第 8 章讨论标准库提供的常见集合数据结构，如向量、字符串和哈希映射。第 9 章探讨 Rust 的错误处理理念与技术。</p>
<p>Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the <code>grep</code> command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.</p>
<p>第 10 章深入讲解泛型、特征（trait）和生命周期（lifetime），这些特性赋予您定义适用于多种类型的代码能力。第 11 章专注于测试，即使在 Rust 的安全保证下，测试对确保程序逻辑正确性仍必不可少。第 12 章我们将共同实现 <code>grep</code> 命令行工具的部分功能（用于在文件中搜索文本），此过程将运用前几章讨论的诸多概念。</p>
<p>Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.</p>
<p>第 13 章探索闭包和迭代器：这些源自函数式编程语言的 Rust 特性。第 14 章我们将更深入探讨 Cargo，并分享与他人共享库的最佳实践。第 15 章讨论标准库提供的智能指针及其功能实现所依赖的特征。</p>
<p>In Chapter 16, we’ll walk through different models of concurrent programming and
talk about how Rust helps you to program in multiple threads fearlessly. In
Chapter 17, we build on that by exploring Rust’s async and await syntax, along
with tasks, futures, and streams, and the lightweight concurrency model they
enable.</p>
<p>第 16 章我们将遍历不同的并发编程模型，并探讨 Rust 如何助您无畏地进行多线程编程。第 17 章在此基础上探索 Rust 的 async/await 语法，以及任务（task）、未来（future）、流（stream）和它们实现的轻量级并发模型。</p>
<p>Chapter 18 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with. Chapter 19 is a reference on patterns and
pattern matching, which are powerful ways of expressing ideas throughout Rust
programs. Chapter 20 contains a smorgasbord of advanced topics of interest,
including unsafe Rust, macros, and more about lifetimes, traits, types,
functions, and closures.</p>
<p>第 18 章比较 Rust 惯用法与您可能熟悉的面向对象编程原则。第 19 章是关于模式与模式匹配的参考指南（它们是贯穿 Rust 程序的强大表达方式）。第 20 章汇集多个进阶主题，包括非安全 Rust、宏，以及生命周期、特征、类型、函数和闭包的深入内容。</p>
<p>In Chapter 21, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!</p>
<p>第 21 章我们将完成一个项目：实现一个底层多线程 Web 服务器！</p>
<p>Finally, some appendixes contain useful information about the language in a more
reference-like format. <strong>Appendix A</strong> covers Rust’s keywords, <strong>Appendix B</strong>
covers Rust’s operators and symbols, <strong>Appendix C</strong> covers derivable traits
provided by the standard library, <strong>Appendix D</strong> covers some useful development
tools, and <strong>Appendix E</strong> explains Rust editions. In <strong>Appendix F</strong>, you can
find translations of the book, and in <strong>Appendix G</strong> we’ll cover how Rust is
made and what nightly Rust is.</p>
<p>最后，部分附录以类参考手册的形式包含实用的语言信息。<strong>附录 A</strong> 涵盖 Rust 关键字，<strong>附录 B</strong> 涵盖 Rust 运算符与符号，<strong>附录 C</strong> 涵盖标准库提供的可派生特征，<strong>附录 D</strong> 涵盖实用开发工具，<strong>附录 E</strong> 解释 Rust 版本机制。<strong>附录 F</strong> 提供本书翻译版本信息，<strong>附录 G</strong> 将介绍 Rust 的构建过程及 Nightly Rust 版本。</p>
<p>There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.</p>
<p>阅读本书没有固定模式*：若您想跳读，请自便！遇到困惑时可能需要回溯前面章节。选择最适合您的方式即可。</p>
<p>An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:</p>
<p>学习 Rust 的关键环节是掌握阅读编译器错误信息的方法：这些信息将引导您编写出可运行的代码。因此我们会提供大量无法编译的示例，并展示每种情况下编译器显示的报错信息。请注意：若您直接输入并运行随机示例，它可能无法编译！请务必阅读上下文说明，确认您尝试运行的示例是否预期会报错。Ferris 小螃蟹也会帮助您识别非预期运行的代码：</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" stype="width: 100px"/></td><td>This code does not compile! 此代码无法编译！</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>This code panics! 此代码会触发恐慌（panic）！</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>This code does not produce the desired behavior. 此代码无法产生预期行为。</td></tr>
</tbody></table>
</div>
<p>In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.</p>
<p>多数情况下，我们会引导您修正无法编译的代码。</p>
<h2 id="source-code-源代码"><a class="header" href="#source-code-源代码">Source Code 源代码</a></h2>
<p>The source files from which this book is generated can be found on
GitHub.</p>
<p>本书生成的源文件可在 <a href="https://github.com/rust-lang/book">GitHub</a> 上获取。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-入门指南"><a class="header" href="#getting-started-入门指南">Getting Started 入门指南</a></h1>
<p>Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:</p>
<p>让我们开启你的 Rust 之旅！虽然需要学习的内容很多，但所有旅程都有起点。在本章中，我们将讨论：</p>
<ul>
<li>Installing Rust on Linux, macOS, and Windows</li>
<li>在 Linux、macOS 和 Windows 上安装 Rust</li>
<li>Writing a program that prints <code>Hello, world!</code></li>
<li>编写打印 <code>Hello, world!</code> 的程序</li>
<li>Using <code>cargo</code>, Rust’s package manager and build system</li>
<li>使用 Rust 的包管理器和构建系统 <code>cargo</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation-安装"><a class="header" href="#installation-安装">Installation 安装</a></h2>
<p>The first step is to install Rust. We’ll download Rust through <code>rustup</code>, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.</p>
<p>第一步是安装 Rust。我们将通过 <code>rustup</code> 下载 Rust，这是一个用于管理 Rust 版本及相关工具的命令行工具。下载过程需要网络连接。</p>
<section class="note" aria-role="note">
<p>Note: If you prefer not to use <code>rustup</code> for some reason, please see the
Other Rust Installation Methods page for more options.</p>
<p>注意：如果因某些原因不想使用 <code>rustup</code>，请参阅<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">其他 Rust 安装方法页面</a>了解更多选项。</p>
</section>
<p>The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions because Rust often improves error messages and
warnings. In other words, any newer, stable version of Rust you install using
these steps should work as expected with the content of this book.</p>
<p>以下步骤将安装最新稳定版的 Rust 编译器。Rust 的稳定性保证确保本书中所有能编译的示例在更新的 Rust 版本中仍可继续编译。不同版本的输出可能略有差异，因为 Rust 会持续改进错误信息和警告。换言之，通过这些步骤安装的任何更新的稳定版 Rust，都应能按预期运行本书内容。</p>
<section class="note" aria-role="note">
<h3 id="command-line-notation-命令行符号说明"><a class="header" href="#command-line-notation-命令行符号说明">Command Line Notation 命令行符号说明</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type the <code>$</code> character; it’s the command line prompt shown to
indicate the start of each command. Lines that don’t start with <code>$</code> typically
show the output of the previous command. Additionally, PowerShell-specific
examples will use <code>&gt;</code> rather than <code>$</code>.</p>
<p>在本章及全书中，我们将展示终端中使用的命令。需要在终端输入的行均以 <code>$</code> 开头。实际无需输入 <code>$</code> 符号，它仅作为命令行提示符表示命令开始。不以 <code>$</code> 开头的行通常显示前一条命令的输出。此外，PowerShell 专属示例将使用 <code>&gt;</code> 而非 <code>$</code>。</p>
</section>
<h3 id="installing-rustup-on-linux-or-macos-在-linux-或-macos-上安装-rustup"><a class="header" href="#installing-rustup-on-linux-or-macos-在-linux-或-macos-上安装-rustup">Installing <code>rustup</code> on Linux or macOS 在 Linux 或 macOS 上安装 <code>rustup</code></a></h3>
<p>If you’re using Linux or macOS, open a terminal and enter the following command:</p>
<p>若使用 Linux 或 macOS，请打开终端并输入以下命令：</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>The command downloads a script and starts the installation of the <code>rustup</code>
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:</p>
<p>此命令将下载脚本并启动 <code>rustup</code> 工具的安装，该工具会安装最新的 Rust 稳定版。系统可能会提示输入密码。安装成功后会出现以下提示：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>You will also need a <em>linker</em>, which is a program that Rust uses to join its
compiled outputs into one file. It is likely you already have one. If you get
linker errors, you should install a C compiler, which will typically include a
linker. A C compiler is also useful because some common Rust packages depend on
C code and will need a C compiler.</p>
<p>您还需要一个<strong>链接器</strong>（linker），这是 Rust 用于将其编译输出合并为单个文件的程序。您可能已安装此工具。若遇到链接器错误，应安装 C 编译器（通常包含链接器）。C 编译器同样重要，因为部分常用 Rust 包依赖 C 代码并需要 C 编译器。</p>
<p>On macOS, you can get a C compiler by running:</p>
<p>在 macOS 上，可通过以下命令安装 C 编译器：</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux users should generally install GCC or Clang, according to their
distribution’s documentation. For example, if you use Ubuntu, you can install
the <code>build-essential</code> package.</p>
<p>Linux 用户通常应根据发行版文档安装 GCC 或 Clang。例如 Ubuntu 用户可安装 <code>build-essential</code> 包。</p>
<h3 id="installing-rustup-on-windows-在-windows-上安装-rustup"><a class="header" href="#installing-rustup-on-windows-在-windows-上安装-rustup">Installing <code>rustup</code> on Windows 在 Windows 上安装 <code>rustup</code></a></h3>
<p>On Windows, go to https://www.rust-lang.org/tools/install and follow
the instructions for installing Rust. At some point in the installation, you’ll
be prompted to install Visual Studio. This provides a linker and the native
libraries needed to compile programs. If you need more help with this step, see
https://rust-lang.github.io/rustup/installation/windows-msvc.html</p>
<p>在 Windows 上，访问 <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> 并遵循 Rust 安装说明。安装过程中会提示安装 Visual Studio，这将提供链接器和编译程序所需的原生库。如需更多帮助，请参阅 <a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">https://rust-lang.github.io/rustup/installation/windows-msvc.html</a>。</p>
<p>The rest of this book uses commands that work in both <em>cmd.exe</em> and PowerShell.
If there are specific differences, we’ll explain which to use.</p>
<p>本书其余部分使用的命令均兼容 <em>cmd.exe</em> 和 PowerShell。若存在特定差异，我们会说明应使用的工具。</p>
<h3 id="troubleshooting-故障排除"><a class="header" href="#troubleshooting-故障排除">Troubleshooting 故障排除</a></h3>
<p>To check whether you have Rust installed correctly, open a shell and enter this
line:</p>
<p>要检查 Rust 是否安装正确，请打开 shell 并输入：</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>You should see the version number, commit hash, and commit date for the latest
stable version that has been released, in the following format:</p>
<p>您应看到最新稳定版的版本号、提交哈希值和提交日期，格式如下：</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>If you see this information, you have installed Rust successfully! If you don’t
see this information, check that Rust is in your <code>%PATH%</code> system variable as
follows.</p>
<p>若看到此信息，则 Rust 已成功安装！若未显示，请按以下方式检查 Rust 是否在 <code>%PATH%</code> 系统变量中：</p>
<p>In Windows CMD, use:</p>
<p>在 Windows CMD 中执行：</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>In PowerShell, use:</p>
<p>在 PowerShell 中执行：</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>In Linux and macOS, use:</p>
<p>在 Linux 和 macOS 中执行：</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>If that’s all correct and Rust still isn’t working, there are a number of
places you can get help. Find out how to get in touch with other Rustaceans (a
silly nickname we call ourselves) on the community page.</p>
<p>若路径配置正确但 Rust 仍不可用，可通过多种渠道获取帮助。请在<a href="https://www.rust-lang.org/community">社区页面</a>了解如何联系其他 Rustacean（我们对 Rust 用户的趣称）。</p>
<h3 id="updating-and-uninstalling-更新与卸载"><a class="header" href="#updating-and-uninstalling-更新与卸载">Updating and Uninstalling 更新与卸载</a></h3>
<p>Once Rust is installed via <code>rustup</code>, updating to a newly released version is
easy. From your shell, run the following update script:</p>
<p>通过 <code>rustup</code> 安装 Rust 后，更新到新发布版本非常简单。在 shell 中运行以下更新脚本：</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>To uninstall Rust and <code>rustup</code>, run the following uninstall script from your
shell:</p>
<p>要卸载 Rust 和 <code>rustup</code>，请在 shell 中运行以下卸载脚本：</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="local-documentation-本地文档"><a class="header" href="#local-documentation-本地文档">Local Documentation 本地文档</a></h3>
<p>The installation of Rust also includes a local copy of the documentation so
that you can read it offline. Run <code>rustup doc</code> to open the local documentation
in your browser.</p>
<p>Rust 安装包包含文档的本地副本，便于离线阅读。运行 <code>rustup doc</code> 可在浏览器中打开本地文档。</p>
<p>Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!</p>
<p>当您不确定标准库提供的类型或函数的作用及用法时，请查阅应用程序接口（API）文档！</p>
<h3 id="text-editors-and-integrated-development-environments-文本编辑器与集成开发环境"><a class="header" href="#text-editors-and-integrated-development-environments-文本编辑器与集成开发环境">Text Editors and Integrated Development Environments 文本编辑器与集成开发环境</a></h3>
<p>This book makes no assumptions about what tools you use to author Rust code.
Just about any text editor will get the job done! However, many text editors and
integrated development environments (IDEs) have built-in support for Rust. You
can always find a fairly current list of many editors and IDEs on the tools
page on the Rust website.</p>
<p>本书不限定编写 Rust 代码的工具。任何文本编辑器均可胜任！不过许多文本编辑器与集成开发环境（IDE）内置了对 Rust 的支持。您可在 Rust 官网的<a href="https://www.rust-lang.org/tools">工具页面</a>找到最新的编辑器与 IDE 支持列表。</p>
<h3 id="working-offline-with-this-book-离线使用本书"><a class="header" href="#working-offline-with-this-book-离线使用本书">Working Offline with This Book 离线使用本书</a></h3>
<p>In several examples, we will use Rust packages beyond the standard library. To
work through those examples, you will either need to have an internet connection
or to have downloaded those dependencies ahead of time. To download the
dependencies ahead of time, you can run the following commands. (We’ll explain
what <code>cargo</code> is and what each of these commands does in detail later.)</p>
<p>部分示例会使用标准库之外的 Rust 包。要运行这些示例，您需要保持网络连接或提前下载依赖项。要预先下载依赖项，可运行以下命令（我们将在后续章节详细解释 <code>cargo</code> 及这些命令的作用）：</p>
<pre><code class="language-console">$ cargo new get-dependencies
$ cd get-dependencies
$ cargo add rand@0.8.5 trpl@0.2.0
</code></pre>
<p>This will cache the downloads for these packages so you will not need to
download them later. Once you have run this command, you do not need to keep the
<code>get-dependencies</code> folder. If you have run this command, you can use the
<code>--offline</code> flag with all <code>cargo</code> commands in the rest of the book to use these
cached versions instead of attempting to use the network.</p>
<p>这将缓存这些包的下载内容，后续无需重复下载。执行此命令后，无需保留 <code>get-dependencies</code> 文件夹。若已执行此命令，在本书后续所有 <code>cargo</code> 命令中添加 <code>--offline</code> 标志即可使用缓存版本，无需连接网络。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>Now that you’ve installed Rust, it’s time to write your first Rust program.
It’s traditional when learning a new language to write a little program that
prints the text <code>Hello, world!</code> to the screen, so we’ll do the same here!</p>
<p>现在你已安装好 Rust，是时候编写第一个 Rust 程序了。学习新语言时，传统做法是编写一个在屏幕上打印 <code>Hello, world!</code> 的小程序，我们也将遵循这一传统！</p>
<section class="note" aria-role="note">
<p>Note: This book assumes basic familiarity with the command line. Rust makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. Many IDEs now have some
degree of Rust support; check the IDE’s documentation for details. The Rust
team has been focusing on enabling great IDE support via <code>rust-analyzer</code>. See
Appendix D for more details.</p>
<p>注意：本书假设读者对命令行有基本了解。Rust 对编辑器、工具或代码存放位置没有特定要求，因此如果你更喜欢使用集成开发环境（IDE）而非命令行，请随意选用你喜欢的 IDE。目前许多 IDE 都提供了一定程度的 Rust 支持；详情请查阅 IDE 的文档。Rust 团队一直致力于通过 <code>rust-analyzer</code> 提供卓越的 IDE 支持，更多细节请参阅附录 D。</p>
</section>
<h3 id="creating-a-project-directory-创建项目目录"><a class="header" href="#creating-a-project-directory-创建项目目录">Creating a Project Directory 创建项目目录</a></h3>
<p>You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a <em>projects</em> directory in your home directory and keeping all
your projects there.</p>
<p>首先创建一个目录来存放 Rust 代码。Rust 不关心代码存放位置，但针对本书的练习和项目，建议在 home 目录下创建 <em>projects</em> 目录并将所有项目存放其中。</p>
<p>Open a terminal and enter the following commands to make a <em>projects</em> directory
and a directory for the “Hello, world!” project within the <em>projects</em> directory.</p>
<p>打开终端并输入以下命令，在 <em>projects</em> 目录中创建 “Hello, world!” 项目目录：</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<p>对于 Linux、macOS 和 Windows PowerShell，输入：</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>For Windows CMD, enter this:</p>
<p>对于 Windows CMD，输入：</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="writing-and-running-a-rust-program-编写并运行-rust-程序"><a class="header" href="#writing-and-running-a-rust-program-编写并运行-rust-程序">Writing and Running a Rust Program 编写并运行 Rust 程序</a></h3>
<p>Next, make a new source file and call it <em>main.rs</em>. Rust files always end with
the <em>.rs</em> extension. If you’re using more than one word in your filename, the
convention is to use an underscore to separate them. For example, use
<em>hello_world.rs</em> rather than <em>helloworld.rs</em>.</p>
<p>接下来创建名为 <em>main.rs</em> 的源文件。Rust 文件总是以 <em>.rs</em> 扩展名结尾。如果文件名包含多个单词，约定使用下划线分隔（例如使用 <em>hello_world.rs</em> 而非 <em>helloworld.rs</em>）。</p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p>打开刚创建的 <em>main.rs</em> 文件，输入代码清单 1-1 中的代码。</p>
<figure class="listing" id="listing-1-1">
<span class="file-name">Filename: main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<figcaption><a href="ch01-02-hello-world.html#listing-1-1">Listing 1-1</a>: A program that prints <code>Hello, world!</code> 打印<code>Hello, world!</code>的程序</figcaption>
</figure>
<p>Save the file and go back to your terminal window in the
<em>~/projects/hello_world</em> directory. On Linux or macOS, enter the following
commands to compile and run the file:</p>
<p>保存文件后回到 <em>~/projects/hello_world</em> 目录下的终端窗口。在 Linux 或 macOS 上输入以下命令编译并运行文件：</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>On Windows, enter the command <code>.\main</code> instead of <code>./main</code>:</p>
<p>在 Windows 上，使用 <code>.\main</code> 替代 <code>./main</code>：</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main
Hello, world!
</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should print to
the terminal. If you don’t see this output, refer back to the
“Troubleshooting” part of the Installation
section for ways to get help.</p>
<p>无论使用何种操作系统，终端都应打印出 <code>Hello, world!</code> 字符串。如果未看到输出，请回顾安装章节的“故障排除“部分以获取帮助。</p>
<p>If <code>Hello, world!</code> did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!</p>
<p>如果成功打印 <code>Hello, world!</code>，恭喜！你已正式编写了 Rust 程序，成为 Rust 程序员——欢迎加入！</p>
<h3 id="anatomy-of-a-rust-program-rust-程序结构解析"><a class="header" href="#anatomy-of-a-rust-program-rust-程序结构解析">Anatomy of a Rust Program Rust 程序结构解析</a></h3>
<p>Let’s review this “Hello, world!” program in detail. Here’s the first piece of
the puzzle:</p>
<p>让我们详细分析这个 “Hello, world!” 程序。以下是关键部分：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>These lines define a function named <code>main</code>. The <code>main</code> function is special: it
is always the first code that runs in every executable Rust program. Here, the
first line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses <code>()</code>.</p>
<p>这几行定义了一个名为 <code>main</code> 的函数。<code>main</code> 函数具有特殊性：它始终是每个可执行 Rust 程序中首先运行的代码。此处第一行声明了无参数且无返回值的 <code>main</code> 函数（若有参数则需放在括号 <code>()</code> 内）。</p>
<p>The function body is wrapped in <code>{}</code>. Rust requires curly brackets around all
function bodies. It’s good style to place the opening curly bracket on the same
line as the function declaration, adding one space in between.</p>
<p>函数体包裹在 <code>{}</code> 中。Rust 要求所有函数体都使用花括号包裹。约定将左花括号与函数声明放在同一行，中间用空格分隔。</p>
<section class="note" aria-role="note">
<p>Note: If you want to stick to a standard style across Rust projects, you can
use an automatic formatter tool called <code>rustfmt</code> to format your code in a
particular style (more on <code>rustfmt</code> in
Appendix D). The Rust team has included this tool
with the standard Rust distribution, as <code>rustc</code> is, so it should already be
installed on your computer!</p>
<p>注意：若要在 Rust 项目中保持统一代码风格，可使用名为 <code>rustfmt</code> 的自动格式化工具（更多信息
见附录 D）。Rust 团队已将该工具与标准 Rust 发行版一同提供（如同 <code>rustc</code>），因此你的计算机上应已安装此工具！</p>
</section>
<p>The body of the <code>main</code> function holds the following code:</p>
<p><code>main</code> 函数体内包含以下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello, world!");
<span class="boring">}</span></code></pre></pre>
<p>This line does all the work in this little program: it prints text to the
screen. There are three important details to notice here.</p>
<p>这行代码完成了整个小程序的工作：将文本打印到屏幕。此处有三个重要细节需注意：</p>
<p>First, <code>println!</code> calls a Rust macro. If it had called a function instead, it
would be entered as <code>println</code> (without the <code>!</code>). Rust macros are a way to write
code that generates code to extend Rust syntax, and we’ll discuss them in more
detail in Chapter 20. For now, you just need to
know that using a <code>!</code> means that you’re calling a macro instead of a normal
function and that macros don’t always follow the same rules as functions.</p>
<p><code>println!</code> 调用的是 Rust 宏。若调用普通函数，应写作 <code>println</code>（不带 <code>!</code>）。Rust 宏是一种通过生成代码来扩展语法的方式，第 20 章将深入讨论。目前只需理解：使用 <code>!</code> 表示调用宏而非普通函数，且宏的规则不一定与函数相同。</p>
<p>Second, you see the <code>"Hello, world!"</code> string. We pass this string as an argument
to <code>println!</code>, and the string is printed to the screen.</p>
<p><code>"Hello, world!"</code> 字符串作为参数传递给 <code>println!</code> 并被打印到屏幕。</p>
<p>Third, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.</p>
<p>行尾的分号 (<code>;</code>) 表示该表达式结束，下一个表达式可开始。大多数 Rust 代码行以分号结尾。</p>
<h3 id="compiling-and-running-are-separate-steps-编译与运行是独立步骤"><a class="header" href="#compiling-and-running-are-separate-steps-编译与运行是独立步骤">Compiling and Running Are Separate Steps 编译与运行是独立步骤</a></h3>
<p>You’ve just run a newly created program, so let’s examine each step in the
process.</p>
<p>你刚刚运行了新创建的程序，现在让我们审视过程中的每个步骤。</p>
<p>Before running a Rust program, you must compile it using the Rust compiler by
entering the <code>rustc</code> command and passing it the name of your source file, like
this:</p>
<p>在运行 Rust 程序前，必须使用 Rust 编译器进行编译：通过 <code>rustc</code> 命令并传入源文件名，如下所示：</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>If you have a C or C++ background, you’ll notice that this is similar to <code>gcc</code>
or <code>clang</code>. After compiling successfully, Rust outputs a binary executable.</p>
<p>若有 C/C++ 背景，你会发现这类似于 <code>gcc</code> 或 <code>clang</code>。成功编译后，Rust 会输出二进制可执行文件。</p>
<p>On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the <code>ls</code> command in your shell:</p>
<p>在 Linux、macOS 和 Windows PowerShell 中，可通过 shell 输入 <code>ls</code> 命令查看可执行文件：</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>On Linux and macOS, you’ll see two files. With PowerShell on Windows, you’ll
see the same three files that you would see using CMD. With CMD on Windows, you
would enter the following:</p>
<p>在 Linux/macOS 中会看到两个文件。在 Windows PowerShell 中会看到与 CMD 相同的三个文件。在 Windows CMD 中需输入：</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>This shows the source code file with the <em>.rs</em> extension, the executable file
(<em>main.exe</em> on Windows, but <em>main</em> on all other platforms), and, when using
Windows, a file containing debugging information with the <em>.pdb</em> extension.
From here, you run the <em>main</em> or <em>main.exe</em> file, like this:</p>
<p>这会显示扩展名为 <em>.rs</em> 的源代码文件、可执行文件（Windows 上是 <em>main.exe</em>，其他平台是 <em>main</em>），以及在 Windows 上还会显示包含调试信息的 <em>.pdb</em> 文件。此时可运行 <em>main</em> 或 <em>main.exe</em> 文件：</p>
<pre><code class="language-console">$ ./main # or .\main on Windows
</code></pre>
<p>If your <em>main.rs</em> is your “Hello, world!” program, this line prints <code>Hello,  world!</code> to your terminal.</p>
<p>如果你的 <em>main.rs</em> 是 “Hello, world!” 程序，此行会将 <code>Hello, world!</code> 打印到终端。</p>
<p>If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an <em>ahead-of-time compiled</em> language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a <em>.rb</em>, <em>.py</em>, or
<em>.js</em> file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.</p>
<p>若更熟悉 Ruby/Python/JavaScript 等动态语言，可能不习惯将编译和运行作为独立步骤。
Rust 是 <em>预编译(ahead-of-time compiled)</em> 语言，意味着你可以编译程序并将可执行文件分发给他人，他们无需安装 Rust 即可运行。若分发 <em>.rb</em>、<em>.py</em> 或 <em>.js</em> 文件，接收方需安装相应的 Ruby/Python/JavaScript 运行环境。虽然这些语言只需单命令即可编译运行程序，但语言设计始终存在权衡取舍。</p>
<p>Just compiling with <code>rustc</code> is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.</p>
<p>对于简单程序，使用 <code>rustc</code> 编译完全可行。但随着项目增长，你将需要管理所有选项并简化代码共享流程。接下来我们将介绍 Cargo 工具，它将帮助你编写实际可用的 Rust 程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
<em>dependencies</em>.)</p>
<p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rust 开发者使用这个工具来管理他们的 Rust 项目，因为 Cargo 为你处理许多任务，例如构建代码、下载代码所依赖的库以及构建这些库。（我们将你的代码所需的库称为<em>依赖项</em>）。</p>
<p>The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. If we had built the “Hello, world!” project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.</p>
<p>最简单的 Rust 程序（比如我们目前编写的程序）没有任何依赖项。如果我们使用 Cargo 构建“Hello, world!”项目，它只会用到 Cargo 处理代码构建的部分。随着你编写更复杂的 Rust 程序，你会添加依赖项；而如果你使用 Cargo 启动项目，添加依赖项将变得容易得多。</p>
<p>Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
“Installation” section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following in your terminal:</p>
<p>由于绝大多数 Rust 项目都使用 Cargo，本书后续内容也假定你在使用 Cargo。如果你使用了“安装”章节中讨论的官方安装程序，安装 Rust 时会附带安装 Cargo。如果你通过其他方式安装了 Rust，请在终端中输入以下命令来检查是否安装了 Cargo：</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>If you see a version number, you have it! If you see an error, such as <code>command  not found</code>, look at the documentation for your method of installation to
determine how to install Cargo separately.</p>
<p>如果你看到版本号，说明已安装！如果看到错误（例如 <code>command not found</code>），请查阅你所用安装方式的文档以确定如何单独安装 Cargo。</p>
<h3 id="creating-a-project-with-cargo-使用-cargo-创建项目"><a class="header" href="#creating-a-project-with-cargo-使用-cargo-创建项目">Creating a Project with Cargo 使用 Cargo 创建项目</a></h3>
<p>Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your <em>projects</em> directory
(or wherever you decided to store your code). Then, on any operating system,
run the following:</p>
<p>让我们使用 Cargo 创建一个新项目，看看它与我们最初的“Hello, world!”项目有何不同。导航回你的 <em>projects</em> 目录（或你决定存储代码的任何位置）。然后，在任何操作系统上运行以下命令：</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>The first command creates a new directory and project called <em>hello_cargo</em>.
We’ve named our project <em>hello_cargo</em>, and Cargo creates its files in a
directory of the same name.</p>
<p>第一条命令创建了一个名为 <em>hello_cargo</em> 的新目录和项目。我们将项目命名为 <em>hello_cargo</em>，Cargo 会在同名目录中创建其文件。</p>
<p>Go into the <em>hello_cargo</em> directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a <em>Cargo.toml</em> file and a
<em>src</em> directory with a <em>main.rs</em> file inside.</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。你会看到 Cargo 为我们生成了两个文件和一个目录：一个 <em>Cargo.toml</em> 文件，以及一个包含 <em>main.rs</em> 文件的 <em>src</em> 目录。</p>
<p>It has also initialized a new Git repository along with a <em>.gitignore</em> file.
Git files won’t be generated if you run <code>cargo new</code> within an existing Git
repository; you can override this behavior by using <code>cargo new --vcs=git</code>.</p>
<p>它还会初始化一个新的 Git 仓库并生成一个 <em>.gitignore</em> 文件。如果在现有的 Git 仓库中运行 <code>cargo new</code>，则不会生成 Git 文件；你可以使用 <code>cargo new --vcs=git</code> 覆盖此行为。</p>
<section class="note" aria-role="note">
<p>Note: Git is a common version control system. You can change <code>cargo new</code> to
use a different version control system or no version control system by using
the <code>--vcs</code> flag. Run <code>cargo new --help</code> to see the available options.</p>
<p>注意：Git 是一个常见的版本控制系统。你可以使用 <code>--vcs</code> 标志来更改 <code>cargo new</code> 使用的版本控制系统或不使用任何版本控制系统。运行 <code>cargo new --help</code> 查看可用选项。</p>
</section>
<p>Open <em>Cargo.toml</em> in your text editor of choice. It should look similar to the
code in Listing 1-2.</p>
<p>在你选择的文本编辑器中打开 <em>Cargo.toml</em>。它应类似于代码清单 1-2 中的代码。</p>
<figure class="listing" id="listing-1-2">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<figcaption><a href="ch01-03-hello-cargo.html#listing-1-2">Listing 1-2</a>: Contents of <em>Cargo.toml</em> generated by <code>cargo new</code> <code>cargo new</code>生成的<em>Cargo.toml</em>内容</figcaption>
</figure>
<p>This file is in the <em>TOML</em> (<em>Tom’s Obvious, Minimal
Language</em>) format, which is Cargo’s configuration format.</p>
<p>此文件采用 <em>TOML</em>（<em>Tom’s Obvious, Minimal Language</em>）格式，这是 Cargo 的配置格式。</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>第一行 <code>[package]</code> 是一个段落标题，表示后续语句用于配置一个包。随着我们向此文件添加更多信息，我们将添加其他段落。</p>
<p>The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the <code>edition</code> key in Appendix E.</p>
<p>接下来的三行设置了 Cargo 编译程序所需的配置信息：名称、版本和要使用的 Rust 版本。我们将在附录 E 中讨论 <code>edition</code> 键。</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
<em>crates</em>. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.</p>
<p>最后一行 <code>[dependencies]</code> 是用于列出项目所有依赖项的段落的开始。在 Rust 中，代码包被称为 <em>crate</em>（包）。本项目不需要其他包，但在第二章的第一个项目中会用到，那时我们将使用这个依赖项段落。</p>
<p>Now open <em>src/main.rs</em> and take a look:</p>
<p>现在打开 <em>src/main.rs</em> 看看：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our project and the
project Cargo generated are that Cargo placed the code in the <em>src</em> directory
and we have a <em>Cargo.toml</em> configuration file in the top directory.</p>
<p>Cargo 为你生成了一个“Hello, world!”程序，与我们代码清单 1-1 中编写的完全一样！到目前为止，我们的项目与 Cargo 生成的项目之间的区别在于：Cargo 将代码放在 <em>src</em> 目录中，并且在顶层目录有一个 <em>Cargo.toml</em> 配置文件。</p>
<p>Cargo expects your source files to live inside the <em>src</em> directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.</p>
<p>Cargo 期望你的源文件位于 <em>src</em> 目录中。顶层项目目录仅用于 README 文件、许可证信息、配置文件以及其他与代码无关的内容。使用 Cargo 有助于你组织项目。各得其所，井井有条。</p>
<p>If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the <em>src</em> directory and create an appropriate <em>Cargo.toml</em>
file. One easy way to get that <em>Cargo.toml</em> file is to run <code>cargo init</code>, which
will create it for you automatically.</p>
<p>如果你启动的项目没有使用 Cargo（就像我们之前的“Hello, world!”项目），可以将其转换为使用 Cargo 的项目。将项目代码移动到 <em>src</em> 目录中，并创建一个合适的 <em>Cargo.toml</em> 文件。获取该 <em>Cargo.toml</em> 文件的一个简单方法是运行 <code>cargo init</code>，它会自动为你创建。</p>
<h3 id="building-and-running-a-cargo-project-构建和运行-cargo-项目"><a class="header" href="#building-and-running-a-cargo-project-构建和运行-cargo-项目">Building and Running a Cargo Project 构建和运行 Cargo 项目</a></h3>
<p>Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your <em>hello_cargo</em> directory, build your project by
entering the following command:</p>
<p>现在让我们看看使用 Cargo 构建和运行“Hello, world!”程序有什么不同！在你的 <em>hello_cargo</em> 目录中，输入以下命令构建项目：</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>This command creates an executable file in <em>target/debug/hello_cargo</em> (or
<em>target\debug\hello_cargo.exe</em> on Windows) rather than in your current
directory. Because the default build is a debug build, Cargo puts the binary in
a directory named <em>debug</em>. You can run the executable with this command:</p>
<p>此命令在 <em>target/debug/hello_cargo</em>（在 Windows 上是 <em>target\debug\hello_cargo.exe</em>）创建可执行文件，而不是在当前目录中。因为默认构建是调试构建（debug build），所以 Cargo 将二进制文件放在名为 <em>debug</em> 的目录中。你可以使用以下命令运行该可执行文件：</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>If all goes well, <code>Hello, world!</code> should print to the terminal. Running <code>cargo  build</code> for the first time also causes Cargo to create a new file at the top
level: <em>Cargo.lock</em>. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.</p>
<p>如果一切顺利，<code>Hello, world!</code> 应打印到终端。首次运行 <code>cargo build</code> 还会导致 Cargo 在顶层创建一个新文件：<em>Cargo.lock</em>。此文件跟踪项目中依赖项的确切版本。本项目没有依赖项，因此该文件内容较少。你永远不需要手动更改此文件；Cargo 会为你管理其内容。</p>
<p>We just built a project with <code>cargo build</code> and ran it with
<code>./target/debug/hello_cargo</code>, but we can also use <code>cargo run</code> to compile the
code and then run the resultant executable all in one command:</p>
<p>我们刚刚使用 <code>cargo build</code> 构建了项目，并用 <code>./target/debug/hello_cargo</code> 运行它，但我们也可以使用 <code>cargo run</code> 在一个命令中编译代码并运行生成的可执行文件：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Using <code>cargo run</code> is more convenient than having to remember to run <code>cargo  build</code> and then use the whole path to the binary, so most developers use <code>cargo  run</code>.</p>
<p>使用 <code>cargo run</code> 比必须记住先运行 <code>cargo build</code> 然后再使用二进制文件的完整路径更方便，因此大多数开发者使用 <code>cargo run</code>。</p>
<p>Notice that this time we didn’t see output indicating that Cargo was compiling
<code>hello_cargo</code>. Cargo figured out that the files hadn’t changed, so it didn’t
rebuild but just ran the binary. If you had modified your source code, Cargo
would have rebuilt the project before running it, and you would have seen this
output:</p>
<p>注意，这次我们没有看到表明 Cargo 正在编译 <code>hello_cargo</code> 的输出。Cargo 判断出文件没有更改，因此它没有重新构建，而是直接运行了二进制文件。如果你修改了源代码，Cargo 会在运行前重新构建项目，你会看到这样的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo also provides a command called <code>cargo check</code>. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:</p>
<p>Cargo 还提供了一个名为 <code>cargo check</code> 的命令。此命令快速检查你的代码以确保它能编译，但不会生成可执行文件：</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Why would you not want an executable? Often, <code>cargo check</code> is much faster than
<code>cargo build</code> because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using <code>cargo check</code> will
speed up the process of letting you know if your project is still compiling! As
such, many Rustaceans run <code>cargo check</code> periodically as they write their
program to make sure it compiles. Then they run <code>cargo build</code> when they’re
ready to use the executable.</p>
<p>为什么你可能不需要生成可执行文件呢？通常，<code>cargo check</code> 比 <code>cargo build</code> 快得多，因为它跳过了生成可执行文件的步骤。如果你在编写代码时持续检查工作，使用 <code>cargo check</code> 将加速获知项目是否仍能编译的过程！因此，许多 Rust 开发者在编写程序时会定期运行 <code>cargo check</code> 以确保它能编译。然后当他们准备使用可执行文件时再运行 <code>cargo build</code>。</p>
<p>Let’s recap what we’ve learned so far about Cargo:</p>
<p>让我们回顾一下目前学到的关于 Cargo 的知识：</p>
<ul>
<li>We can create a project using <code>cargo new</code>.</li>
<li>我们可以使用 <code>cargo new</code> 创建项目。</li>
<li>We can build a project using <code>cargo build</code>.</li>
<li>我们可以使用 <code>cargo build</code> 构建项目。</li>
<li>We can build and run a project in one step using <code>cargo run</code>.</li>
<li>我们可以使用 <code>cargo run</code> 一步完成构建并运行项目。</li>
<li>We can build a project without producing a binary to check for errors using
<code>cargo check</code>.</li>
<li>我们可以使用 <code>cargo check</code> 在不生成二进制文件的情况下构建项目以检查错误。</li>
<li>Instead of saving the result of the build in the same directory as our code,
Cargo stores it in the <em>target/debug</em> directory.</li>
<li>Cargo 将构建结果存储到 <em>target/debug</em> 目录中，而不是与我们的代码放在同一目录下。</li>
</ul>
<p>An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.</p>
<p>使用 Cargo 的另一个优点是，无论你在哪个操作系统上工作，命令都是相同的。因此，从现在开始，我们将不再提供针对 Linux、macOS 与 Windows 的具体说明。</p>
<h3 id="building-for-release-构建发布版本"><a class="header" href="#building-for-release-构建发布版本">Building for Release 构建发布版本</a></h3>
<p>When your project is finally ready for release, you can use <code>cargo build  --release</code> to compile it with optimizations. This command will create an
executable in <em>target/release</em> instead of <em>target/debug</em>. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run <code>cargo build --release</code> and benchmark with
the executable in <em>target/release</em>.</p>
<p>当你的项目最终准备好发布时，可以使用 <code>cargo build --release</code> 进行优化编译。此命令将在 <em>target/release</em> 而不是 <em>target/debug</em> 中创建可执行文件。这些优化使你的 Rust 代码运行得更快，但启用它们会延长程序的编译时间。这就是为什么有两种不同的配置：一种用于开发，此时你希望快速且频繁地重新构建；另一种用于构建最终交付给用户的程序，该程序不会被重复构建，并且需要尽可能快地运行。如果你要对代码的运行时间进行基准测试，请务必运行 <code>cargo build --release</code> 并使用 <em>target/release</em> 中的可执行文件进行基准测试。</p>
<h3 id="cargo-as-convention-cargo-作为约定"><a class="header" href="#cargo-as-convention-cargo-作为约定">Cargo as Convention Cargo 作为约定</a></h3>
<p>With simple projects, Cargo doesn’t provide a lot of value over just using
<code>rustc</code>, but it will prove its worth as your programs become more intricate.
Once programs grow to multiple files or need a dependency, it’s much easier to
let Cargo coordinate the build.</p>
<p>对于简单项目，Cargo 相比直接使用 <code>rustc</code> 并没有提供太多额外价值，但随着程序变得更加复杂，它将证明其价值。一旦程序增长到包含多个文件或需要依赖项，让 Cargo 来协调构建会容易得多。</p>
<p>Even though the <code>hello_cargo</code> project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:</p>
<p>尽管 <code>hello_cargo</code> 项目很简单，但它现在使用了许多你在后续 Rust 生涯中会使用的真实工具。事实上，要处理任何现有项目，你可以使用以下命令通过 Git 检出代码、切换到项目目录并进行构建：</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>For more information about Cargo, check out its documentation.</p>
<p>有关 Cargo 的更多信息，请查阅其文档。</p>
<h2 id="summary-总结"><a class="header" href="#summary-总结">Summary 总结</a></h2>
<p>You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:</p>
<p>你的 Rust 之旅已经有了一个良好的开端！在本章中，你学习了如何：</p>
<ul>
<li>Install the latest stable version of Rust using <code>rustup</code></li>
<li>使用 <code>rustup</code> 安装最新的稳定版 Rust</li>
<li>Update to a newer Rust version</li>
<li>更新到更新的 Rust 版本</li>
<li>Open locally installed documentation</li>
<li>打开本地安装的文档</li>
<li>Write and run a “Hello, world!” program using <code>rustc</code> directly</li>
<li>直接使用 <code>rustc</code> 编写和运行“Hello, world!”程序</li>
<li>Create and run a new project using the conventions of Cargo</li>
<li>使用 Cargo 的约定创建和运行新项目</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.</p>
<p>现在是构建一个更实质性的程序来习惯阅读和编写 Rust 代码的好时机。因此，在第二章中，我们将构建一个猜数字游戏程序。如果你更愿意从学习 Rust 中常见编程概念的工作原理开始，请参阅第三章，然后再回到第二章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-a-guessing-game-编写猜数游戏"><a class="header" href="#programming-a-guessing-game-编写猜数游戏">Programming a Guessing Game 编写猜数游戏</a></h1>
<p>Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about <code>let</code>, <code>match</code>, methods, associated
functions, external crates, and more! In the following chapters, we’ll explore
these ideas in more detail. In this chapter, you’ll just practice the
fundamentals.</p>
<p>让我们通过一个动手项目来快速入门 Rust！本章将通过展示如何在实际程序中使用一些常见的 Rust 概念，向你介绍这些概念。你将学习 <code>let</code>、<code>match</code>、方法、关联函数、外部包等内容！在后续章节中，我们将更详细地探讨这些概念。本章中，你只需练习基础知识。</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.</p>
<p>我们将实现一个经典的初学者编程问题：猜数游戏。规则如下：程序会生成一个 1 到 100 之间的随机整数。然后提示玩家输入猜测值。输入后，程序会提示猜测值是太小还是太大。如果猜对了，游戏将打印祝贺信息并退出。</p>
<h2 id="setting-up-a-new-project-创建新项目"><a class="header" href="#setting-up-a-new-project-创建新项目">Setting Up a New Project 创建新项目</a></h2>
<p>To set up a new project, go to the <em>projects</em> directory that you created in
Chapter 1 and make a new project using Cargo, like so:</p>
<p>要创建新项目，请进入你在第 1 章创建的 <em>projects</em> 目录，使用 Cargo 新建项目：</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project (<code>guessing_game</code>)
as the first argument. The second command changes to the new project’s
directory.</p>
<p>第一条命令 <code>cargo new</code> 将项目名 (<code>guessing_game</code>) 作为第一个参数。第二条命令切换到新项目的目录。</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p>查看生成的 <em>Cargo.toml</em> 文件：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>As you saw in Chapter 1, <code>cargo new</code> generates a “Hello, world!” program for
you. Check out the <em>src/main.rs</em> file:</p>
<p>如第 1 章所见，<code>cargo new</code> 会为你生成一个 “Hello, world!” 程序。查看 <em>src/main.rs</em> 文件：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Now let’s compile this “Hello, world!” program and run it in the same step
using the <code>cargo run</code> command:</p>
<p>现在使用 <code>cargo run</code> 命令编译并运行这个 “Hello, world!” 程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>The <code>run</code> command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.</p>
<p>当你需要快速迭代项目时（就像我们在这个游戏中所做的那样），<code>run</code> 命令非常有用，它能在进入下一次迭代前快速测试当前版本。</p>
<p>Reopen the <em>src/main.rs</em> file. You’ll be writing all the code in this file.</p>
<p>重新打开 <em>src/main.rs</em> 文件。你将在此文件中编写所有代码。</p>
<h2 id="processing-a-guess-处理猜测值"><a class="header" href="#processing-a-guess-处理猜测值">Processing a Guess 处理猜测值</a></h2>
<p>The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
<em>src/main.rs</em>.</p>
<p>猜数游戏的第一部分将请求用户输入，处理该输入，并检查输入是否符合预期格式。首先，我们允许玩家输入猜测值。将代码清单 2-1 中的代码输入 <em>src/main.rs</em>。</p>
<figure class="listing" id="listing-2-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-1">Listing 2-1</a>: Code that gets a guess from the user and prints it 获取用户输入并打印的代码</figcaption>
</figure>
<p>This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
<code>io</code> input/output library into scope. The <code>io</code> library comes from the standard
library, known as <code>std</code>:</p>
<p>这段代码包含大量信息，让我们逐行分析。为了获取用户输入并打印结果，我们需要将输入/输出库 <code>io</code> 引入作用域。<code>io</code> 库来自标准库（即 <code>std</code>）：</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>By default, Rust has a set of items defined in the standard library that it
brings into the scope of every program. This set is called the <em>prelude</em>, and
you can see everything in it in the standard library documentation.</p>
<p>默认情况下，Rust 会将标准库中预定义的一组条目引入每个程序的作用域。这组条目称为 <em>预导入（prelude）</em>，你可以在标准库文档中查看其全部内容。</p>
<p>If a type you want to use isn’t in the prelude, you have to bring that type
into scope explicitly with a <code>use</code> statement. Using the <code>std::io</code> library
provides you with a number of useful features, including the ability to accept
user input.</p>
<p>如果你想使用的类型不在预导入中，必须使用 <code>use</code> 语句显式引入作用域。使用 <code>std::io</code> 库提供了许多有用功能，包括接收用户输入的能力。</p>
<p>As you saw in Chapter 1, the <code>main</code> function is the entry point into the
program:</p>
<p>如第 1 章所述，<code>main</code> 函数是程序的入口点：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>The <code>fn</code> syntax declares a new function; the parentheses, <code>()</code>, indicate there
are no parameters; and the curly bracket, <code>{</code>, starts the body of the function.</p>
<p><code>fn</code> 语法声明新函数；括号 <code>()</code> 表示无参数；花括号 <code>{</code> 开始函数体。</p>
<p>As you also learned in Chapter 1, <code>println!</code> is a macro that prints a string to
the screen:</p>
<p>同样如第 1 章所学，<code>println!</code> 是将字符串打印到屏幕的宏：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>This code is printing a prompt stating what the game is and requesting input
from the user.</p>
<p>这段代码打印提示信息，说明游戏内容并要求用户输入。</p>
<h3 id="storing-values-with-variables-用变量存储值"><a class="header" href="#storing-values-with-variables-用变量存储值">Storing Values with Variables 用变量存储值</a></h3>
<p>Next, we’ll create a <em>variable</em> to store the user input, like this:</p>
<p>接下来，我们创建一个<strong>变量</strong>来存储用户输入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Now the program is getting interesting! There’s a lot going on in this little
line. We use the <code>let</code> statement to create the variable. Here’s another example:</p>
<p>现在程序变得有趣了！这短短一行发生了很多事情。我们使用 <code>let</code> 语句创建变量。再看另一个例子：</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>This line creates a new variable named <code>apples</code> and binds it to the value 5. In
Rust, variables are immutable by default, meaning once we give the variable a
value, the value won’t change. We’ll be discussing this concept in detail in
the “Variables and Mutability”
section in Chapter 3. To make a variable mutable, we add <code>mut</code> before the
variable name:</p>
<p>这段代码创建了一个名为 <code>apples</code> 的新变量，并将其绑定到值 <code>5</code>。在 Rust 中，变量默认是
<strong>不可变</strong>的，这意味着一旦我们给变量赋值，该值就不会改变。我们将在第 3 章的
“变量与可变性”一节详细讨论这个概念。要使变量可变，我们在变量名前添加 <code>mut</code>：</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<section class="note" aria-role="note">
<p>Note: The <code>//</code> syntax starts a comment that continues until the end of the
line. Rust ignores everything in comments. We’ll discuss comments in more
detail in Chapter 3.</p>
<p>注意：<code>//</code> 语法开始一个注释，持续到行尾。Rust 会忽略注释中的所有内容。我们将在第 3 章详细讨论注释。</p>
</section>
<p>Returning to the guessing game program, you now know that <code>let mut guess</code> will
introduce a mutable variable named <code>guess</code>. The equal sign (<code>=</code>) tells Rust we
want to bind something to the variable now. On the right of the equal sign is
the value that <code>guess</code> is bound to, which is the result of calling
<code>String::new</code>, a function that returns a new instance of a <code>String</code>.
<code>String</code> is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.</p>
<p>回到猜数游戏程序，你现在知道 <code>let mut guess</code> 将引入一个名为 <code>guess</code> 的可变变量。等号 (<code>=</code>) 告诉 Rust 现在要将某物绑定到变量。等号右边是 <code>guess</code> 绑定的值，即调用 <code>String::new</code> 的结果，该函数返回 <code>String</code> 的新实例。<code>String</code> 是标准库提供的字符串类型，是可增长的 UTF-8 编码文本。</p>
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an associated
function of the <code>String</code> type. An <em>associated function</em> is a function that’s
implemented on a type, in this case <code>String</code>. This <code>new</code> function creates a
new, empty string. You’ll find a <code>new</code> function on many types because it’s a
common name for a function that makes a new value of some kind.</p>
<p><code>::new</code> 行中的 <code>::</code> 语法表明 <code>new</code> 是 <code>String</code> 类型的<strong>关联函数</strong>。关联函数是针对类型实现的函数，此处即 <code>String</code>。这个 <code>new</code> 函数会创建新的空字符串。许多类型上都有 <code>new</code> 函数，因为它是创建某种新值的常见函数名。</p>
<p>In full, the <code>let mut guess = String::new();</code> line has created a mutable
variable that is currently bound to a new, empty instance of a <code>String</code>. Whew!</p>
<p>总结来说，<code>let mut guess = String::new();</code> 这行代码创建了一个可变变量，该变量当前绑定到一个新的空 <code>String</code> 实例。搞定！</p>
<h3 id="receiving-user-input-接收用户输入"><a class="header" href="#receiving-user-input-接收用户输入">Receiving User Input 接收用户输入</a></h3>
<p>Recall that we included the input/output functionality from the standard
library with <code>use std::io;</code> on the first line of the program. Now we’ll call
the <code>stdin</code> function from the <code>io</code> module, which will allow us to handle user
input:</p>
<p>回想一下，我们在程序第一行用 <code>use std::io;</code> 导入了标准库的输入/输出功能。现在我们将调用 <code>io</code> 模块中的 <code>stdin</code> 函数来处理用户输入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>If we hadn’t imported the <code>io</code> module with <code>use std::io;</code> at the beginning of
the program, we could still use the function by writing this function call as
<code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of
<code>std::io::Stdin</code>, which is a type that represents a
handle to the standard input for your terminal.</p>
<p>如果开头没有用 <code>use std::io;</code> 导入 <code>io</code> 模块，仍可通过 <code>std::io::stdin</code> 调用此函数。<code>stdin</code> 函数返回 <code>std::io::Stdin</code> 的实例，这是表示终端标准输入句柄的类型。</p>
<p>Next, the line <code>.read_line(&amp;mut guess)</code> calls the <code>read_line</code> method on the standard input handle to get input from the user.
We’re also passing <code>&amp;mut guess</code> as the argument to <code>read_line</code> to tell it what
string to store the user input in. The full job of <code>read_line</code> is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string’s content.</p>
<p>接下来，<code>.read_line(&amp;mut guess)</code> 行在标准输入句柄上调用 <code>read_line</code> 方法以获取用户输入。我们还将 <code>&amp;mut guess</code> 作为参数传递给 <code>read_line</code>，告诉它存储用户输入的字符串。<code>read_line</code> 的完整工作是获取用户键入到标准输入的任何内容，并将其追加到字符串中（不覆盖内容），因此我们将该字符串作为参数传递。字符串参数需要是可变的，以便方法能更改其内容。</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that, like variables, references are
immutable by default. Hence, you need to write <code>&amp;mut guess</code> rather than
<code>&amp;guess</code> to make it mutable. (Chapter 4 will explain references more
thoroughly.)</p>
<p><code>&amp;</code> 表示此参数是一个<strong>引用</strong>，它让你无需多次将数据复制到内存中，就能让代码的多个部分访问同一数据片段。引用是一个复杂特性，而 Rust 的主要优势之一就是安全且易于使用引用。要完成此程序，你无需了解太多细节。现在只需知道，与变量类似，引用默认是不可变的。因此，你需要写 <code>&amp;mut guess</code> 而非 <code>&amp;guess</code> 来使其可变。（第 4 章会更详细地解释引用。）</p>
<h3 id="handling-potential-failure-with-result-用-result-处理潜在错误"><a class="header" href="#handling-potential-failure-with-result-用-result-处理潜在错误">Handling Potential Failure with <code>Result</code> 用 <code>Result</code> 处理潜在错误</a></h3>
<p>We’re still working on this line of code. We’re now discussing a third line of
text, but note that it’s still part of a single logical line of code. The next
part is this method:</p>
<p>我们仍在处理这行代码。现在讨论第三行文本，但请注意它仍是单个逻辑代码行的一部分。下一部分是这个方法：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>We could have written this code as:</p>
<p>我们本可以将此代码写成：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>However, one long line is difficult to read, so it’s best to divide it. It’s
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the <code>.method_name()</code> syntax. Now let’s
discuss what this line does.</p>
<p>但长行难以阅读，最好拆开。使用 <code>.method_name()</code> 语法调用方法时，通常明智的做法是换行和添加空格来分隔长行。现在讨论这行代码的作用。</p>
<p>As mentioned earlier, <code>read_line</code> puts whatever the user enters into the string
we pass to it, but it also returns a <code>Result</code> value. <code>Result</code> is an <em>enumeration</em>, often called an <em>enum</em>,
which is a type that can be in one of multiple possible states. We call each
possible state a <em>variant</em>.</p>
<p>如前所述，<code>read_line</code> 将用户输入的内容放入我们传递的字符串中，但它也返回一个 <code>Result</code> 值。<code>Result</code> 是<strong>枚举（enumeration）</strong>，通常称为 <strong>enum</strong>，是一种可以处于多种可能状态之一的类型。我们将每个可能的状态称为<strong>变体（variant）</strong>。</p>
<p>Chapter 6 will cover enums in more detail. The purpose
of these <code>Result</code> types is to encode error-handling information.</p>
<p>第 6 章将更详细地介绍枚举。这些 <code>Result</code> 类型的目的是编码错误处理信息。</p>
<p><code>Result</code>’s variants are <code>Ok</code> and <code>Err</code>. The <code>Ok</code> variant indicates the
operation was successful, and it contains the successfully generated value.
The <code>Err</code> variant means the operation failed, and it contains information
about how or why the operation failed.</p>
<p><code>Result</code> 的变体是 <code>Ok</code> 和 <code>Err</code>。<code>Ok</code> 变体表示操作成功，并包含成功生成的值。<code>Err</code> 变体表示操作失败，并包含有关操作失败方式或原因的信息。</p>
<p>Values of the <code>Result</code> type, like values of any type, have methods defined on
them. An instance of <code>Result</code> has an <code>expect</code> method
that you can call. If this instance of <code>Result</code> is an <code>Err</code> value, <code>expect</code>
will cause the program to crash and display the message that you passed as an
argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>, it would
likely be the result of an error coming from the underlying operating system.
If this instance of <code>Result</code> is an <code>Ok</code> value, <code>expect</code> will take the return
value that <code>Ok</code> is holding and return just that value to you so you can use it.
In this case, that value is the number of bytes in the user’s input.</p>
<p><code>Result</code> 类型的值（如任何类型的值）都定义了方法。<code>Result</code> 实例有一个可调用的 <code>expect</code> 方法。如果此 <code>Result</code> 实例是 <code>Err</code> 值，<code>expect</code> 将导致程序崩溃并显示你作为参数传递给 <code>expect</code> 的消息。如果 <code>read_line</code> 方法返回 <code>Err</code>，很可能是因为底层操作系统错误。如果此 <code>Result</code> 实例是 <code>Ok</code> 值，<code>expect</code> 将获取 <code>Ok</code> 保存的返回值，并将该值返回给你以便使用。此时，该值是用户输入的字节数。</p>
<p>If you don’t call <code>expect</code>, the program will compile, but you’ll get a warning:</p>
<p>如果不调用 <code>expect</code>，程序会编译，但会收到警告：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warns that you haven’t used the <code>Result</code> value returned from <code>read_line</code>,
indicating that the program hasn’t handled a possible error.</p>
<p>Rust 警告你未使用 <code>read_line</code> 返回的 <code>Result</code> 值，表明程序尚未处理可能的错误。</p>
<p>The right way to suppress the warning is to actually write error-handling code,
but in our case we just want to crash this program when a problem occurs, so we
can use <code>expect</code>. You’ll learn about recovering from errors in Chapter
9.</p>
<p>消除警告的正确方法是编写错误处理代码，但在本例中，我们只希望在发生问题时让程序崩溃，因此可以使用 <code>expect</code>。你将在第 9 章学习如何从错误中恢复。</p>
<h3 id="printing-values-with-println-placeholders-用-println-占位符打印值"><a class="header" href="#printing-values-with-println-placeholders-用-println-占位符打印值">Printing Values with <code>println!</code> Placeholders 用 <code>println!</code> 占位符打印值</a></h3>
<p>Aside from the closing curly bracket, there’s only one more line to discuss in
the code so far:</p>
<p>除了右花括号外，目前代码中只有一行需要讨论：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {guess}");
<span class="boring">}</span></code></pre>
<p>This line prints the string that now contains the user’s input. The <code>{}</code> set of
curly brackets is a placeholder: think of <code>{}</code> as little crab pincers that hold
a value in place. When printing the value of a variable, the variable name can
go inside the curly brackets. When printing the result of evaluating an
expression, place empty curly brackets in the format string, then follow the
format string with a comma-separated list of expressions to print in each empty
curly bracket placeholder in the same order. Printing a variable and the result
of an expression in one call to <code>println!</code> would look like this:</p>
<p>此行打印现在包含用户输入的字符串。<code>{}</code> 花括号是一个占位符：将 <code>{}</code> 视为固定值的小蟹钳。打印变量值时，变量名可以放在花括号内。打印表达式求值结果时，在格式字符串中放置空花括号，然后按相同顺序在空花括号占位符中打印以逗号分隔的表达式列表。在单次 <code>println!</code> 调用中打印变量和表达式结果如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>This code would print <code>x = 5 and y + 2 = 12</code>.</p>
<p>此代码将打印 <code>x = 5 and y + 2 = 12</code>。</p>
<h3 id="testing-the-first-part-测试第一部分"><a class="header" href="#testing-the-first-part-测试第一部分">Testing the First Part 测试第一部分</a></h3>
<p>Let’s test the first part of the guessing game. Run it using <code>cargo run</code>:</p>
<p>让我们测试猜数游戏的第一部分。用 <code>cargo run</code> 运行它：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.</p>
<p>至此，游戏的第一部分已完成：我们从键盘获取输入并打印它。</p>
<h2 id="generating-a-secret-number-生成秘密数字"><a class="header" href="#generating-a-secret-number-生成秘密数字">Generating a Secret Number 生成秘密数字</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We’ll use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a <code>rand</code> crate with
said functionality.</p>
<p>接下来，我们需要生成一个用户将尝试猜测的秘密数字。每次秘密数字都应不同，以便游戏可重复游玩。我们将使用 1 到 100 之间的随机数，这样游戏不会太难。Rust 的标准库尚未包含随机数功能。不过，Rust 团队提供了一个具有此功能的 <code>rand</code> 包。</p>
<h3 id="using-a-crate-to-get-more-functionality-使用包获取更多功能"><a class="header" href="#using-a-crate-to-get-more-functionality-使用包获取更多功能">Using a Crate to Get More Functionality 使用包获取更多功能</a></h3>
<p>Remember that a crate is a collection of Rust source code files. The project
we’ve been building is a <em>binary crate</em>, which is an executable. The <code>rand</code>
crate is a <em>library crate</em>, which contains code that is intended to be used in
other programs and can’t be executed on its own.</p>
<p>请记住，<strong>包（crate）</strong> 是 Rust 源代码文件的集合。我们一直在构建的项目是一个<strong>二进制包（binary crate）</strong>，即可执行文件。<code>rand</code> 包是一个<strong>库包（library crate）</strong>，包含供其他程序使用的代码，本身不能执行。</p>
<p>Cargo’s coordination of external crates is where Cargo really shines. Before we
can write code that uses <code>rand</code>, we need to modify the <em>Cargo.toml</em> file to
include the <code>rand</code> crate as a dependency. Open that file now and add the
following line to the bottom, beneath the <code>[dependencies]</code> section header that
Cargo created for you. Be sure to specify <code>rand</code> exactly as we have here, with
this version number, or the code examples in this tutorial may not work:</p>
<p>Cargo 对外部包的协调是其真正亮点所在。在使用 <code>rand</code> 编写代码之前，我们需要修改 <em>Cargo.toml</em> 文件以将 <code>rand</code> 包添加为依赖项。现在打开该文件，在 Cargo 为你创建的 <code>[dependencies]</code> 部分标题下方添加以下行。请务必完全按此处指定 <code>rand</code> 和版本号，否则本教程中的代码示例可能无法工作：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of that
section that continues until another section starts. In <code>[dependencies]</code> you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the <code>rand</code> crate with the
semantic version specifier <code>0.8.5</code>. Cargo understands Semantic
Versioning (sometimes called <em>SemVer</em>), which is a
standard for writing version numbers. The specifier <code>0.8.5</code> is actually
shorthand for <code>^0.8.5</code>, which means any version that is at least 0.8.5 but
below 0.9.0.</p>
<p>在 <em>Cargo.toml</em> 文件中，标题之后的所有内容都属于该部分，直到另一部分开始。
在 <code>[dependencies]</code> 中，你告诉 Cargo 项目依赖哪些外部包以及所需的版本。
此处，我们使用语义版本说明符 <code>0.8.5</code> 指定 <code>rand</code> 包。Cargo 理解语义化版本
（有时称为 <em>SemVer</em>），这是编写版本号的标准。
<span class="highlight">[note]说明符 <code>0.8.5</code> 实际上是 <code>^0.8.5</code> 的简写，
表示至少为 0.8.5 但低于 0.9.0 的任何版本。</span></p>
<p>Cargo considers these versions to have public APIs compatible with version
0.8.5, and this specification ensures you’ll get the latest patch release that
will still compile with the code in this chapter. Any version 0.9.0 or greater
is not guaranteed to have the same API as what the following examples use.</p>
<p>Cargo 认为这些版本与 0.8.5 版本具有兼容的公共 API，此规范确保你将获得仍能编译本章代码的最新补丁版本。0.9.0 或更高版本不保证具有与以下示例相同的 API。</p>
<p>Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.</p>
<p>现在，在不更改任何代码的情况下构建项目，如代码清单 2-2 所示。</p>
<figure class="listing" id="listing-2-2">
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-2">Listing 2-2</a>: The output from running <code>cargo build</code> after adding the rand crate as a dependency 添加<code>rand</code>依赖后<code>cargo build</code>的输出</figcaption>
</figure>
<p>You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!) and different lines (depending on the operating
system), and the lines may be in a different order.</p>
<p>你可能会看到不同的版本号（但由于 SemVer，它们都与代码兼容！）和不同的行（取决于操作系统），且行的顺序可能不同。</p>
<p>When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the <em>registry</em>, which is a copy of data
from Crates.io. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>
<p>当我们包含外部依赖项时，Cargo 会从<strong>注册表（registry）</strong>（Crates.io 的数据副本）获取依赖项所需的所有内容的最新版本。Crates.io 是 Rust 生态系统中人们发布开源 Rust 项目供他人使用的地方。</p>
<p>After updating the registry, Cargo checks the <code>[dependencies]</code> section and
downloads any crates listed that aren’t already downloaded. In this case,
although we only listed <code>rand</code> as a dependency, Cargo also grabbed other crates
that <code>rand</code> depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.</p>
<p>更新注册表后，Cargo 检查 <code>[dependencies]</code> 部分并下载列出的所有尚未下载的包。本例中，尽管只列出了 <code>rand</code> 作为依赖项，但 Cargo 也获取了 <code>rand</code> 工作所需的其他包。下载包后，Rust 编译它们，然后编译项目（依赖项可用）。</p>
<p>If you immediately run <code>cargo build</code> again without making any changes, you
won’t get any output aside from the <code>Finished</code> line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your <em>Cargo.toml</em> file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.</p>
<p>如果未进行任何更改立即再次运行 <code>cargo build</code>，除了 <code>Finished</code> 行外不会有任何输出。Cargo 知道它已下载并编译了依赖项，且你未更改 <em>Cargo.toml</em> 文件中的任何内容。Cargo 也知道你未更改代码，因此也不会重新编译代码。无事可做，它直接退出。</p>
<p>If you open the <em>src/main.rs</em> file, make a trivial change, and then save it and
build again, you’ll only see two lines of output:</p>
<p>如果打开 <em>src/main.rs</em> 文件，进行微小更改，保存后再次构建，只会看到两行输出：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>These lines show that Cargo only updates the build with your tiny change to the
<em>src/main.rs</em> file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.</p>
<p>这些行显示 Cargo 仅使用你对 <em>src/main.rs</em> 文件的微小更改更新构建。依赖项未更改，因此 Cargo 知道它可以重用已下载和编译的内容。</p>
<h4 id="ensuring-reproducible-builds-with-the-cargolock-file-用-cargolock-文件确保可重现构建"><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file-用-cargolock-文件确保可重现构建">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File 用 <em>Cargo.lock</em> 文件确保可重现构建</a></h4>
<p>Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.6 of the <code>rand</code> crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the <em>Cargo.lock</em> file the first
time you run <code>cargo build</code>, so we now have this in the <em>guessing_game</em>
directory.</p>
<p>Cargo 有一种机制确保每次你或他人构建代码时都能重建相同的产物：Cargo 将仅使用你指定的依赖版本，直到你另有指示。例如，假设下周 <code>rand</code> 包的 0.8.6 版本发布，该版本包含重要的错误修复，但也包含会破坏代码的回归问题。为处理此情况，Rust 在你首次运行 <code>cargo build</code> 时创建 <em>Cargo.lock</em> 文件，因此 <em>guessing_game</em> 目录中现在有此文件。</p>
<p>When you build a project for the first time, Cargo figures out all the versions
of the dependencies that fit the criteria and then writes them to the
<em>Cargo.lock</em> file. When you build your project in the future, Cargo will see
that the <em>Cargo.lock</em> file exists and will use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at 0.8.5 until you explicitly upgrade, thanks to the <em>Cargo.lock</em> file.
Because the <em>Cargo.lock</em> file is important for reproducible builds, it’s often
checked into source control with the rest of the code in your project.</p>
<p><span class="highlight">[note]首次构建项目时，Cargo 会确定所有符合条件的依赖版本，然后将它们写入 <em>Cargo.lock</em> 文件。将来构建项目时，Cargo 将看到 <em>Cargo.lock</em> 文件存在，并使用其中指定的版本，而不再重新计算版本。这让你自动拥有可重现的构建。换句话说，由于 <em>Cargo.lock</em> 文件的存在，项目将保持在 0.8.5 版本，直到你显式升级。因为 <em>Cargo.lock</em> 文件对可重现构建很重要，它通常与项目中的其余代码一起检入源代码管理。<span></p>
<h4 id="updating-a-crate-to-get-a-new-version-更新包以获取新版本"><a class="header" href="#updating-a-crate-to-get-a-new-version-更新包以获取新版本">Updating a Crate to Get a New Version 更新包以获取新版本</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides the command <code>update</code>,
which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions
that fit your specifications in <em>Cargo.toml</em>. Cargo will then write those
versions to the <em>Cargo.lock</em> file. In this case, Cargo will only look for
versions greater than 0.8.5 and less than 0.9.0. If the <code>rand</code> crate has
released the two new versions 0.8.6 and 0.9.0, you would see the following if
you ran <code>cargo update</code>:</p>
<p><span class="highlight">[note]当你确实想更新包时，Cargo 提供了 <code>update</code> 命令</span>，该命令会忽略 <em>Cargo.lock</em> 文件，并找出 <em>Cargo.toml</em> 中符合你规范的所有最新版本。然后 Cargo 将这些版本写入 <em>Cargo.lock</em> 文件。本例中，Cargo 仅查找大于 0.8.5 且小于 0.9.0 的版本。如果 <code>rand</code> 包已发布两个新版本 0.8.6 和 0.9.0，运行 <code>cargo update</code> 会看到：</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.9.0)
</code></pre>
<p>Cargo ignores the 0.9.0 release. At this point, you would also notice a change
in your <em>Cargo.lock</em> file noting that the version of the <code>rand</code> crate you are
now using is 0.8.6. To use <code>rand</code> version 0.9.0 or any version in the 0.9.<em>x</em>
series, you’d have to update the <em>Cargo.toml</em> file to look like this instead:</p>
<p>Cargo 忽略了 0.9.0 版本。此时，你还会注意到 <em>Cargo.lock</em> 文件中的变化，表明你现在使用的 <code>rand</code> 包版本是 0.8.6。要使用 <code>rand</code> 0.9.0 或 0.9.<em>x</em> 系列的任何版本，必须将 <em>Cargo.toml</em> 文件更新为如下内容：</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>The next time you run <code>cargo build</code>, Cargo will update the registry of crates
available and reevaluate your <code>rand</code> requirements according to the new version
you have specified.</p>
<p>下次运行 <code>cargo build</code> 时，Cargo 将更新可用包的注册表，并根据你指定的新版本重新评估 <code>rand</code> 要求。</p>
<p>There’s a lot more to say about Cargo and its
ecosystem, which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.</p>
<p>关于 Cargo 及其生态系统还有很多内容，我们将在第 14 章讨论，但现在你只需了解这些。Cargo 让重用库变得非常容易，因此 Rust 开发者能够编写由多个包组成的更小项目。</p>
<h3 id="generating-a-random-number-生成随机数"><a class="header" href="#generating-a-random-number-生成随机数">Generating a Random Number 生成随机数</a></h3>
<p>Let’s start using <code>rand</code> to generate a number to guess. The next step is to
update <em>src/main.rs</em>, as shown in Listing 2-3.</p>
<p>让我们开始使用 <code>rand</code> 生成要猜测的数字。下一步是更新 <em>src/main.rs</em>，如代码清单 2-3 所示。</p>
<figure class="listing" id="listing-2-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-3">Listing 2-3</a>: Adding code to generate a random number 添加生成随机数的代码</figcaption>
</figure>
<p>First we add the line <code>use rand::Rng;</code>. The <code>Rng</code> trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.</p>
<p>首先添加行 <code>use rand::Rng;</code>。<code>Rng</code> 特性定义了随机数生成器实现的方法，该特性必须在作用域中才能使用这些方法。第 10 章将详细讨论特性。</p>
<p>Next, we’re adding two lines in the middle. In the first line, we call the
<code>rand::thread_rng</code> function that gives us the particular random number
generator we’re going to use: one that is local to the current thread of
execution and is seeded by the operating system. Then we call the <code>gen_range</code>
method on the random number generator. This method is defined by the <code>Rng</code>
trait that we brought into scope with the <code>use rand::Rng;</code> statement. The
<code>gen_range</code> method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we’re using here takes
the form <code>start..=end</code> and is inclusive on the lower and upper bounds, so we
need to specify <code>1..=100</code> to request a number between 1 and 100.</p>
<p>接下来，我们在中间添加两行。第一行调用 <code>rand::thread_rng</code> 函数，该函数提供我们将要使用的特定随机数生成器：一个植根于当前执行线程并由操作系统提供种子。然后我们在随机数生成器上调用 <code>gen_range</code> 方法。此方法由我们通过 <code>use rand::Rng;</code> 语句引入作用域的 <code>Rng</code> 特性定义。<code>gen_range</code> 方法将范围表达式作为参数，并在该范围内生成随机数。此处使用的范围表达式形式为 <code>start..=end</code>（包含下限和上限），因此需要指定 <code>1..=100</code> 来请求 1 到 100 之间的数字。</p>
<section class="note" aria-role="note">
<p>Note: You won’t just know which traits to use and which methods and functions
to call from a crate, so each crate has documentation with instructions for
using it. Another neat feature of Cargo is that running the <code>cargo doc  --open</code> command will build documentation provided by all your dependencies
locally and open it in your browser. If you’re interested in other
functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code> and
click <code>rand</code> in the sidebar on the left.</p>
<p>注意：你无法仅凭直觉知道要使用哪些特性以及从包中调用哪些方法和函数，因此每个包都有说明文档。Cargo 的另一个巧妙特性是，运行 <code>cargo doc --open</code> 命令会在本地构建所有依赖项提供的文档并在浏览器中打开。例如，如果你对 <code>rand</code> 包中的其他功能感兴趣，请运行 <code>cargo doc --open</code> 并点击左侧边栏中的 <code>rand</code>。</p>
</section>
<p>The second new line prints the secret number. This is useful while we’re
developing the program to be able to test it, but we’ll delete it from the
final version. It’s not much of a game if the program prints the answer as soon
as it starts!</p>
<p>第二行打印秘密数字。这在开发程序时很有用，但最终版本会删除它。如果程序一启动就打印答案，那就不算游戏了！</p>
<p>Try running the program a few times:</p>
<p>尝试多次运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<p>你应该得到不同的随机数，且它们都应在 1 到 100 之间。干得好！</p>
<h2 id="comparing-the-guess-to-the-secret-number-比较猜测值和秘密数字"><a class="header" href="#comparing-the-guess-to-the-secret-number-比较猜测值和秘密数字">Comparing the Guess to the Secret Number 比较猜测值和秘密数字</a></h2>
<p>Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile just yet, as we will
explain.</p>
<p>现在我们有了用户输入和随机数，可以比较它们了。此步骤如代码清单 2-4 所示。请注意，此代码暂时无法编译，我们将解释原因。</p>
<figure class="listing" id="listing-2-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-4">Listing 2-4</a>: Handling the possible return values of comparing two numbers 处理比较两个数字可能的返回值</figcaption>
</figure>
<p>First we add another <code>use</code> statement, bringing a type called
<code>std::cmp::Ordering</code> into scope from the standard library. The <code>Ordering</code> type
is another enum and has the variants <code>Less</code>, <code>Greater</code>, and <code>Equal</code>. These are
the three outcomes that are possible when you compare two values.</p>
<p>首先添加另一个 <code>use</code> 语句，将名为 <code>std::cmp::Ordering</code> 的类型从标准库引入作用域。<code>Ordering</code> 类型是另一个枚举，具有变体 <code>Less</code>、<code>Greater</code> 和 <code>Equal</code>。这是比较两个值时可能的三种结果。</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type. The
<code>cmp</code> method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing <code>guess</code> to <code>secret_number</code>. Then it returns a variant of the
<code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a
<code>match</code> expression to decide what to do next based on
which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values
in <code>guess</code> and <code>secret_number</code>.</p>
<p>然后我们在底部添加五行使用 <code>Ordering</code> 类型的代码。<code>cmp</code> 方法比较两个值，可在任何可比较对象上调用。它接受一个引用作为参数：此处将 <code>guess</code> 与 <code>secret_number</code> 比较。然后返回我们通过 <code>use</code> 语句引入作用域的 <code>Ordering</code> 枚举变体。我们使用 <code>match</code> 表达式根据调用 <code>cmp</code> 返回的 <code>Ordering</code> 变体决定下一步操作（参数为 <code>guess</code> 和 <code>secret_number</code> 的值）。</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> to
match against, and the code that should be run if the value given to <code>match</code>
fits that arm’s pattern. Rust takes the value given to <code>match</code> and looks
through each arm’s pattern in turn. Patterns and the <code>match</code> construct are
powerful Rust features: they let you express a variety of situations your code
might encounter and they make sure you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 19, respectively.</p>
<p><code>match</code> 表达式由<strong>分支（arms）</strong> 组成。分支包含要匹配的<strong>模式（pattern）</strong>，以及当 <code>match</code> 的值符合该分支模式时应运行的代码。Rust 获取给 <code>match</code> 的值，并依次检查每个分支的模式。模式和 <code>match</code> 结构是 Rust 的强大特性：它们让你表达代码可能遇到的各种情况，并确保你处理所有情况。这些特性将在第 6 章和第 19 章分别详细讨论。</p>
<p>Let’s walk through an example with the <code>match</code> expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is 38.</p>
<p>让我们通过此处的 <code>match</code> 表达式走一遍示例。假设用户猜了 50，而本次随机生成的秘密数字是 38。</p>
<p>When the code compares 50 to 38, the <code>cmp</code> method will return
<code>Ordering::Greater</code> because 50 is greater than 38. The <code>match</code> expression gets
the <code>Ordering::Greater</code> value and starts checking each arm’s pattern. It looks
at the first arm’s pattern, <code>Ordering::Less</code>, and sees that the value
<code>Ordering::Greater</code> does not match <code>Ordering::Less</code>, so it ignores the code in
that arm and moves to the next arm. The next arm’s pattern is
<code>Ordering::Greater</code>, which <em>does</em> match <code>Ordering::Greater</code>! The associated
code in that arm will execute and print <code>Too big!</code> to the screen. The <code>match</code>
expression ends after the first successful match, so it won’t look at the last
arm in this scenario.</p>
<p>当代码比较 50 和 38 时，<code>cmp</code> 方法将返回 <code>Ordering::Greater</code>，因为 50 大于 38。
<code>match</code> 表达式获取 <code>Ordering::Greater</code> 值并开始检查每个分支的模式。它查看第一个分支的模
式 <code>Ordering::Less</code>，发现值 <code>Ordering::Greater</code> 不匹配 <code>Ordering::Less</code>，因此忽略
该分支的代码并移至下一个分支。下一个分支的模式是 <code>Ordering::Greater</code>，它<strong>确实</strong>匹配
<code>Ordering::Greater</code>！该分支的关联代码将执行并在屏幕上打印 <code>Too big!</code>。<code>match</code> 表达式在
第一次成功匹配后结束，因此在此情况下不会查看最后一个分支。</p>
<p>However, the code in Listing 2-4 won’t compile yet. Let’s try it:</p>
<p>但是，代码清单 2-4 中的代码目前无法编译。让我们尝试一下：</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>The core of the error states that there are <em>mismatched types</em>. Rust has a
strong, static type system. However, it also has type inference. When we wrote
<code>let mut guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be
a <code>String</code> and didn’t make us write the type. The <code>secret_number</code>, on the other
hand, is a number type. A few of Rust’s number types can have a value between 1
and 100: <code>i32</code>, a 32-bit number; <code>u32</code>, an unsigned 32-bit number; <code>i64</code>, a
64-bit number; as well as others. Unless otherwise specified, Rust defaults to
an <code>i32</code>, which is the type of <code>secret_number</code> unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.</p>
<p>错误的核心是存在<strong>类型不匹配</strong>。Rust 具有强大的静态类型系统。但它也有类型推断。当我们写 <code>let mut guess = String::new()</code> 时，Rust 能够推断 <code>guess</code> 应为 <code>String</code>，无需我们写出类型。而 <code>secret_number</code> 是数字类型。Rust 的几种数字类型可具有 1 到 100 之间的值：<code>i32</code>（32 位数字）、<code>u32</code>（无符号 32 位数字）、<code>i64</code>（64 位数字）等。除非另有指定，Rust 默认为 <code>i32</code>，即 <code>secret_number</code> 的类型（除非在其他地方添加类型信息导致 Rust 推断出不同的数值类型）。错误原因是 Rust 无法比较字符串和数字类型。</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a
number type so we can compare it numerically to the secret number. We do so by
adding this line to the <code>main</code> function body:</p>
<p>最终，我们希望将程序读取的输入 <code>String</code> 转换为数字类型，以便与秘密数字进行数值比较。通过将此行添加到 <code>main</code> 函数体来实现：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>The line is:</p>
<p>该行代码是：</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>We create a variable named <code>guess</code>. But wait, doesn’t the program already have
a variable named <code>guess</code>? It does, but helpfully Rust allows us to shadow the
previous value of <code>guess</code> with a new one. <em>Shadowing</em> lets us reuse the <code>guess</code>
variable name rather than forcing us to create two unique variables, such as
<code>guess_str</code> and <code>guess</code>, for example. We’ll cover this in more detail in
Chapter 3, but for now, know that this feature is
often used when you want to convert a value from one type to another type.</p>
<p>我们创建名为 <code>guess</code> 的变量。但等等，程序不是已有一个名为 <code>guess</code> 的变量吗？确实有，但 Rust 允许我们<strong>遮蔽（shadow）</strong> <code>guess</code> 的先前值。遮蔽让我们可以重用 <code>guess</code> 变量名，而不必创建两个唯一变量（例如 <code>guess_str</code> 和 <code>guess</code>）。我们将在第 3 章详细介绍此特性，但现在只需知道，当你希望将值从一种类型转换为另一种类型时，通常会使用此特性。</p>
<p>We bind this new variable to the expression <code>guess.trim().parse()</code>. The <code>guess</code>
in the expression refers to the original <code>guess</code> variable that contained the
input as a string. The <code>trim</code> method on a <code>String</code> instance will eliminate any
whitespace at the beginning and end, which we must do before we can convert the
string to a <code>u32</code>, which can only contain numerical data. The user must press
<kbd>enter</kbd> to satisfy <code>read_line</code> and input their guess, which adds a
newline character to the string. For example, if the user types <kbd>5</kbd> and
presses <kbd>enter</kbd>, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents
“newline.” (On Windows, pressing <kbd>enter</kbd> results in a carriage return
and a newline, <code>\r\n</code>.) The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>, resulting
in just <code>5</code>.</p>
<p>我们将这个新变量绑定到表达式 <code>guess.trim().parse()</code>。表达式中的 <code>guess</code> 指的是原始的 <code>guess</code> 变量（包含字符串形式的输入）。<code>String</code> 实例上的 <code>trim</code> 方法将消除开头和结尾的任何空白，我们必须先执行此操作才能将字符串转换为 <code>u32</code>（只能包含数字数据）。用户必须按 <kbd>enter</kbd> 键来满足 <code>read_line</code> 并输入猜测值，这会在字符串中添加换行符。例如，如果用户键入 <kbd>5</kbd> 并按 <kbd>enter</kbd>，<code>guess</code> 看起来像这样：<code>5\n</code>。<code>\n</code> 表示“换行”。（在 Windows 上，按 <kbd>enter</kbd> 会产生回车符和换行符 <code>\r\n</code>。）<code>trim</code> 方法会消除 <code>\n</code> 或 <code>\r\n</code>，仅留下 <code>5</code>。</p>
<p>The <code>parse</code> method on strings converts a string to
another type. Here, we use it to convert from a string to a number. We need to
tell Rust the exact number type we want by using <code>let guess: u32</code>. The colon
(<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust has a
few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit integer.
It’s a good default choice for a small positive number. You’ll learn about
other number types in Chapter 3.</p>
<p>字符串上的 <code>parse</code> 方法将字符串转换为另一种类型。此处，我们用它从字符串转换为数字。我们需要使用 <code>let guess: u32</code> 告诉 Rust 所需的数字类型。<code>guess</code> 后的冒号 (<code>:</code>) 告诉 Rust 我们将注解变量类型。Rust 有一些内置的数字类型；此处看到的 <code>u32</code> 是无符号 32 位整数。对于小的正数来说，这是一个不错的选择。你将在第 3 章了解其他数字类型。</p>
<p>Additionally, the <code>u32</code> annotation in this example program and the comparison
with <code>secret_number</code> means Rust will infer that <code>secret_number</code> should be a
<code>u32</code> as well. So now the comparison will be between two values of the same
type!</p>
<p>此外，本例中的 <code>u32</code> 注解以及与 <code>secret_number</code> 的比较意味着 Rust 将推断 <code>secret_number</code> 也应为 <code>u32</code>。因此现在比较将在两个相同类型的值之间进行！</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained <code>A👍%</code>, there would be no way to convert that to a number. Because it
might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code>
method does (discussed earlier in “Handling Potential Failure with
<code>Result</code>”). We’ll treat
this <code>Result</code> the same way by using the <code>expect</code> method again. If <code>parse</code>
returns an <code>Err</code> <code>Result</code> variant because it couldn’t create a number from the
string, the <code>expect</code> call will crash the game and print the message we give it.
If <code>parse</code> can successfully convert the string to a number, it will return the
<code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the number that we want from
the <code>Ok</code> value.</p>
<p><code>parse</code> 方法仅适用于逻辑上可转换为数字的字符，因此很容易出错。例如，如果字符串包含 <code>A👍%</code>，则无法将其转换为数字。因为它可能失败，<code>parse</code> 方法返回 <code>Result</code> 类型（类似于前面讨论的 <code>read_line</code> 方法）。我们将以相同方式处理此 <code>Result</code>：再次使用 <code>expect</code> 方法。如果 <code>parse</code> 因无法从字符串创建数字而返回 <code>Err</code> <code>Result</code> 变体，<code>expect</code> 调用将使游戏崩溃并打印我们给它的消息。如果 <code>parse</code> 成功将字符串转换为数字，它将返回 <code>Result</code> 的 <code>Ok</code> 变体，而 <code>expect</code> 将从 <code>Ok</code> 值中返回我们想要的数字。</p>
<p>Let’s run the program now:</p>
<p>现在运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.</p>
<p>很好！即使猜测值前添加了空格，程序仍能识别用户猜的是 76。多次运行程序以验证不同输入的行为：正确猜出数字、猜得太大和猜得太小。</p>
<p>We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!</p>
<p>现在游戏的大部分功能已实现，但用户只能猜一次。让我们通过添加循环来改变这一点！</p>
<h2 id="allowing-multiple-guesses-with-looping-使用循环允许多次猜测"><a class="header" href="#allowing-multiple-guesses-with-looping-使用循环允许多次猜测">Allowing Multiple Guesses with Looping 使用循环允许多次猜测</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. We’ll add a loop to give users
more chances at guessing the number:</p>
<p><code>loop</code> 关键字创建一个无限循环。我们将添加循环以让用户有更多机会猜测数字：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>As you can see, we’ve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn’t seem like the user can quit!</p>
<p>如你所见，我们将从猜测输入提示之后的所有内容移入循环。请确保将循环内的行再缩进四个空格，然后再次运行程序。程序现在将永远要求再次猜测，这实际上引入了一个新问题：用户似乎无法退出！</p>
<p>The user could always interrupt the program by using the keyboard shortcut
<kbd>ctrl</kbd>-<kbd>c</kbd>. But there’s another way to escape this insatiable
monster, as mentioned in the <code>parse</code> discussion in “Comparing the Guess to the
Secret Number”: if
the user enters a non-number answer, the program will crash. We can take
advantage of that to allow the user to quit, as shown here:</p>
<p>用户总是可以通过键盘快捷键 <kbd>ctrl</kbd>-<kbd>c</kbd> 中断程序。但还有另一种方法逃离这
个贪得无厌的怪物，正如在“比较猜测值和秘密数字”中 <code>parse</code> 讨论所提到的：如果用户输入非数字答案，程序将崩溃。我们可以利用这一点允许用户退出，如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Typing <code>quit</code> will quit the game, but as you’ll notice, so will entering any
other non-number input. This is suboptimal, to say the least; we want the game
to also stop when the correct number is guessed.</p>
<p>输入 <code>quit</code> 会退出游戏，但你会注意到，输入任何其他非数字输入也是如此。这充其量只是次优解；我们希望游戏在猜对数字时也停止。</p>
<h3 id="quitting-after-a-correct-guess-猜对后退出"><a class="header" href="#quitting-after-a-correct-guess-猜对后退出">Quitting After a Correct Guess 猜对后退出</a></h3>
<p>Let’s program the game to quit when the user wins by adding a <code>break</code> statement:</p>
<p>让我们通过添加 <code>break</code> 语句来让游戏在用户获胜时退出：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>Adding the <code>break</code> line after <code>You win!</code> makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of <code>main</code>.</p>
<p>在 <code>You win!</code> 后添加 <code>break</code> 行，使程序在用户猜对秘密数字时退出循环。退出循环也意味着退出程序，因为循环是 <code>main</code> 的最后一部分。</p>
<h3 id="handling-invalid-input-处理无效输入"><a class="header" href="#handling-invalid-input-处理无效输入">Handling Invalid Input 处理无效输入</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where <code>guess</code>
is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<p>为了进一步完善游戏行为，我们不让程序在用户输入非数字时崩溃，而是忽略非数字以便用户可以继续猜测。我们可以通过更改将 <code>guess</code> 从 <code>String</code> 转换为 <code>u32</code> 的行来实现，如代码清单 2-5 所示。</p>
<figure class="listing" id="listing-2-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-5">Listing 2-5</a>: Ignoring a non-number guess and asking for another guess instead of crashing the program 忽略非数字的猜测，让用户输入另一个猜测而不是让程序崩溃</figcaption>
</figure>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing
on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code>
type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We’re using
a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code>
method.</p>
<p>我们将 <code>expect</code> 调用替换为 <code>match</code> 表达式，以从崩溃错误转为处理错误。请记住，<code>parse</code> 返回 <code>Result</code> 类型，而 <code>Result</code> 是具有 <code>Ok</code> 和 <code>Err</code> 变体的枚举。我们在此处使用 <code>match</code> 表达式（就像处理 <code>cmp</code> 方法的 <code>Ordering</code> 结果一样）。</p>
<p>If <code>parse</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resultant number. That <code>Ok</code> value will
match the first arm’s pattern, and the <code>match</code> expression will just return the
<code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it in the new <code>guess</code> variable we’re creating.</p>
<p>如果 <code>parse</code> 能成功将字符串转换为数字，它将返回包含结果数字的 <code>Ok</code> 值。该 <code>Ok</code> 值将匹配第一个分支的模式，<code>match</code> 表达式将仅返回 <code>parse</code> 生成并放入 <code>Ok</code> 值中的 <code>num</code> 值。该数字最终将出现在我们创建的新 <code>guess</code> 变量中。</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does
match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a
catch-all value; in this example, we’re saying we want to match all <code>Err</code>
values, no matter what information they have inside them. So the program will
execute the second arm’s code, <code>continue</code>, which tells the program to go to the
next iteration of the <code>loop</code> and ask for another guess. So, effectively, the
program ignores all errors that <code>parse</code> might encounter!</p>
<p>如果 <code>parse</code> <strong>无法</strong>将字符串转换为数字，它将返回包含有关错误更多信息的 <code>Err</code> 值。<code>Err</code> 值与第一个 <code>match</code> 分支中的 <code>Ok(num)</code> 模式不匹配，但它与第二个分支中的 <code>Err(_)</code> 模式匹配。下划线 <code>_</code> 是通配符值；此例中，我们希望匹配所有 <code>Err</code> 值，无论它们内部有何信息。因此程序将执行第二个分支的代码 <code>continue</code>，这告诉程序进入循环的下一次迭代并要求再次猜测。因此，程序实际上忽略了 <code>parse</code> 可能遇到的所有错误！</p>
<p>Now everything in the program should work as expected. Let’s try it:</p>
<p>现在程序中的所有内容都应如预期工作。让我们试试：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the <code>println!</code> that outputs the
secret number. Listing 2-6 shows the final code.</p>
<p>太棒了！再做一个微小的最终调整，我们将完成猜数游戏。回想一下，程序仍在打印秘密数字。这对测试很有效，但它破坏了游戏。让我们删除输出秘密数字的 <code>println!</code>。代码清单 2-6 展示了最终代码。</p>
<figure class="listing" id="listing-2-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<figcaption><a href="ch02-00-guessing-game-tutorial.html#listing-2-6">Listing 2-6</a>: Complete guessing game code 猜数游戏的完整代码</figcaption>
</figure>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>至此，你已成功构建了猜数游戏。恭喜！</p>
<h2 id="summary-总结-1"><a class="header" href="#summary-总结-1">Summary 总结</a></h2>
<p>This project was a hands-on way to introduce you to many new Rust concepts:
<code>let</code>, <code>match</code>, functions, the use of external crates, and more. In the next
few chapters, you’ll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.</p>
<p>本项目通过实践向你介绍了许多新的 Rust 概念：<code>let</code>、<code>match</code>、函数、外部包的使用等。在接下来的几章中，你将更详细地学习这些概念。第 3 章涵盖大多数编程语言共有的概念（如变量、数据类型和函数），并展示如何在 Rust 中使用它们。第 4 章探讨所有权（Rust 区别于其他语言的特性）。第 5 章讨论结构体和方法语法，第 6 章解释枚举的工作原理。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts-通用编程概念"><a class="header" href="#common-programming-concepts-通用编程概念">Common Programming Concepts 通用编程概念</a></h1>
<p>This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.</p>
<p>本章介绍几乎所有编程语言都存在的概念及其在 Rust 中的实现方式。许多编程语言在核心上有很多共同点。本章所述概念并非 Rust 独有，但我们将结合 Rust 的特性进行讨论，并解释使用这些概念的相关惯例。</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.</p>
<p>具体而言，你将学习变量、基本类型、函数、注释和控制流。这些基础要素存在于每个 Rust 程序中，尽早掌握它们将为你奠定坚实的起步基础。</p>
<section class="note" aria-role="note">
<h4 id="keywords-关键字"><a class="header" href="#keywords-关键字">Keywords 关键字</a></h4>
<p>The Rust language has a set of <em>keywords</em> that are reserved for use by the
language only, much as in other languages. Keep in mind that you cannot use
these words as names of variables or functions. Most of the keywords have
special meanings, and you’ll be using them to do various tasks in your Rust
programs; a few have no current functionality associated with them but have
been reserved for functionality that might be added to Rust in the future. You
can find a list of the keywords in Appendix A.</p>
<p>Rust 语言拥有一组<strong>关键字</strong>，这些词汇与其他语言类似，专门保留给语言本身使用。请注意不能将这些关键字用作变量名或函数名。大多数关键字具有特殊含义，你将在 Rust 程序中用它们执行各种任务；少数关键字当前虽未关联具体功能，但保留用于未来可能添加到 Rust 的特性。关键字列表详见附录 A。</p>
</section><div style="break-before: page; page-break-before: always;"></div><h2 id="variables-and-mutability-变量与可变性"><a class="header" href="#variables-and-mutability-变量与可变性">Variables and Mutability 变量与可变性</a></h2>
<p>As mentioned in the “Storing Values with
Variables” section, by default,
variables are immutable. This is one of many nudges Rust gives you to write
your code in a way that takes advantage of the safety and easy concurrency that
Rust offers. However, you still have the option to make your variables mutable.
Let’s explore how and why Rust encourages you to favor immutability and why
sometimes you might want to opt out.</p>
<p>如“使用变量存储值”章节所述，变量默认是不可变的。这是 Rust 引导你充分利用其安全性和简易并发特性编写代码的方式之一。不过，你仍然可以选择让变量可变。让我们探讨 Rust 为何鼓励你优先使用不可变性，以及何时可能需要选择可变性。</p>
<p>When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, generate a new project called <em>variables</em> in
your <em>projects</em> directory by using <code>cargo new variables</code>.</p>
<p>当变量不可变时，一旦值绑定到名称上，就无法更改该值。为了说明这一点，请在 <em>projects</em> 目录下使用 <code>cargo new variables</code> 生成一个名为 <em>variables</em> 的新项目。</p>
<p>Then, in your new <em>variables</em> directory, open <em>src/main.rs</em> and replace its
code with the following code, which won’t compile just yet:</p>
<p>接着，在新的 <em>variables</em> 目录中，打开 <em>src/main.rs</em> 并将其代码替换为以下代码（这段代码暂时无法编译）：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre>
<p>Save and run the program using <code>cargo run</code>. You should receive an error message
regarding an immutability error, as shown in this output:</p>
<p>保存并使用 <code>cargo run</code> 运行程序。你会收到关于不可变性的错误信息，如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but really they only mean your program
isn’t safely doing what you want it to do yet; they do <em>not</em> mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.</p>
<p>此例展示了编译器如何帮助你发现程序中的错误。编译错误可能令人沮丧，但它们仅意味着你的程序尚未安全地执行预期操作，而<strong>绝不</strong>意味着你不是优秀的程序员！经验丰富的 Rust 开发者也会遇到编译错误。</p>
<p>You received the error message <code>cannot assign twice to immutable variable `x`</code> because you tried to assign a second value to the immutable <code>x</code> variable.</p>
<p>错误信息 <code>cannot assign twice to immutable variable `x`</code> 的出现，是因为你尝试为不可变的 <code>x</code> 变量赋予第二个值。</p>
<p>It’s important that we get compile-time errors when we attempt to change a
value that’s designated as immutable because this very situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, it’s possible
that the first part of the code won’t do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only <em>sometimes</em>. The Rust
compiler guarantees that when you state that a value won’t change, it really
won’t change, so you don’t have to keep track of it yourself. Your code is thus
easier to reason through.</p>
<p>当我们尝试更改标记为不可变的值时，获得编译时错误至关重要，因为这种情况可能导致 bug。如果代码的某部分基于值永不改变的假设运行，而另一部分却更改了该值，那么第一部分代码可能无法按预期执行。这类 bug 的根源在事后往往难以追踪，特别是当第二段代码<strong>偶尔</strong>才更改值时。Rust 编译器保证：当你声明一个值不会改变时，它就确实不会改变，因此你无需自行跟踪状态。这样你的代码逻辑会更清晰。</p>
<p>But mutability can be very useful, and can make code more convenient to write.
Although variables are immutable by default, you can make them mutable by
adding <code>mut</code> in front of the variable name as you did in Chapter
2. Adding <code>mut</code> also conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable’s value.</p>
<p>但可变性非常实用，它能让代码编写更便捷。虽然变量默认不可变，你可以像第 2 章那样在变量名前添加 <code>mut</code> 使其可变。添加 <code>mut</code> 还能向未来的代码阅读者表明：其他部分的代码将会更改此变量的值。</p>
<p>For example, let’s change <em>src/main.rs</em> to the following:</p>
<p>例如，将 <em>src/main.rs</em> 修改如下：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>When we run the program now, we get this:</p>
<p>现在运行程序，将得到：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>We’re allowed to change the value bound to <code>x</code> from <code>5</code> to <code>6</code> when <code>mut</code> is
used. Ultimately, deciding whether to use mutability or not is up to you and
depends on what you think is clearest in that particular situation.</p>
<p>当使用 <code>mut</code> 时，我们允许将绑定到 <code>x</code> 的值从 <code>5</code> 改为 <code>6</code>。最终是否使用可变性取决于你，需根据具体场景选择最清晰的方式。</p>
<h3 id="constants-常量"><a class="header" href="#constants-常量">Constants 常量</a></h3>
<p>Like immutable variables, <em>constants</em> are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.</p>
<p>与不可变变量类似，<strong>常量</strong>也是绑定到名称且不允许更改的值，但常量与变量存在几点区别。</p>
<p>First, you aren’t allowed to use <code>mut</code> with constants. Constants aren’t just
immutable by default—they’re always immutable. You declare constants using the
<code>const</code> keyword instead of the <code>let</code> keyword, and the type of the value <em>must</em>
be annotated. We’ll cover types and type annotations in the next section,
“Data Types”, so don’t worry about the details
right now. Just know that you must always annotate the type.</p>
<p>首先，常量不能使用 <code>mut</code>。常量不仅是默认不可变——它们始终不可变。使用 <code>const</code> 关键字而非 <code>let</code> 声明常量，且<strong>必须</strong>标注值的类型。类型与类型标注将在下一节“数据类型”中介绍，现在无需深究细节，只需记住必须始终标注类型。</p>
<p>Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.</p>
<p>常量可在任何作用域声明（包括全局作用域），这使得它们非常适合需要被多部分代码知晓的值。</p>
<p>The last difference is that constants may be set only to a constant expression,
not the result of a value that could only be computed at runtime.</p>
<p>最后一点区别是：<span class="highlight">[note]常量只能设置为常量表达式，不能是运行时才能计算结果的表达式。</span></p>
<p>Here’s an example of a constant declaration:</p>
<p>以下是常量声明的示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>The constant’s name is <code>THREE_HOURS_IN_SECONDS</code> and its value is set to the
result of multiplying 60 (the number of seconds in a minute) by 60 (the number
of minutes in an hour) by 3 (the number of hours we want to count in this
program). Rust’s naming convention for constants is to use all uppercase with
underscores between words. The compiler is able to evaluate a limited set of
operations at compile time, which lets us choose to write out this value in a
way that’s easier to understand and verify, rather than setting this constant
to the value 10,800. See the Rust Reference’s section on constant
evaluation for more information on what operations can be used
when declaring constants.</p>
<p>常量名为 <code>THREE_HOURS_IN_SECONDS</code>，其值设置为 60（每分钟秒数）乘以 60（每小时分钟数）再乘以 3（本程序要计算的小时数）的结果。Rust 的常量命名规范是使用全大写字母并用下划线分隔单词。编译器能在编译时执行有限的操作运算，这让我们可以用更易理解和验证的方式写出此值（而非直接设为 10800）。有关常量声明中可使用的操作，请参阅《Rust 参考手册》的常量求值章节。</p>
<p>Constants are valid for the entire time a program runs, within the scope in
which they were declared. This property makes constants useful for values in
your application domain that multiple parts of the program might need to know
about, such as the maximum number of points any player of a game is allowed to
earn, or the speed of light.</p>
<p>常量在声明的作用域内于整个程序运行期间有效。这一特性使常量非常适合表示程序中多部分需要知晓的应用领域值，例如游戏玩家允许获得的最高分数，或光速。</p>
<p>Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.</p>
<p>将程序中硬编码的值命名为常量，有助于向未来的代码维护者传达值的含义。若将来需要更新硬编码值，这也确保只需在代码中的一个位置修改。</p>
<h3 id="shadowing-变量遮蔽"><a class="header" href="#shadowing-变量遮蔽">Shadowing 变量遮蔽</a></h3>
<p>As you saw in the guessing game tutorial in Chapter
2, you can declare a
new variable with the same name as a previous variable. Rustaceans say that the
first variable is <em>shadowed</em> by the second, which means that the second
variable is what the compiler will see when you use the name of the variable.
In effect, the second variable overshadows the first, taking any uses of the
variable name to itself until either it itself is shadowed or the scope ends.
We can shadow a variable by using the same variable’s name and repeating the
use of the <code>let</code> keyword as follows:</p>
<p>如第 2 章猜谜游戏教程所示，你可以声明与先前变量同名的新变量。Rust 开发者称第一个变量被第二个变量<strong>遮蔽</strong>，意味着编译器在使用该变量名时将看到第二个变量。实际上，第二个变量会覆盖第一个，直到它自身被遮蔽或其作用域结束。我们可以通过重复使用 <code>let</code> 关键字来遮蔽变量：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it creates a new variable
<code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the
value of <code>x</code> is then <code>6</code>. Then, within an inner scope created with the curly
brackets, the third <code>let</code> statement also shadows <code>x</code> and creates a new
variable, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>.
When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code>.
When we run this program, it will output the following:</p>
<p>此程序首先将 <code>x</code> 绑定到值 <code>5</code>。然后通过重复 <code>let x =</code> 创建新变量 <code>x</code>，取原值加 <code>1</code>，此时 <code>x</code> 值为 <code>6</code>。接着在用花括号创建的内部作用域中，第三条 <code>let</code> 语句再次遮蔽 <code>x</code> 并创建新变量，将前值乘以 <code>2</code> 使 <code>x</code> 变为 <code>12</code>。该作用域结束后，内部遮蔽终止，<code>x</code> 恢复为 <code>6</code>。运行此程序将输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>Shadowing is different from marking a variable as <code>mut</code> because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the <code>let</code> keyword. By using <code>let</code>, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.</p>
<p>遮蔽与将变量标记为 <code>mut</code> 不同：若不使用 <code>let</code> 而尝试重新赋值，将导致编译时错误。通过 <code>let</code>，我们可以对值进行多次转换，并在转换完成后保持变量不可变。</p>
<p>The other difference between <code>mut</code> and shadowing is that because we’re
effectively creating a new variable when we use the <code>let</code> keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, and then we want to store that input as a number:</p>
<p><code>mut</code> 与遮蔽的另一区别是：重新使用 <code>let</code> 关键字会创建新变量，因此可更改值的类型但重用同名。例如，当程序让用户输入空格字符来指定文本间距，随后需将输入存储为数字：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>The first <code>spaces</code> variable is a string type and the second <code>spaces</code> variable
is a number type. Shadowing thus spares us from having to come up with
different names, such as <code>spaces_str</code> and <code>spaces_num</code>; instead, we can reuse
the simpler <code>spaces</code> name. However, if we try to use <code>mut</code> for this, as shown
here, we’ll get a compile-time error:</p>
<p>第一个 <code>spaces</code> 变量是字符串类型，第二个 <code>spaces</code> 变量是数字类型。遮蔽使我们无需构思不同名称（如 <code>spaces_str</code> 和 <code>spaces_num</code>），可直接复用更简洁的 <code>spaces</code>。但若尝试用 <code>mut</code> 实现，则会导致编译错误：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>The error says we’re not allowed to mutate a variable’s type:</p>
<p>错误信息指出禁止更改变量的类型：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Now that we’ve explored how variables work, let’s look at more data types they
can have.</p>
<p>现在我们已经探索了变量的工作机制，接下来看看它们能使用的更多数据类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="data-types-数据类型"><a class="header" href="#data-types-数据类型">Data Types 数据类型</a></h2>
<p>Every value in Rust is of a certain <em>data type</em>, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.</p>
<p>Rust 中的每个值都属于特定的<strong>数据类型</strong>，这告诉 Rust 被指定的是何种数据，从而让其知道如何处理这些数据。我们将研究两种数据类型子集：标量类型和复合类型。</p>
<p>Keep in mind that Rust is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a <code>String</code> to a numeric
type using <code>parse</code> in the “Comparing the Guess to the Secret
Number” section in
Chapter 2, we must add a type annotation, like this:</p>
<p>请记住 Rust 是<strong>静态类型</strong>语言，这意味着它必须在编译时知道所有变量的类型。编译器通常能根据值及其使用方式推断出我们想使用的类型。但在多种类型都可能的情况下（例如在第 2 章的“将猜测值与秘密数字比较”部分使用 <code>parse</code> 将 <code>String</code> 转换为数字类型时），我们必须添加类型标注，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p>If we don’t add the <code>: u32</code> type annotation shown in the preceding code, Rust
will display the following error, which means the compiler needs more
information from us to know which type we want to use:</p>
<p>如果我们不添加如上所示的 <code>: u32</code> 类型标注，Rust 会显示以下错误，这意味着编译器需要更多信息来确定我们想使用的类型：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<p>对于其他数据类型，你会看到不同的类型标注。</p>
<h3 id="scalar-types-标量类型"><a class="header" href="#scalar-types-标量类型">Scalar Types 标量类型</a></h3>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.</p>
<p><strong>标量</strong>类型表示单个值。Rust 有四种基本标量类型：整数、浮点数、布尔值和字符。你可能在其他编程语言中见过它们。让我们深入了解它们在 Rust 中的工作方式。</p>
<h4 id="integer-types-整数类型"><a class="header" href="#integer-types-整数类型">Integer Types 整数类型</a></h4>
<p>An <em>integer</em> is a number without a fractional component. We used one integer
type in Chapter 2, the <code>u32</code> type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with <code>i</code> instead of <code>u</code>) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. We can use any of these variants to declare
the type of an integer value.</p>
<p><strong>整数</strong>是没有小数部分的数字。我们在第 2 章使用过一种整数类型 <code>u32</code>。该类型声明表明其关联值应为无符号整数（有符号整数类型以 <code>i</code> 开头而非 <code>u</code>），占用 32 位空间。表 3-1 展示了 Rust 内置的整数类型。我们可以使用其中任意变体声明整数值的类型。</p>
<p><span class="caption">Table 3-1: Integer Types in Rust. Rust 中的整数类型</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>架构相关</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Each variant can be either signed or unsigned and has an explicit size.
<em>Signed</em> and <em>unsigned</em> refer to whether it’s possible for the number to be
negative—in other words, whether the number needs to have a sign with it
(signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using two’s complement representation.</p>
<p>每种变体可以是有符号或无符号的，并有明确的大小。<strong>有符号</strong>和<strong>无符号</strong>表示数字是否可以取负值——换句话说，数字是否需要带符号（有符号），或者是否永远为正因而无需符号表示（无符号）。这类似于在纸上书写数字：当符号重要时，数字会显示加号或减号；但当可安全假定数字为正数时，则不显示符号。有符号数以二进制补码形式存储。</p>
<p>Each signed variant can store numbers from −(2<sup>n − 1</sup>) to 2<sup>n −
1</sup> − 1 inclusive, where <em>n</em> is the number of bits that variant uses. So an
<code>i8</code> can store numbers from −(2<sup>7</sup>) to 2<sup>7</sup> − 1, which equals
−128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> − 1,
so a <code>u8</code> can store numbers from 0 to 2<sup>8</sup> − 1, which equals 0 to 255.</p>
<p>每个有符号变体能存储从 -(2<sup>n − 1</sup>) 到 2<sup>n − 1</sup> − 1（含）范围内的数字，其中 <em>n</em> 是该变体使用的位数。因此 <code>i8</code> 可存储从 -(2<sup>7</sup>) 到 2<sup>7</sup> − 1 的数字，即 -128 到 127。无符号变体能存储从 0 到 2<sup>n</sup> − 1 的数字，因此 <code>u8</code> 可存储 0 到 2<sup>8</sup> − 1 的数字，即 0 到 255。</p>
<p>Additionally, the <code>isize</code> and <code>usize</code> types depend on the architecture of the
computer your program is running on: 64 bits if you’re on a 64-bit architecture
and 32 bits if you’re on a 32-bit architecture.</p>
<p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行计算机的架构：在 64 位架构上是 64 位，在 32 位架构上是 32 位。</p>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as <code>57u8</code>, to designate the type. Number literals can also use <code>_</code> as a
visual separator to make the number easier to read, such as <code>1_000</code>, which will
have the same value as if you had specified <code>1000</code>.</p>
<p>你可以按表 3-2 所示的任意形式书写整数字面值。注意可为多种数字类型的数字字面值允许类型后缀（如 <code>57u8</code>）来指定类型。数字字面值也可使用 <code>_</code> 作为视觉分隔符使数字更易读，例如 <code>1_000</code> 的值与指定 <code>1000</code> 相同。</p>
<p><span class="caption">Table 3-2: Integer Literals in Rust. Rust 中的整数字面值</span></p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good places to start: integer types default to <code>i32</code>.
The primary situation in which you’d use <code>isize</code> or <code>usize</code> is when indexing
some sort of collection.</p>
<p><span class="highlight">[note]那么如何确定使用哪种整数类型？如果不确定，Rust 的默认值通常是良好的起点：整数类型默认为 <code>i32</code>。使用 <code>isize</code> 或 <code>usize</code> 的主要场景是索引某种集合时。</span></p>
<section class="note" aria-role="note">
<h5 id="integer-overflow-整数溢出"><a class="header" href="#integer-overflow-整数溢出">Integer Overflow 整数溢出</a></h5>
<p>Let’s say you have a variable of type <code>u8</code> that can hold values between 0
and 255. If you try to change the variable to a value outside that range, such as
256, <em>integer overflow</em> will occur, which can result in one of two behaviors.
When you’re compiling in debug mode, Rust includes checks for integer overflow
that cause your program to <em>panic</em> at runtime if this behavior occurs. Rust
uses the term <em>panicking</em> when a program exits with an error; we’ll discuss
panics in more depth in the “Unrecoverable Errors with
<code>panic!</code>” section in Chapter 9.</p>
<p>假设你有一个 <code>u8</code> 类型的变量，它能容纳 0 到 255 的值。如果尝试将其更改为超出此范围的值（例如 256），将发生<strong>整数溢出</strong>，可能导致两种行为之一。在调试模式下编译时，Rust 包含整数溢出检查，若发生此行为会导致程序在运行时<strong>恐慌</strong>。Rust 使用术语 <strong>panicking</strong> 表示程序因错误退出；我们将在第 9 章的“<code>panic!</code> 不可恢复错误”部分深入讨论恐慌。</p>
<p>When you’re compiling in release mode with the <code>--release</code> flag, Rust does
<em>not</em> include checks for integer overflow that cause panics. Instead, if
overflow occurs, Rust performs <em>two’s complement wrapping</em>. In short, values
greater than the maximum value the type can hold “wrap around” to the minimum
of the values the type can hold. In the case of a <code>u8</code>, the value 256 becomes
0, the value 257 becomes 1, and so on. The program won’t panic, but the
variable will have a value that probably isn’t what you were expecting it to
have. Relying on integer overflow’s wrapping behavior is considered an error.</p>
<p>在发布模式下使用 <code>--release</code> 标志编译时，Rust <strong>不</strong>包含导致恐慌的整数溢出检查。相反，若发生溢出，Rust 会执行<strong>二进制补码回绕</strong>。简而言之，大于类型能容纳最大值的数值会“回绕”到类型能容纳的最小值。对于 <code>u8</code>，256 变为 0，257 变为 1，依此类推。程序不会恐慌，但变量的值可能不符合预期。依赖整数溢出的回绕行为被视为错误。</p>
<p>To explicitly handle the possibility of overflow, you can use these families
of methods provided by the standard library for primitive numeric types:</p>
<p>要显式处理溢出的可能性，可以使用标准库为基本数值类型提供的以下方法族：</p>
<ul>
<li>Wrap in all modes with the <code>wrapping_*</code> methods, such as <code>wrapping_add</code>.</li>
<li>所有模式下回绕：使用 <code>wrapping_*</code> 方法，如 <code>wrapping_add</code></li>
<li>Return the <code>None</code> value if there is overflow with the <code>checked_*</code> methods.</li>
<li>溢出时返回 <code>None</code>：使用 <code>checked_*</code> 方法</li>
<li>Return the value and a Boolean indicating whether there was overflow with
the <code>overflowing_*</code> methods.</li>
<li>返回值及表示是否溢出的布尔值：使用 <code>overflowing_*</code> 方法</li>
<li>Saturate at the value’s minimum or maximum values with the <code>saturating_*</code>
methods.</li>
<li>在值的最小或最大值处饱和：使用 <code>saturating_*</code> 方法</li>
</ul>
</section>
<h4 id="floating-point-types-浮点类型"><a class="header" href="#floating-point-types-浮点类型">Floating-Point Types 浮点类型</a></h4>
<p>Rust also has two primitive types for <em>floating-point numbers</em>, which are
numbers with decimal points. Rust’s floating-point types are <code>f32</code> and <code>f64</code>,
which are 32 bits and 64 bits in size, respectively. The default type is <code>f64</code>
because on modern CPUs, it’s roughly the same speed as <code>f32</code> but is capable of
more precision. All floating-point types are signed.</p>
<p>Rust 还有两种<strong>浮点数</strong>基本类型，即带小数点的数字。Rust 的浮点类型是 <code>f32</code> 和 <code>f64</code>，大小分别为 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 上，其速度与 <code>f32</code> 大致相同但精度更高。所有浮点类型均为有符号。</p>
<p>Here’s an example that shows floating-point numbers in action:</p>
<p>以下示例展示了浮点数的实际使用：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Floating-point numbers are represented according to the IEEE-754 standard.</p>
<p>浮点数根据 IEEE-754 标准表示。</p>
<h4 id="numeric-operations-数值运算"><a class="header" href="#numeric-operations-数值运算">Numeric Operations 数值运算</a></h4>
<p>Rust supports the basic mathematical operations you’d expect for all the number
types: addition, subtraction, multiplication, division, and remainder. Integer
division truncates toward zero to the nearest integer. The following code shows
how you’d use each numeric operation in a <code>let</code> statement:</p>
<p>Rust 支持所有数字类型的基本数学运算：加、减、乘、除和取余。整数除法向零截断到最接近的整数。以下代码展示了如何在 <code>let</code> 语句中使用每种数值运算：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix
B contains a list of all operators that Rust
provides.</p>
<p>这些语句中的每个表达式都使用了数学运算符并求值为单个值，然后绑定到变量。附录 B 包含 Rust 提供的所有运算符列表。</p>
<h4 id="the-boolean-type-布尔类型"><a class="header" href="#the-boolean-type-布尔类型">The Boolean Type 布尔类型</a></h4>
<p>As in most other programming languages, a Boolean type in Rust has two possible
values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in
Rust is specified using <code>bool</code>. For example:</p>
<p>与大多数编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。布尔值的大小为一字节。在 Rust 中布尔类型使用 <code>bool</code> 指定。例如：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Rust in the “Control
Flow” section.</p>
<p>使用布尔值的主要方式是通过条件语句（如 <code>if</code> 表达式）。我们将在“控制流”部分介绍 Rust 中 <code>if</code> 表达式的工作原理。</p>
<h4 id="the-character-type-字符类型"><a class="header" href="#the-character-type-字符类型">The Character Type 字符类型</a></h4>
<p>Rust’s <code>char</code> type is the language’s most primitive alphabetic type. Here are
some examples of declaring <code>char</code> values:</p>
<p>Rust 的 <code>char</code> 类型是语言中最基本的字母类型。以下是一些声明 <code>char</code> 值的示例：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Note that we specify <code>char</code> literals with single quotes, as opposed to string
literals, which use double quotes. Rust’s <code>char</code> type is four bytes in size and
represents a Unicode scalar value, which means it can represent a lot more than
just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji;
and zero-width spaces are all valid <code>char</code> values in Rust. Unicode scalar
values range from <code>U+0000</code> to <code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive.
However, a “character” isn’t really a concept in Unicode, so your human
intuition for what a “character” is may not match up with what a <code>char</code> is in
Rust. We’ll discuss this topic in detail in “Storing UTF-8 Encoded Text with
Strings” in Chapter 8.</p>
<p>注意我们使用单引号指定 <code>char</code> 字面值，而字符串字面值使用双引号。<span class="highlight">[note]Rust 的 <code>char</code> 类型大小为四字节</span>，表示一个 Unicode 标量值，这意味着它可以表示的远不止 ASCII。重音字母、中日韩字符、表情符号和零宽空格在 Rust 中都是有效的 <code>char</code> 值。Unicode 标量值范围包含 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code>。但“字符”并非 Unicode 的真正概念，因此你对“字符”的人类直觉可能与 Rust 中的 <code>char</code> 不完全一致。我们将在第 8 章的“使用字符串存储 UTF-8 编码文本”中详细讨论此主题。</p>
<h3 id="compound-types-复合类型"><a class="header" href="#compound-types-复合类型">Compound Types 复合类型</a></h3>
<p><em>Compound types</em> can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.</p>
<p><strong>复合类型</strong>可将多个值组合为一种类型。Rust 有两种基本复合类型：元组和数组。</p>
<h4 id="the-tuple-type-元组类型"><a class="header" href="#the-tuple-type-元组类型">The Tuple Type 元组类型</a></h4>
<p>A <em>tuple</em> is a general way of grouping together a number of values with a
variety of types into one compound type. Tuples have a fixed length: once
declared, they cannot grow or shrink in size.</p>
<p><strong>元组</strong>是将多个不同类型的值组合为一种复合类型的通用方式。元组长度固定：声明后无法增长或缩短。</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<p><span class="highlight">[note]通过在括号内写入逗号分隔的值列表来创建元组。</span>元组中每个位置都有类型，且元组内不同值的类型不必相同。此示例中添加了可选类型标注：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:</p>
<p>变量 <code>tup</code> 绑定到整个元组，因为元组被视为单个复合元素。要从元组中提取单个值，可以使用模式匹配来解构元组值，如下所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em> because it breaks
the single tuple into three parts. Finally, the program prints the value of
<code>y</code>, which is <code>6.4</code>.</p>
<p>此程序首先创建元组并将其绑定到变量 <code>tup</code>，然后使用带 <code>let</code> 的模式将 <code>tup</code> 拆分为三个独立变量 <code>x</code>、<code>y</code> 和 <code>z</code>。这称为<strong>解构</strong>，因为它将单个元组拆分为三部分。最后程序打印 <code>y</code> 的值，即 <code>6.4</code>。</p>
<p>We can also access a tuple element directly by using a period (<code>.</code>) followed by
the index of the value we want to access. For example:</p>
<p>我们也可以通过句点（<code>.</code>）后接要访问值的索引来直接访问元组元素。例如：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>This program creates the tuple <code>x</code> and then accesses each element of the tuple
using their respective indices. As with most programming languages, the first
index in a tuple is 0.</p>
<p>此程序创建元组 <code>x</code>，然后使用相应索引访问元组的每个元素。与大多数编程语言一样，元组的第一个索引是 0。</p>
<p>The tuple without any values has a special name, <em>unit</em>. This value and its
corresponding type are both written <code>()</code> and represent an empty value or an
empty return type. Expressions implicitly return the unit value if they don’t
return any other value.</p>
<p>没有任何值的元组有一个特殊名称：<strong>单元</strong>。该值及其对应类型均写作 <code>()</code>，表示空值或空返回类型。如果表达式不返回任何其他值，则隐式返回单元值。</p>
<h4 id="the-array-type-数组类型"><a class="header" href="#the-array-type-数组类型">The Array Type 数组类型</a></h4>
<p>Another way to have a collection of multiple values is with an <em>array</em>. Unlike
a tuple, every element of an array must have the same type. Unlike arrays in
some other languages, arrays in Rust have a fixed length.</p>
<p>拥有多个值集合的另一种方式是使用<strong>数组</strong>。与元组不同，数组的每个元素必须具有相同类型。与其他语言中的数组不同，Rust 中的数组长度固定。</p>
<p>We write the values in an array as a comma-separated list inside square
brackets:</p>
<p><span class="highlight">[note]我们将数组中的值写作方括号内的逗号分隔列表</span>：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Arrays are useful when you want your data allocated on the stack, the same as
the other types we have seen so far, rather than the heap (we will discuss the
stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn’t
as flexible as the vector type, though. A <em>vector</em> is a similar collection type
provided by the standard library that <em>is</em> allowed to grow or shrink in size
because its contents live on the heap. If you’re unsure whether to use an array
or a vector, chances are you should use a vector. Chapter 8 discusses vectors in more detail.</p>
<p>数组在希望数据分配在栈上（与我们目前见过的其他类型相同）而非堆上时很有用（我们将在第 4 章详细讨论栈和堆），或者当你希望确保始终有固定数量的元素时。但数组不如 vector 类型灵活。<strong>vector</strong> 是标准库提供的类似集合类型，它<strong>允许</strong>增大或缩小大小，因为其内容位于堆上。如果不确定该使用数组还是 vector，很可能应该使用 vector。第 8 章将详细讨论 vector。</p>
<p>However, arrays are more useful when you know the number of elements will not
need to change. For example, if you were using the names of the month in a
program, you would probably use an array rather than a vector because you know
it will always contain 12 elements:</p>
<p>然而，当知道元素数量不需要改变时，数组更有用。例如，如果在程序中使用月份名称，可能会使用数组而非 vector，因为你知道它始终包含 12 个元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>You write an array’s type using square brackets with the type of each element,
a semicolon, and then the number of elements in the array, like so:</p>
<p><span class="highlight">[note]使用方括号指定数组类型，其中包含每个元素的类型、分号及数组元素数量</span>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>i32</code> is the type of each element. After the semicolon, the number <code>5</code>
indicates the array contains five elements.</p>
<p>这里 <code>i32</code> 是每个元素的类型。分号后的数字 <code>5</code> 表示数组包含五个元素。</p>
<p>You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:</p>
<p><span class="highlight">[note]也可以通过指定初始值后加分号，再在方括号中写数组长度来初始化每个元素相同的数组</span>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>The array named <code>a</code> will contain <code>5</code> elements that will all be set to the value
<code>3</code> initially. This is the same as writing <code>let a = [3, 3, 3, 3, 3];</code> but in a
more concise way.</p>
<p>名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，初始值均为 <code>3</code>。这等同于 <code>let a = [3, 3, 3, 3, 3];</code>，但更简洁。</p>
<h5 id="accessing-array-elements-访问数组元素"><a class="header" href="#accessing-array-elements-访问数组元素">Accessing Array Elements 访问数组元素</a></h5>
<p>An array is a single chunk of memory of a known, fixed size that can be
allocated on the stack. You can access elements of an array using indexing,
like this:</p>
<p>数组是已知固定大小的单个内存块，可分配在栈上。可以使用索引访问数组元素，如下所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>1</code> because that
is the value at index <code>[0]</code> in the array. The variable named <code>second</code> will get
the value <code>2</code> from index <code>[1]</code> in the array.</p>
<p>在此示例中，变量 <code>first</code> 将获得值 <code>1</code>，因为它是数组索引 <code>[0]</code> 处的值。变量 <code>second</code> 将从索引 <code>[1]</code> 处获得值 <code>2</code>。</p>
<h5 id="invalid-array-element-access-无效的数组元素访问"><a class="header" href="#invalid-array-element-access-无效的数组元素访问">Invalid Array Element Access 无效的数组元素访问</a></h5>
<p>Let’s see what happens if you try to access an element of an array that is past
the end of the array. Say you run this code, similar to the guessing game in
Chapter 2, to get an array index from the user:</p>
<p>让我们看看如果尝试访问超出数组末尾的元素会发生什么。假设运行此代码（类似于第 2 章的猜谜游戏）以从用户获取数组索引：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p>This code compiles successfully. If you run this code using <code>cargo run</code> and
enter <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, or <code>4</code>, the program will print out the corresponding
value at that index in the array. If you instead enter a number past the end of
the array, such as <code>10</code>, you’ll see output like this:</p>
<p>此代码编译成功。如果使用 <code>cargo run</code> 运行此代码并输入 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 或 <code>4</code>，程序将输出数组中相应索引的值。如果输入超出数组末尾的数字（例如 <code>10</code>），将看到类似输出：</p>
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The program resulted in a <em>runtime</em> error at the point of using an invalid
value in the indexing operation. The program exited with an error message and
didn’t execute the final <code>println!</code> statement. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the length,
Rust will panic. This check has to happen at runtime, especially in this case,
because the compiler can’t possibly know what value a user will enter when they
run the code later.</p>
<p>程序在使用无效值进行索引操作时发生<strong>运行时</strong>错误。程序以错误消息退出，未执行最后的 <code>println!</code> 语句。当你尝试使用索引访问元素时，Rust 会检查指定的索引是否小于数组长度。如果索引大于或等于长度，Rust 将恐慌。此检查必须在运行时进行，尤其是在这种情况下，因为编译器无法预知用户稍后运行代码时会输入什么值。</p>
<p>This is an example of Rust’s memory safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling and how you can
write readable, safe code that neither panics nor allows invalid memory access.</p>
<p>这是 Rust 内存安全原则的实际体现。在许多底层语言中，不会进行此类检查，提供错误索引时可能访问无效内存。Rust 通过立即退出而非允许内存访问和继续执行来防止此类错误。第 9 章将详细讨论 Rust 的错误处理，以及如何编写既不会恐慌也不允许无效内存访问的可读安全代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions-函数"><a class="header" href="#functions-函数">Functions 函数</a></h2>
<p>Functions are prevalent in Rust code. You’ve already seen one of the most
important functions in the language: the <code>main</code> function, which is the entry
point of many programs. You’ve also seen the <code>fn</code> keyword, which allows you to
declare new functions.</p>
<p>函数在 Rust 代码中无处不在。您已经见过这门语言中最重要的函数之一：<code>main</code> 函数，它是许多程序的入口点。您也见过 <code>fn</code> 关键字，它用于声明新函数。</p>
<p>Rust code uses <em>snake case</em> as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:</p>
<p>Rust 代码采用 <strong>蛇形命名法（snake case）</strong> 作为函数和变量名的传统风格，即所有字母小写并用下划线分隔单词。以下是一个包含函数定义示例的程序：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}</code></pre></pre>
<p>We define a function in Rust by entering <code>fn</code> followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.</p>
<p>在 Rust 中定义函数时，先输入 <code>fn</code>，后跟函数名和一对圆括号。花括号告诉编译器函数体的开始和结束位置。</p>
<p>We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because <code>another_function</code> is defined in the program, it can be
called from inside the <code>main</code> function. Note that we defined <code>another_function</code>
<em>after</em> the <code>main</code> function in the source code; we could have defined it before
as well. Rust doesn’t care where you define your functions, only that they’re
defined somewhere in a scope that can be seen by the caller.</p>
<p>我们可以通过输入函数名加圆括号来调用任何已定义的函数。由于 <code>another_function</code> 已在程序中定义，因此可以从 <code>main</code> 函数内部调用它。注意，我们在源代码中是在 <code>main</code> 函数 <strong>之后</strong> 定义的 <code>another_function</code>；当然也可以在其之前定义。Rust 不关心函数定义的位置，只要求它们在调用者可见的作用域内某处定义。</p>
<p>Let’s start a new binary project named <em>functions</em> to explore functions
further. Place the <code>another_function</code> example in <em>src/main.rs</em> and run it. You
should see the following output:</p>
<p>让我们新建一个名为 <em>functions</em> 的二进制项目来进一步探索函数。将 <code>another_function</code> 示例放入 <em>src/main.rs</em> 并运行它。您将看到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>The lines execute in the order in which they appear in the <code>main</code> function.
First the “Hello, world!” message prints, and then <code>another_function</code> is called
and its message is printed.</p>
<p>代码行按它们在 <code>main</code> 函数中出现的顺序执行。首先打印 “Hello, world!” 信息，然后调用 <code>another_function</code> 并打印其信息。</p>
<h3 id="parameters-参数"><a class="header" href="#parameters-参数">Parameters 参数</a></h3>
<p>We can define functions to have <em>parameters</em>, which are special variables that
are part of a function’s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called <em>arguments</em>, but in casual conversation, people tend to use
the words <em>parameter</em> and <em>argument</em> interchangeably for either the variables
in a function’s definition or the concrete values passed in when you call a
function.</p>
<p>我们可以定义带有 <strong>参数</strong> 的函数，参数是函数签名中的特殊变量。当函数有参数时，您可以为其提供具体的值。从技术上讲，具体的值称为 <strong>实参（arguments）</strong>，但在日常交流中，人们往往混用 <strong>参数（parameter）</strong> 和 <strong>实参（argument）</strong> 这两个词，既可指函数定义中的变量，也可指调用函数时传入的具体值。</p>
<p>In this version of <code>another_function</code> we add a parameter:</p>
<p>在这个版本的 <code>another_function</code> 中，我们添加了一个参数：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}</code></pre></pre>
<p>Try running this program; you should get the following output:</p>
<p>尝试运行此程序，您将得到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>The declaration of <code>another_function</code> has one parameter named <code>x</code>. The type of
<code>x</code> is specified as <code>i32</code>. When we pass <code>5</code> in to <code>another_function</code>, the
<code>println!</code> macro puts <code>5</code> where the pair of curly brackets containing <code>x</code> was
in the format string.</p>
<p><code>another_function</code> 的声明中有一个名为 <code>x</code> 的参数。<code>x</code> 的类型被指定为 <code>i32</code>。当我们将 <code>5</code> 传入 <code>another_function</code> 时，<code>println!</code> 宏会将 <code>5</code> 放入格式字符串中原本包含 <code>x</code> 的花括号位置。</p>
<p>In function signatures, you <em>must</em> declare the type of each parameter. This is
a deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean. The compiler is also able to give
more helpful error messages if it knows what types the function expects.</p>
<p>在函数签名中，您 <strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中的一项慎重决定：在函数定义中要求类型注解意味着编译器几乎不需要您在代码其他地方再使用类型注解来推断您的意图。如果编译器知道函数期望的类型，它还能提供更有帮助的错误信息。</p>
<p>When defining multiple parameters, separate the parameter declarations with
commas, like this:</p>
<p>定义多个参数时，用逗号分隔参数声明，如下所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}</code></pre></pre>
<p>This example creates a function named <code>print_labeled_measurement</code> with two
parameters. The first parameter is named <code>value</code> and is an <code>i32</code>. The second is
named <code>unit_label</code> and is type <code>char</code>. The function then prints text containing
both the <code>value</code> and the <code>unit_label</code>.</p>
<p>此示例创建了一个名为 <code>print_labeled_measurement</code> 的函数，它有两个参数。第一个参数名为 <code>value</code>，类型是 <code>i32</code>。第二个参数名为 <code>unit_label</code>，类型是 <code>char</code>。然后该函数打印包含 <code>value</code> 和 <code>unit_label</code> 的文本。</p>
<p>Let’s try running this code. Replace the program currently in your <em>functions</em>
project’s <em>src/main.rs</em> file with the preceding example and run it using <code>cargo  run</code>:</p>
<p>尝试运行此代码。用前面的示例替换您 <em>functions</em> 项目中 <em>src/main.rs</em> 文件的当前内容，并用 <code>cargo run</code> 运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Because we called the function with <code>5</code> as the value for <code>value</code> and <code>'h'</code> as
the value for <code>unit_label</code>, the program output contains those values.</p>
<p>因为我们调用函数时传入 <code>5</code> 作为 <code>value</code> 的值，<code>'h'</code> 作为 <code>unit_label</code> 的值，所以程序输出包含这些值。</p>
<h3 id="statements-and-expressions-语句和表达式"><a class="header" href="#statements-and-expressions-语句和表达式">Statements and Expressions 语句和表达式</a></h3>
<p>Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions we’ve covered haven’t included an ending
expression, but you have seen an expression as part of a statement. Because
Rust is an expression-based language, this is an important distinction to
understand. Other languages don’t have the same distinctions, so let’s look at
what statements and expressions are and how their differences affect the bodies
of functions.</p>
<p>函数体由一系列语句组成，可选择以表达式结尾。到目前为止，我们介绍的函数都没有以表达式结尾，但您已经见过作为语句一部分的表达式。由于 Rust 是基于表达式的语言，理解这一区别非常重要。其他语言没有这样的区别，因此我们来看看语句和表达式是什么，以及它们的差异如何影响函数体。</p>
<ul>
<li>Statements are instructions that perform some action and do not return
a value.</li>
<li><strong>语句（Statements）</strong> 是执行某些操作但不返回值的指令。</li>
<li>Expressions evaluate to a resultant value.</li>
<li><strong>表达式（Expressions）</strong> 会计算产生一个结果值。</li>
</ul>
<p>Let’s look at some examples.</p>
<p>我们来看一些例子。</p>
<p>We’ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the <code>let</code> keyword is a statement. In Listing 3-1,
<code>let y = 6;</code> is a statement.</p>
<p>实际上我们已经使用过语句和表达式。用 <code>let</code> 关键字创建变量并为其赋值是一个语句。在示例 3-1 中，<code>let y = 6;</code> 是一个语句。</p>
<figure class="listing" id="listing-3-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<figcaption><a href="ch03-03-how-functions-work.html#listing-3-1">Listing 3-1</a>: A <code>main</code> function declaration containing one statement 包含一个语句的<code>main</code>函数声明</figcaption>
</figure>
<p>Function definitions are also statements; the entire preceding example is a
statement in itself. (As we’ll see below, <em>calling</em> a function is not a
statement, though.)</p>
<p>函数定义也是语句；实际上整个前面的示例本身就是一个语句。（我们稍后会看到，<strong>调用</strong> 函数不是语句。）</p>
<p>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement
to another variable, as the following code tries to do; you’ll get an error:</p>
<p>语句不返回值。因此，您不能像下面代码尝试的那样将 <code>let</code> 语句赋值给另一个变量，否则会报错：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>When you run this program, the error you’ll get looks like this:</p>
<p>运行此程序时，您将得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>The <code>let y = 6</code> statement does not return a value, so there isn’t anything for
<code>x</code> to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value
<code>6</code>; that is not the case in Rust.</p>
<p><code>let y = 6</code> 语句没有返回值，因此 <code>x</code> 无法绑定到任何值。这与其他语言（如 C 和 Ruby）不同，在那些语言中赋值操作会返回所赋的值。在这些语言中，您可以写 <code>x = y = 6</code>，让 <code>x</code> 和 <code>y</code> 的值都为 <code>6</code>；但在 Rust 中不行。</p>
<p>Expressions evaluate to a value and make up most of the rest of the code that
you’ll write in Rust. Consider a math operation, such as <code>5 + 6</code>, which is an
expression that evaluates to the value <code>11</code>. Expressions can be part of
statements: in Listing 3-1, the <code>6</code> in the statement <code>let y = 6;</code> is an
expression that evaluates to the value <code>6</code>. Calling a function is an
expression. Calling a macro is an expression. A new scope block created with
curly brackets is an expression, for example:</p>
<p>表达式会计算出一个值，并且构成了您将在 Rust 中编写的大部分其余代码。考虑一个数学运算，例如 <code>5 + 6</code>，这是一个计算结果为 <code>11</code> 的表达式。表达式可以是语句的一部分：在示例 3-1 中，语句 <code>let y = 6;</code> 中的 <code>6</code> 就是一个计算结果为 <code>6</code> 的表达式。调用函数是一个表达式。调用宏也是一个表达式。用花括号创建的新作用域块同样是一个表达式，例如：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>This expression:</p>
<p>此表达式：</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code>
as part of the <code>let</code> statement. Note that the <code>x + 1</code> line doesn’t have a
semicolon at the end, which is unlike most of the lines you’ve seen so far.
Expressions do not include ending semicolons. If you add a semicolon to the end
of an expression, you turn it into a statement, and it will then not return a
value. Keep this in mind as you explore function return values and expressions
next.</p>
<p>是一个代码块，在此示例中计算结果为 <code>4</code>。该值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code>。请注意，<code>x + 1</code> 行末尾没有分号，这与您目前见过的大多数行不同。表达式不包含结尾的分号。如果在表达式末尾添加分号，它就变成了语句，不再返回值。在接下来探索函数返回值和表达式时，请牢记这一点。</p>
<h3 id="functions-with-return-values-带返回值的函数"><a class="header" href="#functions-with-return-values-带返回值的函数">Functions with Return Values 带返回值的函数</a></h3>
<p>Functions can return values to the code that calls them. We don’t name return
values, but we must declare their type after an arrow (<code>-&gt;</code>). In Rust, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the <code>return</code> keyword and specifying a value, but most
functions return the last expression implicitly. Here’s an example of a
function that returns a value:</p>
<p>函数可以向调用它的代码返回值。我们不为返回值命名，但必须在箭头 (<code>-&gt;</code>) 后声明其类型。在 Rust 中，函数的返回值等同于函数体块中最后一个表达式的值。您可以使用 <code>return</code> 关键字提前返回并指定值，但大多数函数隐式返回最后一个表达式。下面是一个返回值的函数示例：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}</code></pre></pre>
<p>There are no function calls, macros, or even <code>let</code> statements in the <code>five</code>
function—just the number <code>5</code> by itself. That’s a perfectly valid function in
Rust. Note that the function’s return type is specified too, as <code>-&gt; i32</code>. Try
running this code; the output should look like this:</p>
<p><code>five</code> 函数中没有函数调用、宏，甚至没有 <code>let</code> 语句——只有一个数字 <code>5</code>。这在 Rust 中是完全有效的函数。注意函数的返回类型也指定为 <code>-&gt; i32</code>。尝试运行此代码，输出如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>The <code>5</code> in <code>five</code> is the function’s return value, which is why the return type
is <code>i32</code>. Let’s examine this in more detail. There are two important bits:
first, the line <code>let x = five();</code> shows that we’re using the return value of a
function to initialize a variable. Because the function <code>five</code> returns a <code>5</code>,
that line is the same as the following:</p>
<p><code>five</code> 函数中的 <code>5</code> 是函数的返回值，因此返回类型是 <code>i32</code>。让我们更详细地分析这一点。有两个重点：首先，<code>let x = five();</code> 这一行表明我们使用函数的返回值来初始化变量。因为函数 <code>five</code> 返回 <code>5</code>，所以该行等同于：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Second, the <code>five</code> function has no parameters and defines the type of the
return value, but the body of the function is a lonely <code>5</code> with no semicolon
because it’s an expression whose value we want to return.</p>
<p>其次，<code>five</code> 函数没有参数并定义了返回值的类型，但函数体只有一个孤零零的 <code>5</code> 而没有分号，因为它是一个我们希望返回其值的表达式。</p>
<p>Let’s look at another example:</p>
<p>再看另一个例子：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Running this code will print <code>The value of x is: 6</code>. But if we place a
semicolon at the end of the line containing <code>x + 1</code>, changing it from an
expression to a statement, we’ll get an error:</p>
<p>运行此代码将打印 <code>The value of x is: 6</code>。但如果我们在包含 <code>x + 1</code> 的行尾添加分号，将其从表达式变为语句，就会出错：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>Compiling this code produces an error, as follows:</p>
<p>编译此代码会产生如下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>The main error message, <code>mismatched types</code>, reveals the core issue with this
code. The definition of the function <code>plus_one</code> says that it will return an
<code>i32</code>, but statements don’t evaluate to a value, which is expressed by <code>()</code>,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.</p>
<p>主错误信息 <code>mismatched types</code>（类型不匹配）揭示了此代码的核心问题。函数 <code>plus_one</code> 的定义表明它将返回一个 <code>i32</code>，但语句不会计算值，这由单元类型 <code>()</code> 表示。因此，没有返回任何值，这与函数定义相矛盾，导致错误。在此输出中，Rust 提供了一条可能帮助纠正此问题的信息：它建议移除分号，这将修复错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comments-注释"><a class="header" href="#comments-注释">Comments 注释</a></h2>
<p>All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave <em>comments</em> in
their source code that the compiler will ignore but people reading the source
code may find useful.</p>
<p>所有程序员都致力于编写易于理解的代码，但有时需要额外的说明。此时，程序员会在源代码中添加<strong>注释</strong>，这些内容会被编译器忽略，但对阅读源代码的人很有帮助。</p>
<p>Here’s a simple comment:</p>
<p>这是一个简单的注释示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<p>In Rust, the idiomatic comment style starts a comment with two slashes, and the
comment continues until the end of the line. For comments that extend beyond a
single line, you’ll need to include <code>//</code> on each line, like this:</p>
<p>在 Rust 中，惯用的注释风格是以双斜线开始注释，注释会持续到行尾。对于跨越多行的注释，需要在每行前添加 <code>//</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we're doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what's going on.
// 我们正在这里进行复杂操作，其冗长程度需要多行注释才能说明！
// 哇！希望这段注释能解释清楚发生了什么。
<span class="boring">}</span></code></pre></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<p>注释也可以放在代码行的末尾：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I'm feeling lucky today
}</code></pre></pre>
<p>But you’ll more often see them used in this format, with the comment on a
separate line above the code it’s annotating:</p>
<p><span class="highlight">[note]但更常见的用法是将注释单独放在被注解代码的上方</span>：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I'm feeling lucky today
    let lucky_number = 7;
}</code></pre></pre>
<p>Rust also has another kind of comment, documentation comments, which we’ll
discuss in the “Publishing a Crate to Crates.io”
section of Chapter 14.</p>
<p>Rust 还有另一种注释类型：文档注释，我们将在第 14 章的“发布 crate 到 Crates.io”章节中讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow-控制流"><a class="header" href="#control-flow-控制流">Control Flow 控制流</a></h2>
<p>The ability to run some code depending on whether a condition is <code>true</code> and to
run some code repeatedly while a condition is <code>true</code> are basic building blocks
in most programming languages. The most common constructs that let you control
the flow of execution of Rust code are <code>if</code> expressions and loops.</p>
<p>根据条件是否为 <code>true</code> 来决定是否执行某段代码，以及在条件为 <code>true</code> 时重复执行某段代码的能力，是大多数编程语言的基本组成部分。在 Rust 中控制执行流的主要结构是 <code>if</code> 表达式和循环。</p>
<h3 id="if-expressions-if-表达式"><a class="header" href="#if-expressions-if-表达式"><code>if</code> Expressions <code>if</code> 表达式</a></h3>
<p>An <code>if</code> expression allows you to branch your code depending on conditions. You
provide a condition and then state, “If this condition is met, run this block
of code. If the condition is not met, do not run this block of code.”</p>
<p><code>if</code> 表达式允许根据条件分支执行代码。你提供一个条件，然后声明：“如果满足此条件，则执行此代码块；如果不满足，则不执行此代码块。”</p>
<p>Create a new project called <em>branches</em> in your <em>projects</em> directory to explore
the <code>if</code> expression. In the <em>src/main.rs</em> file, input the following:</p>
<p>在 <em>projects</em> 目录下创建一个名为 <em>branches</em> 的新项目来探索 <code>if</code> 表达式。在 <em>src/main.rs</em> 文件中输入以下内容：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}</code></pre></pre>
<p>All <code>if</code> expressions start with the keyword <code>if</code>, followed by a condition. In
this case, the condition checks whether or not the variable <code>number</code> has a
value less than 5. We place the block of code to execute if the condition is
<code>true</code> immediately after the condition inside curly brackets. Blocks of code
associated with the conditions in <code>if</code> expressions are sometimes called <em>arms</em>,
just like the arms in <code>match</code> expressions that we discussed in the “Comparing
the Guess to the Secret Number” section of Chapter 2.</p>
<p>所有 <code>if</code> 表达式都以关键字 <code>if</code> 开头，后跟一个条件。在本例中，条件检查变量 <code>number</code> 的值是否小于 5。我们将条件为 <code>true</code> 时要执行的代码块放在条件后的大括号内。与 <code>if</code> 表达式中条件关联的代码块有时被称为 <em>分支</em>（arms），类似于第 2 章“将猜测与秘密数字比较”一节中讨论的 <code>match</code> 表达式中的分支。</p>
<p>Optionally, we can also include an <code>else</code> expression, which we chose to do
here, to give the program an alternative block of code to execute should the
condition evaluate to <code>false</code>. If you don’t provide an <code>else</code> expression and
the condition is <code>false</code>, the program will just skip the <code>if</code> block and move on
to the next bit of code.</p>
<p>我们还可以选择包含一个 <code>else</code> 表达式（这里我们选择了这样做），以便在条件为 <code>false</code> 时提供替代执行的代码块。如果不提供 <code>else</code> 表达式且条件为 <code>false</code>，程序将跳过 <code>if</code> 块并继续执行后续代码。</p>
<p>Try running this code; you should see the following output:</p>
<p>尝试运行此代码；你将看到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Let’s try changing the value of <code>number</code> to a value that makes the condition
<code>false</code> to see what happens:</p>
<p>让我们将 <code>number</code> 的值改为使条件为 <code>false</code> 的值，看看会发生什么：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("condition was true");
</span><span class="boring">    } else {
</span><span class="boring">        println!("condition was false");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Run the program again, and look at the output:</p>
<p>再次运行程序，查看输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>It’s also worth noting that the condition in this code <em>must</em> be a <code>bool</code>. If
the condition isn’t a <code>bool</code>, we’ll get an error. For example, try running the
following code:</p>
<p>另外值得注意的是，此代码中的条件<strong>必须</strong>是 <code>bool</code> 类型。如果条件不是 <code>bool</code> 类型，我们将收到错误。例如，尝试运行以下代码：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}</code></pre>
<p>The <code>if</code> condition evaluates to a value of <code>3</code> this time, and Rust throws an
error:</p>
<p>这次 <code>if</code> 条件的值为 <code>3</code>，Rust 会抛出错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>The error indicates that Rust expected a <code>bool</code> but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
<code>if</code> with a Boolean as its condition. If we want the <code>if</code> code block to run
only when a number is not equal to <code>0</code>, for example, we can change the <code>if</code>
expression to the following:</p>
<p>错误表明 Rust 期望一个 <code>bool</code> 但得到了整数。与 Ruby 和 JavaScript 等语言不同，Rust 不会自动尝试将非布尔类型转换为布尔类型。你必须明确地始终为 <code>if</code> 提供一个布尔条件。例如，如果我们希望仅当数字不等于 <code>0</code> 时才运行 <code>if</code> 代码块，可以将 <code>if</code> 表达式修改如下：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}</code></pre></pre>
<p>Running this code will print <code>number was something other than zero</code>.</p>
<p>运行此代码将打印 <code>number was something other than zero</code>。</p>
<h4 id="handling-multiple-conditions-with-else-if-使用-else-if-处理多重条件"><a class="header" href="#handling-multiple-conditions-with-else-if-使用-else-if-处理多重条件">Handling Multiple Conditions with <code>else if</code> 使用 <code>else if</code> 处理多重条件</a></h4>
<p>You can use multiple conditions by combining <code>if</code> and <code>else</code> in an <code>else if</code>
expression. For example:</p>
<p>通过组合 <code>if</code> 和 <code>else</code> 形成 <code>else if</code> 表达式，可以处理多个条件。例如：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}</code></pre></pre>
<p>This program has four possible paths it can take. After running it, you should
see the following output:</p>
<p>该程序有四种可能的执行路径。运行后，你将看到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>When this program executes, it checks each <code>if</code> expression in turn and executes
the first body for which the condition evaluates to <code>true</code>. Note that even
though 6 is divisible by 2, we don’t see the output <code>number is divisible by 2</code>,
nor do we see the <code>number is not divisible by 4, 3, or 2</code> text from the <code>else</code>
block. That’s because Rust only executes the block for the first <code>true</code>
condition, and once it finds one, it doesn’t even check the rest.</p>
<p>程序执行时，会依次检查每个 <code>if</code> 表达式，并执行第一个条件为 <code>true</code> 的分支体。注意，尽管 6 能被 2 整除，但我们既看不到输出 <code>number is divisible by 2</code>，也看不到 <code>else</code> 块中的 <code>number is not divisible by 4, 3, or 2</code> 的文本。这是因为 Rust 仅执行第一个条件为 <code>true</code> 的块，一旦找到，就不再检查其余条件。</p>
<p>Using too many <code>else if</code> expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called <code>match</code> for these cases.</p>
<p>使用过多的 <code>else if</code> 表达式会使代码混乱，因此如果有多个条件，可能需要重构代码。第 6 章将介绍 Rust 中一个强大的分支结构 <code>match</code> 来处理此类情况。</p>
<h4 id="using-if-in-a-let-statement-在-let-语句中使用-if"><a class="header" href="#using-if-in-a-let-statement-在-let-语句中使用-if">Using <code>if</code> in a <code>let</code> Statement 在 <code>let</code> 语句中使用 <code>if</code></a></h4>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code>
statement to assign the outcome to a variable, as in Listing 3-2.</p>
<p><span class="highlight">[note]因为 <code>if</code> 是一个表达式，所以我们可以将其用在 <code>let</code> 语句的右侧，将结果赋值给变量</span>，如示例 3-2 所示。</p>
<figure class="listing" id="listing-3-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}</code></pre></pre>
<figcaption><a href="ch03-05-control-flow.html#listing-3-2">Listing 3-2</a>: Assigning the result of an <code>if</code> expression to a variable 将 <code>if</code> 表达式的结果赋值给变量</figcaption>
</figure>
<p>The <code>number</code> variable will be bound to a value based on the outcome of the <code>if</code>
expression. Run this code to see what happens:</p>
<p>变量 <code>number</code> 将根据 <code>if</code> 表达式的结果绑定一个值。运行此代码查看结果：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole <code>if</code> expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the <code>if</code> must be
the same type; in Listing 3-2, the results of both the <code>if</code> arm and the <code>else</code>
arm were <code>i32</code> integers. If the types are mismatched, as in the following
example, we’ll get an error:</p>
<p>记住，代码块的值由其最后一个表达式决定，而数字本身也是表达式。在本例中，整个 <code>if</code> 表达式的值取决于执行的代码块。这意味着 <code>if</code> 的每个分支可能返回的结果值必须是相同类型；在示例 3-2 中，<code>if</code> 分支和 <code>else</code> 分支的结果都是 <code>i32</code> 整数。如果类型不匹配，如下例所示，我们将得到错误：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}</code></pre>
<p>When we try to compile this code, we’ll get an error. The <code>if</code> and <code>else</code> arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:</p>
<p>尝试编译此代码时，我们会得到一个错误。<code>if</code> 和 <code>else</code> 分支的值类型不兼容，Rust 明确指出了程序中问题所在的位置：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>The expression in the <code>if</code> block evaluates to an integer, and the expression in
the <code>else</code> block evaluates to a string. This won’t work because variables must
have a single type, and Rust needs to know at compile time what type the
<code>number</code> variable is, definitively. Knowing the type of <code>number</code> lets the
compiler verify the type is valid everywhere we use <code>number</code>. Rust wouldn’t be
able to do that if the type of <code>number</code> was only determined at runtime; the
compiler would be more complex and would make fewer guarantees about the code
if it had to keep track of multiple hypothetical types for any variable.</p>
<p><code>if</code> 块中的表达式计算为整数，而 <code>else</code> 块中的表达式计算为字符串。这是行不通的，因为变量必须有单一类型，且 Rust 需要在编译时确切知道变量 <code>number</code> 的类型。知道 <code>number</code> 的类型可以让编译器在使用 <code>number</code> 的任何地方验证类型是否有效。如果 <code>number</code> 的类型仅在运行时确定，Rust 就无法做到这一点；如果编译器必须跟踪任何变量的多种假设类型，它会变得更复杂，对代码的保证也会减少。</p>
<h3 id="repetition-with-loops-使用循环进行重复"><a class="header" href="#repetition-with-loops-使用循环进行重复">Repetition with Loops 使用循环进行重复</a></h3>
<p>It’s often useful to execute a block of code more than once. For this task,
Rust provides several <em>loops</em>, which will run through the code inside the loop
body to the end and then start immediately back at the beginning. To experiment
with loops, let’s make a new project called <em>loops</em>.</p>
<p>多次执行同一代码块通常很有用。为此，Rust 提供了几种<strong>循环</strong>（loops），它们会执行循环体中的代码直到结束，然后立即从头开始重新执行。为了试验循环，让我们创建一个名为 <em>loops</em> 的新项目。</p>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Let’s try each one.</p>
<p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。让我们逐一尝试。</p>
<h4 id="repeating-code-with-loop-使用-loop-重复执行代码"><a class="header" href="#repeating-code-with-loop-使用-loop-重复执行代码">Repeating Code with <code>loop</code> 使用 <code>loop</code> 重复执行代码</a></h4>
<p>The <code>loop</code> keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.</p>
<p><code>loop</code> 关键字告诉 Rust 重复执行一段代码，直到你显式告诉它停止。</p>
<p>As an example, change the <em>src/main.rs</em> file in your <em>loops</em> directory to look
like this:</p>
<p>例如，将 <em>loops</em> 目录中的 <em>src/main.rs</em> 文件修改如下：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("again!");
    }
}</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously
until we stop the program manually. Most terminals support the keyboard shortcut
<kbd>ctrl</kbd>-<kbd>c</kbd> to interrupt a program that is stuck in a continual
loop. Give it a try:</p>
<p>运行此程序时，我们将看到 <code>again!</code> 被重复打印，直到手动停止程序。大多数终端支持键盘快捷键 <kbd>ctrl</kbd>-<kbd>c</kbd> 来中断陷入无限循环的程序。试试看：</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed <kbd>ctrl</kbd>-<kbd>c</kbd>.</p>
<p>符号 <code>^C</code> 表示你按下 <kbd>ctrl</kbd>-<kbd>c</kbd> 的位置。</p>
<p>You may or may not see the word <code>again!</code> printed after the <code>^C</code>, depending on
where the code was in the loop when it received the interrupt signal.</p>
<p>在 <code>^C</code> 之后，你可能会也可能不会看到单词 <code>again!</code>，这取决于循环接收到中断信号时代码执行的位置。</p>
<p>Fortunately, Rust also provides a way to break out of a loop using code. You
can place the <code>break</code> keyword within the loop to tell the program when to stop
executing the loop. Recall that we did this in the guessing game in the
“Quitting After a Correct Guess” section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.</p>
<p>幸运的是，Rust 也提供了通过代码跳出循环的方法。你可以在循环中放置 <code>break</code> 关键字，告诉程序何时停止执行循环。回想一下，我们在第 2 章“在正确猜测后退出”一节的猜谜游戏中这样做了，当用户猜中正确数字赢得游戏时退出程序。</p>
<p>We also used <code>continue</code> in the guessing game, which in a loop tells the program
to skip over any remaining code in this iteration of the loop and go to the
next iteration.</p>
<p>在猜谜游戏中我们还使用了 <code>continue</code>，它在循环中告诉程序跳过本次循环中剩余的代码，直接进入下一次迭代。</p>
<h4 id="returning-values-from-loops-从循环返回值"><a class="header" href="#returning-values-from-loops-从循环返回值">Returning Values from Loops 从循环返回值</a></h4>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such
as checking whether a thread has completed its job. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the <code>break</code> expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:</p>
<p><code>loop</code> 的一个用途是重试可能失败的操作，例如检查线程是否已完成其任务。你可能还需要将该操作的结果传递到循环外部给其余代码使用。为此，你可以<span class="highlight">[note]在用于停止循环的 <code>break</code> 表达式后添加要返回的值；该值将被返回出循环</span>，以便你使用，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}</code></pre></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to
<code>0</code>. Then we declare a variable named <code>result</code> to hold the value returned from
the loop. On every iteration of the loop, we add <code>1</code> to the <code>counter</code> variable,
and then check whether the <code>counter</code> is equal to <code>10</code>. When it is, we use the
<code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a
semicolon to end the statement that assigns the value to <code>result</code>. Finally, we
print the value in <code>result</code>, which in this case is <code>20</code>.</p>
<p>在循环之前，我们声明了一个名为 <code>counter</code> 的变量并将其初始化为 <code>0</code>。然后声明一个名为 <code>result</code> 的变量来保存循环返回的值。在每次循环迭代中，我们将 <code>counter</code> 变量加 <code>1</code>，然后检查 <code>counter</code> 是否等于 <code>10</code>。当条件满足时，我们使用值 <code>counter * 2</code> 执行 <code>break</code>。循环之后，我们用分号结束赋值给 <code>result</code> 的语句。最后，我们打印 <code>result</code> 的值，本例中为 <code>20</code>。</p>
<p>You can also <code>return</code> from inside a loop. While <code>break</code> only exits the current
loop, <code>return</code> always exits the current function.</p>
<p>你也可以在循环内部使用 <code>return</code>。虽然 <code>break</code> 仅退出当前循环，但 <code>return</code> 总是退出当前函数。</p>
<h4 id="loop-labels-to-disambiguate-between-multiple-loops-循环标签消除多个循环间的歧义"><a class="header" href="#loop-labels-to-disambiguate-between-multiple-loops-循环标签消除多个循环间的歧义">Loop Labels to Disambiguate Between Multiple Loops 循环标签消除多个循环间的歧义</a></h4>
<p>If you have loops within loops, <code>break</code> and <code>continue</code> apply to the innermost
loop at that point. You can optionally specify a <em>loop label</em> on a loop that
you can then use with <code>break</code> or <code>continue</code> to specify that those keywords
apply to the labeled loop instead of the innermost loop. Loop labels must begin
with a single quote. Here’s an example with two nested loops:</p>
<p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 默认作用于最内层循环。你可以选择在循环上指定一个<strong>循环标签</strong>（loop label），然后与 <code>break</code> 或 <code>continue</code> 一起使用，以指定这些关键字应用于带标签的循环而非最内层循环。<span class="highlight">[note]循环标签必须以单引号开头</span>。下面是一个包含两个嵌套循环的示例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}</code></pre></pre>
<p>The outer loop has the label <code>'counting_up</code>, and it will count up from 0 to 2.
The inner loop without a label counts down from 10 to 9. The first <code>break</code> that
doesn’t specify a label will exit the inner loop only. The <code>break  'counting_up;</code> statement will exit the outer loop. This code prints:</p>
<p>外层循环带有标签 <code>'counting_up</code>，它将从 0 计数到 2。没有标签的内层循环从 10 倒数到 9。未指定标签的第一个 <code>break</code> 将仅退出内层循环。<code>break 'counting_up;</code> 语句将退出外层循环。此代码打印：</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="conditional-loops-with-while-使用-while-进行条件循环"><a class="header" href="#conditional-loops-with-while-使用-while-进行条件循环">Conditional Loops with <code>while</code> 使用 <code>while</code> 进行条件循环</a></h4>
<p>A program will often need to evaluate a condition within a loop. While the
condition is <code>true</code>, the loop runs. When the condition ceases to be <code>true</code>, the
program calls <code>break</code>, stopping the loop. It’s possible to implement behavior
like this using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could
try that now in a program, if you’d like. However, this pattern is so common
that Rust has a built-in language construct for it, called a <code>while</code> loop. In
Listing 3-3, we use <code>while</code> to loop the program three times, counting down each
time, and then, after the loop, print a message and exit.</p>
<p>程序通常需要在循环中评估条件。当条件为 <code>true</code> 时，循环运行；当条件不再为 <code>true</code> 时，程序调用 <code>break</code> 停止循环。你可以使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 的组合来实现这种行为；如果愿意，可以尝试在程序中实现。然而，这种模式非常常见，因此 Rust 内置了一个语言结构，称为 <code>while</code> 循环。在示例 3-3 中，我们使用 <code>while</code> 循环程序三次，每次倒计时，然后在循环后打印消息并退出。</p>
<figure class="listing" id="listing-3-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}</code></pre></pre>
<figcaption><a href="ch03-05-control-flow.html#listing-3-3">Listing 3-3</a>: Using a <code>while</code> loop to run code while a condition evaluates to <code>true</code> 使用 <code>while</code> 循环在条件为 <code>true</code> 时运行代码</figcaption>
</figure>
<p>This construct eliminates a lot of nesting that would be necessary if you used
<code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>, and it’s clearer. While a condition
evaluates to <code>true</code>, the code runs; otherwise, it exits the loop.</p>
<p>这种结构消除了使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 时可能产生的大量嵌套，使代码更清晰。当条件为 <code>true</code> 时，代码运行；否则，它退出循环。</p>
<h4 id="looping-through-a-collection-with-for-使用-for-遍历集合"><a class="header" href="#looping-through-a-collection-with-for-使用-for-遍历集合">Looping Through a Collection with <code>for</code> 使用 <code>for</code> 遍历集合</a></h4>
<p>You can choose to use the <code>while</code> construct to loop over the elements of a
collection, such as an array. For example, the loop in Listing 3-4 prints each
element in the array <code>a</code>.</p>
<p>你可以选择使用 <code>while</code> 结构来遍历集合（例如数组）的元素。例如，示例 3-4 中的循环打印数组 <code>a</code> 的每个元素。</p>
<figure class="listing" id="listing-3-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
<figcaption><a href="ch03-05-control-flow.html#listing-3-4">Listing 3-4</a>: Looping through each element of a collection using a <code>while</code> loop 使用 <code>while</code> 循环遍历集合的每个元素</figcaption>
</figure>
<p>Here, the code counts up through the elements in the array. It starts at index
<code>0</code>, and then loops until it reaches the final index in the array (that is,
when <code>index &lt; 5</code> is no longer <code>true</code>). Running this code will print every
element in the array:</p>
<p>此代码遍历数组中的元素。它从索引 <code>0</code> 开始，循环直到到达数组的最后一个索引（即当 <code>index &lt; 5</code> 不再为 <code>true</code> 时）。运行此代码将打印数组中的每个元素：</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>All five array values appear in the terminal, as expected. Even though <code>index</code>
will reach a value of <code>5</code> at some point, the loop stops executing before trying
to fetch a sixth value from the array.</p>
<p>所有五个数组值都如预期出现在终端中。即使 <code>index</code> 在某个时刻会达到值 <code>5</code>，循环也会在尝试从数组中获取第六个值之前停止执行。</p>
<p>However, this approach is error prone; we could cause the program to panic if
the index value or test condition is incorrect. For example, if you changed the
definition of the <code>a</code> array to have four elements but forgot to update the
condition to <code>while index &lt; 4</code>, the code would panic. It’s also slow, because
the compiler adds runtime code to perform the conditional check of whether the
index is within the bounds of the array on every iteration through the loop.</p>
<p>然而，这种方法容易出错；如果索引值或测试条件不正确，我们可能导致程序 panic。例如，如果将数组 <code>a</code> 的定义更改为包含四个元素，但忘记将条件更新为 <code>while index &lt; 4</code>，代码将 panic。这种方式也较慢，因为编译器在每次循环迭代时都会添加运行时代码来检查索引是否在数组边界内。</p>
<p>As a more concise alternative, you can use a <code>for</code> loop and execute some code
for each item in a collection. A <code>for</code> loop looks like the code in Listing 3-5.</p>
<p>作为更简洁的替代方案，你可以使用 <code>for</code> 循环来遍历集合并对每个元素执行代码。<code>for</code> 循环如示例 3-5 所示。</p>
<figure class="listing" id="listing-3-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}</code></pre></pre>
<figcaption><a href="ch03-05-control-flow.html#listing-3-5">Listing 3-5</a>: Looping through each element of a collection using a <code>for</code> loop 使用 <code>for</code> 循环遍历集合的每个元素</figcaption>
</figure>
<p>When we run this code, we’ll see the same output as in Listing 3-4. More
importantly, we’ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items. Machine code generated from <code>for</code>
loops can be more efficient as well, because the index doesn’t need to be
compared to the length of the array at every iteration.</p>
<p>运行此代码时，我们将看到与示例 3-4 相同的输出。更重要的是，我们现在提高了代码的安全性，并消除了因超出数组末尾或未遍历足够元素而遗漏某些项所导致的错误可能性。<code>for</code> 循环生成的机器代码也可能更高效，因为索引在每次迭代时不需要与数组长度进行比较。</p>
<p>Using the <code>for</code> loop, you wouldn’t need to remember to change any other code if
you changed the number of values in the array, as you would with the method
used in Listing 3-4.</p>
<p>使用 <code>for</code> 循环时，如果更改数组中值的数量，你不需要像示例 3-4 中的方法那样记住修改其他代码。</p>
<p>The safety and conciseness of <code>for</code> loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a <code>while</code> loop
in Listing 3-3, most Rustaceans would use a <code>for</code> loop. The way to do that
would be to use a <code>Range</code>, provided by the standard library, which generates
all numbers in sequence starting from one number and ending before another
number.</p>
<p><code>for</code> 循环的安全性和简洁性使其成为 Rust 中最常用的循环结构。即使在你需要运行代码特定次数的情况下（如示例 3-3 中使用 <code>while</code> 循环的倒计时示例），大多数 Rust 开发者也会使用 <code>for</code> 循环。实现方式是<span class="highlight">[note]使用标准库提供的 <code>Range</code>，它生成从一个数字开始到另一个数字之前结束的所有连续数字</span>。</p>
<p>Here’s what the countdown would look like using a <code>for</code> loop and another method
we’ve not yet talked about, <code>rev</code>, to reverse the range:</p>
<p>以下是使用 <code>for</code> 循环和我们尚未讨论的另一个方法 <code>rev</code>（用于反转范围）来实现的倒计时：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}</code></pre></pre>
<p>This code is a bit nicer, isn’t it?</p>
<p>这段代码更简洁，不是吗？</p>
<h2 id="summary-总结-2"><a class="header" href="#summary-总结-2">Summary 总结</a></h2>
<p>You made it! This was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, <code>if</code> expressions, and loops! To
practice with the concepts discussed in this chapter, try building programs to
do the following:</p>
<p>你做到了！这是一个相当长的章节：你学习了变量、标量和复合数据类型、函数、注释、<code>if</code> 表达式以及循环！为了练习本章讨论的概念，尝试编写程序来完成以下任务：</p>
<ul>
<li>Convert temperatures between Fahrenheit and Celsius.</li>
<li>在摄氏度和华氏度之间转换温度。</li>
<li>Generate the <em>n</em>th Fibonacci number.</li>
<li>生成第 <em>n</em> 个斐波那契数。</li>
<li>Print the lyrics to the Christmas carol “The Twelve Days of Christmas,”
taking advantage of the repetition in the song.</li>
<li>利用歌曲中的重复性，打印圣诞颂歌《圣诞节的十二天》的歌词。</li>
</ul>
<p>When you’re ready to move on, we’ll talk about a concept in Rust that <em>doesn’t</em>
commonly exist in other programming languages: ownership.</p>
<p>当你准备好继续前进时，我们将讨论 Rust 中一个<strong>不</strong>常见于其他编程语言的概念：所有权。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ownership-理解所有权"><a class="header" href="#understanding-ownership-理解所有权">Understanding Ownership 理解所有权</a></h1>
<p>Ownership is Rust’s most unique feature and has deep implications for the rest
of the language. It enables Rust to make memory safety guarantees without
needing a garbage collector, so it’s important to understand how ownership
works. In this chapter, we’ll talk about ownership as well as several related
features: borrowing, slices, and how Rust lays data out in memory.</p>
<p>所有权是 Rust 最独特的特性，对语言的其他部分有着深远的影响。它使 Rust 能够在不需要垃圾回收器的情况下保证内存安全，因此理解所有权的工作原理至关重要。在本章中，我们将讨论所有权以及几个相关特性：借用（borrowing）、切片（slices）以及 Rust 如何在内存中布局数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-ownership-什么是所有权"><a class="header" href="#what-is-ownership-什么是所有权">What Is Ownership? 什么是所有权？</a></h2>
<p><em>Ownership</em> is a set of rules that govern how a Rust program manages memory.
All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that regularly looks for no-longer-used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks. If
any of the rules are violated, the program won’t compile. None of the features
of ownership will slow down your program while it’s running.</p>
<p><strong>所有权</strong>（<em>Ownership</em>）是一套管理 Rust 程序如何管理内存的规则。所有程序在运行时都必须管理其使用计算机内存的方式。某些语言通过垃圾回收机制在程序运行时定期寻找不再使用的内存；在其他语言中，程序员必须显式分配和释放内存。Rust 采用了第三种方法：内存通过所有权系统进行管理，该系统包含一组编译器检查的规则。如果违反任何规则，程序将无法编译。所有权的特性在程序运行时不会降低其速度。</p>
<p>Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the easier you’ll find it to naturally
develop code that is safe and efficient. Keep at it!</p>
<p>由于所有权对许多程序员来说是一个新概念，确实需要一些时间来适应。好消息是，随着你对 Rust 和所有权系统规则的熟悉程度提高，你会发现自己能更自然地编写安全高效的代码。坚持学习！</p>
<p>When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.</p>
<p>当你理解了所有权，就为理解 Rust 的独特特性奠定了坚实基础。在本章中，你将通过一些专注于常见数据结构（字符串）的示例来学习所有权。</p>
<section class="note" aria-role="note">
<h3 id="the-stack-and-the-heap-栈与堆"><a class="header" href="#the-stack-and-the-heap-栈与堆">The Stack and the Heap 栈与堆</a></h3>
<p>Many programming languages don’t require you to think about the stack and the
heap very often. But in a systems programming language like Rust, whether a
value is on the stack or the heap affects how the language behaves and why
you have to make certain decisions. Parts of ownership will be described in
relation to the stack and the heap later in this chapter, so here is a brief
explanation in preparation.</p>
<p>许多编程语言不常要求你考虑栈和堆。但在像 Rust 这样的系统编程语言中，值位于栈上还是堆上会影响语言的行为以及你为何必须做出某些决策。所有权的部分内容将在本章稍后结合栈和堆进行描述，因此这里先做一个简要说明以备后续理解。</p>
<p>Both the stack and the heap are parts of memory available to your code to use
at runtime, but they are structured in different ways. The stack stores
values in the order it gets them and removes the values in the opposite
order. This is referred to as <em>last in, first out</em>. Think of a stack of
plates: when you add more plates, you put them on top of the pile, and when
you need a plate, you take one off the top. Adding or removing plates from
the middle or bottom wouldn’t work as well! Adding data is called <em>pushing
onto the stack</em>, and removing data is called <em>popping off the stack</em>. All
data stored on the stack must have a known, fixed size. Data with an unknown
size at compile time or a size that might change must be stored on the heap
instead.</p>
<p>栈和堆都是代码在运行时可以使用的内存部分，但它们的结构方式不同。栈按照获取值的顺序存储值，并按相反顺序移除值。这被称为 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一叠盘子：添加更多盘子时放在顶部，需要盘子时从顶部取走。从中间或底部添加或移除盘子效果不佳！添加数据称为 <strong>压栈</strong>（<em>pushing onto the stack</em>），移除数据称为 <strong>出栈</strong>（<em>popping off the stack</em>）。存储在栈上的所有数据必须具有已知的固定大小。编译时大小未知或大小可能变化的数据必须存储在堆上。</p>
<p>The heap is less organized: when you put data on the heap, you request a
certain amount of space. The memory allocator finds an empty spot in the heap
that is big enough, marks it as being in use, and returns a <em>pointer</em>, which
is the address of that location. This process is called <em>allocating on the
heap</em> and is sometimes abbreviated as just <em>allocating</em> (pushing values onto
the stack is not considered allocating). Because the pointer to the heap is a
known, fixed size, you can store the pointer on the stack, but when you want
the actual data, you must follow the pointer. Think of being seated at a
restaurant. When you enter, you state the number of people in your group, and
the host finds an empty table that fits everyone and leads you there. If
someone in your group comes late, they can ask where you’ve been seated to
find you.</p>
<p>堆的组织性较差：当你将数据放入堆时，会请求一定大小的空间。内存分配器在堆中找到足够大的空位，将其标记为正在使用，并返回一个 <strong>指针</strong>（<em>pointer</em>），即该位置的地址。此过程称为 <strong>在堆上分配</strong>（<em>allocating on the heap</em>），有时简称为 <strong>分配</strong>（<em>allocating</em>）（将值压入栈不被视为分配）。由于指向堆的指针是已知且固定大小的，你可以将指针存储在栈上，但当需要实际数据时，必须跟随指针。想象在餐厅入座：进入时说明人数，接待员找到合适的空桌并带你过去。如果有人迟到，他们可以询问你的位置找到你。</p>
<p>Pushing to the stack is faster than allocating on the heap because the
allocator never has to search for a place to store new data; that location is
always at the top of the stack. Comparatively, allocating space on the heap
requires more work because the allocator must first find a big enough space
to hold the data and then perform bookkeeping to prepare for the next
allocation.</p>
<p>压栈比在堆上分配更快，因为分配器无需搜索存储新数据的位置；该位置始终在栈顶。相比之下，在堆上分配空间需要更多工作，因为分配器必须先找到足够大的空间存放数据，然后执行簿记工作为下次分配做准备。</p>
<p>Accessing data in the heap is generally slower than accessing data on the
stack because you have to follow a pointer to get there. Contemporary
processors are faster if they jump around less in memory. Continuing the
analogy, consider a server at a restaurant taking orders from many tables.
It’s most efficient to get all the orders at one table before moving on to
the next table. Taking an order from table A, then an order from table B,
then one from A again, and then one from B again would be a much slower
process. By the same token, a processor can usually do its job better if it
works on data that’s close to other data (as it is on the stack) rather than
farther away (as it can be on the heap).</p>
<p>访问堆中的数据通常比访问栈中数据慢，因为必须跟随指针。当代处理器在内存中跳跃越少，速度越快。延续类比：餐厅服务员从多桌接收点单。最有效的方式是在移动到下一桌之前获取完一桌的所有订单。从 A 桌点单，然后 B 桌，再回到 A 桌，再到 B 桌，这将是一个慢得多的过程。同理，处理器处理彼此靠近的数据（如在栈上）通常比处理较远的数据（如在堆上）效果更好。</p>
<p>When your code calls a function, the values passed into the function
(including, potentially, pointers to data on the heap) and the function’s
local variables get pushed onto the stack. When the function is over, those
values get popped off the stack.</p>
<p>当代码调用函数时，传入函数的值（可能包括指向堆数据的指针）和函数的局部变量会被压入栈。函数结束时，这些值会出栈。</p>
<p>Keeping track of what parts of code are using what data on the heap,
minimizing the amount of duplicate data on the heap, and cleaning up unused
data on the heap so you don’t run out of space are all problems that ownership
addresses. Once you understand ownership, you won’t need to think about the
stack and the heap very often, but knowing that the main purpose of ownership
is to manage heap data can help explain why it works the way it does.</p>
<p>跟踪代码的哪些部分在使用堆上的哪些数据、最小化堆上的重复数据量以及清理堆上未使用的数据以免空间耗尽，这些都是所有权要解决的问题。一旦理解了所有权，就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据有助于理解其工作方式。</p>
</section>
<h3 id="ownership-rules-所有权规则"><a class="header" href="#ownership-rules-所有权规则">Ownership Rules 所有权规则</a></h3>
<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:</p>
<p>首先，我们来看所有权规则。在阅读说明这些规则的示例时，请牢记这些规则：</p>
<ul>
<li>Each value in Rust has an <em>owner</em>.</li>
<li>Rust 中的每个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>There can only be one owner at a time.</li>
<li>同一时间只能有一个所有者。</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
<li>当所有者离开作用域时，该值将被丢弃。</li>
</ul>
<h3 id="variable-scope-变量作用域"><a class="header" href="#variable-scope-变量作用域">Variable Scope 变量作用域</a></h3>
<p>Now that we’re past basic Rust syntax, we won’t include all the <code>fn main() {</code>
code in examples, so if you’re following along, make sure to put the following
examples inside a <code>main</code> function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.</p>
<p>现在我们已经掌握了 Rust 的基本语法，示例中将不再包含所有 <code>fn main() {</code> 代码，因此如果你要动手操作，请确保手动将以下示例放入 <code>main</code> 函数中。这样我们的示例会更简洁，让我们专注于实际细节而非样板代码。</p>
<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Take the
following variable:</p>
<p>作为所有权的第一个示例，我们将观察一些变量的<strong>作用域</strong>（<em>scope</em>）。作用域是程序中一个项目有效的范围。以下面的变量为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>The variable <code>s</code> refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 4-1 shows a
program with comments annotating where the variable <code>s</code> would be valid.</p>
<p>变量 <code>s</code> 引用了一个字符串字面值，其值被硬编码到程序文本中。该变量从声明点开始有效，直到当前<strong>作用域</strong>结束。代码清单 4-1 展示了一个程序，其中注释标明了变量 <code>s</code> 的有效范围。</p>
<figure class="listing" id="listing-4-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, since it's not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch04-01-what-is-ownership.html#listing-4-1">Listing 4-1</a>: A variable and the scope in which it is valid 一个变量及其有效的作用域</figcaption>
</figure>
<p>In other words, there are two important points in time here:</p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>When <code>s</code> comes <em>into</em> scope, it is valid.</li>
<li>当 <code>s</code> <strong>进入</strong>作用域时，它有效。</li>
<li>It remains valid until it goes <em>out of</em> scope.</li>
<li>它持续有效，直到<strong>离开</strong>作用域。</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the <code>String</code> type.</p>
<p>此时，作用域和变量有效性之间的关系与其他编程语言类似。现在我们将通过引入 <code>String</code> 类型在此理解基础上展开。</p>
<h3 id="the-string-type-string-类型"><a class="header" href="#the-string-type-string-类型">The <code>String</code> Type <code>String</code> 类型</a></h3>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than those we covered in the “Data Types” section
of Chapter 3. The types covered previously are of a known size, can be stored
on the stack and popped off the stack when their scope is over, and can be
quickly and trivially copied to make a new, independent instance if another
part of code needs to use the same value in a different scope. But we want to
look at data that is stored on the heap and explore how Rust knows when to
clean up that data, and the <code>String</code> type is a great example.</p>
<p>为了说明所有权规则，我们需要一个比第 3 章“数据类型”部分所涉及更复杂的数据类型。之前介绍的类型大小已知，可以存储在栈上并在作用域结束时弹出，如果代码的其他部分需要在不同作用域中使用相同的值，可以快速简单地复制以创建新的独立实例。但我们希望查看存储在堆上的数据，并探索 Rust 如何知道何时清理这些数据，而 <code>String</code> 类型就是一个很好的例子。</p>
<p>We’ll concentrate on the parts of <code>String</code> that relate to ownership. These
aspects also apply to other complex data types, whether they are provided by
the standard library or created by you. We’ll discuss <code>String</code> in more depth in
Chapter 8.</p>
<p>我们将专注于与所有权相关的 <code>String</code> 部分。这些方面也适用于其他复杂数据类型，无论是标准库提供的还是你创建的。我们将在第 8 章更深入地讨论 <code>String</code>。</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, <code>String</code>. This type manages
data allocated on the heap and as such is able to store an amount of text that
is unknown to us at compile time. You can create a <code>String</code> from a string
literal using the <code>from</code> function, like so:</p>
<p>我们已经见过字符串字面值，其值被硬编码到程序中。字符串字面值很方便，但并不适用于所有需要使用文本的场景。原因之一是它们不可变。另一个原因是我们编写代码时无法知道所有字符串值：例如，如果我们想获取用户输入并存储呢？对于这些情况，Rust 提供了第二种字符串类型 <code>String</code>。此类型管理在堆上分配的数据，因此能够存储编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值创建 <code>String</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>The double colon <code>::</code> operator allows us to namespace this particular <code>from</code>
function under the <code>String</code> type rather than using some sort of name like
<code>string_from</code>. We’ll discuss this syntax more in the “Method
Syntax” section of Chapter 5, and when we talk
about namespacing with modules in “Paths for Referring to an Item in the
Module Tree” in Chapter 7.</p>
<p>双冒号 <code>::</code> 运算符允许我们将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间下，而不是使用类似 <code>string_from</code> 的名称。我们将在第 5 章的“方法语法”部分讨论此语法，并在第 7 章的“模块树中引用项目的路径”部分讨论模块命名空间。</p>
<p>This kind of string <em>can</em> be mutated:</p>
<p>这种字符串<strong>可以</strong>被改变：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // this will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>So, what’s the difference here? Why can <code>String</code> be mutated but literals
cannot? The difference is in how these two types deal with memory.</p>
<p>那么，这里的区别是什么？为什么 <code>String</code> 可被改变而字面值不能？区别在于这两种类型处理内存的方式。</p>
<h3 id="memory-and-allocation-内存与分配"><a class="header" href="#memory-and-allocation-内存与分配">Memory and Allocation 内存与分配</a></h3>
<p>In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.</p>
<p>对于字符串字面值，我们在编译时就知道其内容，因此文本直接硬编码到最终可执行文件中。这就是字符串字面值快速高效的原因。但这些特性仅源于字符串字面值的不可变性。不幸的是，我们无法在二进制文件中为每一段编译时大小未知或运行时大小可能变化的文本放入一块内存。</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:</p>
<p>对于 <code>String</code> 类型，为了支持可变的、可增长的文本片段，我们需要在堆上分配一块编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>The memory must be requested from the memory allocator at runtime.</li>
<li>必须在运行时向内存分配器请求内存。</li>
<li>We need a way of returning this memory to the allocator when we’re done with
our <code>String</code>.</li>
<li>当使用完 <code>String</code> 时，需要一种方式将此内存返回给分配器。</li>
</ul>
<p>That first part is done by us: when we call <code>String::from</code>, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.</p>
<p>第一部分由我们完成：调用 <code>String::from</code> 时，其实现会请求所需内存。这在编程语言中几乎是通用的。</p>
<p>However, the second part is different. In languages with a <em>garbage collector
(GC)</em>, the GC keeps track of and cleans up memory that isn’t being used
anymore, and we don’t need to think about it. In most languages without a GC,
it’s our responsibility to identify when memory is no longer being used and to
call code to explicitly free it, just as we did to request it. Doing this
correctly has historically been a difficult programming problem. If we forget,
we’ll waste memory. If we do it too early, we’ll have an invalid variable. If
we do it twice, that’s a bug too. We need to pair exactly one <code>allocate</code> with
exactly one <code>free</code>.</p>
<p>然而，第二部分不同。在有<strong>垃圾回收器（GC）</strong>（<em>garbage collector (GC)</em>）的语言中，GC 会跟踪并清理不再使用的内存，我们无需关心。在没有 GC 的大多数语言中，我们有责任识别内存何时不再使用并调用代码显式释放它，就像我们请求时那样。历史上，正确执行此操作一直是个难题。如果忘记释放，会浪费内存；过早释放，会产生无效变量；重复释放，同样是个错误。我们需要精确地一次 <code>allocate</code> 配对一次 <code>free</code>。</p>
<p>Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a <code>String</code> instead of a string literal:</p>
<p>Rust 选择了不同的路径：一旦拥有内存的变量离开作用域，内存就会自动返回。以下是使用 <code>String</code> 替代字符串字面值的代码清单 4-1 的作用域示例变体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}</span></code></pre></pre>
<p>There is a natural point at which we can return the memory our <code>String</code> needs
to the allocator: when <code>s</code> goes out of scope. When a variable goes out of
scope, Rust calls a special function for us. This function is called
<code>drop</code>, and it’s where the author of <code>String</code> can put
the code to return the memory. Rust calls <code>drop</code> automatically at the closing
curly bracket.</p>
<p>这里有一个自然的时机可以将 <code>String</code> 所需的内存返回给分配器：当 <code>s</code> 离开作用域时。当变量离开作用域时，Rust 会为我们调用一个特殊的函数。此函数名为 <code>drop</code>，<code>String</code> 的作者可以在此放置返回内存的代码。Rust 在右花括号处自动调用 <code>drop</code>。</p>
<section class="note" aria-role="note">
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s
lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>.
The <code>drop</code> function in Rust will be familiar to you if you’ve used RAII
patterns.</p>
<p>注意：<span class="highlight">[note]在 C++ 中，这种在项目生命周期结束时释放资源的模式有时称为 <strong>资源获取即初始化（RAII）</strong>。</span>如果你使用过 RAII 模式，Rust 中的 <code>drop</code> 函数会让你感到熟悉。</p>
</section>
<p>This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.</p>
<p>这种模式对 Rust 代码的编写方式有着深远影响。现在看起来简单，但在更复杂的情况下（当我们希望多个变量使用堆上分配的数据时），代码的行为可能出乎意料。现在让我们探讨其中一些情况。</p>
<h4 id="variables-and-data-interacting-with-move-变量与数据的交互移动move"><a class="header" href="#variables-and-data-interacting-with-move-变量与数据的交互移动move">Variables and Data Interacting with Move 变量与数据的交互：移动（Move）</a></h4>
<p>Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.</p>
<p>在 Rust 中，多个变量可以通过不同方式与同一数据交互。让我们看一个使用整数的示例（部分如代码清单 4-2 所示）。</p>
<figure class="listing" id="listing-4-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch04-01-what-is-ownership.html#listing-4-2">Listing 4-2</a>: Assigning the integer value of variable <code>x</code> to <code>y</code> 将变量 <code>x</code> 的整数值赋给 <code>y</code></figcaption>
</figure>
<p>We can probably guess what this is doing: “bind the value <code>5</code> to <code>x</code>; then make
a copy of the value in <code>x</code> and bind it to <code>y</code>.” We now have two variables, <code>x</code>
and <code>y</code>, and both equal <code>5</code>. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two <code>5</code> values are pushed
onto the stack.</p>
<p>我们可能猜到它的作用：“将值 <code>5</code> 绑定到 <code>x</code>；然后复制 <code>x</code> 中的值并绑定到 <code>y</code>。”现在有两个变量 <code>x</code> 和 <code>y</code>，都等于 <code>5</code>。确实如此，因为整数是具有已知固定大小的简单值，这两个 <code>5</code> 值都被压入栈。</p>
<p>Now let’s look at the <code>String</code> version:</p>
<p>现在来看 <code>String</code> 版本：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>This looks very similar, so we might assume that the way it works would be the
same: that is, the second line would make a copy of the value in <code>s1</code> and bind
it to <code>s2</code>. But this isn’t quite what happens.</p>
<p>这看起来非常相似，因此我们可能认为其工作方式相同：即第二行复制 <code>s1</code> 中的值并绑定到 <code>s2</code>。但实际并非如此。</p>
<p>Take a look at Figure 4-1 to see what is happening to <code>String</code> under the
covers. A <code>String</code> is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.</p>
<p>查看图 4-1 了解底层 <code>String</code> 的情况。<code>String</code> 由三部分组成，如左侧所示：指向存放字符串内容内存的指针、长度和容量。这组数据存储在栈上。右侧是存放内容的堆内存。</p>
<img alt="" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representation in memory of a <code>String</code>
holding the value <code>"hello"</code> bound to <code>s1</code> 绑定到 <code>s1</code> 的持有值 <code>"hello"</code> 的 <code>String</code> 在内存中的表示</span></p>
<p>The length is how much memory, in bytes, the contents of the <code>String</code> are
currently using. The capacity is the total amount of memory, in bytes, that the
<code>String</code> has received from the allocator. The difference between length and
capacity matters, but not in this context, so for now, it’s fine to ignore the
capacity.</p>
<p>长度是 <code>String</code> 内容当前使用的内存量（字节）。容量是 <code>String</code> 从分配器获得的总内存量（字节）。长度和容量的区别很重要，但在此上下文中无关，目前可以忽略容量。</p>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.</p>
<p>当我们将 <code>s1</code> 赋给 <code>s2</code> 时，会复制 <code>String</code> 数据，即复制栈上的指针、长度和容量。我们不会复制指针所指向的堆上数据。换句话说，内存中的数据表示如图 4-2 所示。</p>
<img alt="" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representation in memory of the variable <code>s2</code>
that has a copy of the pointer, length, and capacity of <code>s1</code> 拥有 <code>s1</code> 指针、长度和容量副本的变量 <code>s2</code> 在内存中的表示</span></p>
<p>The representation does <em>not</em> look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation <code>s2 = s1</code> could be very expensive in terms of runtime performance if
the data on the heap were large.</p>
<p>其表示<strong>并非</strong>图 4-3 所示（如果 Rust 同时复制堆数据，内存会呈现此状态）。如果 Rust 这样做，当堆数据很大时，操作 <code>s2 = s1</code> 的运行时性能成本会非常高。</p>
<img alt="" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Another possibility for what <code>s2 = s1</code> might
do if Rust copied the heap data as well 如果 Rust 同时复制堆数据，<code>s2 = s1</code> 可能的另一种行为</span></p>
<p>Earlier, we said that when a variable goes out of scope, Rust automatically
calls the <code>drop</code> function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the
same memory. This is known as a <em>double free</em> error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.</p>
<p>之前提到，当变量离开作用域时，Rust 会自动调用 <code>drop</code> 函数清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一位置。这会带来问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域时，它们都会尝试释放相同的内存。这称为<strong>二次释放</strong>（<em>double free</em>）错误，是之前提到的内存安全问题之一。重复释放内存可能导致内存损坏，进而可能引发安全漏洞。</p>
<p>To ensure memory safety, after the line <code>let s2 = s1;</code>, Rust considers <code>s1</code> as
no longer valid. Therefore, Rust doesn’t need to free anything when <code>s1</code> goes
out of scope. Check out what happens when you try to use <code>s1</code> after <code>s2</code> is
created; it won’t work:</p>
<p>为确保内存安全，在 <code>let s2 = s1;</code> 之后，Rust 认为 <code>s1</code> 不再有效。因此，当 <code>s1</code> 离开作用域时，Rust 无需释放任何内容。尝试在创建 <code>s2</code> 后使用 <code>s1</code> 会发生什么？它将无法工作：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>You’ll get an error like this because Rust prevents you from using the
invalidated reference:</p>
<p>你会收到类似错误，因为 Rust 阻止你使用无效引用：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a <em>move</em>. In this example, we would say that <code>s1</code>
was <em>moved</em> into <code>s2</code>. So, what actually happens is shown in Figure 4-4.</p>
<p>如果你在使用其他语言时听说过<strong>浅拷贝</strong>（<em>shallow copy</em>）和<strong>深拷贝</strong>（<em>deep copy</em>），复制指针、长度和容量而不复制数据的概念可能听起来像是浅拷贝。但由于 Rust 同时使第一个变量无效，它被称为<strong>移动</strong>（<em>move</em>）而非浅拷贝。在此示例中，我们说 <code>s1</code> 被<strong>移动</strong>（<em>moved</em>）到了 <code>s2</code> 中。实际发生的情况如图 4-4 所示。</p>
<img alt="" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: Representation in memory after <code>s1</code> has been
invalidated <code>s1</code> 失效后的内存表示</span></p>
<p>That solves our problem! With only <code>s2</code> valid, when it goes out of scope it
alone will free the memory, and we’re done.</p>
<p>这解决了我们的问题！只有 <code>s2</code> 有效，当其离开作用域时，它会单独释放内存，问题解决。</p>
<p>In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any <em>automatic</em>
copying can be assumed to be inexpensive in terms of runtime performance.</p>
<p>此外，这隐含了一个设计选择：Rust 永远不会自动创建数据的“深”拷贝。因此，任何<strong>自动</strong>复制在运行时性能上都可以认为是低成本的。</p>
<h4 id="scope-and-assignment-作用域与赋值"><a class="header" href="#scope-and-assignment-作用域与赋值">Scope and Assignment 作用域与赋值</a></h4>
<p>The inverse of this is true for the relationship between scoping, ownership, and
memory being freed via the <code>drop</code> function as well. When you assign a completely
new value to an existing variable, Rust will call <code>drop</code> and free the original
value’s memory immediately. Consider this code, for example:</p>
<p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系，其逆命题同样成立。当你为现有变量分配一个全新的值时，Rust 会立即调用 <code>drop</code> 并释放原值的内存。例如考虑以下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>We initially declare a variable <code>s</code> and bind it to a <code>String</code> with the value
<code>"hello"</code>. Then we immediately create a new <code>String</code> with the value <code>"ahoy"</code> and
assign it to <code>s</code>. At this point, nothing is referring to the original value on
the heap at all.</p>
<p>我们最初声明变量 <code>s</code> 并将其绑定到值为 <code>"hello"</code> 的 <code>String</code>。然后我们立即创建一个值为 <code>"ahoy"</code> 的新 <code>String</code> 并将其赋给 <code>s</code>。此时，没有任何东西引用堆上的原始值。</p>
<img alt="" src="img/trpl04-05.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-5: Representation in memory after the initial
value has been replaced in its entirety. 初始值被完全替换后的内存表示</span></p>
<p>The original string thus immediately goes out of scope. Rust will run the <code>drop</code>
function on it and its memory will be freed right away. When we print the value
at the end, it will be <code>"ahoy, world!"</code>.</p>
<p>因此原始字符串立即离开作用域。Rust 将对其运行 <code>drop</code> 函数，其内存将立即被释放。当我们最后打印值时，它将是 <code>"ahoy, world!"</code>。</p>
<h4 id="variables-and-data-interacting-with-clone-变量与数据的交互克隆clone"><a class="header" href="#variables-and-data-interacting-with-clone-变量与数据的交互克隆clone">Variables and Data Interacting with Clone 变量与数据的交互：克隆（Clone）</a></h4>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the
stack data, we can use a common method called <code>clone</code>. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.</p>
<p>如果我们<strong>确实</strong>想深度复制 <code>String</code> 的堆数据，而不仅仅是栈数据，可以使用一个名为 <code>clone</code> 的常用方法。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言的常见特性，你可能以前见过它们。</p>
<p>Here’s an example of the <code>clone</code> method in action:</p>
<p>以下是 <code>clone</code> 方法的实际示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data <em>does</em> get copied.</p>
<p>这种方法完全可行，并明确产生了图 4-3 所示的行为，堆数据<strong>确实</strong>被复制了。</p>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.</p>
<p><span class="highlight">[note]当你看到 <code>clone</code> 调用时，就知道正在执行某些可能开销较大的代码。</span>这是一个视觉指示器，表明发生了某些不同的事情。</p>
<h4 id="stack-only-data-copy-仅栈数据复制copy"><a class="header" href="#stack-only-data-copy-仅栈数据复制copy">Stack-Only Data: Copy 仅栈数据：复制（Copy）</a></h4>
<p>There’s another wrinkle we haven’t talked about yet. This code using
integers—part of which was shown in Listing 4-2—works and is valid:</p>
<p>还有另一个我们尚未讨论的细节。这段使用整数的代码（部分如代码清单 4-2 所示）是有效且可工作的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>But this code seems to contradict what we just learned: we don’t have a call to
<code>clone</code>, but <code>x</code> is still valid and wasn’t moved into <code>y</code>.</p>
<p>但这段代码似乎与我们刚刚学到的内容矛盾：我们没有调用 <code>clone</code>，但 <code>x</code> 仍然有效且未被移动到 <code>y</code>。</p>
<p>The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent <code>x</code> from being
valid after we create the variable <code>y</code>. In other words, there’s no difference
between deep and shallow copying here, so calling <code>clone</code> wouldn’t do anything
different from the usual shallow copying, and we can leave it out.</p>
<p>原因在于整数等类型在编译时具有已知大小，完全存储在栈上，复制实际值非常快。这意味着我们没有理由在创建变量 <code>y</code> 后让 <code>x</code> 无效。换句话说，这里深拷贝和浅拷贝没有区别，因此调用 <code>clone</code> 与通常的浅拷贝不会有任何不同，我们可以省略它。</p>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on
types that are stored on the stack, as integers are (we’ll talk more about
traits in Chapter 10). If a type implements the <code>Copy</code>
trait, variables that use it do not move, but rather are trivially copied,
making them still valid after assignment to another variable.</p>
<p><span class="highlight">[note]Rust 有一个称为 <code>Copy</code> trait 的特殊注解，可以用于存储在栈上的类型（如整数）。如果类型实现了 <code>Copy</code> trait，使用它的变量在赋值给另一个变量时不会移动，而是被简单地复制，使得它们在赋值后仍然有效。</span></p>
<p>Rust won’t let us annotate a type with <code>Copy</code> if the type, or any of its parts,
has implemented the <code>Drop</code> trait. If the type needs something special to happen
when the value goes out of scope and we add the <code>Copy</code> annotation to that type,
we’ll get a compile-time error. To learn about how to add the <code>Copy</code> annotation
to your type to implement the trait, see “Derivable
Traits” in Appendix C.</p>
<p><span class="highlight">[note]如果某个类型或其任何部分实现了 <code>Drop</code> trait，Rust 不允许我们用 <code>Copy</code> 标注该类型。</span>如果该类型在值离开作用域时需要特殊处理，而我们为其添加了 <code>Copy</code> 注解，将导致编译时错误。要了解如何为类型添加 <code>Copy</code> 注解以实现该 trait，请参阅附录 C 中的“可派生的 trait”。</p>
<p>So, what types implement the <code>Copy</code> trait? You can check the documentation for
the given type to be sure, but as a general rule, any group of simple scalar
values can implement <code>Copy</code>, and nothing that requires allocation or is some
form of resource can implement <code>Copy</code>. Here are some of the types that
implement <code>Copy</code>:</p>
<p>那么，哪些类型实现了 <code>Copy</code> trait？你可以查阅给定类型的文档确认，但作为一般规则，任何简单标量值组合都可以实现 <code>Copy</code>，而任何需要分配资源或属于某种资源的形式都不能实现 <code>Copy</code>。以下是一些实现 <code>Copy</code> 的类型：</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>所有整数类型，如 <code>u32</code>。</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>布尔类型 <code>bool</code>，值为 <code>true</code> 和 <code>false</code>。</li>
<li>All the floating-point types, such as <code>f64</code>.</li>
<li>所有浮点类型，如 <code>f64</code>。</li>
<li>The character type, <code>char</code>.</li>
<li>字符类型 <code>char</code>。</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>. For example,
<code>(i32, i32)</code> implements <code>Copy</code>, but <code>(i32, String)</code> does not.</li>
<li>元组，当且仅当其包含的所有类型也都实现 <code>Copy</code> 时。例如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 没有。</li>
</ul>
<h3 id="ownership-and-functions-所有权与函数"><a class="header" href="#ownership-and-functions-所有权与函数">Ownership and Functions 所有权与函数</a></h3>
<p>The mechanics of passing a value to a function are similar to those when
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p>将值传递给函数的机制与将值赋给变量类似。向函数传递变量会移动（move）或复制（copy），就像赋值一样。代码清单 4-3 是一个示例，带有注释说明变量进入和离开作用域的位置。</p>
<figure class="listing" id="listing-4-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // Because i32 implements the Copy trait,
                                    // x does NOT move into the function,
                                    // so it's okay to use x afterward.

} // Here, x goes out of scope, then s. However, because s's value was moved,
  // nothing special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.</code></pre></pre>
<figcaption><a href="ch04-01-what-is-ownership.html#listing-4-3">Listing 4-3</a>: Functions with ownership and scope annotated 带所有权和作用域注释的函数</figcaption>
</figure>
<p>If we tried to use <code>s</code> after the call to <code>takes_ownership</code>, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>s</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<p>如果我们尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code>，Rust 会抛出编译时错误。这些静态检查保护我们免于犯错。尝试在 <code>main</code> 中添加使用 <code>s</code> 和 <code>x</code> 的代码，看看你可以在哪里使用它们，而所有权规则在哪里阻止你这样做。</p>
<h3 id="return-values-and-scope-返回值与作用域"><a class="header" href="#return-values-and-scope-返回值与作用域">Return Values and Scope 返回值与作用域</a></h3>
<p>Returning values can also transfer ownership. Listing 4-4 shows an example of a
function that returns some value, with similar annotations as those in Listing
4-3.</p>
<p>返回值也可以转移所有权。代码清单 4-4 展示了一个返回某个值的函数示例，其注释与代码清单 4-3 类似。</p>
<figure class="listing" id="listing-4-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();        // gives_ownership moves its return
                                       // value into s1

    let s2 = String::from("hello");    // s2 comes into scope

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {       // gives_ownership will move its
                                       // return value into the function
                                       // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                        // some_string is returned and
                                       // moves out to the calling
                                       // function
}

// This function takes a String and returns a String.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string comes into
    // scope

    a_string  // a_string is returned and moves out to the calling function
}</code></pre></pre>
<figcaption><a href="ch04-01-what-is-ownership.html#listing-4-4">Listing 4-4</a>: Transferring ownership of return values 返回值的所有权转移</figcaption>
</figure>
<p>The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by <code>drop</code> unless ownership
of the data has been moved to another variable.</p>
<p>变量的所有权每次都遵循相同的模式：将值赋给另一个变量会移动它。当包含堆数据的变量离开作用域时，除非数据的所有权已转移到另一个变量，否则该值将被 <code>drop</code> 清理。</p>
<p>While this works, taking ownership and then returning ownership with every
function is a bit tedious. What if we want to let a function use a value but
not take ownership? It’s quite annoying that anything we pass in also needs to
be passed back if we want to use it again, in addition to any data resulting
from the body of the function that we might want to return as well.</p>
<p>虽然这种方法有效，但每个函数都获取所有权然后又返回所有权有点繁琐。如果我们想让函数使用一个值但不获取所有权呢？我们传入的任何内容还需要传回才能再次使用，这非常烦人，此外可能还需要返回函数体产生的任何数据。</p>
<p>Rust does let us return multiple values using a tuple, as shown in Listing 4-5.</p>
<p>Rust 确实允许我们使用元组返回多个值，如代码清单 4-5 所示。</p>
<figure class="listing" id="listing-4-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}</code></pre></pre>
<figcaption><a href="ch04-01-what-is-ownership.html#listing-4-5">Listing 4-5</a>: Returning ownership of parameters 返回参数的所有权</figcaption>
</figure>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for using a value without
transferring ownership, called <em>references</em>.</p>
<p>但对于一个本应常见的概念来说，这仪式感太强且工作量太大。幸运的是，Rust 有一个特性用于使用值而不转移所有权，称为<strong>引用</strong>（<em>references</em>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="references-and-borrowing-引用与借用"><a class="header" href="#references-and-borrowing-引用与借用">References and Borrowing 引用与借用</a></h2>
<p>The issue with the tuple code in Listing 4-5 is that we have to return the
<code>String</code> to the calling function so we can still use the <code>String</code> after the
call to <code>calculate_length</code>, because the <code>String</code> was moved into
<code>calculate_length</code>. Instead, we can provide a reference to the <code>String</code> value.
A <em>reference</em> is like a pointer in that it’s an address we can follow to access
the data stored at that address; that data is owned by some other variable.
Unlike a pointer, a reference is guaranteed to point to a valid value of a
particular type for the life of that reference.</p>
<p>清单4-5中元组代码的问题在于，我们必须将<code>String</code>返回给调用函数，这样才能在调用<code>calculate_length</code>后继续使用<code>String</code>，因为<code>String</code>被移动到了<code>calculate_length</code>中。实际上，我们可以提供<code>String</code>值的引用。<strong>引用</strong>类似于指针，它是一个可以追踪到存储数据的地址；这些数据由其他变量所有。与指针不同，引用在其生命周期内保证指向特定类型的有效值。</p>
<p>Here is how you would define and use a <code>calculate_length</code> function that has a
reference to an object as a parameter instead of taking ownership of the value:</p>
<p>以下是定义和使用带引用参数的<code>calculate_length</code>函数的方法（而非获取值的所有权）：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</figure>
<p>First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass <code>&amp;s1</code> into
<code>calculate_length</code> and, in its definition, we take <code>&amp;String</code> rather than
<code>String</code>. These ampersands represent <em>references</em>, and they allow you to refer
to some value without taking ownership of it. Figure 4-6 depicts this concept.</p>
<p>首先注意变量声明和函数返回值中的所有元组代码都消失了。其次，我们向<code>calculate_length</code>传递<code>&amp;s1</code>，在函数定义中接收<code>&amp;String</code>而非<code>String</code>。这些<code>&amp;</code>符号表示<strong>引用</strong>，它们允许你引用某个值而不获取其所有权。图4-6描绘了这一概念。</p>
<img alt="" src="img/trpl04-06.svg" class="center" />
<p><span class="caption">Figure 4-6: A diagram of <code>&amp;String s</code> pointing at <code>String  s1</code> 指向<code>String s1</code>的<code>&amp;String s</code>示意图</span></p>
<section class="note" aria-role="note">
<p>Note: The opposite of referencing by using <code>&amp;</code> is <em>dereferencing</em>, which is
accomplished with the dereference operator, <code>*</code>. We’ll see some uses of the
dereference operator in Chapter 8 and discuss details of dereferencing in
Chapter 15.</p>
<p>注意：使用<code>&amp;</code>引用的反操作是<strong>解引用</strong>，通过解引用运算符<code>*</code>实现。我们将在第8章看到解引用运算符的应用，并在第15章讨论解引用细节。</p>
</section>
<p>Let’s take a closer look at the function call here:</p>
<p>仔细观察此函数调用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refers</em> to the value of <code>s1</code>
but does not own it. Because the reference does not own it, the value it points
to will not be dropped when the reference stops being used.</p>
<p><code>&amp;s1</code>语法创建了一个<strong>指向</strong><code>s1</code>值但不拥有它的引用。由于引用不拥有该值，当引用停止使用时，其指向的值不会被丢弃。</p>
<p>Likewise, the signature of the function uses <code>&amp;</code> to indicate that the type of
the parameter <code>s</code> is a reference. Let’s add some explanatory annotations:</p>
<p>同理，函数签名中的<code>&amp;</code>表明参数<code>s</code>是引用类型。添加注释说明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("The length of '{s1}' is {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because s does not have ownership of what
  // it refers to, the String is not dropped.</code></pre></pre>
<p>The scope in which the variable <code>s</code> is valid is the same as any function
parameter’s scope, but the value pointed to by the reference is not dropped
when <code>s</code> stops being used, because <code>s</code> doesn’t have ownership. When functions
have references as parameters instead of the actual values, we won’t need to
return the values in order to give back ownership, because we never had
ownership.</p>
<p>变量<code>s</code>的作用域与任何函数参数相同，但当<code>s</code>停止使用时，引用指向的值不会被丢弃，因为<code>s</code>没有所有权。当函数使用引用而非实际值作为参数时，我们无需返回值来归还所有权，因为我们从未拥有所有权。</p>
<p>We call the action of creating a reference <em>borrowing</em>. As in real life, if a
person owns something, you can borrow it from them. When you’re done, you have
to give it back. You don’t own it.</p>
<p>创建引用的行为称为<strong>借用</strong>。如同现实生活，若某人拥有某物，你可以借用它。用完后必须归还，你并不拥有它。</p>
<p>So, what happens if we try to modify something we’re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn’t work!</p>
<p>若尝试修改借用的值会发生什么？试运行清单4-6的代码（剧透警告：无法运行！）：</p>
<figure class="listing" id="listing-4-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
<figcaption><a href="ch04-02-references-and-borrowing.html#listing-4-6">Listing 4-6</a>: Attempting to modify a borrowed value 尝试修改借用值</figcaption>
</figure>
<p>Here’s the error:</p>
<p>错误信息如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Just as variables are immutable by default, so are references. We’re not
allowed to modify something we have a reference to.</p>
<p>正如变量默认不可变，引用也是不可变的。不允许修改引用的值。</p>
<h3 id="mutable-references-可变引用"><a class="header" href="#mutable-references-可变引用">Mutable References 可变引用</a></h3>
<p>We can fix the code from Listing 4-6 to allow us to modify a borrowed value
with just a few small tweaks that use, instead, a <em>mutable reference</em>:</p>
<p>我们可通过少量调整修复清单4-6的代码，改为使用<strong>可变引用</strong>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</figure>
<p>First we change <code>s</code> to be <code>mut</code>. Then we create a mutable reference with <code>&amp;mut  s</code> where we call the <code>change</code> function, and update the function signature to
accept a mutable reference with <code>some_string: &amp;mut String</code>. This makes it very
clear that the <code>change</code> function will mutate the value it borrows.</p>
<p>首先将<code>s</code>改为<code>mut</code>。在调用<code>change</code>函数时用<code>&amp;mut s</code>创建可变引用，并将函数签名更新为<code>some_string: &amp;mut String</code>以接收可变引用。这明确表示<code>change</code>函数将修改其借用的值。</p>
<p>Mutable references have one big restriction: if you have a mutable reference to
a value, you can have no other references to that value. This code that
attempts to create two mutable references to <code>s</code> will fail:</p>
<p>可变引用有严格限制：若存在对某值的可变引用，则不能有其他指向该值的引用。尝试创建两个指向<code>s</code>的可变引用的代码会失败：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{r1}, {r2}");
<span class="boring">}</span></code></pre>
</figure>
<p>Here’s the error:</p>
<p>错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{r1}, {r2}");
  |               ---- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>This error says that this code is invalid because we cannot borrow <code>s</code> as
mutable more than once at a time. The first mutable borrow is in <code>r1</code> and must
last until it’s used in the <code>println!</code>, but between the creation of that
mutable reference and its usage, we tried to create another mutable reference
in <code>r2</code> that borrows the same data as <code>r1</code>.</p>
<p>此错误表明代码无效，因为我们不能同时多次可变借用<code>s</code>。第一个可变借用位于<code>r1</code>，其生命周期持续到<code>println!</code>使用它为止，但在此可变引用创建和使用之间，我们尝试在<code>r2</code>创建另一个借用相同数据的可变引用。</p>
<p>The restriction preventing multiple mutable references to the same data at the
same time allows for mutation but in a very controlled fashion. It’s something
that new Rustaceans struggle with because most languages let you mutate
whenever you’d like. The benefit of having this restriction is that Rust can
prevent data races at compile time. A <em>data race</em> is similar to a race
condition and happens when these three behaviors occur:</p>
<p>该限制允许在严格控制下进行修改。新手常因此困扰，因为多数语言允许自由修改变量。此限制的好处是Rust能在编译时防止数据竞争。<strong>数据竞争</strong>类似于竞态条件，在以下三种行为同时发生时出现：</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>两个或更多指针同时访问同一数据</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>至少有一个指针用于写入数据</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
<li>未使用同步机制协调数据访问</li>
</ul>
<p>Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem by
refusing to compile code with data races!</p>
<p>数据竞争会导致未定义行为，且在运行时难以诊断和修复；Rust通过拒绝编译存在数据竞争的代码来避免此问题！</p>
<p>As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not <em>simultaneous</em> ones:</p>
<p>我们可用花括号创建新作用域，允许非<strong>同时</strong>存在的多个可变引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust enforces a similar rule for combining mutable and immutable references.
This code results in an error:</p>
<p>Rust对可变引用与不可变引用的组合有类似规则。以下代码会报错：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!("{r1}, {r2}, and {r3}");
<span class="boring">}</span></code></pre>
<p>Here’s the error:</p>
<p>错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{r1}, {r2}, and {r3}");
  |               ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Whew! We <em>also</em> cannot have a mutable reference while we have an immutable one
to the same value.</p>
<p>哇！当存在对同一值的不可变引用时，也不能拥有可变引用。</p>
<p>Users of an immutable reference don’t expect the value to suddenly change out
from under them! However, multiple immutable references are allowed because no
one who is just reading the data has the ability to affect anyone else’s
reading of the data.</p>
<p>不可变引用用户不期望值突然被修改！但允许多个不可变引用存在，因为只读数据的用户不会影响其他用户的读取。</p>
<p>Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references is in the <code>println!</code>,
before the mutable reference is introduced:</p>
<p>注意引用的作用域从声明处开始，持续到最后一次使用。例如以下代码可编译，因为不可变引用的最后一次使用在<code>println!</code>（在可变引用创建之前）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!("{r1} and {r2}");
    // Variables r1 and r2 will not be used after this point.

    let r3 = &amp;mut s; // no problem
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>The scopes of the immutable references <code>r1</code> and <code>r2</code> end after the <code>println!</code>
where they are last used, which is before the mutable reference <code>r3</code> is
created. These scopes don’t overlap, so this code is allowed: the compiler can
tell that the reference is no longer being used at a point before the end of
the scope.</p>
<p>不可变引用<code>r1</code>和<code>r2</code>的作用域在最后一次使用的<code>println!</code>后结束，此时可变引用<code>r3</code>尚未创建。这些作用域不重叠，因此允许此代码：编译器能判断在作用域结束前引用已不再使用。</p>
<p>Even though borrowing errors may be frustrating at times, remember that it’s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don’t
have to track down why your data isn’t what you thought it was.</p>
<p>尽管借用错误有时令人沮丧，但请记住：Rust编译器是在早期（编译时而非运行时）指出潜在错误，并精确定位问题所在。这样你就不必追踪数据为何不符合预期。</p>
<h3 id="dangling-references-悬垂引用"><a class="header" href="#dangling-references-悬垂引用">Dangling References 悬垂引用</a></h3>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling
pointer</em>—a pointer that references a location in memory that may have been
given to someone else—by freeing some memory while preserving a pointer to that
memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.</p>
<p>在使用指针的语言中，容易错误创建<strong>悬垂指针</strong>（指向已释放内存的指针）。而在Rust中，编译器保证引用永远不会成为悬垂引用：若存在对某数据的引用，编译器将确保该数据在引用失效前不会离开作用域。</p>
<p>Let’s try to create a dangling reference to see how Rust prevents them with a
compile-time error:</p>
<p>尝试创建悬垂引用以观察Rust如何通过编译错误阻止：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</figure>
<p>Here’s the error:</p>
<p>错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>This error message refers to a feature we haven’t covered yet: lifetimes. We’ll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:</p>
<p>此错误涉及未涵盖的特性：生命周期（第10章详解）。若忽略生命周期部分，消息确实包含代码问题的关键信息：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
此函数返回类型包含借用值，但无被借用的值
</code></pre>
<p>Let’s take a closer look at exactly what’s happening at each stage of our
<code>dangle</code> code:</p>
<p>逐步分析<code>dangle</code>代码的执行过程：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope and is dropped, so its memory goes away.
  // Danger!</code></pre>
</figure>
<p>Because <code>s</code> is created inside <code>dangle</code>, when the code of <code>dangle</code> is finished,
<code>s</code> will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid <code>String</code>. That’s no good! Rust
won’t let us do this.</p>
<p>由于<code>s</code>在<code>dangle</code>内部创建，当<code>dangle</code>代码执行完毕时，<code>s</code>会被释放。但我们试图返回对它的引用，这将指向无效的<code>String</code>。Rust不允许此操作。</p>
<p>The solution here is to return the <code>String</code> directly:</p>
<p>解决方案是直接返回<code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>This works without any problems. Ownership is moved out, and nothing is
deallocated.</p>
<p>此代码正常运行。所有权被移出，且未释放任何内容。</p>
<h3 id="the-rules-of-references-引用规则"><a class="header" href="#the-rules-of-references-引用规则">The Rules of References 引用规则</a></h3>
<p>Let’s recap what we’ve discussed about references:</p>
<p>回顾引用的核心规则：</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any
number of immutable references.</li>
<li>任意时刻，只能有<strong>一个</strong>可变引用<strong>或</strong>任意数量不可变引用</li>
<li>References must always be valid.</li>
<li>引用必须始终有效</li>
</ul>
<p>Next, we’ll look at a different kind of reference: slices.</p>
<p>接下来我们将探讨另一种引用类型：切片。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-slice-type-切片类型"><a class="header" href="#the-slice-type-切片类型">The Slice Type 切片类型</a></h2>
<p><em>Slices</em> let you reference a contiguous sequence of elements in a
collection. A slice is a kind
of reference, so it does not have ownership.</p>
<p><strong>切片</strong>（slice）允许你引用集合中一段连续的元素序列。切片是一种引用类型，因此它不拥有所有权。</p>
<p>Here’s a small programming problem: write a function that takes a string of
words separated by spaces and returns the first word it finds in that string.
If the function doesn’t find a space in the string, the whole string must be
one word, so the entire string should be returned.</p>
<p>这里有个小编程问题：编写一个函数，该函数接收一个由空格分隔的单词字符串，并返回该字符串中的第一个单词。如果函数在字符串中未找到空格，则整个字符串必然是一个单词，因此应返回整个字符串。</p>
<section class="note" aria-role="note">
<p>Note: For the purposes of introducing string slices, we are assuming ASCII
only in this section; a more thorough discussion of UTF-8 handling is in the
“Storing UTF-8 Encoded Text with Strings” section
of Chapter 8.</p>
<p>注意：为介绍字符串切片，本节我们仅假设字符串为 ASCII 字符集；关于 UTF-8 处理的更全面讨论请见第 8 章的“使用字符串存储 UTF-8 编码文本”部分。</p>
</section>
<p>Let’s work through how we’d write the signature of this function without using
slices, to understand the problem that slices will solve:</p>
<p>让我们先尝试在不使用切片的情况下编写该函数的签名，以理解切片要解决的问题：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>The <code>first_word</code> function has a parameter of type <code>&amp;String</code>. We don’t need
ownership, so this is fine. (In idiomatic Rust, functions do not take ownership
of their arguments unless they need to, and the reasons for that will become
clear as we keep going.) But what should we return? We don’t really have a way
to talk about <em>part</em> of a string. However, we could return the index of the end
of the word, indicated by a space. Let’s try that, as shown in Listing 4-7.</p>
<p><code>first_word</code> 函数有一个 <code>&amp;String</code> 类型的参数。我们不需要所有权，所以这样没问题。（在惯用的 Rust 代码中，除非必要，函数通常不会获取其参数的所有权，随着深入学习，原因会逐渐清晰。）但我们应该返回什么？实际上我们无法表达字符串的<strong>部分</strong>内容。不过，可以返回单词结尾的索引位置，即空格的位置。让我们尝试如示例 4-7 所示的方法。</p>
<figure class="listing" id="listing-4-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch04-03-slices.html#listing-4-7">Listing 4-7</a>: The <code>first_word</code> function that returns a byte index value into the <code>String</code> parameter 返回 <code>String</code> 参数字节索引值的 <code>first_word</code> 函数</figcaption>
</figure>
<p>Because we need to go through the <code>String</code> element by element and check whether
a value is a space, we’ll convert our <code>String</code> to an array of bytes using the
<code>as_bytes</code> method.</p>
<p>由于需要逐个元素遍历 <code>String</code> 并检查是否为空格，我们将使用 <code>as_bytes</code> 方法将 <code>String</code> 转换为字节数组。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Next, we create an iterator over the array of bytes using the <code>iter</code> method:</p>
<p>接着，使用 <code>iter</code> 方法在字节数组上创建迭代器：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>We’ll discuss iterators in more detail in Chapter 13.
For now, know that <code>iter</code> is a method that returns each element in a collection
and that <code>enumerate</code> wraps the result of <code>iter</code> and returns each element as
part of a tuple instead. The first element of the tuple returned from
<code>enumerate</code> is the index, and the second element is a reference to the element.
This is a bit more convenient than calculating the index ourselves.</p>
<p>我们将在第 13 章详细讨论迭代器。现在只需知道：<code>iter</code> 方法返回集合中的每个元素，而 <code>enumerate</code> 包装 <code>iter</code> 的结果，将每个元素作为元组返回。<code>enumerate</code> 返回元组的第一个元素是索引，第二个元素是元素的引用。这比自己计算索引更方便。</p>
<p>Because the <code>enumerate</code> method returns a tuple, we can use patterns to
destructure that tuple. We’ll be discussing patterns more in Chapter 6.
In the <code>for</code> loop, we specify a pattern that has <code>i</code>
for the index in the tuple and <code>&amp;item</code> for the single byte in the tuple.
Because we get a reference to the element from <code>.iter().enumerate()</code>, we use
<code>&amp;</code> in the pattern.</p>
<p>由于 <code>enumerate</code> 方法返回元组，我们可以使用模式来解构它（第 6 章将深入讨论模式）。在 <code>for</code> 循环中，我们指定一个模式：<code>i</code> 表示元组中的索引，<code>&amp;item</code> 表示元组中的单个字节。因为通过 <code>.iter().enumerate()</code> 获取的是元素的引用，所以在模式中使用了 <code>&amp;</code>。</p>
<p>Inside the <code>for</code> loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using <code>s.len()</code>.</p>
<p>在 <code>for</code> 循环内部，我们使用字节字面值语法查找代表空格的字节。找到空格时返回其位置，否则返回字符串长度 <code>s.len()</code>。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a <code>usize</code> on its own, but it’s
only a meaningful number in the context of the <code>&amp;String</code>. In other words,
because it’s a separate value from the <code>String</code>, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the <code>first_word</code> function from Listing 4-7.</p>
<p>现在有办法获取字符串中第一个单词结尾的索引了，但存在一个问题：返回的 <code>usize</code> 本身脱离了 <code>&amp;String</code> 上下文就失去意义。换句话说，由于它是独立于 <code>String</code> 的值，无法保证未来它仍然有效。考虑示例 4-8 的程序，它使用了示例 4-7 的 <code>first_word</code> 函数。</p>
<figure class="listing" id="listing-4-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but s no longer has any content that we
    // could meaningfully use with the value 5, so word is now totally invalid!
}</code></pre></pre>
<figcaption><a href="ch04-03-slices.html#listing-4-8">Listing 4-8</a>: Storing the result from calling the <code>first_word</code> function and then changing the <code>String</code> contents 存储调用 <code>first_word</code> 函数的结果后修改 <code>String</code> 内容</figcaption>
</figure>
<p>This program compiles without any errors and would also do so if we used <code>word</code>
after calling <code>s.clear()</code>. Because <code>word</code> isn’t connected to the state of <code>s</code>
at all, <code>word</code> still contains the value <code>5</code>. We could use that value <code>5</code> with
the variable <code>s</code> to try to extract the first word out, but this would be a bug
because the contents of <code>s</code> have changed since we saved <code>5</code> in <code>word</code>.</p>
<p>此程序编译无错误，即使调用 <code>s.clear()</code> 后使用 <code>word</code> 也能通过。因为 <code>word</code> 与 <code>s</code> 的状态完全无关，它仍然包含值 <code>5</code>。我们可以尝试用这个值 <code>5</code> 从变量 <code>s</code> 中提取第一个单词，但这会产生 bug，因为 <code>s</code> 的内容在我们将 <code>5</code> 存入 <code>word</code> 后已改变。</p>
<p>Having to worry about the index in <code>word</code> getting out of sync with the data in
<code>s</code> is tedious and error prone! Managing these indices is even more brittle if
we write a <code>second_word</code> function. Its signature would have to look like this:</p>
<p>担心 <code>word</code> 的索引与 <code>s</code> 的数据不同步既繁琐又易错！若编写 <code>second_word</code> 函数，管理这些索引会更加脆弱。其签名可能如下：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Now we’re tracking a starting <em>and</em> an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We have three unrelated variables floating around that need
to be kept in sync.</p>
<p>现在需要跟踪起始索引和结束索引，更多计算值依赖于特定状态的数据，却未与该状态绑定。三个独立变量飘荡在代码中，必须保持同步。</p>
<p>Luckily, Rust has a solution to this problem: string slices.</p>
<p>幸运的是，Rust 提供了解决方案：字符串切片。</p>
<h3 id="string-slices-字符串切片"><a class="header" href="#string-slices-字符串切片">String Slices 字符串切片</a></h3>
<p>A <em>string slice</em> is a reference to a contiguous sequence of the elements of a
<code>String</code>, and it looks like this:</p>
<p><strong>字符串切片</strong>（string slice）是对 <code>String</code> 中连续元素的引用，形如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>Rather than a reference to the entire <code>String</code>, <code>hello</code> is a reference to a
portion of the <code>String</code>, specified in the extra <code>[0..5]</code> bit. We create slices
using a range within brackets by specifying <code>[starting_index..ending_index]</code>,
where <em><code>starting_index</code></em> is the first position in the slice and <em><code>ending_index</code></em>
is one more than the last position in the slice. Internally, the slice data
structure stores the starting position and the length of the slice, which
corresponds to <em><code>ending_index</code></em> minus <em><code>starting_index</code></em>. So, in the case of <code>let  world = &amp;s[6..11];</code>, <code>world</code> would be a slice that contains a pointer to the
byte at index 6 of <code>s</code> with a length value of <code>5</code>.</p>
<p>这里 <code>hello</code> 不是对整个 <code>String</code> 的引用，而是通过附加的 <code>[0..5]</code> 指定了 <code>String</code> 的一部分。我们使用括号内的范围创建切片：<code>[起始索引..结束索引]</code>，其中 <em><code>起始索引</code></em> 是切片起始位置，<em><code>结束索引</code></em> 是切片末尾位置的下一个索引。切片数据结构内部存储起始位置和长度（即 <em><code>结束索引</code></em> 减去 <em><code>起始索引</code></em>）。因此 <code>let world = &amp;s[6..11];</code> 中，<code>world</code> 将是一个指向 <code>s</code> 索引 6 处字节的切片，长度值为 <code>5</code>。</p>
<p>Figure 4-7 shows this in a diagram.</p>
<p>图 4-7 展示了此结构。</p>
<img alt="" src="img/trpl04-07.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-7: String slice referring to part of a
<code>String</code> 引用部分 <code>String</code> 的字符串切片</span></p>
<p>With Rust’s <code>..</code> range syntax, if you want to start at index 0, you can drop
the value before the two periods. In other words, these are equal:</p>
<p>使用 Rust 的 <code>..</code> 范围语法时，若从索引 0 开始，可省略句号前的值。即以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>By the same token, if your slice includes the last byte of the <code>String</code>, you
can drop the trailing number. That means these are equal:</p>
<p>同理，若切片包含 <code>String</code> 的最后一个字节，可省略结尾数字。即以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So these
are equal:</p>
<p>也可同时省略两个值来获取整个字符串的切片。因此以下等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<section class="note" aria-role="note">
<p>Note: String slice range indices must occur at valid UTF-8 character
boundaries. If you attempt to create a string slice in the middle of a
multibyte character, your program will exit with an error.</p>
<p>注意：字符串切片的范围索引必须位于有效的 UTF-8 字符边界。若尝试在多字节字符中间创建字符串切片，程序将因错误退出。</p>
</section>
<p>With all this information in mind, let’s rewrite <code>first_word</code> to return a
slice. The type that signifies “string slice” is written as <code>&amp;str</code>:</p>
<p>了解这些信息后，我们重写 <code>first_word</code> 以返回切片。表示“字符串切片”的类型写作 <code>&amp;str</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</figure>
<p>We get the index for the end of the word the same way we did in Listing 4-7, by
looking for the first occurrence of a space. When we find a space, we return a
string slice using the start of the string and the index of the space as the
starting and ending indices.</p>
<p>我们沿用示例 4-7 的方法获取单词结尾索引：查找第一个空格。找到空格时，用字符串起始位置和空格索引作为起止索引返回字符串切片。</p>
<p>Now when we call <code>first_word</code>, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.</p>
<p>现在调用 <code>first_word</code> 会返回一个与底层数据绑定的值。该值由切片起始点的引用和切片元素数量组成。</p>
<p>Returning a slice would also work for a <code>second_word</code> function:</p>
<p>返回切片同样适用于 <code>second_word</code> 函数：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>We now have a straightforward API that’s much harder to mess up because the
compiler will ensure the references into the <code>String</code> remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of <code>first_word</code> will throw a
compile-time error:</p>
<p>现在我们有了简洁的 API，且更难出错，因为编译器将确保指向 <code>String</code> 的引用保持有效。还记得示例 4-8 中的 bug 吗？我们获取了第一个单词结尾的索引，却清空了字符串导致索引失效。那段代码逻辑错误但未立即显现问题。若继续尝试对已清空的字符串使用第一个单词索引，问题会在后续暴露。切片杜绝了此类 bug，让我们更早发现代码问题。使用切片版本的 <code>first_word</code> 会引发编译时错误：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>
</figure>
<p>Here’s the compiler error:</p>
<p>编译器报错如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because <code>clear</code> needs to
truncate the <code>String</code>, it needs to get a mutable reference. The <code>println!</code>
after the call to <code>clear</code> uses the reference in <code>word</code>, so the immutable
reference must still be active at that point. Rust disallows the mutable
reference in <code>clear</code> and the immutable reference in <code>word</code> from existing at the
same time, and compilation fails. Not only has Rust made our API easier to use,
but it has also eliminated an entire class of errors at compile time!</p>
<p>回忆借用规则：若存在不可变引用，就不能再获取可变引用。因为 <code>clear</code> 需要截断 <code>String</code>，它必须获取可变引用。<code>clear</code> 调用后的 <code>println!</code> 使用了 <code>word</code> 的引用，此时不可变引用必须仍有效。Rust 禁止 <code>clear</code> 中的可变引用和 <code>word</code> 中的不可变引用同时存在，因此编译失败。Rust 不仅使 API 更易用，还在编译时消除了整类错误！</p>
<h4 id="string-literals-as-slices-字符串字面值是切片"><a class="header" href="#string-literals-as-slices-字符串字面值是切片">String Literals as Slices 字符串字面值是切片</a></h4>
<p>Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:</p>
<p>前文提到字符串字面值存储在二进制文件中。了解切片后，我们可以正确理解字符串字面值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; <code>&amp;str</code> is an
immutable reference.</p>
<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制文件特定位置的切片。这也解释了字符串字面值不可变的原因：<code>&amp;str</code> 是不可变引用。</p>
<h4 id="string-slices-as-parameters-将字符串切片作为参数"><a class="header" href="#string-slices-as-parameters-将字符串切片作为参数">String Slices as Parameters 将字符串切片作为参数</a></h4>
<p>Knowing that you can take slices of literals and <code>String</code> values leads us to
one more improvement on <code>first_word</code>, and that’s its signature:</p>
<p>知道可以对字面值和 <code>String</code> 值取切片后，我们可以进一步改进 <code>first_word</code> 的签名：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both <code>&amp;String</code> values
and <code>&amp;str</code> values.</p>
<p>更有经验的 Rust 开发者会采用示例 4-9 的签名，因为它允许在 <code>&amp;String</code> 值和 <code>&amp;str</code> 值上使用同一函数。</p>
<figure class="listing" id="listing-4-9">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or
</span><span class="boring">    // whole.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch04-03-slices.html#listing-4-9">Listing 4-9</a>: Improving the <code>first_word</code> function by using a string slice for the type of the <code>s</code> parameter 通过为参数 <code>s</code> 使用字符串切片类型改进 <code>first_word</code> 函数</figcaption>
</figure>
<p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we
can pass a slice of the <code>String</code> or a reference to the <code>String</code>. This
flexibility takes advantage of <em>deref coercions</em>, a feature we will cover in the
“Implicit Deref Coercions with Functions and
Methods” section of Chapter 15.</p>
<p>若拥有字符串切片，可直接传递。若拥有 <code>String</code>，则可传递其切片或引用。这种灵活性利用了<strong>解引用强制转换</strong>（deref coercions）特性，我们将在第 15 章的“函数和方法的隐式解引用强制转换”章节介绍。</p>
<p>Defining a function to take a string slice instead of a reference to a <code>String</code>
makes our API more general and useful without losing any functionality:</p>
<p>定义函数接收字符串切片而非 <code>String</code> 的引用，使 API 更通用实用且不损失功能：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or
    // whole.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</figure>
<h3 id="other-slices-其他切片"><a class="header" href="#other-slices-其他切片">Other Slices 其他切片</a></h3>
<p>String slices, as you might imagine, are specific to strings. But there’s a
more general slice type too. Consider this array:</p>
<p>字符串切片专用于字符串，但存在更通用的切片类型。考虑数组：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Just as we might want to refer to part of a string, we might want to refer to
part of an array. We’d do so like this:</p>
<p>正如可能引用字符串的一部分，也可能引用数组的一部分：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.</p>
<p>此<span class="highlight">[note]切片类型为 <code>&amp;[i32]</code></span>，其工作方式与字符串切片相同：存储首元素引用和长度。这种切片适用于所有集合类型。第 8 章讨论向量（vector）时将深入介绍这些集合。</p>
<h2 id="summary-总结-3"><a class="header" href="#summary-总结-3">Summary 总结</a></h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.</p>
<p>所有权、借用和切片的概念在编译时确保 Rust 程序的内存安全。Rust 语言像其他系统编程语言一样让你控制内存使用，但所有者离开作用域时自动清理数据的功能，意味着你无需编写和调试额外代码来实现这种控制。</p>
<p>Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>
<p>所有权影响着 Rust 的诸多其他部分，因此后续章节将进一步探讨这些概念。接下来，第 5 章将学习如何用 <code>struct</code> 组合数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-structs-to-structure-related-data-使用结构体组织关联数据"><a class="header" href="#using-structs-to-structure-related-data-使用结构体组织关联数据">Using Structs to Structure Related Data 使用结构体组织关联数据</a></h1>
<p>A <em>struct</em>, or <em>structure</em>, is a custom data type that lets you package
together and name multiple related values that make up a meaningful group. If
you’re familiar with an object-oriented language, a <em>struct</em> is like an
object’s data attributes. In this chapter, we’ll compare and contrast tuples
with structs to build on what you already know and demonstrate when structs are
a better way to group data.</p>
<p><strong>结构体</strong>（struct）是一种自定义数据类型，允许你将多个关联的值打包组合并命名，从而形成一个有意义的组。如果你熟悉面向对象语言，那么结构体就像是对象的数据属性。本章将通过比较元组与结构体的异同来巩固你已有的知识，并演示何时使用结构体是更合适的数据组织方式。</p>
<p>We’ll demonstrate how to define and instantiate structs. We’ll discuss how to
define associated functions, especially the kind of associated functions called
<em>methods</em>, to specify behavior associated with a struct type. Structs and enums
(discussed in Chapter 6) are the building blocks for creating new types in your
program’s domain to take full advantage of Rust’s compile-time type checking.</p>
<p>我们将演示如何定义和实例化结构体。讨论如何定义关联函数，特别是称为<strong>方法</strong>（methods）的关联函数，用于指定与结构体类型相关的行为。结构体和枚举（将在第6章讨论）是在程序领域中创建新类型的基石，能充分利用Rust的编译时类型检查机制。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-and-instantiating-structs-定义和实例化结构体"><a class="header" href="#defining-and-instantiating-structs-定义和实例化结构体">Defining and Instantiating Structs 定义和实例化结构体</a></h2>
<p>Structs are similar to tuples, discussed in “The Tuple Type” section, in that both hold multiple related values. Like tuples, the
pieces of a struct can be different types. Unlike with tuples, in a struct
you’ll name each piece of data so it’s clear what the values mean. Adding these
names means that structs are more flexible than tuples: you don’t have to rely
on the order of the data to specify or access the values of an instance.</p>
<p>结构体与元组（在“元组类型”章节讨论过）的相似之处在于它们都持有多个关联值。与元组类似，结构体的各个部分可以是不同类型。但与元组不同的是，在结构体中你需要为每个数据片段命名，以明确值的含义。添加这些名称意味着结构体比元组更灵活：无需依赖数据顺序来指定或访问实例的值。</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a
struct that stores information about a user account.</p>
<p>定义结构体时，需输入关键字 <code>struct</code> 并为整个结构体命名。结构体名称应描述所组合数据片段的意义。随后，在大括号内定义数据片段的名称和类型，这些称为<strong>字段</strong>。例如，示例5-1展示了一个存储用户账户信息的结构体。</p>
<figure class="listing" id="listing-5-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-1">Listing 5-1</a>: A <code>User</code> struct definition <code>User</code> 结构体定义</figcaption>
</figure>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing <em><code>key:  value</code></em> pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.</p>
<p>定义结构体后，通过为每个字段指定具体值来创建该结构体的<strong>实例</strong>。创建实例时，先声明结构体名称，然后添加包含 <strong><code>键: 值</code></strong> 对的大括号，其中键是字段名，值是要存储的数据。字段的顺序无需与结构体声明时的顺序一致。换言之，结构体定义像是类型的通用模板，而实例则用具体数据填充该模板以创建类型的值。例如，我们可以如示例5-2所示声明特定用户。</p>
<figure class="listing" id="listing-5-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-2">Listing 5-2</a>: Creating an instance of the <code>User</code> struct 创建 <code>User</code> 结构体实例</figcaption>
</figure>
<p>To get a specific value from a struct, we use dot notation. For example, to
access this user’s email address, we use <code>user1.email</code>. If the instance is
mutable, we can change a value by using the dot notation and assigning into a
particular field. Listing 5-3 shows how to change the value in the <code>email</code>
field of a mutable <code>User</code> instance.</p>
<p>要从结构体获取特定值，需使用点号表示法。例如，访问此用户的邮箱地址使用 <code>user1.email</code>。若实例可变，可通过点号表示法赋值给特定字段来修改值。示例5-3展示了如何修改可变 <code>User</code> 实例的 <code>email</code> 字段值。</p>
<figure class="listing" id="listing-5-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-3">Listing 5-3</a>: Changing the value in the <code>email</code> field of a <code>User</code> instance 修改 <code>User</code> 实例的 <code>email</code> 字段值</figcaption>
</figure>
<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.</p>
<p>注意：整个实例必须是可变的；Rust不允许仅将某些字段标记为可变。与其他表达式类似，我们可以在函数体末尾将结构体的新实例作为最后一个表达式来隐式返回该实例。</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with
the given email and username. The <code>active</code> field gets the value of <code>true</code>, and
the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<p>示例5-4展示了一个 <code>build_user</code> 函数，它返回具有指定邮箱和用户名的 <code>User</code> 实例。<code>active</code> 字段值为 <code>true</code>，<code>sign_in_count</code> 值为 <code>1</code>。</p>
<figure class="listing" id="listing-5-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-4">Listing 5-4</a>: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance 接收邮箱和用户名并返回 <code>User</code> 实例的 <code>build_user</code> 函数</figcaption>
</figure>
<p>It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the <code>email</code> and <code>username</code> field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<p>将函数参数命名为与结构体字段同名是合理的，但重复 <code>email</code> 和 <code>username</code> 的字段名和变量名略显繁琐。若结构体字段更多，重复每个名称会更令人厌烦。幸运的是，存在便捷的简写方式！</p>
<h3 id="using-the-field-init-shorthand-使用字段初始化简写语法"><a class="header" href="#using-the-field-init-shorthand-使用字段初始化简写语法">Using the Field Init Shorthand 使用字段初始化简写语法</a></h3>
<p>Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the <em>field init shorthand</em> syntax to rewrite
<code>build_user</code> so it behaves exactly the same but doesn’t have the repetition of
<code>username</code> and <code>email</code>, as shown in Listing 5-5.</p>
<p>由于示例5-4中<span class="highlight">[note]参数名与结构体字段名完全相同，我们可以使用<strong>字段初始化简写语法</strong></span>重写 <code>build_user</code>，其行为完全相同但避免了 <code>username</code> 和 <code>email</code> 的重复，如示例5-5所示。</p>
<figure class="listing" id="listing-5-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-5">Listing 5-5</a>: A <code>build_user</code> function that uses field init shorthand because the <code>username</code> and <code>email</code> parameters have the same name as struct fields 使用字段初始化简写的 <code>build_user</code> 函数（因 <code>username</code> 和 <code>email</code> 参数与结构体字段同名）</figcaption>
</figure>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field
named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the
<code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather
than <code>email: email</code>.</p>
<p>这里我们创建了 <code>User</code> 结构体的新实例，该结构体有名为 <code>email</code> 的字段。我们希望将 <code>email</code> 字段的值设置为 <code>build_user</code> 函数中 <code>email</code> 参数的值。因为 <code>email</code> 字段和 <code>email</code> 参数同名，只需写 <code>email</code> 而非 <code>email: email</code>。</p>
<h3 id="creating-instances-from-other-instances-with-struct-update-syntax-使用结构体更新语法从其他实例创建"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax-使用结构体更新语法从其他实例创建">Creating Instances from Other Instances with Struct Update Syntax 使用结构体更新语法从其他实例创建</a></h3>
<p>It’s often useful to create a new instance of a struct that includes most of
the values from another instance of the same type, but changes some. You can do
this using <em>struct update syntax</em>.</p>
<p>创建一个结构体的新实例，其中包含来自同类型另一实例的大部分值但修改部分字段，通常很有用。这可以通过<strong>结构体更新语法</strong>实现。</p>
<p>First, in Listing 5-6 we show how to create a new <code>User</code> instance in <code>user2</code>
regularly, without the update syntax. We set a new value for <code>email</code> but
otherwise use the same values from <code>user1</code> that we created in Listing 5-2.</p>
<p>首先，示例5-6展示了如何在不使用更新语法的情况下常规创建 <code>user2</code> 的新 <code>User</code> 实例。我们为 <code>email</code> 设置新值，其余值沿用示例5-2中创建的 <code>user1</code>。</p>
<figure class="listing" id="listing-5-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-6">Listing 5-6</a>: Creating a new <code>User</code> instance using all but one of the values from <code>user1</code> 使用 <code>user1</code> 中除一个值外的所有值创建新 <code>User</code> 实例</figcaption>
</figure>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.</p>
<p>使用结构体更新语法，我们可以用更少的代码实现相同效果，如示例5-7所示。<span class="highlight">[note]<code>..</code> 语法指定未显式设置的剩余字段应与给定实例中的字段同值。</span></p>
<figure class="listing" id="listing-5-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
<figcaption><a href="ch05-01-defining-structs.html#listing-5-7">Listing 5-7</a>: Using struct update syntax to set a new <code>email</code> value for a <code>User</code> instance but to use the rest of the values from <code>user1</code> 使用结构体更新语法为 <code>User</code> 实例设置新 <code>email</code> 值，其余值沿用 <code>user1</code></figcaption>
</figure>
<p>The code in Listing 5-7 also creates an instance in <code>user2</code> that has a
different value for <code>email</code> but has the same values for the <code>username</code>,
<code>active</code>, and <code>sign_in_count</code> fields from <code>user1</code>. The <code>..user1</code> must come last
to specify that any remaining fields should get their values from the
corresponding fields in <code>user1</code>, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.</p>
<p>示例5-7中的代码同样创建了 <code>user2</code> 实例，其 <code>email</code> 值不同，但 <code>username</code>、<code>active</code> 和 <code>sign_in_count</code> 字段的值与 <code>user1</code> 相同。<code>..user1</code> 必须置于最后，表示剩余字段从 <code>user1</code> 的对应字段中取值。我们可以在任意顺序中指定任意多字段的值，无需考虑结构体定义中的字段顺序。</p>
<p>Note that the struct update syntax uses <code>=</code> like an assignment; this is because
it moves the data, just as we saw in the “Variables and Data Interacting with
Move” section. In this example, we can no longer use
<code>user1</code> after creating <code>user2</code> because the <code>String</code> in the <code>username</code> field of
<code>user1</code> was moved into <code>user2</code>. If we had given <code>user2</code> new <code>String</code> values for
both <code>email</code> and <code>username</code>, and thus only used the <code>active</code> and <code>sign_in_count</code>
values from <code>user1</code>, then <code>user1</code> would still be valid after creating <code>user2</code>.
Both <code>active</code> and <code>sign_in_count</code> are types that implement the <code>Copy</code> trait, so
the behavior we discussed in the “Stack-Only Data: Copy”
section would apply. We can also still use <code>user1.email</code> in this example,
because its value was not moved out of <code>user1</code>.</p>
<p>注意：<span class="highlight">[note]结构体更新语法使用 <code>=</code> 进行赋值，这是因为它会移动数据</span>，正如我们在“变量与数据的交互：移动”章节所见。此例中，创建 <code>user2</code> 后无法再使用 <code>user1</code>，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>String</code> 已被移动到 <code>user2</code>。若我们为 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都赋予新 <code>String</code> 值，从而仅使用 <code>user1</code> 的 <code>active</code> 和 <code>sign_in_count</code> 值，那么创建 <code>user2</code> 后 <code>user1</code> 仍然有效。因为 <code>active</code> 和 <code>sign_in_count</code> 是实现了 <code>Copy</code> trait 的类型，符合“仅栈数据：拷贝”章节讨论的行为。此例中仍可使用 <code>user1.email</code>，因为其值未被移出 <code>user1</code>。</p>
<h3 id="using-tuple-structs-without-named-fields-to-create-different-types-使用元组结构体创建无名字段的不同类型"><a class="header" href="#using-tuple-structs-without-named-fields-to-create-different-types-使用元组结构体创建无名字段的不同类型">Using Tuple Structs Without Named Fields to Create Different Types 使用元组结构体创建无名字段的不同类型</a></h3>
<p>Rust also supports structs that look similar to tuples, called <em>tuple structs</em>.
Tuple structs have the added meaning the struct name provides but don’t have
names associated with their fields; rather, they just have the types of the
fields. Tuple structs are useful when you want to give the whole tuple a name
and make the tuple a different type from other tuples, and when naming each
field as in a regular struct would be verbose or redundant.</p>
<p>Rust 也支持类似元组的结构体，称为<strong>元组结构体</strong>（tuple structs）。<span class="highlight">[note]元组结构体通过结构体名称提供附加含义，但字段没有关联名称</span>；仅包含字段类型。当你想为整个元组命名并使其区别于其他元组类型，或为每个字段命名（如常规结构体）会显得冗长或多余时，元组结构体非常有用。</p>
<p>To define a tuple struct, start with the <code>struct</code> keyword and the struct name
followed by the types in the tuple. For example, here we define and use two
tuple structs named <code>Color</code> and <code>Point</code>:</p>
<p>定义元组结构体时，以 <code>struct</code> 关键字和结构体名称开头，后跟元组中的类型。例如，此处定义并使用了两个名为 <code>Color</code> 和 <code>Point</code> 的元组结构体：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</figure>
<p>Note that the <code>black</code> and <code>origin</code> values are different types because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct might have the same types. For
example, a function that takes a parameter of type <code>Color</code> cannot take a
<code>Point</code> as an argument, even though both types are made up of three <code>i32</code>
values. Otherwise, tuple struct instances are similar to tuples in that you can
destructure them into their individual pieces, and you can use a <code>.</code> followed
by the index to access an individual value. Unlike tuples, tuple structs
require you to name the type of the struct when you destructure them. For
example, we would write <code>let Point(x, y, z) = origin;</code> to destructure the
values in the <code>origin</code> point into variables named <code>x</code>, <code>y</code>, and <code>z</code>.</p>
<p>注意：<code>black</code> 和 <code>origin</code> 属于不同类型，因为它们是不同元组结构体的实例。即使结构体内字段类型相同，你定义的每个结构体仍是独立类型。例如，接收 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，尽管两者都由三个 <code>i32</code> 值组成。除此之外，元组结构体实例的行为类似于元组：可解构为单独部分，也可用 <code>.</code> 后跟索引访问单个值。与元组不同的是，<span class="highlight">[note]解构元组结构体时需要声明结构体类型</span>。例如，解构 <code>origin</code> 点中的值到变量 <code>x</code>、<code>y</code> 和 <code>z</code> 需写作：<code>let Point(x, y, z) = origin;</code>。</p>
<h3 id="unit-like-structs-without-any-fields-无字段的类单元结构体"><a class="header" href="#unit-like-structs-without-any-fields-无字段的类单元结构体">Unit-Like Structs Without Any Fields 无字段的类单元结构体</a></h3>
<p>You can also define structs that don’t have any fields! These are called
<em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type that
we mentioned in “The Tuple Type” section. Unit-like
structs can be useful when you need to implement a trait on some type but don’t
have any data that you want to store in the type itself. We’ll discuss traits
in Chapter 10. Here’s an example of declaring and instantiating a unit struct
named <code>AlwaysEqual</code>:</p>
<p><span class="highlight">[note]你也可以定义没有任何字段的结构体！它们被称为<strong>类单元结构体</strong>（unit-like structs），因为其行为类似于 <code>()</code>（我们在“元组类型”章节提到的单元类型）。当需要在某类型上实现 trait 但不想在类型本身中存储任何数据时，类单元结构体很有用。</span>我们将在第10章讨论 trait。以下示例声明并实例化了名为 <code>AlwaysEqual</code> 的类单元结构体：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</figure>
<p>To define <code>AlwaysEqual</code>, we use the <code>struct</code> keyword, the name we want, and
then a semicolon. No need for curly brackets or parentheses! Then we can get an
instance of <code>AlwaysEqual</code> in the <code>subject</code> variable in a similar way: using the
name we defined, without any curly brackets or parentheses. Imagine that later
we’ll implement behavior for this type such that every instance of
<code>AlwaysEqual</code> is always equal to every instance of any other type, perhaps to
have a known result for testing purposes. We wouldn’t need any data to
implement that behavior! You’ll see in Chapter 10 how to define traits and
implement them on any type, including unit-like structs.</p>
<p>定义 <code>AlwaysEqual</code> 时，使用 <code>struct</code> 关键字、名称后加分号，无需大括号或圆括号！随后可用类似方式在 <code>subject</code> 变量中获取 <code>AlwaysEqual</code> 实例：使用定义的名称，不加任何大括号或圆括号。假设之后我们会为这种类型实现行为：每个 <code>AlwaysEqual</code> 实例始终等于任何其他类型的实例（可能用于测试目的）。实现该行为不需要任何数据！第10章将介绍如何定义 trait 并在任意类型（包括类单元结构体）上实现它们。</p>
<section class="note" aria-role="note">
<h3 id="ownership-of-struct-data-结构体数据的所有权"><a class="header" href="#ownership-of-struct-data-结构体数据的所有权">Ownership of Struct Data 结构体数据的所有权</a></h3>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code>
type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice
because we want each instance of this struct to own all of its data and for
that data to be valid for as long as the entire struct is valid.</p>
<p>在示例5-1的 <code>User</code> 结构体定义中，我们使用了自有类型 <code>String</code> 而非字符串切片 <code>&amp;str</code>。这是有意为之，因为我们希望此结构体的每个实例都拥有其全部数据，且只要整个结构体有效，其数据就有效。</p>
<p>It’s also possible for structs to store references to data owned by something
else, but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll
discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
is valid for as long as the struct is. Let’s say you try to store a reference
in a struct without specifying lifetimes, like the following; this won’t work:</p>
<p>结构体也可以存储指向其他位置数据的引用，但这需要使用<strong>生命周期</strong>（Rust 的特性，将在第10章讨论）。生命周期确保结构体引用的数据在结构体有效期间持续有效。假设你尝试在结构体中存储未指定生命周期的引用（如下所示），这将无法工作：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</figure>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<p>编译器会提示需要生命周期标识符：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store
references in structs, but for now, we’ll fix errors like these using owned
types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
<p>第10章将讨论如何修复这些错误以在结构体中存储引用，但目前我们使用自有类型（如 <code>String</code>）替代引用（如 <code>&amp;str</code>）来解决此类问题。</p>
</section><div style="break-before: page; page-break-before: always;"></div><h2 id="an-example-program-using-structs-使用结构体的示例程序"><a class="header" href="#an-example-program-using-structs-使用结构体的示例程序">An Example Program Using Structs 使用结构体的示例程序</a></h2>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start by using single variables, and
then refactor the program until we’re using structs instead.</p>
<p>为了理解何时使用结构体，我们将编写一个计算矩形面积的程序。首先使用单变量实现，然后逐步重构，最终用结构体替代。</p>
<p>Let’s make a new binary project with Cargo called <em>rectangles</em> that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s <em>src/main.rs</em>.</p>
<p>使用 Cargo 创建一个名为 <em>rectangles</em> 的二进制项目，它将接收以像素为单位的矩形宽度和高度，并计算矩形面积。代码清单 5-8 展示了项目 <em>src/main.rs</em> 中的实现方式：</p>
<figure class="listing" id="listing-5-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
<figcaption><a href="ch05-02-example-structs.html#listing-5-8">Listing 5-8</a>: Calculating the area of a rectangle specified by separate width and height variables 通过独立的宽高变量计算矩形面积</figcaption>
</figure>
<p>Now, run this program using <code>cargo run</code>:</p>
<p>使用 <code>cargo run</code> 运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>This code succeeds in figuring out the area of the rectangle by calling the
<code>area</code> function with each dimension, but we can do more to make this code clear
and readable.</p>
<p>此代码通过向 <code>area</code> 函数传入两个维度成功计算出面积，但我们可以优化代码使其更清晰易读。</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<p>问题体现在 <code>area</code> 的函数签名中：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "The area of the rectangle is {} square pixels.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters, and it’s not clear anywhere in our
program that the parameters are related. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in “The Tuple Type” section
of Chapter 3: by using tuples.</p>
<p><code>area</code> 函数本应计算单个矩形面积，但我们编写的函数有两个参数，且参数间的关联性不明确。将宽高组合在一起会更清晰易管理。第三章的[“元组类型”]章节已讨论过用元组实现的方式。</p>
<h3 id="refactoring-with-tuples--使用元组重构"><a class="header" href="#refactoring-with-tuples--使用元组重构">Refactoring with Tuples  使用元组重构</a></h3>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<p>代码清单 5-9 展示了使用元组的版本：</p>
<figure class="listing" id="listing-5-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
<figcaption><a href="ch05-02-example-structs.html#listing-5-9">Listing 5-9</a>: Specifying the width and height of the rectangle with a tuple 使用元组表示矩形宽高</figcaption>
</figure>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so we have to index into the parts of
the tuple, making our calculation less obvious.</p>
<p>一方面此版本更优：元组提供了基础结构，且只需传递一个参数。但另一方面清晰度下降：元组元素未命名，需通过索引访问，降低了计算逻辑的直观性。</p>
<p>Mixing up the width and height wouldn’t matter for the area calculation, but if
we want to draw the rectangle on the screen, it would matter! We would have to
keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple
index <code>1</code>. This would be even harder for someone else to figure out and keep in
mind if they were to use our code. Because we haven’t conveyed the meaning of
our data in our code, it’s now easier to introduce errors.</p>
<p>混淆宽高虽不影响面积计算，但在屏幕绘制矩形时会产生问题！我们必须记住 <code>width</code> 对应元组索引 <code>0</code>，<code>height</code> 对应索引 <code>1</code>。这对其他使用者而言更易出错，因为我们未在代码中体现数据的含义。</p>
<h3 id="refactoring-with-structs-adding-more-meaning-使用结构体重构增强语义"><a class="header" href="#refactoring-with-structs-adding-more-meaning-使用结构体重构增强语义">Refactoring with Structs: Adding More Meaning 使用结构体重构：增强语义</a></h3>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a struct with a name for the whole as well as names for the
parts, as shown in Listing 5-10.</p>
<p>我们通过结构体为数据添加标签来明确含义。如代码清单 5-10 所示，可将元组转换为具有整体命名和字段命名的结构体：</p>
<figure class="listing" id="listing-5-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
<figcaption><a href="ch05-02-example-structs.html#listing-5-10">Listing 5-10</a>: Defining a <code>Rectangle</code> struct 定义 <code>Rectangle</code> 结构体</figcaption>
</figure>
<p>Here, we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly
brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have
type <code>u32</code>. Then, in <code>main</code>, we created a particular instance of <code>Rectangle</code>
that has a width of <code>30</code> and a height of <code>50</code>.</p>
<p>这里定义了名为 <code>Rectangle</code> 的结构体，其内部包含 <code>u32</code> 类型的 <code>width</code> 和 <code>height</code> 字段。在 <code>main</code> 中创建了宽 <code>30</code>、高 <code>50</code> 的结构体实例。</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p><code>area</code> 函数现在接收一个名为 <code>rectangle</code> 的参数，其类型是对 <code>Rectangle</code> 实例的不可变借用。如第四章所述，我们选择借用而非获取所有权，这样 <code>main</code> 函数可保留所有权并继续使用 <code>rect1</code>，这也是函数签名和使用处添加 <code>&amp;</code> 的原因。</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code>
instance (note that accessing fields of a borrowed struct instance does not
move the field values, which is why you often see borrows of structs). Our
function signature for <code>area</code> now says exactly what we mean: calculate the area
of <code>Rectangle</code>, using its <code>width</code> and <code>height</code> fields. This conveys that the
width and height are related to each other, and it gives descriptive names to
the values rather than using the tuple index values of <code>0</code> and <code>1</code>. This is a
win for clarity.</p>
<p><code>area</code> 函数访问 <code>Rectangle</code> 实例的字段（注意：访问借用结构体的字段不会移动值）。现在的函数签名精准表达了意图：利用 <code>width</code> 和 <code>height</code> 字段计算矩形面积。这明确了宽高的关联性，并提供了描述性名称而非元组索引 <code>0</code> 和 <code>1</code>，显著提升了代码清晰度。</p>
<h3 id="adding-useful-functionality-with-derived-traits-通过派生-trait-增加实用功能"><a class="header" href="#adding-useful-functionality-with-derived-traits-通过派生-trait-增加实用功能">Adding Useful Functionality with Derived Traits 通过派生 trait 增加实用功能</a></h3>
<p>It’d be useful to be able to print an instance of <code>Rectangle</code> while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the <code>println!</code> macro as we have used in
previous chapters. This won’t work, however.</p>
<p>调试时若能打印 <code>Rectangle</code> 实例及其字段值将非常有用。代码清单 5-11 尝试使用 <code>println!</code> 宏，但无法正常工作：</p>
<figure class="listing" id="listing-5-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1}");
}</code></pre>
<figcaption><a href="ch05-02-example-structs.html#listing-5-11">Listing 5-11</a>: Attempting to print a <code>Rectangle</code> instance 尝试打印 <code>Rectangle</code> 实例</figcaption>
</figure>
<p>When we compile this code, we get an error with this core message:</p>
<p>编译时将出现核心错误信息：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, the curly
brackets tell <code>println!</code> to use formatting known as <code>Display</code>: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement <code>Display</code> by default because there’s only one way you’d want to show
a <code>1</code> or any other primitive type to a user. But with structs, the way
<code>println!</code> should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn’t try to guess what we want, and structs don’t have a provided
implementation of <code>Display</code> to use with <code>println!</code> and the <code>{}</code> placeholder.</p>
<p><code>println!</code> 宏支持多种格式化，默认花括号要求使用 <code>Display</code> 格式（面向最终用户的输出）。基础类型默认实现 <code>Display</code>，但结构体存在多种显示方式（是否加逗号/花括号？显示哪些字段？），因此 Rust 不进行猜测，结构体也未提供 <code>Display</code> 实现。</p>
<p>If we continue reading the errors, we’ll find this helpful note:</p>
<p>继续阅读错误会发现提示：</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Let’s try it! The <code>println!</code> macro call will now look like <code>println!("rect1 is  {rect1:?}");</code>. Putting the specifier <code>:?</code> inside the curly brackets tells
<code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code> trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.</p>
<p>尝试修改为 <code>println!("rect1 是 {rect1:?}");</code>。在花括号内添加 <code>:?</code> 指定使用 <code>Debug</code> 输出格式，该 trait 专为开发者设计，可在调试时查看值。</p>
<p>Compile the code with this change. Drat! We still get an error:</p>
<p>但修改后仍报错：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<p>编译器再次给出提示：</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>does</em> include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the outer attribute <code>#[derive(Debug)]</code> just before the
struct definition, as shown in Listing 5-12.</p>
<p>Rust 包含调试输出功能，但需显式为结构体启用。如代码清单 5-12 所示，在结构体定义前添加 <code>#[derive(Debug)]</code> 属性：</p>
<figure class="listing" id="listing-5-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}</code></pre></pre>
<figcaption><a href="ch05-02-example-structs.html#listing-5-12">Listing 5-12</a>: Adding the attribute to derive the <code>Debug</code> trait and printing the <code>Rectangle</code> instance using debug formatting 添加派生 <code>Debug</code> 属性并使用调试格式化输出</figcaption>
</figure>
<p>Now when we run the program, we won’t get any errors, and we’ll see the
following output:</p>
<p>运行程序将成功输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string. In
this example, using the <code>{:#?}</code> style will output the following:</p>
<p>虽然输出不够美观，但完整展示了字段值，对调试极有帮助。大型结构体可使用 <code>{:#?}</code> 替代 <code>{:?}</code> 获得更易读的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Another way to print out a value using the <code>Debug</code> format is to use the <code>dbg!</code>
macro, which takes ownership of an expression (as opposed
to <code>println!</code>, which takes a reference), prints the file and line number of
where that <code>dbg!</code> macro call occurs in your code along with the resultant value
of that expression, and returns ownership of the value.</p>
<p>另一种调试方式是使用 <code>dbg!</code> 宏。它会获取表达式所有权（而 <code>println!</code> 使用引用），输出调用位置的文件名、行号及结果值，并返回所有权。</p>
<section class="note" aria-role="note">
<p>Note: Calling the <code>dbg!</code> macro prints to the standard error console stream
(<code>stderr</code>), as opposed to <code>println!</code>, which prints to the standard output
console stream (<code>stdout</code>). We’ll talk more about <code>stderr</code> and <code>stdout</code> in the
“Writing Error Messages to Standard Error Instead of Standard Output”
section in Chapter 12.</p>
<p>注意：<code>dbg!</code> 输出到标准错误流（<code>stderr</code>），而 <code>println!</code> 输出到标准输出流（<code>stdout</code>）。第十二章[“将错误信息输出到标准错误流”]将详细讨论。</p>
</section>
<p>Here’s an example where we’re interested in the value that gets assigned to the
<code>width</code> field, as well as the value of the whole struct in <code>rect1</code>:</p>
<p>以下示例同时查看 <code>width</code> 字段和整个结构体的值：</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>We can put <code>dbg!</code> around the expression <code>30 * scale</code> and, because <code>dbg!</code>
returns ownership of the expression’s value, the <code>width</code> field will get the
same value as if we didn’t have the <code>dbg!</code> call there. We don’t want <code>dbg!</code> to
take ownership of <code>rect1</code>, so we use a reference to <code>rect1</code> in the next call.
Here’s what the output of this example looks like:</p>
<p>将 <code>dbg!</code> 置于表达式 <code>30 * scale</code> 周围时，因其返回表达式值的所有权，<code>width</code> 字段仍会获得原值。后续调用中使用 <code>rect1</code> 的引用避免所有权转移。输出如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>We can see the first bit of output came from <em>src/main.rs</em> line 10 where we’re
debugging the expression <code>30 * scale</code>, and its resultant value is <code>60</code> (the
<code>Debug</code> formatting implemented for integers is to print only their value). The
<code>dbg!</code> call on line 14 of <em>src/main.rs</em> outputs the value of <code>&amp;rect1</code>, which is
the <code>Rectangle</code> struct. This output uses the pretty <code>Debug</code> formatting of the
<code>Rectangle</code> type. The <code>dbg!</code> macro can be really helpful when you’re trying to
figure out what your code is doing!</p>
<p>首行输出来自 <em>src/main.rs</em> 第 10 行对 <code>30 * scale</code> 的调试（结果为 <code>60</code>）。第 14 行输出 <code>&amp;rect1</code> 的值（即 <code>Rectangle</code> 结构体）。<code>dbg!</code> 宏在代码调试中极为实用！</p>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us
to use with the <code>derive</code> attribute that can add useful behavior to our custom
types. Those traits and their behaviors are listed in Appendix C. We’ll cover how to implement these traits with custom behavior as
well as how to create your own traits in Chapter 10. There are also many
attributes other than <code>derive</code>; for more information, see the “Attributes”
section of the Rust Reference.</p>
<p>除 <code>Debug</code> 外，Rust 还提供大量可通过 <code>derive</code> 属性派生的 trait（附录 C 列出完整列表），它们能为自定义类型添加有用行为。第十章将介绍如何实现自定义 trait 及创建新 trait。更多属性详见 Rust 参考手册的[“属性”]章节。</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code> struct
because it won’t work with any other type. Let’s look at how we can continue to
refactor this code by turning the <code>area</code> function into an <code>area</code> <em>method</em>
defined on our <code>Rectangle</code> type.</p>
<p>当前 <code>area</code> 函数仅适用于矩形。若能将此行为与 <code>Rectangle</code> 结构体更紧密绑定将更合理。接下来我们将把 <code>area</code> 函数重构为 <code>Rectangle</code> 类型的<strong>方法</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="method-syntax-方法"><a class="header" href="#method-syntax-方法">Method Syntax 方法</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait
object, which we cover in Chapter 6 and Chapter
18, respectively), and their first parameter is
always <code>self</code>, which represents the instance of the struct the method is being
called on.</p>
<p><strong>方法</strong>（method）与函数类似：使用 <code>fn</code> 关键字声明并命名，可包含参数和返回值，并拥有在方法被调用时执行的代码。与函数不同之处在于，方法定义在结构体（或枚举、trait 对象，我们将在第 6 章和第 18 章分别介绍）的上下文中，且它们的第一个参数始终是 <code>self</code>，表示调用该方法的结构体实例。</p>
<h3 id="defining-methods-定义方法"><a class="header" href="#defining-methods-定义方法">Defining Methods 定义方法</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13.</p>
<p>让我们将接受 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改为定义在 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示。</p>
<figure class="listing" id="listing-5-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
<figcaption><a href="ch05-03-method-syntax.html#listing-5-13">Listing 5-13</a>: Defining an <code>area</code> method on the <code>Rectangle</code> struct 在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</figcaption>
</figure>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block
will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function
within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>要在 <code>Rectangle</code> 的上下文中定义函数，我们需为 <code>Rectangle</code> 开启一个 <code>impl</code>（实现）块。该 <code>impl</code> 块内的所有内容都将与 <code>Rectangle</code> 类型关联。接着将 <code>area</code> 函数移至 <code>impl</code> 的花括号内，并将签名和函数体中的第一个（本例中也是唯一一个）参数改为 <code>self</code>。在 <code>main</code> 函数中，原先调用 <code>area</code> 函数并传入 <code>rect1</code> 作为参数的地方，现在可使用<strong>方法语法</strong>（method syntax）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法位于实例之后：添加点号 <code>.</code>，后接方法名、括号及参数。</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>.
The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the
type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must
have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust
lets you abbreviate this with only the name <code>self</code> in the first parameter spot.
Note that we still need to use the <code>&amp;</code> in front of the <code>self</code> shorthand to
indicate that this method borrows the <code>Self</code> instance, just as we did in
<code>rectangle: &amp;Rectangle</code>. Methods can take ownership of <code>self</code>, borrow <code>self</code>
immutably, as we’ve done here, or borrow <code>self</code> mutably, just as they can any
other parameter.</p>
<p>在 <code>area</code> 的签名中，我们使用 <code>&amp;self</code> 替代了 <code>rectangle: &amp;Rectangle</code>。<span class="highlight">[note]<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的简写。在 <code>impl</code> 块中，<code>Self</code> 类型是该 <code>impl</code> 块所属类型的别名。</span>方法的第一个参数必须是名为 <code>self</code> 且类型为 <code>Self</code> 的参数，因此 Rust 允许在第一个参数位置仅使用 <code>self</code> 作为缩写。注意我们仍需在 <code>self</code> 简写前添加 <code>&amp;</code> 表示此方法借用了 <code>Self</code> 实例，正如我们在 <code>rectangle: &amp;Rectangle</code> 中所做的那样。方法可以获取 <code>self</code> 的所有权、不可变借用 <code>self</code>（如本例），或可变借用 <code>self</code>，与其他参数的处理方式一致。</p>
<p>We chose <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function
version: we don’t want to take ownership, and we just want to read the data in
the struct, not write to it. If we wanted to change the instance that we’ve
called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as
the first parameter. Having a method that takes ownership of the instance by
using just <code>self</code> as the first parameter is rare; this technique is usually
used when the method transforms <code>self</code> into something else and you want to
prevent the caller from using the original instance after the transformation.</p>
<p>此处选择 <code>&amp;self</code> 的原因与函数版本中使用 <code>&amp;Rectangle</code> 相同：我们不想获取所有权，仅需读取结构体数据而不写入。若想在方法执行过程中修改调用方法的实例，则需将第一个参数设为 <code>&amp;mut self</code>。使用仅含 <code>self</code> 作为第一个参数的方法获取实例所有权的情况较为罕见；通常用于方法将 <code>self</code> 转换为其他内容且需防止调用者在转换后使用原实例的场景。</p>
<p>The main reason for using methods instead of functions, in addition to
providing method syntax and not having to repeat the type of <code>self</code> in every
method’s signature, is for organization. We’ve put all the things we can do
with an instance of a type in one <code>impl</code> block rather than making future users
of our code search for capabilities of <code>Rectangle</code> in various places in the
library we provide.</p>
<p>使用方法而非函数的主要原因，除了提供方法语法及避免在每个方法签名中重复 <code>self</code> 的类型外，还在于组织性。我们将类型实例能执行的所有操作集中在一个 <code>impl</code> 块中，避免代码使用者在我们提供的库中四处查找 <code>Rectangle</code> 的功能。</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> that is also named
<code>width</code>:</p>
<p>注意，我们可以选择为方法赋予与结构体字段相同的名称。例如，可在 <code>Rectangle</code> 上定义一个同样名为 <code>width</code> 的方法：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}</code></pre></pre>
</figure>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is
<code>0</code>: we can use a field within a method of the same name for any purpose. In
<code>main</code>, when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the
method <code>width</code>. When we don’t use parentheses, Rust knows we mean the field
<code>width</code>.</p>
<p>在此，若实例的 <code>width</code> 字段值大于 <code>0</code>，则让 <code>width</code> 方法返回 <code>true</code>；若值为 <code>0</code> 则返回 <code>false</code>：在方法中可使用同名字段实现任何目的。在 <code>main</code> 中，当在 <code>rect1.width</code> 后添加括号时，Rust 知道我们指的是 <code>width</code> 方法；不加括号时，则指 <code>width</code> 字段。</p>
<p>Often, but not always, when we give a method the same name as a field we want
it to only return the value in the field and do nothing else. Methods like this
are called <em>getters</em>, and Rust does not implement them automatically for struct
fields as some other languages do. Getters are useful because you can make the
field private but the method public, and thus enable read-only access to that
field as part of the type’s public API. We will discuss what public and private
are and how to designate a field or method as public or private in Chapter 7.</p>
<p>通常（非绝对），当方法名与字段名相同时，我们希望它仅返回字段值而不做其他操作。此类方法称为 <strong>getter</strong>，Rust 不会像其他语言那样自动为结构体字段实现它们。Getters 很有用，因为可将字段设为私有而方法公开，从而通过类型的公共 API 提供对该字段的只读访问权限。我们将在第 7 章讨论公有与私有的概念及如何将字段或方法标记为公有或私有。</p>
<section class="note" aria-role="note">
<h3 id="wheres-the---operator---运算符在哪"><a class="header" href="#wheres-the---operator---运算符在哪">Where’s the <code>-&gt;</code> Operator? <code>-&gt;</code> 运算符在哪？</a></h3>
<p>In C and C++, two different operators are used for calling methods: you use
<code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re
calling the method on a pointer to the object and need to dereference the
pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>在 C/C++ 中，调用方法使用两种运算符：直接调用对象方法时用 <code>.</code>，调用指针对象的方法时用 <code>-&gt;</code>（需先解引用指针）。换言之，若 <code>object</code> 是指针，则 <code>object-&gt;something()</code> 类似于 <code>(*object).something()</code>。</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust with this behavior.</p>
<p><span class="highlight">[note]Rust 没有等效的 <code>-&gt;</code> 运算符，而是提供了<strong>自动引用与解引用</strong>（automatic referencing and dereferencing）功能。方法调用是 Rust 中少数具有此行为的场景之一。</span></p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of
the method. In other words, the following are the same:</p>
<p>其工作原理如下：当使用 <code>object.()</code> 调用方法时，Rust 会自动添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以使 <code>object</code> 匹配方法的签名。换言之，以下两种写法等价：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
<p>第一种形式更简洁。这种自动引用行为有效是因为方法具有明确的接收者（<code>self</code> 的类型）。根据接收者和方法名，Rust 可明确判断方法是读取（<code>&amp;self</code>）、修改（<code>&amp;mut self</code>）还是消费（<code>self</code>）。Rust 对方法接收者隐式处理借用的特性，是实现所有权实践人体工程学的重要部分。</p>
</section>
<h3 id="methods-with-more-parameters-带更多参数的方法"><a class="header" href="#methods-with-more-parameters-带更多参数的方法">Methods with More Parameters 带更多参数的方法</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise, it should return <code>false</code>.
That is, once we’ve defined the <code>can_hold</code> method, we want to be able to write
the program shown in Listing 5-14.</p>
<p>让我们通过为 <code>Rectangle</code> 结构体实现第二个方法 <code>can_hold</code> 来练习方法的使用。此方法接受另一个 <code>Rectangle</code> 实例，若该实例能完全容纳在 <code>self</code>（第一个 <code>Rectangle</code>）内则返回 <code>true</code>，否则返回 <code>false</code>。定义 <code>can_hold</code> 方法后，我们希望编写如示例 5-14 所示的程序。</p>
<figure class="listing" id="listing-5-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
<figcaption><a href="ch05-03-method-syntax.html#listing-5-14">Listing 5-14</a>: Using the as-yet-unwritten <code>can_hold</code> method 使用尚未编写的 <code>can_hold</code> 方法</figcaption>
</figure>
<p>The expected output would look like the following because both dimensions of
<code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<p>由于 <code>rect2</code> 的尺寸小于 <code>rect1</code> 而 <code>rect3</code> 比 <code>rect1</code> 宽，预期输出如下：</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-13, shown in Listing 5-15.</p>
<p>我们想定义方法，因此它将位于 <code>impl Rectangle</code> 块中。方法名为 <code>can_hold</code>，参数为另一个 <code>Rectangle</code> 的不可变借用。通过调用代码 <code>rect1.can_hold(&amp;rect2)</code> 可知参数类型：传入的 <code>&amp;rect2</code> 是对 <code>rect2</code>（<code>Rectangle</code> 实例）的不可变借用。这很合理，因为我们只需读取 <code>rect2</code>（无需写入，否则需可变借用），且希望 <code>main</code> 保留 <code>rect2</code> 的所有权以便在调用 <code>can_hold</code> 后再次使用。<code>can_hold</code> 的返回值是布尔值，其实现将检查 <code>self</code> 的宽高是否分别大于另一个 <code>Rectangle</code> 的宽高。让我们将新的 <code>can_hold</code> 方法添加到示例 5-13 的 <code>impl</code> 块中，如示例 5-15 所示。</p>
<figure class="listing" id="listing-5-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch05-03-method-syntax.html#listing-5-15">Listing 5-15</a>: Implementing the <code>can_hold</code> method on <code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter 在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，该方法接受另一个 <code>Rectangle</code> 实例作为参数</figcaption>
</figure>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<p>结合示例 5-14 的 <code>main</code> 函数运行此代码，将得到预期输出。方法可接受多个参数，这些参数添加在 <code>self</code> 参数后的签名中，其工作方式与函数参数一致。</p>
<h3 id="associated-functions-关联函数"><a class="header" href="#associated-functions-关联函数">Associated Functions 关联函数</a></h3>
<p>All functions defined within an <code>impl</code> block are called <em>associated functions</em>
because they’re associated with the type named after the <code>impl</code>. We can define
associated functions that don’t have <code>self</code> as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.
We’ve already used one function like this: the <code>String::from</code> function that’s
defined on the <code>String</code> type.</p>
<p>所有定义在 <code>impl</code> 块中的函数称为<strong>关联函数</strong>（associated function），因为它们与 <code>impl</code> 后的类型相关联。<span class="highlight">[note]可定义不以 <code>self</code> 为第一参数的关联函数</span>（因此不是方法），因为它们不需要类型的实例来工作。我们已使用过此类函数：定义在 <code>String</code> 类型上的 <code>String::from</code> 函数。</p>
<p>Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p>非方法的关联函数常用于返回结构体新实例的构造函数，通常命名为 <code>new</code>，但 <code>new</code> 并非语言内置关键字。例如，可提供名为 <code>square</code> 的关联函数，它接受一个维度参数并同时作为宽高，从而更便捷地创建正方形 <code>Rectangle</code>，无需重复指定相同值：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>Self</code> keywords in the return type and in the body of the function are
aliases for the type that appears after the <code>impl</code> keyword, which in this case
is <code>Rectangle</code>.</p>
<p>函数返回值类型和函数体中的 <code>Self</code> 关键字是 <code>impl</code> 关键字后类型（本例为 <code>Rectangle</code>）的别名。</p>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;
<code>let sq = Rectangle::square(3);</code> is an example. This function is namespaced by
the struct: the <code>::</code> syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.</p>
<p>调用此关联函数需使用结构体名加 <code>::</code> 语法：例如 <code>let sq = Rectangle::square(3);</code>。此函数由结构体命名空间限定：<code>::</code> 语法既用于关联函数，也用于模块创建的命名空间。我们将在第 7 章讨论模块。</p>
<h3 id="multiple-impl-blocks-多个-impl-块"><a class="header" href="#multiple-impl-blocks-多个-impl-块">Multiple <code>impl</code> Blocks 多个 <code>impl</code> 块</a></h3>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method in
its own <code>impl</code> block.</p>
<p>每个结构体允许有多个 <code>impl</code> 块。例如，示例 5-15 的代码等价于示例 5-16（每个方法位于独立的 <code>impl</code> 块中）。</p>
<figure class="listing" id="listing-5-16">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch05-03-method-syntax.html#listing-5-16">Listing 5-16</a>: Rewriting Listing 5-15 using multiple <code>impl</code> blocks 使用多个 <code>impl</code> 块重写示例 5-15</figcaption>
</figure>
<p>There’s no reason to separate these methods into multiple <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple <code>impl</code> blocks are
useful in Chapter 10, where we discuss generic types and traits.</p>
<p>此处无需将这些方法拆分到多个 <code>impl</code> 块，但这是有效语法。在第 10 章讨论泛型和 trait 时，我们会看到多 <code>impl</code> 块的应用场景。</p>
<h2 id="summary-总结-4"><a class="header" href="#summary-总结-4">Summary 总结</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In <code>impl</code> blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.</p>
<p>结构体让你能创建自定义类型以契合问题域。通过结构体，可将关联数据保持连接状态，并为各部分命名使代码清晰。在 <code>impl</code> 块中，可定义与类型关联的函数，而方法作为一种关联函数，能指定结构体实例的行为。</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.</p>
<p>但结构体并非创建自定义类型的唯一方式：接下来我们将介绍 Rust 的枚举功能，为你的工具箱再添利器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-pattern-matching-枚举与模式匹配"><a class="header" href="#enums-and-pattern-matching-枚举与模式匹配">Enums and Pattern Matching 枚举与模式匹配</a></h1>
<p>In this chapter, we’ll look at <em>enumerations</em>, also referred to as <em>enums</em>.
Enums allow you to define a type by enumerating its possible <em>variants</em>. First
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called <code>Option</code>, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the <code>match</code> expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the <code>if let</code>
construct is another convenient and concise idiom available to handle enums in
your code.</p>
<p>本章将探讨<strong>枚举</strong>（enumerations），通常简称为<strong>enums</strong>。枚举允许您通过列举其可能的<strong>变体</strong>（variants）来定义类型。首先我们将定义并使用枚举来展示其如何将数据与含义结合。接着我们将探索一个特别实用的枚举<code>Option</code>，它表示一个值可以是某个值或空值。然后我们将了解<code>match</code>表达式中的模式匹配如何简化针对不同枚举值的代码执行。最后，我们会介绍<code>if let</code>结构——另一种处理枚举的便捷简洁语法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-an-enum-定义枚举"><a class="header" href="#defining-an-enum-定义枚举">Defining an Enum 定义枚举</a></h2>
<p>Where structs give you a way of grouping together related fields and data, like
a <code>Rectangle</code> with its <code>width</code> and <code>height</code>, enums give you a way of saying a
value is one of a possible set of values. For example, we may want to say that
<code>Rectangle</code> is one of a set of possible shapes that also includes <code>Circle</code> and
<code>Triangle</code>. To do this, Rust allows us to encode these possibilities as an enum.</p>
<p>结构体让您能够将相关字段和数据分组（例如包含<code>width</code>和<code>height</code>的<code>Rectangle</code>），而枚举则允许您声明一个值属于可能的取值集合之一。例如，我们可能希望说明<code>Rectangle</code>是包含<code>Circle</code>和<code>Triangle</code>在内的可能形状之一。为此，Rust允许我们将这些可能性编码为枚举。</p>
<p>Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. Because these are the only possibilities for an
IP address that our program will come across, we can <em>enumerate</em> all possible
variants, which is where enumeration gets its name.</p>
<p>让我们看一个我们可能想在代码中表达的情况，并看看为什么在这种情况下枚举比结构体更有用且更合适。假设我们需要处理IP地址。目前IP地址主要使用两个标准：IPv4和IPv6。由于程序只会遇到这两种IP地址，我们可以<strong>枚举</strong>所有可能的变体——这正是枚举名称的由来。</p>
<p>Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate because an enum value can only be one of its variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.</p>
<p>任何IP地址只能是IPv4或IPv6，不能同时是两者。IP地址的这种特性使得枚举数据结构非常适用，因为枚举值只能是其变体之一。IPv4和IPv6地址本质上都是IP地址，因此在处理适用于所有IP地址的场景时，它们应被视为同类型。</p>
<p>We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and
listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are the
variants of the enum:</p>
<p>我们可以通过定义<code>IpAddrKind</code>枚举并在其中列出可能的类型<code>V4</code>和<code>V6</code>，在代码中表达这一概念：</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>
<p>现在<code>IpAddrKind</code>成为了可在代码其他地方使用的自定义数据类型。</p>
<h3 id="enum-values-枚举值"><a class="header" href="#enum-values-枚举值">Enum Values 枚举值</a></h3>
<p>We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p>
<p>我们可以这样创建<code>IpAddrKind</code>两个变体的实例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. This is useful because now both values
<code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type: <code>IpAddrKind</code>. We
can then, for instance, define a function that takes any <code>IpAddrKind</code>:</p>
<p>注意枚举变体位于其标识符的命名空间下，我们使用双冒号进行分隔。这很有用，因为<code>IpAddrKind::V4</code>和<code>IpAddrKind::V6</code>现在属于同一类型<code>IpAddrKind</code>。例如，我们可以定义一个接受任何<code>IpAddrKind</code>的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>And we can call this function with either variant:</p>
<p>并且可以用任一变体调用此函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address <em>data</em>; we
only know what <em>kind</em> it is. Given that you just learned about structs in
Chapter 5, you might be tempted to tackle this problem with structs as shown in
Listing 6-1.</p>
<p>使用枚举还有更多优势。回到IP地址类型，目前我们无法存储实际的IP地址<strong>数据</strong>，只知道其<strong>类型</strong>。鉴于您刚在第5章学习了结构体，可能会想用结构体解决这个问题，如示例6-1所示。</p>
<figure class="listing" id="listing-6-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-01-defining-an-enum.html#listing-6-1">Listing 6-1</a>: Storing the data and <code>IpAddrKind</code> variant of an IP address using a <code>struct</code> 使用结构体存储IP地址数据和<code>IpAddrKind</code>变体</figcaption>
</figure>
<p>Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that
is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field
of type <code>String</code>. We have two instances of this struct. The first is <code>home</code>,
and it has the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address
data of <code>127.0.0.1</code>. The second instance is <code>loopback</code>. It has the other
variant of <code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code>
associated with it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code>
values together, so now the variant is associated with the value.</p>
<p>这里我们定义了结构体<code>IpAddr</code>，它有两个字段：类型为<code>IpAddrKind</code>（先前定义的枚举）的<code>kind</code>字段，和类型为<code>String</code>的<code>address</code>字段。我们创建了这个结构体的两个实例：第一个是<code>home</code>，其<code>kind</code>值为<code>IpAddrKind::V4</code>，关联地址数据为<code>127.0.0.1</code>；第二个实例是<code>loopback</code>，其<code>kind</code>值为另一变体<code>V6</code>，关联地址为<code>::1</code>。我们使用结构体将<code>kind</code>和<code>address</code>值打包在一起，现在变体已与值关联。</p>
<p>However, representing the same concept using just an enum is more concise:
rather than an enum inside a struct, we can put data directly into each enum
variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code>
variants will have associated <code>String</code> values:</p>
<p>但仅用枚举表示相同概念会更简洁：无需将枚举嵌套在结构体中，我们可以直接将数据放入每个枚举变体。<code>IpAddr</code>枚举的新定义表明<code>V4</code>和<code>V6</code>变体都将关联<code>String</code>值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an
extra struct. Here, it’s also easier to see another detail of how enums work:
the name of each enum variant that we define also becomes a function that
constructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call
that takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We
automatically get this constructor function defined as a result of defining the
enum.</p>
<p>我们直接将数据附加到枚举的每个变体，省去了额外的结构体。这里也更容易看到枚举的另一个细节：我们<span class="highlight">[note]定义的每个枚举变体名称也会成为构造枚举实例的函数</span>。即<code>IpAddr::V4()</code>是一个函数调用，它接受<code>String</code>参数并返回<code>IpAddr</code>类型的实例。定义枚举时会自动获得此构造函数。</p>
<p>There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but
still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with
a struct. Enums handle this case with ease:</p>
<p>使用枚举而非结构体还有另一个优势：每个变体可以拥有不同类型和数量的关联数据。IPv4地址总是由四个取值范围在0到255的数值组成。若想将<code>V4</code>地址存储为四个<code>u8</code>值，而<code>V6</code>地址仍存储为<code>String</code>值，结构体无法实现，但枚举可以轻松处理：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that the standard
library has a definition we can use! Let’s look at how
the standard library defines <code>IpAddr</code>: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:</p>
<p>我们展示了多种定义数据结构存储IPv4和IPv6地址的方式。但实际上，存储IP地址并编码其类型的需求如此常见，标准库已提供了定义！让我们看看标准库如何定义<code>IpAddr</code>：它使用了与我们定义完全相同的枚举和变体，但将地址数据嵌入变体中，形式是两个不同的结构体（每个变体有不同定义）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.</p>
<p>这段代码说明您可以在枚举变体中放入任意类型数据：字符串、数值类型或结构体等。甚至可以包含另一个枚举！标准库类型通常也不会比您能想到的复杂多少。</p>
<p>Note that even though the standard library contains a definition for <code>IpAddr</code>,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.</p>
<p>注意：即使标准库包含<code>IpAddr</code>定义，我们仍可创建并使用自己的定义而不会冲突，因为我们尚未将标准库的定义引入作用域。第7章将详细讨论类型引入作用域。</p>
<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.</p>
<p>再看<span class="highlight">[note]示例6-2中的枚举，其变体嵌入了多种类型</span>：</p>
<figure class="listing" id="listing-6-2">
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch06-01-defining-an-enum.html#listing-6-2">Listing 6-2</a>: A <code>Message</code> enum whose variants each store different amounts and types of values <code>Message</code>枚举的变体各自存储不同类型和数量的值</figcaption>
</figure>
<p>This enum has four variants with different types:</p>
<p>该枚举有四个不同类型的变体：</p>
<ul>
<li><code>Quit</code>: Has no data associated with it at all</li>
<li><code>Quit</code>：完全不关联数据</li>
<li><code>Move</code>: Has named fields, like a struct does</li>
<li><code>Move</code>：包含具名字段（类似结构体）</li>
<li><code>Write</code>: Includes a single <code>String</code></li>
<li><code>Write</code>：包含单个<code>String</code></li>
<li><code>ChangeColor</code>: Includes three <code>i32</code> values</li>
<li><code>ChangeColor</code>：包含三个<code>i32</code>值</li>
</ul>
<p>Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
<code>struct</code> keyword and all the variants are grouped together under the <code>Message</code>
type. The following structs could hold the same data that the preceding enum
variants hold:</p>
<p>定义如示例6-2的枚举变体类似于定义不同结构体，区别在于枚举不使用<code>struct</code>关键字，且所有变体都归在<code>Message</code>类型下。以下结构体可保存与上述枚举变体相同的数据：</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>But if we used the different structs, each of which has its own type, we
couldn’t as easily define a function to take any of these kinds of messages as
we could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</p>
<p>但如果使用这些独立结构体（每个都有自己的类型），就无法像示例6-2定义的<code>Message</code>枚举那样轻松定义函数来接收任意消息类型（枚举是单一类型）。</p>
<p>There is one more similarity between enums and structs: just as we’re able to
define methods on structs using <code>impl</code>, we’re also able to define methods on
enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<p>枚举和结构体还有一点相似：正如可以用<code>impl</code>为结构体定义方法，也能为枚举定义方法。以下是可为<code>Message</code>枚举定义的<code>call</code>方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>The body of the method would use <code>self</code> to get the value that we called the
method on. In this example, we’ve created a variable <code>m</code> that has the value
<code>Message::Write(String::from("hello"))</code>, and that is what <code>self</code> will be in the
body of the <code>call</code> method when <code>m.call()</code> runs.</p>
<p>方法体使用<code>self</code>获取调用该方法的实例值。此例中，变量<code>m</code>的值是<code>Message::Write(String::from("hello"))</code>，当执行<code>m.call()</code>时，<code>call</code>方法体中的<code>self</code>即为此值。</p>
<p>Let’s look at another enum in the standard library that is very common and
useful: <code>Option</code>.</p>
<p>现在看看标准库中另一个常见且实用的枚举：<code>Option</code>。</p>
<h3 id="the-option-enum-and-its-advantages-over-null-values-option枚举及其相对空值的优势"><a class="header" href="#the-option-enum-and-its-advantages-over-null-values-option枚举及其相对空值的优势">The <code>Option</code> Enum and Its Advantages Over Null Values <code>Option</code>枚举及其相对空值的优势</a></h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined
by the standard library. The <code>Option</code> type encodes the very common scenario in
which a value could be something or it could be nothing.</p>
<p>本节探讨标准库定义的另一个枚举<code>Option</code>。<code>Option</code>类型编码了一种常见场景：值可能有意义（某物），也可能无意义（空无）。</p>
<p>For example, if you request the first item in a non-empty list, you would get
a value. If you request the first item in an empty list, you would get nothing.
Expressing this concept in terms of the type system means the compiler can
check whether you’ve handled all the cases you should be handling; this
functionality can prevent bugs that are extremely common in other programming
languages.</p>
<p>例如，请求非空列表的首项会得到值，而请求空列表的首项会得到空无。在类型系统中表达此概念意味着编译器可检查您是否处理了所有应处理的情况，此功能可预防其他语言中极为常见的错误。</p>
<p>Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. <em>Null</em> is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.</p>
<p>编程语言设计常关注包含哪些特性，但排除的特性同样重要。Rust没有许多其他语言拥有的空值（null）特性。<strong>空值</strong>（null）表示“无值“的概念。在有空值的语言中，变量总是处于两种状态之一：空或非空。</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, had this to say:</p>
<p>在2009年的演讲“空引用：十亿美元的错误“中，空值发明者Tony Hoare表示：</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
<p>我称之为十亿美元的错误。当时我在为面向对象语言设计首个全面的引用类型系统，目标是确保所有引用使用绝对安全，由编译器自动检查。但我未能抵制添加空引用的诱惑，只因它太容易实现。这导致了无数错误、漏洞和系统崩溃，过去四十年可能已造成十亿美元的损失和痛苦。</p>
</blockquote>
<p>The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.</p>
<p>空值的问题在于：若将空值当作非空值使用，会导致某种错误。由于“空或非空“属性无处不在，此类错误极易发生。</p>
<p>However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.</p>
<p>然而，空值试图表达的概念仍有价值：空值表示当前因故无效或缺失的值。</p>
<p>The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
<code>Option&lt;T&gt;</code>, and it is defined by the standard library
as follows:</p>
<p>问题不在概念本身，而在具体实现。因此Rust没有空值，但提供了可编码“值存在或缺失“概念的枚举，即<code>Option&lt;T&gt;</code>，标准库定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. Its variants are also included in
the prelude: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code>
prefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and
<code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>
<p><code>Option&lt;T&gt;</code>枚举非常实用，它甚至包含在预导入模块（prelude）中——无需显式引入作用域。其变体也在预导入中：可直接使用<code>Some</code>和<code>None</code>，无需<code>Option::</code>前缀。<code>Option&lt;T&gt;</code>仍是常规枚举，<code>Some(T)</code>和<code>None</code>仍是其变体。</p>
<p>The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that <code>&lt;T&gt;</code> means that the <code>Some</code> variant of
the <code>Option</code> enum can hold one piece of data of any type, and that each
concrete type that gets used in place of <code>T</code> makes the overall <code>Option&lt;T&gt;</code> type
a different type. Here are some examples of using <code>Option</code> values to hold
number types and char types:</p>
<p><code>&lt;T&gt;</code>语法是Rust的泛型类型参数（第10章详解泛型）。目前只需知道：<code>&lt;T&gt;</code>表示<code>Option</code>枚举的<code>Some</code>变体能持有任意类型的单块数据，每个替换<code>T</code>的具体类型都会使<code>Option&lt;T&gt;</code>整体成为不同类型。以下是使用<code>Option</code>值保存数值类型和字符类型的示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is
<code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because
we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust
requires us to annotate the overall <code>Option</code> type: the compiler can’t infer the
type that the corresponding <code>Some</code> variant will hold by looking only at a
<code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type
<code>Option&lt;i32&gt;</code>.</p>
<p><code>some_number</code>的类型是<code>Option&lt;i32&gt;</code>，<code>some_char</code>的类型是<code>Option&lt;char&gt;</code>（不同类）。Rust能推断这些类型，因为我们在<code>Some</code>变体中指定了值。对于<code>absent_number</code>，Rust要求标注整个<code>Option</code>类型——编译器无法仅通过<code>None</code>值推断对应<code>Some</code>变体将持有的类型。这里我们明确告知Rust：<code>absent_number</code>应为<code>Option&lt;i32&gt;</code>类型。</p>
<p>When we have a <code>Some</code> value, we know that a value is present and the value is
held within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the
same thing as null: we don’t have a valid value. So why is having <code>Option&lt;T&gt;</code>
any better than having null?</p>
<p>当持有<code>Some</code>值时，表明值存在且包含在<code>Some</code>中。当持有<code>None</code>值时，某种意义上等同于空值：无有效值。那么为何<code>Option&lt;T&gt;</code>优于空值？</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different
types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were
definitely a valid value. For example, this code won’t compile, because it’s
trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<p>简言之，因为<code>Option&lt;T&gt;</code>和<code>T</code>（<code>T</code>可为任意类型）是不同类型，编译器不会允许我们将<code>Option&lt;T&gt;</code>当作有效值使用。例如以下代码无法编译，因为它试图将<code>i8</code>与<code>Option&lt;i8&gt;</code>相加：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>If we run this code, we get an error message like this one:</p>
<p>运行此代码会产生类似错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Intense! In effect, this error message means that Rust doesn’t understand how
to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we
have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.</p>
<p>这明确意味着：Rust无法理解如何将<code>i8</code>和<code>Option&lt;i8&gt;</code>相加，因为它们是不同类型。在Rust中持有<code>i8</code>这类类型的值时，编译器确保它总是有效值，我们可以放心使用而无需空值检查。只有持有<code>Option&lt;i8&gt;</code>（或任何正在处理的类型）时，才需考虑可能无值的情况，编译器会确保我们在使用值前处理该情况。</p>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can
perform <code>T</code> operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually is.</p>
<p>换言之，必须先转换<code>Option&lt;T&gt;</code>为<code>T</code>，才能执行<code>T</code>的操作。这通常能捕获空值最常见的问题：在值实际为空时错误假设其非空。</p>
<p>Eliminating the risk of incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
<code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.</p>
<p>消除错误假设非空值的风险有助于提升代码信心。要让值可能为空，必须显式选择将其类型设为<code>Option&lt;T&gt;</code>。使用该值时，必须显式处理空值情况。对于类型非<code>Option&lt;T&gt;</code>的值，您可以<strong>安全</strong>假设其非空。这是Rust有意为之的设计决策，旨在限制空值泛滥，提升Rust代码安全性。</p>
<p>So how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value
of type <code>Option&lt;T&gt;</code> so that you can use that value? The <code>Option&lt;T&gt;</code> enum has a
large number of methods that are useful in a variety of situations; you can
check them out in its documentation. Becoming familiar
with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with
Rust.</p>
<p>那么当持有<code>Option&lt;T&gt;</code>类型的值时，如何从<code>Some</code>变体中取出<code>T</code>值以便使用？<code>Option&lt;T&gt;</code>枚举提供大量实用方法（详见文档）。熟悉这些方法对Rust编程之旅极其有用。</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that
will handle each variant. You want some code that will run only when you have a
<code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some
other code to run only if you have a <code>None</code> value, and that code doesn’t have a
<code>T</code> value available. The <code>match</code> expression is a control flow construct that
does just this when used with enums: it will run different code depending on
which variant of the enum it has, and that code can use the data inside the
matching value.</p>
<p>通常，使用<code>Option&lt;T&gt;</code>值时，您需要处理所有变体的代码：部分代码仅在持有<code>Some(T)</code>时运行，且可使用内部的<code>T</code>；另一部分代码仅在持有<code>None</code>时运行，且无法使用<code>T</code>值。<code>match</code>表达式正是处理枚举的控制流结构：根据枚举变体运行不同代码，且该代码可使用匹配值内部的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-match-control-flow-construct--match-控制流结构"><a class="header" href="#the-match-control-flow-construct--match-控制流结构">The <code>match</code> Control Flow Construct  <code>match</code> 控制流结构</a></h2>
<p>Rust has an extremely powerful control flow construct called <code>match</code> that
allows you to compare a value against a series of patterns and then execute
code based on which pattern matches. Patterns can be made up of literal values,
variable names, wildcards, and many other things; Chapter
19 covers all the different kinds of patterns
and what they do. The power of <code>match</code> comes from the expressiveness of the
patterns and the fact that the compiler confirms that all possible cases are
handled.</p>
<p>Rust 拥有一个极为强大的控制流结构 <code>match</code>，它允许将值与一系列模式进行比较，并根据匹配到的模式执行对应代码。模式可由字面值、变量名、通配符等组成；第 19 章会介绍所有模式类型及其功能。<code>match</code> 的强大之处在于模式的表现力以及编译器会确保所有可能情况都得到处理。</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a <code>match</code>, and at the first pattern the value “fits,”
the value falls into the associated code block to be used during execution.</p>
<p>可以将 <code>match</code> 表达式想象成硬币分拣机：硬币沿轨道滑下，轨道上有各种尺寸的孔洞，每枚硬币会从第一个匹配的孔洞掉落。类似地，值会依次通过 <code>match</code> 中的每个模式，当遇到第一个“适配“的模式时，该值会进入关联的代码块中执行。</p>
<p>Speaking of coins, let’s use them as an example using <code>match</code>! We can write a
function that takes an unknown US coin and, in a similar way as the counting
machine, determines which coin it is and returns its value in cents, as shown
in Listing 6-3.</p>
<p>既然提到硬币，让我们以它们为例使用 <code>match</code>！我们可以编写一个函数：接收未知的美国硬币，像点钞机一样确定其种类并返回对应美分值，如示例 6-3 所示。</p>
<figure class="listing" id="listing-6-3">
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch06-02-match.html#listing-6-3">Listing 6-3</a>: An enum and a <code>match</code> expression that has the variants of the enum as its patterns 包含枚举变体作为模式的枚举和 <code>match</code> 表达式</figcaption>
</figure>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First we list
the <code>match</code> keyword followed by an expression, which in this case is the value
<code>coin</code>. This seems very similar to a conditional expression used with <code>if</code>, but
there’s a big difference: with <code>if</code>, the condition needs to evaluate to a
Boolean value, but here it can be any type. The type of <code>coin</code> in this example
is the <code>Coin</code> enum that we defined on the first line.</p>
<p>现在解析 <code>value_in_cents</code> 函数中的 <code>match</code>。首先列出 <code>match</code> 关键字及表达式（此处为 <code>coin</code> 值）。这看似与 <code>if</code> 的条件表达式相似，但有重大区别：<code>if</code> 的条件必须返回布尔值，而此处可以是任意类型。本例中 <code>coin</code> 的类型是第一行定义的 <code>Coin</code> 枚举。</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code>
operator that separates the pattern and the code to run. The code in this case
is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>接下来是 <code>match</code> 分支。每个分支有两部分：模式和代码。第一个分支的模式是值 <code>Coin::Penny</code>，后跟分隔模式与代码的 <code>=&gt;</code> 运算符。此处的代码是值 <code>1</code>。分支间用逗号分隔。</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our <code>match</code> has four arms.</p>
<p>执行 <code>match</code> 表达式时，会按顺序将结果值与每个分支的模式比较。若模式匹配值，则执行关联代码；若不匹配，则继续下一个分支（类似硬币分拣机）。我们可以添加任意数量的分支：示例 6-3 中有四个分支。</p>
<p>The code associated with each arm is an expression, and the resultant value of
the expression in the matching arm is the value that gets returned for the
entire <code>match</code> expression.</p>
<p>每个分支的关联代码是一个表达式，匹配分支的表达式的返回值即是整个 <code>match</code> 表达式的返回值。</p>
<p>We don’t typically use curly brackets if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you must use curly brackets, and the comma
following the arm is then optional. For example, the following code prints
“Lucky penny!” every time the method is called with a <code>Coin::Penny</code>, but still
returns the last value of the block, <code>1</code>:</p>
<p>若分支代码较短（如示例 6-3 中每个分支仅返回值），通常省略花括号。<span class="highlight">[note]若需在分支中运行多行代码，必须使用花括号，此时分支后的逗号可选。</span>例如以下代码在传入 <code>Coin::Penny</code> 时打印 “Lucky penny!”，但仍返回代码块末尾值 <code>1</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="patterns-that-bind-to-values-绑定值的模式"><a class="header" href="#patterns-that-bind-to-values-绑定值的模式">Patterns That Bind to Values 绑定值的模式</a></h3>
<p>Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.</p>
<p>匹配分支的另一项实用功能是：它们可以绑定到匹配模式的值部分，从而从枚举变体中提取值。</p>
<p>As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value
stored inside it, which we’ve done in Listing 6-4.</p>
<p>例如，修改枚举变体使其包含内部数据。1999 年至 2008 年间，美国铸造的 25 美分硬币背面印有各州设计。其他硬币无此设计，因此只有 25 美分有此附加值。我们可通过修改 <code>Quarter</code> 变体包含 <code>UsState</code> 值来添加此信息，如示例 6-4 所示。</p>
<figure class="listing" id="listing-6-4">
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch06-02-match.html#listing-6-4">Listing 6-4</a>: A <code>Coin</code> enum in which the <code>Quarter</code> variant also holds a <code>UsState</code> value <code>Quarter</code> 变体包含 <code>UsState</code> 值的 <code>Coin</code> 枚举</figcaption>
</figure>
<p>Let’s imagine that a friend is trying to collect all 50 state quarters. While
we sort our loose change by coin type, we’ll also call out the name of the
state associated with each quarter so that if it’s one our friend doesn’t have,
they can add it to their collection.</p>
<p>假设有朋友想收集全部 50 州纪念币。当按硬币类型分类零钱时，我们将同时喊出对应州名，以便朋友将未收集的硬币加入收藏。</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the
pattern that matches values of the variant <code>Coin::Quarter</code>. When a
<code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that
quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<p>在此代码的 <code>match</code> 表达式中，为匹配 <code>Coin::Quarter</code> 变体的模式添加变量 <code>state</code>。当匹配到 <code>Coin::Quarter</code> 时，<code>state</code> 将绑定到该硬币的州名值。随后即可在该分支代码中使用 <code>state</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code>
would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each
of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At
that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can
then use that binding in the <code>println!</code> expression, thus getting the inner
state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<p>若调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当与各分支比较时，直到 <code>Coin::Quarter(state)</code> 才会匹配。此时 <code>state</code> 的绑定值为 <code>UsState::Alaska</code>。接着在 <code>println!</code> 表达式中使用该绑定，从而从 <code>Quarter</code> 枚举变体中提取出内部州名值。</p>
<h3 id="matching-with-optiont-匹配-optiont"><a class="header" href="#matching-with-optiont-匹配-optiont">Matching with <code>Option&lt;T&gt;</code> 匹配 <code>Option&lt;T&gt;</code></a></h3>
<p>In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code>
case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code>, as
we did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the
variants of <code>Option&lt;T&gt;</code>, but the way the <code>match</code> expression works remains the
same.</p>
<p>上一节中，我们希望在 <code>Option&lt;T&gt;</code> 的 <code>Some</code> 情况下获取内部 <code>T</code> 值；也可用 <code>match</code> 处理 <code>Option&lt;T&gt;</code>（如同处理 <code>Coin</code> 枚举）。这里比较的是 <code>Option&lt;T&gt;</code> 的变体，但 <code>match</code> 的工作方式不变。</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;i32&gt;</code> and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the <code>None</code> value and not attempt to perform any
operations.</p>
<p>假设要编写函数：接收 <code>Option&lt;i32&gt;</code>，若内部有值则加 1；若无值则直接返回 <code>None</code>。</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like
Listing 6-5.</p>
<p>借助 <code>match</code> 可轻松实现，如示例 6-5 所示。</p>
<figure class="listing" id="listing-6-5">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-02-match.html#listing-6-5">Listing 6-5</a>: A function that uses a <code>match</code> expression on an <code>Option&lt;i32&gt;</code> 对 <code>Option&lt;i32&gt;</code> 使用 <code>match</code> 表达式的函数</figcaption>
</figure>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call
<code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the
value <code>Some(5)</code>. We then compare that against each match arm:</p>
<p>详细解析第一次调用 <code>plus_one</code> 的过程。当调用 <code>plus_one(five)</code> 时，<code>plus_one</code> 函数体内的 <code>x</code> 将为 <code>Some(5)</code>。接着与各分支比较：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>The <code>Some(5)</code> value doesn’t match the pattern <code>None</code>, so we continue to the
next arm:</p>
<p><code>Some(5)</code> 不匹配 <code>None</code> 模式，继续下一分支：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Does <code>Some(5)</code> match <code>Some(i)</code>? It does! We have the same variant. The <code>i</code>
binds to the value contained in <code>Some</code>, so <code>i</code> takes the value <code>5</code>. The code in
the match arm is then executed, so we add 1 to the value of <code>i</code> and create a
new <code>Some</code> value with our total <code>6</code> inside.</p>
<p><code>Some(5)</code> 匹配 <code>Some(i)</code> 吗？匹配！两者为相同变体。<code>i</code> 绑定到 <code>Some</code> 的内部值，因此 <code>i</code> 取值 <code>5</code>。执行该分支代码：将 <code>i</code> 的值加 1，生成包含结果 <code>6</code> 的新 <code>Some</code> 值。</p>
<p>Now let’s consider the second call of <code>plus_one</code> in Listing 6-5, where <code>x</code> is
<code>None</code>. We enter the <code>match</code> and compare to the first arm:</p>
<p>现在考虑示例 6-5 中第二次调用 <code>plus_one</code> 的情况（<code>x</code> 为 <code>None</code>）。进入 <code>match</code> 后与第一分支比较：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>It matches! There’s no value to add to, so the program stops and returns the
<code>None</code> value on the right side of <code>=&gt;</code>. Because the first arm matched, no other
arms are compared.</p>
<p>匹配成功！无需增加值，程序停止并返回 <code>=&gt;</code> 右侧的 <code>None</code> 值。因第一分支已匹配，不再比较其他分支。</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: <code>match</code> against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.</p>
<p><code>match</code> 与枚举的组合在多种场景中都很有用。你会在 Rust 代码中频繁看到此模式：用 <code>match</code> 匹配枚举，将变量绑定到内部数据，再据此执行代码。初用可能有些棘手，但习惯后你会希望所有语言都拥有此功能——它始终深受用户喜爱。</p>
<h3 id="matches-are-exhaustive-匹配的穷尽性"><a class="header" href="#matches-are-exhaustive-匹配的穷尽性">Matches Are Exhaustive 匹配的穷尽性</a></h3>
<p>There’s one other aspect of <code>match</code> we need to discuss: the arms’ patterns must
cover all possibilities. Consider this version of our <code>plus_one</code> function,
which has a bug and won’t compile:</p>
<p><code>match</code> 还有另一特性：分支模式必须覆盖所有可能性。考虑以下有缺陷的 <code>plus_one</code> 函数版本（无法编译）：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:</p>
<p>因未处理 <code>None</code> 情况，此代码存在错误。幸运的是 Rust 能捕获此类错误。尝试编译时将提示：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1
 ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust knows that we didn’t cover every possible case, and even knows which
pattern we forgot! Matches in Rust are <em>exhaustive</em>: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
<code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the
<code>None</code> case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier impossible.</p>
<p>Rust 不仅知道我们未覆盖所有情况，甚至能指出遗漏的模式！Rust 中的匹配是<strong>穷尽的</strong>（exhaustive）：必须覆盖所有可能性代码才有效。尤其在处理 <code>Option&lt;T&gt;</code> 时，Rust 强制显式处理 <code>None</code> 情况，防止我们在可能为空时假定存在值，从而避免了之前讨论的“十亿美元错误“。</p>
<h3 id="catch-all-patterns-and-the-_-placeholder-通配模式和-_-占位符"><a class="header" href="#catch-all-patterns-and-the-_-placeholder-通配模式和-_-占位符">Catch-All Patterns and the <code>_</code> Placeholder 通配模式和 <code>_</code> 占位符</a></h3>
<p>Using enums, we can also take special actions for a few particular values, but
for all other values take one default action. Imagine we’re implementing a game
where, if you roll a 3 on a dice roll, your player doesn’t move, but instead
gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all
other values, your player moves that number of spaces on the game board. Here’s
a <code>match</code> that implements that logic, with the result of the dice roll
hardcoded rather than a random value, and all other logic represented by
functions without bodies because actually implementing them is out of scope for
this example:</p>
<p>使用枚举时，可对特定值执行特殊操作，而对其他值执行默认操作。假设在游戏中：掷骰子得 3 时玩家获得新帽子；得 7 时失去帽子；其他数值则在棋盘移动对应格数。以下是硬编码骰子结果的 <code>match</code> 实现（其他逻辑用无主体函数表示，因实际实现超出本例范围）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>For the first two arms, the patterns are the literal values <code>3</code> and <code>7</code>. For
the last arm that covers every other possible value, the pattern is the
variable we’ve chosen to name <code>other</code>. The code that runs for the <code>other</code> arm
uses the variable by passing it to the <code>move_player</code> function.</p>
<p>前两个分支的模式是字面值 <code>3</code> 和 <code>7</code>。最后一个分支覆盖其他所有值，模式为变量 <code>other</code>。该分支代码通过向 <code>move_player</code> 传递 <code>other</code> 来使用此变量。</p>
<p>This code compiles, even though we haven’t listed all the possible values a
<code>u8</code> can have, because the last pattern will match all values not specifically
listed. This catch-all pattern meets the requirement that <code>match</code> must be
exhaustive. Note that we have to put the catch-all arm last because the
patterns are evaluated in order. If we put the catch-all arm earlier, the other
arms would never run, so Rust will warn us if we add arms after a catch-all!</p>
<p>此代码可编译通过，因为我们未列出 <code>u8</code> 所有可能值——最后的模式会匹配所有未显式列出的值。这种通配模式满足了 <code>match</code> 必须穷尽的要求。注意：通配分支必须放在最后，因为模式按顺序求值。若将其提前，其他分支将无法运行。因此若在通配分支后添加分支，Rust 会发出警告！</p>
<p>Rust also has a pattern we can use when we want a catch-all but don’t want to
<em>use</em> the value in the catch-all pattern: <code>_</code> is a special pattern that matches
any value and does not bind to that value. This tells Rust we aren’t going to
use the value, so Rust won’t warn us about an unused variable.</p>
<p>当需要通配但不想使用值时，Rust 提供了特殊模式 <code>_</code>：它匹配任意值且不进行绑定。这告知 Rust 我们不会使用该值，因此不会产生未使用变量的警告。</p>
<p>Let’s change the rules of the game: now, if you roll anything other than a 3 or
a 7, you must roll again. We no longer need to use the catch-all value, so we
can change our code to use <code>_</code> instead of the variable named <code>other</code>:</p>
<p>现在修改游戏规则：若掷出非 3 或 7 的值，必须重掷。此时不再需要通配值，可将 <code>other</code> 改为 <code>_</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>This example also meets the exhaustiveness requirement because we’re explicitly
ignoring all other values in the last arm; we haven’t forgotten anything.</p>
<p>此示例同样满足穷尽性要求，因为我们在最后分支显式忽略了其他所有值。</p>
<p>Finally, we’ll change the rules of the game one more time so that nothing else
happens on your turn if you roll anything other than a 3 or a 7. We can express
that by using the unit value (the empty tuple type we mentioned in “The Tuple
Type” section) as the code that goes with the <code>_</code> arm:</p>
<p>再次修改规则：掷出非 3 或 7 时回合无操作。可通过 <code>_</code> 分支使用单元值（即“元组类型“章节提到的空元组类型）实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Here, we’re telling Rust explicitly that we aren’t going to use any other value
that doesn’t match a pattern in an earlier arm, and we don’t want to run any
code in this case.</p>
<p>这里显式告知 Rust：对于不匹配前序分支的值，不执行任何操作。</p>
<p>There’s more about patterns and matching that we’ll cover in Chapter 19.
For now, we’re going to move on to the
<code>if let</code> syntax, which can be useful in situations where the <code>match</code> expression
is a bit wordy.</p>
<p>关于模式与匹配的更多内容将在第 19 章介绍。现在我们将继续讨论 <code>if let</code> 语法，它在 <code>match</code> 表达式较冗长时非常实用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concise-control-flow-with-if-let-and-let-else-使用-if-let-和-let-else-简化控制流"><a class="header" href="#concise-control-flow-with-if-let-and-let-else-使用-if-let-和-let-else-简化控制流">Concise Control Flow with <code>if let</code> and <code>let else</code> 使用 <code>if let</code> 和 <code>let else</code> 简化控制流</a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an <code>Option&lt;u8&gt;</code> value in the
<code>config_max</code> variable but only wants to execute code if the value is the <code>Some</code>
variant.</p>
<p><code>if let</code> 语法将 <code>if</code> 和 <code>let</code> 结合，提供了一种更简洁的方式来处理匹配某个模式的值，同时忽略其他情况。参考示例 6-6 中的程序，它对 <code>config_max</code> 变量中的 <code>Option&lt;u8&gt;</code> 值进行匹配，但仅在值为 <code>Some</code> 变体时执行代码。</p>
<figure class="listing" id="listing-6-6">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("The maximum is configured to be {max}"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-03-if-let.html#listing-6-6">Listing 6-6</a>: A <code>match</code> that only cares about executing code when the value is <code>Some</code> 仅当值为 <code>Some</code> 时才执行代码的 <code>match</code></figcaption>
</figure>
<p>If the value is <code>Some</code>, we print out the value in the <code>Some</code> variant by binding
the value to the variable <code>max</code> in the pattern. We don’t want to do anything
with the <code>None</code> value. To satisfy the <code>match</code> expression, we have to add <code>_ =&gt;  ()</code> after processing just one variant, which is annoying boilerplate code to
add.</p>
<p>若值为 <code>Some</code>，我们通过在模式中将值绑定到变量 <code>max</code> 来打印 <code>Some</code> 变体中的值。对于 <code>None</code> 值则无需操作。为了满足 <code>match</code> 表达式的要求，我们必须在处理一个变体后添加 <code>_ =&gt; ()</code>，这种样板代码显得冗余。</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following
code behaves the same as the <code>match</code> in Listing 6-6:</p>
<p>使用 <code>if let</code> 可以更简洁地实现相同功能。以下代码的行为与示例 6-6 中的 <code>match</code> 一致：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {max}");
    }
<span class="boring">}</span></code></pre></pre>
<p>The syntax <code>if let</code> takes a pattern and an expression separated by an equal
sign. It works the same way as a <code>match</code>, where the expression is given to the
<code>match</code> and the pattern is its first arm. In this case, the pattern is
<code>Some(max)</code>, and the <code>max</code> binds to the value inside the <code>Some</code>. We can then
use <code>max</code> in the body of the <code>if let</code> block in the same way we used <code>max</code> in
the corresponding <code>match</code> arm. The code in the <code>if let</code> block only runs if the
value matches the pattern.</p>
<p><code>if let</code> 语法接受由等号分隔的模式和表达式。其工作方式类似于 <code>match</code>：将表达式提供给 <code>match</code>，模式作为其第一个分支。此处模式为 <code>Some(max)</code>，<code>max</code> 会绑定到 <code>Some</code> 内部的值。我们可以在 <code>if let</code> 代码块中使用 <code>max</code>，用法与对应 <code>match</code> 分支中一致。仅当值匹配模式时，<code>if let</code> 块中的代码才会执行。</p>
<p>Using <code>if let</code> means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking <code>match</code> enforces that ensures you
aren’t forgetting to handle any cases. Choosing between <code>match</code> and <code>if let</code>
depends on what you’re doing in your particular situation and whether gaining
conciseness is an appropriate trade-off for losing exhaustive checking.</p>
<p>使用 <code>if let</code> 意味着更少的输入、更少的缩进和更少的样板代码。但代价是失去了 <code>match</code> 强制执行的穷尽性检查（确保不会遗漏处理任何情况）。在 <code>match</code> 和 <code>if let</code> 间的选择取决于具体场景，需权衡简洁性与穷尽性检查的重要性。</p>
<p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>换言之，可将 <code>if let</code> 视为 <code>match</code> 的语法糖：当值匹配某个模式时运行代码，并忽略所有其他值。</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with the
<code>else</code> is the same as the block of code that would go with the <code>_</code> case in the
<code>match</code> expression that is equivalent to the <code>if let</code> and <code>else</code>. Recall the
<code>Coin</code> enum definition in Listing 6-4, where the <code>Quarter</code> variant also held a
<code>UsState</code> value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a <code>match</code>
expression, like this:</p>
<p>我们可以在 <code>if let</code> 后添加 <code>else</code>。<code>else</code> 关联的代码块等同于与 <code>if let</code> 和 <code>else</code> 等价的 <code>match</code> 表达式中 <code>_</code> 分支的代码块。回顾示例 6-4 中的 <code>Coin</code> 枚举定义，其中 <code>Quarter</code> 变体包含 <code>UsState</code> 值。若要在统计所有非 25 分硬币时同时报告 25 分硬币的州名，可使用 <code>match</code> 表达式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("State quarter from {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression, like this:</p>
<p>或使用 <code>if let</code> 和 <code>else</code> 表达式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("State quarter from {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="staying-on-the-happy-path-with-letelse--使用-letelse-保持快乐路径"><a class="header" href="#staying-on-the-happy-path-with-letelse--使用-letelse-保持快乐路径">Staying on the “Happy Path” with <code>let...else</code>  使用 <code>let...else</code> 保持“快乐路径“</a></h2>
<p>The common pattern is to perform some computation when a value is present and
return a default value otherwise. Continuing on with our example of coins with a
<code>UsState</code> value, if we wanted to say something funny depending on how old the
state on the quarter was, we might introduce a method on <code>UsState</code> to check the
age of a state, like so:</p>
<p>常见模式是当值存在时执行计算，否则返回默认值。延续包含 <code>UsState</code> 值的硬币示例，假设要根据 25 分硬币上州的“年龄“输出趣味信息，可为 <code>UsState</code> 添加检查州年龄的方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // -- snip --
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("{state:?} is pretty old, for America!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("{state:?} is relatively new."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>Then we might use <code>if let</code> to match on the type of coin, introducing a <code>state</code>
variable within the body of the condition, as in Listing 6-7.</p>
<p>接着可用 <code>if let</code> 匹配硬币类型，在条件体内引入 <code>state</code> 变量，如示例 6-7 所示。</p>
<figure class="listing" id="listing-6-7">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} is pretty old, for America!"))
        } else {
            Some(format!("{state:?} is relatively new."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-03-if-let.html#listing-6-7">Listing 6-7</a>: Checking whether a state existed in 1900 by using conditionals nested inside an <code>if let</code>. 在 <code>if let</code> 中嵌套条件判断以检查州是否存在于 1900 年</figcaption>
</figure>
<p>That gets the job done, but it has pushed the work into the body of the <code>if  let</code> statement, and if the work to be done is more complicated, it might be
hard to follow exactly how the top-level branches relate. We could also take
advantage of the fact that expressions produce a value either to produce the
<code>state</code> from the <code>if let</code> or to return early, as in Listing 6-8. (You could do
similar with a <code>match</code>, too.)</p>
<p>这实现了功能，但将逻辑推入了 <code>if let</code> 语句内部。若处理逻辑更复杂，将难以理清顶层分支的关系。也可利用表达式产生值的特性，通过 <code>if let</code> 产生 <code>state</code> 或提前返回，如示例 6-8 所示（使用 <code>match</code> 也可实现类似效果）。</p>
<figure class="listing" id="listing-6-8">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-03-if-let.html#listing-6-8">Listing 6-8</a>: Using <code>if let</code> to produce a value or return early. 使用 <code>if let</code> 产生值或提前返回</figcaption>
</figure>
<p>This is a bit annoying to follow in its own way, though! One branch of the <code>if  let</code> produces a value, and the other one returns from the function entirely.</p>
<p>但这种写法仍有缺陷：<code>if let</code> 的一个分支产生值，另一分支则直接退出函数。</p>
<p>To make this common pattern nicer to express, Rust has <code>let...else</code>. The
<code>let...else</code> syntax takes a pattern on the left side and an expression on the
right, very similar to <code>if let</code>, but it does not have an <code>if</code> branch, only an
<code>else</code> branch. If the pattern matches, it will bind the value from the pattern
in the outer scope. If the pattern does <em>not</em> match, the program will flow into
the <code>else</code> arm, which must return from the function.</p>
<p>为优雅表达此模式，<span class="highlight">[note]Rust 提供了 <code>let...else</code>。其语法左侧接受模式，右侧接受表达式（类似 <code>if let</code>），但没有 <code>if</code> 分支，仅含 <code>else</code> 分支。若模式匹配，则在外部作用域绑定模式中的值；若不匹配，程序将进入 <code>else</code> 分支</span>（该分支必须退出函数）。</p>
<p>In Listing 6-9, you can see how Listing 6-8 looks when using <code>let...else</code> in
place of <code>if let</code>.</p>
<p>示例 6-9 展示了用 <code>let...else</code> 重构示例 6-8 的效果。</p>
<figure class="listing" id="listing-6-9">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)] // so we can inspect the state in a minute
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch06-03-if-let.html#listing-6-9">Listing 6-9</a>: Using <code>let...else</code> to clarify the flow through the function. 使用 <code>let...else</code> 清晰表达函数流程</figcaption>
</figure>
<p>Notice that it stays “on the happy path” in the main body of the function this
way, without having significantly different control flow for two branches the
way the <code>if let</code> did.</p>
<p>这种方式使函数主体保持在“快乐路径“上，避免了 <code>if let</code> 中两个分支的显著控制流差异。</p>
<p>If you have a situation in which your program has logic that is too verbose to
express using a <code>match</code>, remember that <code>if let</code> and <code>let...else</code> are in your
Rust toolbox as well.</p>
<p>当程序中存在因过于冗长而不适合 <code>match</code> 表达的逻辑时，请记住 Rust 工具箱中的 <code>if let</code> 和 <code>let...else</code>。</p>
<h2 id="summary-总结-5"><a class="header" href="#summary-总结-5">Summary 总结</a></h2>
<p>We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s <code>Option&lt;T&gt;</code>
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those
values, depending on how many cases you need to handle.</p>
<p>我们已学习如何使用枚举创建包含一组枚举值的自定义类型，并展示了标准库的 <code>Option&lt;T&gt;</code> 类型如何利用类型系统预防错误。当枚举值包含内部数据时，可根据需处理的情况数量，选用 <code>match</code> 或 <code>if let</code> 提取和使用这些值。</p>
<p>Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions only get values of the type each
function expects.</p>
<p>现在您的 Rust 程序可通过结构体和枚举表达领域概念。在 API 中使用自定义类型能确保类型安全：编译器会保证函数仅获取其期望类型的值。</p>
<p>In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.</p>
<p>为向用户提供组织良好、易于使用且精准满足需求的 API，接下来我们将探讨 Rust 的模块系统。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-growing-projects-with-packages-crates-and-modules-使用包箱和模块管理增长中的项目"><a class="header" href="#managing-growing-projects-with-packages-crates-and-modules-使用包箱和模块管理增长中的项目">Managing Growing Projects with Packages, Crates, and Modules 使用包、箱和模块管理增长中的项目</a></h1>
<p>As you write large programs, organizing your code will become increasingly
important. By grouping related functionality and separating code with distinct
features, you’ll clarify where to find code that implements a particular
feature and where to go to change how a feature works.</p>
<p>随着程序规模扩大，代码组织的重要性日益凸显。通过将相关功能分组并分离不同特性的代码，你能清晰定位特定功能的实现代码所在，以及修改功能逻辑的位置。</p>
<p>The programs we’ve written so far have been in one module in one file. As a
project grows, you should organize code by splitting it into multiple modules
and then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects comprising a set of interrelated
packages that evolve together, Cargo provides <em>workspaces</em>, which we’ll cover
in “Cargo Workspaces” in Chapter 14.</p>
<p>目前我们编写的程序都位于单文件单模块中。当项目增长时，应通过拆分多个模块再分至多个文件来组织代码。一个包（package）可包含多个二进制箱（binary crate），还可选择包含一个库箱（library crate）。随着包体量增长，可将部分代码提取为独立箱作为外部依赖。本章将涵盖所有这些技术。对于由多个协同演化的关联包组成的大型项目，Cargo 提供了 <strong>工作空间</strong>（workspaces）功能，我们将在第14章 “Cargo 工作空间” 中探讨。</p>
<p>We’ll also discuss encapsulating implementation details, which lets you reuse
code at a higher level: once you’ve implemented an operation, other code can
call your code via its public interface without having to know how the
implementation works. The way you write code defines which parts are public for
other code to use and which parts are private implementation details that you
reserve the right to change. This is another way to limit the amount of detail
you have to keep in your head.</p>
<p>我们还将讨论封装实现细节，这能让你在更高层次复用代码：某个操作一旦实现，其他代码可通过其公开接口调用，而无需了解内部实现。代码编写方式决定了哪些部分公开供外部使用，哪些部分作为保留修改权的私有实现细节。这是另一种减少心智负担的方法。</p>
<p>A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope; tools are available to resolve name conflicts.</p>
<p>相关概念是<strong>作用域（scope）</strong>：代码所处的嵌套上下文环境包含一组“在作用域内“的定义名称。程序员和编译器在读写、编译代码时，需明确特定位置的名称所指代的是变量、函数、结构体、枚举、模块、常量或其他条目及其含义。你可创建作用域并控制名称的可见性。同一作用域内不允许存在同名条目；Rust 提供了解决命名冲突的工具。</p>
<p>Rust has a number of features that allow you to manage your code’s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the <em>module system</em>, include:</p>
<p>Rust 通过多项特性管理代码组织方式，包括细节的公开性、私有性以及程序中各作用域的名称管理。这些常被统称为<strong>模块系统</strong>的特性包含：</p>
<ul>
<li><strong>Packages</strong>: A Cargo feature that lets you build, test, and share crates</li>
<li><strong>包（Packages）</strong>：Cargo 提供的构建、测试和共享箱的功能</li>
<li><strong>Crates</strong>: A tree of modules that produces a library or executable</li>
<li><strong>箱（Crates）</strong>：生成库或可执行文件的模块树结构</li>
<li><strong>Modules and use</strong>: Let you control the organization, scope, and privacy of</li>
<li><strong>模块与 use</strong>：控制路径的组织方式、作用域和私有性
paths</li>
<li><strong>Paths</strong>: A way of naming an item, such as a struct, function, or module</li>
<li><strong>路径（Paths）</strong>：命名条目的方式，如结构体、函数或模块</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!</p>
<p>本章将涵盖所有特性，阐释其协作机制，并说明如何利用它们管理作用域。学完本章，你将对模块系统建立扎实理解，并能像专家般驾驭作用域！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="packages-and-crates-包与箱"><a class="header" href="#packages-and-crates-包与箱">Packages and Crates 包与箱</a></h2>
<p>The first parts of the module system we’ll cover are packages and crates.</p>
<p>我们将要探讨模块系统的第一部分是包（packages）和箱（crates）。</p>
<p>A <em>crate</em> is the smallest amount of code that the Rust compiler considers at a
time. Even if you run <code>rustc</code> rather than <code>cargo</code> and pass a single source code
file (as we did all the way back in “Writing and Running a Rust Program” in
Chapter 1), the compiler considers that file to be a crate. Crates can contain
modules, and the modules may be defined in other files that get compiled with
the crate, as we’ll see in the coming sections.</p>
<p>一个<strong>箱</strong>（crate）是 Rust 编译器一次处理的最小代码单元。即使你直接运行 <code>rustc</code> 而非 <code>cargo</code> 并传递单个源代码文件（如我们在第 1 章“编写并运行 Rust 程序”中所做的那样），编译器也会将该文件视为一个箱。箱可以包含模块，这些模块可以定义在与箱共同编译的其他文件中（我们将在后续章节中看到）。</p>
<p>A crate can come in one of two forms: a binary crate or a library crate.
<em>Binary crates</em> are programs you can compile to an executable that you can run,
such as a command line program or a server. Each must have a function called
<code>main</code> that defines what happens when the executable runs. All the crates we’ve
created so far have been binary crates.</p>
<p>箱有两种形式：二进制箱或库箱。<strong>二进制箱</strong>可编译成可执行程序运行，例如命令行工具或服务器。每个二进制箱必须包含名为 <code>main</code> 的函数，用于定义可执行文件运行时的行为。我们目前创建的所有箱都是二进制箱。</p>
<p><em>Library crates</em> don’t have a <code>main</code> function, and they don’t compile to an
executable. Instead, they define functionality intended to be shared with
multiple projects. For example, the <code>rand</code> crate we used in Chapter
2 provides functionality that generates random numbers.
Most of the time when Rustaceans say “crate,” they mean library crate, and they
use “crate” interchangeably with the general programming concept of a “library.”</p>
<p><strong>库箱</strong>没有 <code>main</code> 函数，也不会编译成可执行文件。它们定义的功能旨在供多个项目共享。例如，我们在第 2 章使用的 <code>rand</code> 箱提供了生成随机数的功能。当 Rust 开发者提到“箱”时，通常指库箱，并与通用编程概念中的“库”（library）互换使用。</p>
<p>The <em>crate root</em> is a source file that the Rust compiler starts from and makes
up the root module of your crate (we’ll explain modules in depth in “Defining
Modules to Control Scope and Privacy”).</p>
<p><strong>箱根</strong>（crate root）是 Rust 编译器的起始源文件，它构成箱的根模块（我们将在“定义模块以控制作用域与私有性”中深入解释模块）。</p>
<p>A <em>package</em> is a bundle of one or more crates that provides a set of
functionality. A package contains a <em>Cargo.toml</em> file that describes how to
build those crates. Cargo is actually a package that contains the binary crate
for the command line tool you’ve been using to build your code. The Cargo
package also contains a library crate that the binary crate depends on. Other
projects can depend on the Cargo library crate to use the same logic the Cargo
command line tool uses.</p>
<p><strong>包</strong>（package）是提供一组功能的一个或多个箱的集合。包包含描述如何构建这些箱的 <em>Cargo.toml</em> 文件。Cargo 本身就是一个包含命令行工具二进制箱的包。Cargo 包还包含该二进制箱依赖的库箱。其他项目可依赖 Cargo 库箱来复用其命令行工具的逻辑。</p>
<p>A package can contain as many binary crates as you like, but at most only one
library crate. A package must contain at least one crate, whether that’s a
library or binary crate.</p>
<p>一个包可包含任意数量的二进制箱，但最多只能有一个库箱。包必须至少包含一个箱（库箱或二进制箱）。</p>
<p>Let’s walk through what happens when we create a package. First we enter the
command <code>cargo new my-project</code>:</p>
<p>让我们观察创建包时的过程。首先输入命令 <code>cargo new my-project</code>：</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>After we run <code>cargo new my-project</code>, we use <code>ls</code> to see what Cargo creates. In
the project directory, there’s a <em>Cargo.toml</em> file, giving us a package.
There’s also a <em>src</em> directory that contains <em>main.rs</em>. Open <em>Cargo.toml</em> in
your text editor, and note there’s no mention of <em>src/main.rs</em>. Cargo follows a
convention that <em>src/main.rs</em> is the crate root of a binary crate with the same
name as the package. Likewise, Cargo knows that if the package directory
contains <em>src/lib.rs</em>, the package contains a library crate with the same name
as the package, and <em>src/lib.rs</em> is its crate root. Cargo passes the crate root
files to <code>rustc</code> to build the library or binary.</p>
<p>运行 <code>cargo new my-project</code> 后，我们用 <code>ls</code> 查看 Cargo 的生成内容。项目目录中有 <em>Cargo.toml</em> 文件（即包），以及包含 <em>main.rs</em> 的 <em>src</em> 目录。在文本编辑器中打开 <em>Cargo.toml</em>，会发现未提及 <em>src/main.rs</em>。Cargo 遵循的约定是：<em>src/main.rs</em> 是与包同名的二进制箱的箱根。同样，若包目录包含 <em>src/lib.rs</em>，Cargo 会认为该包包含同名库箱，且 <em>src/lib.rs</em> 是其箱根。Cargo 将箱根文件传递给 <code>rustc</code> 来构建库或二进制文件。</p>
<p>Here, we have a package that only contains <em>src/main.rs</em>, meaning it only
contains a binary crate named <code>my-project</code>. If a package contains <em>src/main.rs</em>
and <em>src/lib.rs</em>, it has two crates: a binary and a library, both with the same
name as the package. A package can have multiple binary crates by placing files
in the <em>src/bin</em> directory: each file will be a separate binary crate.</p>
<p>此处，包仅包含 <em>src/main.rs</em>，意味着它只有一个名为 <code>my-project</code> 的二进制箱。若包同时包含 <em>src/main.rs</em> 和 <em>src/lib.rs</em>，则它有两个箱：一个二进制箱和一个库箱，均与包同名。通过在 <em>src/bin</em> 目录放置文件，包可拥有多个二进制箱：每个文件都是独立的二进制箱。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defining-modules-to-control-scope-and-privacy-定义模块以控制作用域与私有性"><a class="header" href="#defining-modules-to-control-scope-and-privacy-定义模块以控制作用域与私有性">Defining Modules to Control Scope and Privacy 定义模块以控制作用域与私有性</a></h2>
<p>In this section, we’ll talk about modules and other parts of the module system,
namely <em>paths</em>, which allow you to name items; the <code>use</code> keyword that brings a
path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss
the <code>as</code> keyword, external packages, and the glob operator.</p>
<p>本节我们将讨论模块及模块系统的其他部分：<strong>路径</strong>（用于命名条目）、<code>use</code> 关键字（将路径引入作用域）、<code>pub</code> 关键字（公开条目）。同时涵盖 <code>as</code> 关键字、外部包和通配符操作符。</p>
<h3 id="modules-cheat-sheet-模块速查表"><a class="header" href="#modules-cheat-sheet-模块速查表">Modules Cheat Sheet 模块速查表</a></h3>
<p>Before we get to the details of modules and paths, here we provide a quick
reference on how modules, paths, the <code>use</code> keyword, and the <code>pub</code> keyword work
in the compiler, and how most developers organize their code. We’ll be going
through examples of each of these rules throughout this chapter, but this is a
great place to refer to as a reminder of how modules work.</p>
<p>在深入模块与路径细节前，先提供关于模块、路径、<code>use</code> 和 <code>pub</code> 在编译器中如何运作的快速参考，以及开发者的常见代码组织方式。本章后续将通过示例演示这些规则，此处可作为模块工作机制的备忘指南。</p>
<ul>
<li><strong>Start from the crate root</strong>: When compiling a crate, the compiler first
looks in the crate root file (usually <em>src/lib.rs</em> for a library crate or
<em>src/main.rs</em> for a binary crate) for code to compile.</li>
<li><strong>从箱根开始</strong>：编译箱时，编译器首先在箱根文件（库箱通常是 <em>src/lib.rs</em>，二进制箱是 <em>src/main.rs</em>）中查找待编译代码。</li>
<li><strong>Declaring modules</strong>: In the crate root file, you can declare new modules;
say you declare a “garden” module with <code>mod garden;</code>. The compiler will look
for the module’s code in these places:</li>
<li><strong>声明模块</strong>：在箱根文件中，可用 <code>mod garden;</code> 声明新模块。编译器会在以下位置查找模块代码：
<ul>
<li>Inline, within curly brackets that replace the semicolon following <code>mod  garden</code></li>
<li>在 <code>mod garden</code> 后的花括号内（替代分号）</li>
<li>In the file <em>src/garden.rs</em></li>
<li>在文件 <em>src/garden.rs</em></li>
<li>In the file <em>src/garden/mod.rs</em></li>
<li>在文件 <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Declaring submodules</strong>: In any file other than the crate root, you can
declare submodules. For example, you might declare <code>mod vegetables;</code> in
<em>src/garden.rs</em>. The compiler will look for the submodule’s code within the
directory named for the parent module in these places:</li>
<li><strong>声明子模块</strong>：在箱根外的任何文件中，可声明子模块（如 <em>src/garden.rs</em> 中的 <code>mod vegetables;</code>）。编译器会在父模块同名目录的以下位置查找子模块代码：
<ul>
<li>Inline, directly following <code>mod vegetables</code>, within curly brackets instead
of the semicolon</li>
<li>紧接 <code>mod vegetables</code> 后的花括号内（替代分号）</li>
<li>In the file <em>src/garden/vegetables.rs</em></li>
<li>在文件 <em>src/garden/vegetables.rs</em></li>
<li>In the file <em>src/garden/vegetables/mod.rs</em></li>
<li>在文件 <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>Paths to code in modules</strong>: Once a module is part of your crate, you can
refer to code in that module from anywhere else in that same crate, as long
as the privacy rules allow, using the path to the code. For example, an
<code>Asparagus</code> type in the garden vegetables module would be found at
<code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>模块内代码的路径</strong>：只要符合私有性规则，模块成为箱的一部分后，可通过路径在箱内任意位置引用其代码。例如，garden vegetables 模块中的 <code>Asparagus</code> 类型位于 <code>crate::garden::vegetables::Asparagus</code>。</li>
<li><strong>Private vs. public</strong>: Code within a module is private from its parent
modules by default. To make a module public, declare it with <code>pub mod</code>
instead of <code>mod</code>. To make items within a public module public as well, use
<code>pub</code> before their declarations.</li>
<li><strong>私有 vs 公有</strong>：模块内代码默认对其父模块私有。使用 <code>pub mod</code> 替代 <code>mod</code> 可公开模块。对公有模块中的条目使用 <code>pub</code> 可进一步公开它们。</li>
<li><strong>The <code>use</code> keyword</strong>: Within a scope, the <code>use</code> keyword creates shortcuts to
items to reduce repetition of long paths. In any scope that can refer to
<code>crate::garden::vegetables::Asparagus</code>, you can create a shortcut with <code>use  crate::garden::vegetables::Asparagus;</code> and from then on you only need to
write <code>Asparagus</code> to make use of that type in the scope.</li>
<li><strong><code>use</code> 关键字</strong>：在作用域内，<code>use</code> 为条目创建快捷方式以减少长路径重复。在能访问 <code>crate::garden::vegetables::Asparagus</code> 的作用域中，使用 <code>use crate::garden::vegetables::Asparagus;</code> 创建快捷方式后，只需写 <code>Asparagus</code> 即可使用该类型。</li>
</ul>
<p>Here, we create a binary crate named <code>backyard</code> that illustrates these rules.
The crate’s directory, also named <code>backyard</code>, contains these files and
directories:</p>
<p>以下示例创建了名为 <code>backyard</code> 的二进制箱，目录结构如下：</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>The crate root file in this case is <em>src/main.rs</em>, and it contains:</p>
<p>此处的箱根文件是 <em>src/main.rs</em>，其内容为：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}</code></pre>
</figure>
<p>The <code>pub mod garden;</code> line tells the compiler to include the code it finds in
<em>src/garden.rs</em>, which is:</p>
<p><code>pub mod garden;</code> 指示编译器包含 <em>src/garden.rs</em> 的代码：</p>
<figure class="listing">
<span class="file-name">Filename: src/garden.rs</span>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
</figure>
<p>Here, <code>pub mod vegetables;</code> means the code in <em>src/garden/vegetables.rs</em> is
included too. That code is:</p>
<p>此处的 <code>pub mod vegetables;</code> 意味着也包含 <em>src/garden/vegetables.rs</em> 的代码：</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>Now let’s get into the details of these rules and demonstrate them in action!</p>
<p>现在让我们深入探讨这些规则并演示其实际应用！</p>
<h3 id="grouping-related-code-in-modules-在模块中组织相关代码"><a class="header" href="#grouping-related-code-in-modules-在模块中组织相关代码">Grouping Related Code in Modules 在模块中组织相关代码</a></h3>
<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.
Modules also allow us to control the <em>privacy</em> of items because code within a
module is private by default. Private items are internal implementation details
not available for outside use. We can choose to make modules and the items
within them public, which exposes them to allow external code to use and depend
on them.</p>
<p><strong>模块</strong>让我们在箱内组织代码以提高可读性和复用性。模块还通过默认私有性控制条目的<strong>可见性</strong>——模块内代码默认私有。私有条目是内部实现细节，不对外部开放。我们可选择将模块及其内部条目设为公有（<code>pub</code>），从而允许外部代码使用和依赖它们。</p>
<p>As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code rather than the
implementation of a restaurant.</p>
<p>例如，我们将编写一个提供餐厅功能的库箱。先定义函数签名而不实现具体逻辑，以便专注于代码组织而非餐厅实现细节。</p>
<p>In the restaurant industry, some parts of a restaurant are referred to as
<em>front of house</em> and others as <em>back of house</em>. Front of house is where
customers are; this encompasses where the hosts seat customers, servers take
orders and payment, and bartenders make drinks. Back of house is where the
chefs and cooks work in the kitchen, dishwashers clean up, and managers do
administrative work.</p>
<p>餐饮业中，餐厅分为<strong>前厅</strong>（front of house）和<strong>后厨</strong>（back of house）。前厅接待顾客，包含领位区、服务员处理点单/付款区、调酒师制作饮品区；后厨是厨师工作区，包含洗碗区和管理员办公区。</p>
<p>To structure our crate in this way, we can organize its functions into nested
modules. Create a new library named <code>restaurant</code> by running <code>cargo new  restaurant --lib</code>. Then enter the code in Listing 7-1 into <em>src/lib.rs</em> to
define some modules and function signatures; this code is the front of house
section.</p>
<p>为按此结构组织箱，我们将函数分层嵌套到模块中。运行 <code>cargo new restaurant --lib</code> 创建名为 <code>restaurant</code> 的新库。将示例 7-1 的代码写入 <em>src/lib.rs</em> 以定义模块和函数签名（这部分代码对应前厅模块）：</p>
<figure class="listing" id="listing-7-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
<figcaption><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html#listing-7-1">Listing 7-1</a>: A <code>front_of_house</code> module containing other modules that then contain functions 包含嵌套模块的 <code>front_of_house</code> 模块，模块内含有函数</figcaption>
</figure>
<p>We define a module with the <code>mod</code> keyword followed by the name of the module
(in this case, <code>front_of_house</code>). The body of the module then goes inside curly
brackets. Inside modules, we can place other modules, as in this case with the
modules <code>hosting</code> and <code>serving</code>. Modules can also hold definitions for other
items, such as structs, enums, constants, traits, and as in Listing 7-1,
functions.</p>
<p>使用 <code>mod</code> 关键字加模块名（此处为 <code>front_of_house</code>）定义模块，模块体位于花括号内。模块内可嵌套其他模块（如 <code>hosting</code> 和 <code>serving</code>）。模块也可包含其他条目定义，如结构体、枚举、常量、特性，以及如示例 7-1 所示的函数。</p>
<p>By using modules, we can group related definitions together and name why
they’re related. Programmers using this code can navigate the code based on the
groups rather than having to read through all the definitions, making it easier
to find the definitions relevant to them. Programmers adding new functionality
to this code would know where to place the code to keep the program organized.</p>
<p>通过模块，我们能将相关定义分组并标明关联性。使用此代码的程序员可按分组导航，无需通读所有定义，从而更易定位相关条目。新增功能时，开发者也能明确代码存放位置以保持组织性。</p>
<p>Earlier, we mentioned that <em>src/main.rs</em> and <em>src/lib.rs</em> are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named <code>crate</code> at the root of the crate’s module structure,
known as the <em>module tree</em>.</p>
<p>前文提到 <em>src/main.rs</em> 和 <em>src/lib.rs</em> 称为箱根。其命名原因是：这两个文件的内容构成箱模块结构根部的 <code>crate</code> 模块，该结构称为<strong>模块树</strong>。</p>
<p>Listing 7-2 shows the module tree for the structure in Listing 7-1.</p>
<p>示例 7-2 展示了示例 7-1 结构的模块树：</p>
<figure class="listing" id="listing-7-2">
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<figcaption><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html#listing-7-2">Listing 7-2</a>: The module tree for the code in Listing 7-1 示例 7-1 代码的模块树</figcaption>
</figure>
<p>This tree shows how some of the modules nest inside other modules; for example,
<code>hosting</code> nests inside <code>front_of_house</code>. The tree also shows that some modules
are <em>siblings</em>, meaning they’re defined in the same module; <code>hosting</code> and
<code>serving</code> are siblings defined within <code>front_of_house</code>. If module A is
contained inside module B, we say that module A is the <em>child</em> of module B and
that module B is the <em>parent</em> of module A. Notice that the entire module tree
is rooted under the implicit module named <code>crate</code>.</p>
<p>此树展示了模块的嵌套关系（如 <code>hosting</code> 嵌套在 <code>front_of_house</code> 中）。同时显示某些模块是<strong>同级模块</strong>（定义在同一模块中），如 <code>hosting</code> 和 <code>serving</code> 都在 <code>front_of_house</code> 内定义。若模块 A 位于模块 B 内部，称 A 是 B 的<strong>子模块</strong>，B 是 A 的<strong>父模块</strong>。注意整个模块树植根于隐式的 <code>crate</code> 模块下。</p>
<p>The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.</p>
<p>模块树可能让你联想到计算机的文件系统目录树——这是非常贴切的类比！如同文件系统中的目录，我们用模块组织代码；如同目录中的文件，我们需要定位模块的路径。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paths-for-referring-to-an-item-in-the-module-tree-在模块树中引用项的路径"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree-在模块树中引用项的路径">Paths for Referring to an Item in the Module Tree 在模块树中引用项的路径</a></h2>
<p>To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. To call a function, we need to
know its path.</p>
<p>为了告诉 Rust 在模块树中查找项的位置，我们使用路径的方式类似于在文件系统中导航路径。要调用函数，我们需要知道其路径。</p>
<p>A path can take two forms:</p>
<p>路径有两种形式：</p>
<ul>
<li>An <em>absolute path</em> is the full path starting from a crate root; for code
from an external crate, the absolute path begins with the crate name, and for
code from the current crate, it starts with the literal <code>crate</code>.</li>
<li><strong>绝对路径</strong>：从 crate 根开始的完整路径。对于外部 crate 的代码，绝对路径以 crate 名称开头；对于当前 crate 的代码，则以字面量 <code>crate</code> 开头。</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or
an identifier in the current module.</li>
<li><strong>相对路径</strong>：从当前模块开始，使用 <code>self</code>、<code>super</code> 或当前模块中的标识符。</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
<p>绝对路径和相对路径后都跟着一个或多个由双冒号(<code>::</code>)分隔的标识符。</p>
<p>Returning to Listing 7-1, say we want to call the <code>add_to_waitlist</code> function.
This is the same as asking: what’s the path of the <code>add_to_waitlist</code> function?
Listing 7-3 contains Listing 7-1 with some of the modules and functions
removed.</p>
<p>回顾示例 7-1，假设我们要调用 <code>add_to_waitlist</code> 函数。这等价于询问：<code>add_to_waitlist</code> 函数的路径是什么？示例 7-3 展示了简化后的模块和函数结构。</p>
<p>We’ll show two ways to call the <code>add_to_waitlist</code> function from a new function,
<code>eat_at_restaurant</code>, defined in the crate root. These paths are correct, but
there’s another problem remaining that will prevent this example from compiling
as is. We’ll explain why in a bit.</p>
<p>我们将展示从 crate 根定义的 <code>eat_at_restaurant</code> 函数中调用 <code>add_to_waitlist</code> 的两种方式。虽然路径正确，但存在另一个问题导致此示例无法编译，稍后会解释原因。</p>
<p>The <code>eat_at_restaurant</code> function is part of our library crate’s public API, so
we mark it with the <code>pub</code> keyword. In the “Exposing Paths with the <code>pub</code>
Keyword” section, we’ll go into more detail about <code>pub</code>.</p>
<p><code>eat_at_restaurant</code> 函数是库 crate 公共 API 的一部分，因此我们用 <code>pub</code> 关键字标记它。在使用 <code>pub</code> 关键字暴露路径一节中会详细讨论 <code>pub</code>。</p>
<figure class="listing" id="listing-7-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-3">Listing 7-3</a>: Calling the <code>add_to_waitlist</code> function using absolute and relative paths 使用绝对路径和相对路径调用 <code>add_to_waitlist</code> 函数</figcaption>
</figure>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>,
we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to
start an absolute path. We then include each of the successive modules until we
make our way to <code>add_to_waitlist</code>. You can imagine a filesystem with the same
structure: we’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to
run the <code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the
crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>在 <code>eat_at_restaurant</code> 中首次调用 <code>add_to_waitlist</code> 时使用了绝对路径。由于 <code>add_to_waitlist</code> 与 <code>eat_at_restaurant</code> 同属一个 crate，我们可以用 <code>crate</code> 关键字起始绝对路径，然后逐级包含模块直到 <code>add_to_waitlist</code>。类比文件系统：要执行 <code>add_to_waitlist</code> 程序需指定路径 <code>/front_of_house/hosting/add_to_waitlist</code>；使用 <code>crate</code> 从 crate 根开始类似于在 shell 中使用 <code>/</code> 从文件系统根开始。</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a
relative path. The path starts with <code>front_of_house</code>, the name of the module
defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the
filesystem equivalent would be using the path
<code>front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means
that the path is relative.</p>
<p>第二次调用时使用了相对路径。路径以 <code>front_of_house</code>（与 <code>eat_at_restaurant</code> 同级的模块名）开头。文件系统中等价路径为 <code>front_of_house/hosting/add_to_waitlist</code>。以模块名起始表示路径是相对的。</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make
based on your project, and it depends on whether you’re more likely to move
item definition code separately from or together with the code that uses the
item. For example, if we moved the <code>front_of_house</code> module and the
<code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d
need to update the absolute path to <code>add_to_waitlist</code>, but the relative path
would still be valid. However, if we moved the <code>eat_at_restaurant</code> function
separately into a module named <code>dining</code>, the absolute path to the
<code>add_to_waitlist</code> call would stay the same, but the relative path would need to
be updated. Our preference in general is to specify absolute paths because it’s
more likely we’ll want to move code definitions and item calls independently of
each other.</p>
<p>选择相对路径还是绝对路径取决于项目需求，需考虑项定义代码与使用代码是否可能分离移动。若将 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数移至 <code>customer_experience</code> 模块，需更新绝对路径，但相对路径仍有效。若将 <code>eat_at_restaurant</code> 单独移至 <code>dining</code> 模块，绝对路径不变，但相对路径需更新。通常我们推荐使用绝对路径，因为更可能独立移动代码定义和调用点。</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The
errors we get are shown in Listing 7-4.</p>
<p>尝试编译示例 7-3 会发现错误，如示例 7-4 所示：</p>
<figure class="listing" id="listing-7-4">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-4">Listing 7-4</a>: Compiler errors from building the code in Listing 7-3 示例 7-3 代码的编译错误</figcaption>
</figure>
<p>The error messages say that module <code>hosting</code> is private. In other words, we
have the correct paths for the <code>hosting</code> module and the <code>add_to_waitlist</code>
function, but Rust won’t let us use them because it doesn’t have access to the
private sections. In Rust, all items (functions, methods, structs, enums,
modules, and constants) are private to parent modules by default. If you want
to make an item like a function or struct private, you put it in a module.</p>
<p>错误信息指出 <code>hosting</code> 模块是私有的。虽然路径正确，但 Rust 因无法访问私有部分而拒绝使用。在 Rust 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对父模块私有。要使函数或结构体等项私有，只需将其放入模块。</p>
<p>Items in a parent module can’t use the private items inside child modules, but
items in child modules can use the items in their ancestor modules. This is
because child modules wrap and hide their implementation details, but the child
modules can see the context in which they’re defined. To continue with our
metaphor, think of the privacy rules as being like the back office of a
restaurant: what goes on in there is private to restaurant customers, but
office managers can see and do everything in the restaurant they operate.</p>
<p>父模块中的项不能使用子模块的私有项，但子模块中的项可使用祖先模块的项。这是因为子模块封装并隐藏了实现细节，但能看见定义它们的上下文。类比餐厅后台办公室：对顾客私有，但经理可查看运营的所有细节。</p>
<p>Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. However, Rust does give
you the option to expose inner parts of child modules’ code to outer ancestor
modules by using the <code>pub</code> keyword to make an item public.</p>
<p>Rust 的模块系统默认隐藏内部实现细节，这样你就知道可以修改哪些内部代码而不破坏外部代码。当然，Rust 也提供 <code>pub</code> 关键字选项来将子模块内部代码暴露给外部祖先模块。</p>
<h3 id="exposing-paths-with-the-pub-keyword-使用-pub-关键字暴露路径"><a class="header" href="#exposing-paths-with-the-pub-keyword-使用-pub-关键字暴露路径">Exposing Paths with the <code>pub</code> Keyword 使用 <code>pub</code> 关键字暴露路径</a></h3>
<p>Let’s return to the error in Listing 7-4 that told us the <code>hosting</code> module is
private. We want the <code>eat_at_restaurant</code> function in the parent module to have
access to the <code>add_to_waitlist</code> function in the child module, so we mark the
<code>hosting</code> module with the <code>pub</code> keyword, as shown in Listing 7-5.</p>
<p>回到示例 7-4 关于 <code>hosting</code> 模块私有的错误。为了让父模块的 <code>eat_at_restaurant</code> 函数访问子模块的 <code>add_to_waitlist</code> 函数，我们用 <code>pub</code> 标记 <code>hosting</code> 模块，如示例 7-5 所示：</p>
<figure class="listing" id="listing-7-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-5">Listing 7-5</a>: Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code> 将 <code>hosting</code> 模块声明为 <code>pub</code> 以便从 <code>eat_at_restaurant</code> 使用</figcaption>
</figure>
<p>Unfortunately, the code in Listing 7-5 still results in compiler errors, as
shown in Listing 7-6.</p>
<p>但示例 7-5 仍会导致编译错误，如示例 7-6 所示：</p>
<figure class="listing" id="listing-7-6">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-6">Listing 7-6</a>: Compiler errors from building the code in Listing 7-5 示例 7-5 代码的编译错误</figcaption>
</figure>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting</code> makes the
module public. With this change, if we can access <code>front_of_house</code>, we can
access <code>hosting</code>. But the <em>contents</em> of <code>hosting</code> are still private; making the
module public doesn’t make its contents public. The <code>pub</code> keyword on a module
only lets code in its ancestor modules refer to it, not access its inner code.
Because modules are containers, there’s not much we can do by only making the
module public; we need to go further and choose to make one or more of the
items within the module public as well.</p>
<p>原因何在？在 <code>mod hosting</code> 前添加 <code>pub</code> 使模块公开后，若能访问 <code>front_of_house</code> 就能访问 <code>hosting</code>，但 <code>hosting</code> 的<strong>内容</strong>仍私有。模块的 <code>pub</code> 关键字仅允许祖先模块引用它，而非访问其内部代码。由于模块是容器，仅公开模块作用有限，还需进一步选择公开模块内的一个或多个项。</p>
<p>The errors in Listing 7-6 say that the <code>add_to_waitlist</code> function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.</p>
<p>示例 7-6 的错误表明 <code>add_to_waitlist</code> 函数是私有的。隐私规则同样适用于结构体、枚举、函数、方法和模块。</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code>
keyword before its definition, as in Listing 7-7.</p>
<p>我们在 <code>add_to_waitlist</code> 函数定义前添加 <code>pub</code> 关键字使其公开，如示例 7-7 所示：</p>
<figure class="listing" id="listing-7-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-7">Listing 7-7</a>: Adding the <code>pub</code> keyword to <code>mod hosting</code> and <code>fn add_to_waitlist</code> lets us call the function from <code>eat_at_restaurant</code> 给 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 添加 <code>pub</code> 关键字</figcaption>
</figure>
<p>Now the code will compile! To see why adding the <code>pub</code> keyword lets us use
these paths in <code>eat_at_restaurant</code> with respect to the privacy rules, let’s look
at the absolute and the relative paths.</p>
<p>现在代码可以编译了！关于为何添加 <code>pub</code> 后能在 <code>eat_at_restaurant</code> 使用这些路径，让我们从隐私规则角度分析绝对路径和相对路径：</p>
<p>In the absolute path, we start with <code>crate</code>, the root of our crate’s module
tree. The <code>front_of_house</code> module is defined in the crate root. While
<code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is
defined in the same module as <code>front_of_house</code> (that is, <code>eat_at_restaurant</code>
and <code>front_of_house</code> are siblings), we can refer to <code>front_of_house</code> from
<code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can
access the parent module of <code>hosting</code>, so we can access <code>hosting</code>. Finally, the
<code>add_to_waitlist</code> function is marked with <code>pub</code> and we can access its parent
module, so this function call works!</p>
<p><strong>绝对路径</strong>：从 <code>crate</code>（crate 模块树的根）开始。<code>front_of_house</code> 模块定义在 crate 根中。虽然 <code>front_of_house</code> 非公开，但因 <code>eat_at_restaurant</code> 与它定义在同一模块（即它们是同级），可以从 <code>eat_at_restaurant</code> 引用 <code>front_of_house</code>。接着是用 <code>pub</code> 标记的 <code>hosting</code> 模块，我们能访问其父模块，故可访问 <code>hosting</code>。最后，<code>add_to_waitlist</code> 函数被标记为 <code>pub</code> 且我们能访问其父模块，因此函数调用成立！</p>
<p>In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
<code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module
as <code>eat_at_restaurant</code>, so the relative path starting from the module in which
<code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and
<code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this
function call is valid!</p>
<p><strong>相对路径</strong>：逻辑与绝对路径相同，仅第一步不同：路径从 <code>front_of_house</code> 而非 crate 根开始。<code>front_of_house</code> 模块与 <code>eat_at_restaurant</code> 定义在同一模块内，因此从 <code>eat_at_restaurant</code> 所在模块开始的相对路径有效。之后因 <code>hosting</code> 和 <code>add_to_waitlist</code> 被标记为 <code>pub</code>，路径剩余部分有效，函数调用成立！</p>
<p>If you plan on sharing your library crate so other projects can use your code,
your public API is your contract with users of your crate that determines how
they can interact with your code. There are many considerations around managing
changes to your public API to make it easier for people to depend on your
crate. These considerations are beyond the scope of this book; if you’re
interested in this topic, see The Rust API Guidelines.</p>
<p>若计划共享库 crate 供其他项目使用，公共 API 就是你与 crate 用户之间的契约。管理公共 API 变更有许多考量点，这些超出了本书范围；若感兴趣可参阅《Rust API 指南》。</p>
<section class="note" aria-role="note">
<h4 id="best-practices-for-packages-with-a-binary-and-a-library-含二进制和库的包的最佳实践"><a class="header" href="#best-practices-for-packages-with-a-binary-and-a-library-含二进制和库的包的最佳实践">Best Practices for Packages with a Binary and a Library 含二进制和库的包的最佳实践</a></h4>
<p>We mentioned that a package can contain both a <em>src/main.rs</em> binary crate
root as well as a <em>src/lib.rs</em> library crate root, and both crates will have
the package name by default. Typically, packages with this pattern of
containing both a library and a binary crate will have just enough code in the
binary crate to start an executable that calls code defined in the library
crate. This lets other projects benefit from the most functionality that the
package provides because the library crate’s code can be shared.</p>
<p>我们提到包可同时包含 <em>src/main.rs</em> 二进制 crate 根和 <em>src/lib.rs</em> 库 crate 根，且两者默认使用包名。通常这类包中，二进制 crate 只包含启动执行代码并调用库 crate 定义的代码。这样其他项目可最大程度复用包的功能，因为库 crate 的代码可共享。</p>
<p>The module tree should be defined in <em>src/lib.rs</em>. Then, any public items can
be used in the binary crate by starting paths with the name of the package.
The binary crate becomes a user of the library crate just like a completely
external crate would use the library crate: it can only use the public API.
This helps you design a good API; not only are you the author, you’re also a
client!</p>
<p>模块树应在 <em>src/lib.rs</em> 中定义。然后二进制 crate 可通过以包名开头的路径使用所有公共项。二进制 crate 成为库 crate 的用户，就像完全外部 crate 那样：只能使用公共 API。这有助于设计良好 API，因为你既是作者也是客户！</p>
<p>In Chapter 12, we’ll demonstrate this organizational
practice with a command line program that will contain both a binary crate
and a library crate.</p>
<p>第 12 章将通过命令行程序演示此实践，该程序将包含二进制 crate 和库 crate。</p>
</section>
<h3 id="starting-relative-paths-with-super-使用-super-起始相对路径"><a class="header" href="#starting-relative-paths-with-super-使用-super-起始相对路径">Starting Relative Paths with <code>super</code> 使用 <code>super</code> 起始相对路径</a></h3>
<p>We can construct relative paths that begin in the parent module, rather than
the current module or the crate root, by using <code>super</code> at the start of the
path. This is like starting a filesystem path with the <code>..</code> syntax that means
to go to the parent directory. Using <code>super</code> allows us to reference an item
that we know is in the parent module, which can make rearranging the module
tree easier when the module is closely related to the parent but the parent
might be moved elsewhere in the module tree someday.</p>
<p>通过在路径开头使用 <code>super</code>，可以构建起始于父模块而非当前模块或 crate 根的相对路径。这类似于文件系统中用 <code>..</code> 表示进入父目录。使用 <code>super</code> 允许引用已知在父模块中的项，当模块与父模块紧密关联但未来可能移动时，能简化模块树重组。</p>
<p>Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function <code>fix_incorrect_order</code> defined in the <code>back_of_house</code> module calls the
function <code>deliver_order</code> defined in the parent module by specifying the path to
<code>deliver_order</code>, starting with <code>super</code>.</p>
<p>考虑示例 7-8 的代码，模拟厨师修正错误订单并亲自送给顾客的场景。定义在 <code>back_of_house</code> 模块的 <code>fix_incorrect_order</code> 函数，通过以 <code>super</code> 起始的路径调用父模块中的 <code>deliver_order</code> 函数。</p>
<figure class="listing" id="listing-7-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-8">Listing 7-8</a>: Calling a function using a relative path starting with <code>super</code> 使用以 <code>super</code> 开头的相对路径调用函数</figcaption>
</figure>
<p>The <code>fix_incorrect_order</code> function is in the <code>back_of_house</code> module, so we can
use <code>super</code> to go to the parent module of <code>back_of_house</code>, which in this case
is <code>crate</code>, the root. From there, we look for <code>deliver_order</code> and find it.
Success! We think the <code>back_of_house</code> module and the <code>deliver_order</code> function
are likely to stay in the same relationship to each other and get moved
together should we decide to reorganize the crate’s module tree. Therefore, we
used <code>super</code> so we’ll have fewer places to update code in the future if this
code gets moved to a different module.</p>
<p><code>fix_incorrect_order</code> 函数在 <code>back_of_house</code> 模块中，因此可用 <code>super</code> 访问其父模块（此处是 crate 根）。在此找到 <code>deliver_order</code> 并成功调用！我们认为 <code>back_of_house</code> 模块和 <code>deliver_order</code> 函数很可能保持相互关系，若重组模块树会一起移动。因此使用 <code>super</code> 后，未来移动这些代码时需修改的地方更少。</p>
<h3 id="making-structs-and-enums-public-公开结构体和枚举"><a class="header" href="#making-structs-and-enums-public-公开结构体和枚举">Making Structs and Enums Public 公开结构体和枚举</a></h3>
<p>We can also use <code>pub</code> to designate structs and enums as public, but there are a
few extra details to the usage of <code>pub</code> with structs and enums. If we use <code>pub</code>
before a struct definition, we make the struct public, but the struct’s fields
will still be private. We can make each field public or not on a case-by-case
basis. In Listing 7-9, we’ve defined a public <code>back_of_house::Breakfast</code> struct
with a public <code>toast</code> field but a private <code>seasonal_fruit</code> field. This models
the case in a restaurant where the customer can pick the type of bread that
comes with a meal, but the chef decides which fruit accompanies the meal based
on what’s in season and in stock. The available fruit changes quickly, so
customers can’t choose the fruit or even see which fruit they’ll get.</p>
<p>也可用 <code>pub</code> 将结构体和枚举设为公开，但有些额外细节：<code>pub</code> 使结构体公开，但字段仍私有。可逐字段选择是否公开；<code>pub</code> 使枚举公开后，其所有变体自动公开。示例 7-9 定义了公开的 <code>back_of_house::Breakfast</code> 结构体，其中 <code>toast</code> 字段公开而 <code>seasonal_fruit</code> 字段私有。这模拟了餐厅中顾客选择面包类型，但厨师根据季节和库存搭配水果的场景（水果变化快，顾客不能选择甚至看不到水果）。</p>
<figure class="listing" id="listing-7-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast.
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like.
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-9">Listing 7-9</a>: A struct with some public fields and some private fields 包含公开字段和私有字段的结构体</figcaption>
</figure>
<p>Because the <code>toast</code> field in the <code>back_of_house::Breakfast</code> struct is public,
in <code>eat_at_restaurant</code> we can write and read to the <code>toast</code> field using dot
notation. Notice that we can’t use the <code>seasonal_fruit</code> field in
<code>eat_at_restaurant</code>, because <code>seasonal_fruit</code> is private. Try uncommenting the
line modifying the <code>seasonal_fruit</code> field value to see what error you get!</p>
<p>因 <code>back_of_house::Breakfast</code> 结构体的 <code>toast</code> 字段公开，在 <code>eat_at_restaurant</code> 中可用点号读写该字段。注意不可使用 <code>seasonal_fruit</code> 字段（它是私有的）。尝试取消修改该字段的注释，观察错误！</p>
<p>Also, note that because <code>back_of_house::Breakfast</code> has a private field, the
struct needs to provide a public associated function that constructs an
instance of <code>Breakfast</code> (we’ve named it <code>summer</code> here). If <code>Breakfast</code> didn’t
have such a function, we couldn’t create an instance of <code>Breakfast</code> in
<code>eat_at_restaurant</code> because we couldn’t set the value of the private
<code>seasonal_fruit</code> field in <code>eat_at_restaurant</code>.</p>
<p>另外注意，由于 <code>back_of_house::Breakfast</code> 有私有字段，结构体需提供公开关联函数（此处命名为 <code>summer</code>）来构造实例。若没有此函数，在 <code>eat_at_restaurant</code> 中无法创建 <code>Breakfast</code> 实例，因为无法设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p>In contrast, if we make an enum public, all of its variants are then public. We
only need the <code>pub</code> before the <code>enum</code> keyword, as shown in Listing 7-10.</p>
<p>相反，公开枚举时其所有变体会自动公开（仅需在 <code>enum</code> 关键字前加 <code>pub</code>），如示例 7-10 所示：</p>
<figure class="listing" id="listing-7-10">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<figcaption><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#listing-7-10">Listing 7-10</a>: Designating an enum as public makes all its variants public. 公开枚举会使其所有变体自动公开</figcaption>
</figure>
<p>Because we made the <code>Appetizer</code> enum public, we can use the <code>Soup</code> and <code>Salad</code>
variants in <code>eat_at_restaurant</code>.</p>
<p>将 <code>Appetizer</code> 枚举设为公开后，即可在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 变体。</p>
<p>Enums aren’t very useful unless their variants are public; it would be annoying
to have to annotate all enum variants with <code>pub</code> in every case, so the default
for enum variants is to be public. Structs are often useful without their
fields being public, so struct fields follow the general rule of everything
being private by default unless annotated with <code>pub</code>.</p>
<p>枚举若变体不公开则用处不大，若每次都给所有变体标注 <code>pub</code> 会很繁琐，因此枚举变体默认公开。结构体字段默认私有则通常更有用，除非用 <code>pub</code> 标注。</p>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that is
our last module system feature: the <code>use</code> keyword. We’ll cover <code>use</code> by itself
first, and then we’ll show how to combine <code>pub</code> and <code>use</code>.</p>
<p>最后还有一种涉及 <code>pub</code> 的情形，这是我们模块系统的最后一个功能：<code>use</code> 关键字。我们将先单独介绍 <code>use</code>，再展示如何组合 <code>pub</code> 和 <code>use</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bringing-paths-into-scope-with-the-use-keyword-使用-use-关键字将路径引入作用域"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword-使用-use-关键字将路径引入作用域">Bringing Paths into Scope with the <code>use</code> Keyword 使用 <code>use</code> 关键字将路径引入作用域</a></h2>
<p>Having to write out the paths to call functions can feel inconvenient and
repetitive. In Listing 7-7, whether we chose the absolute or relative path to
the <code>add_to_waitlist</code> function, every time we wanted to call <code>add_to_waitlist</code>
we had to specify <code>front_of_house</code> and <code>hosting</code> too. Fortunately, there’s a
way to simplify this process: we can create a shortcut to a path with the <code>use</code>
keyword once, and then use the shorter name everywhere else in the scope.</p>
<p>反复写出调用函数的路径既不方便又显得重复。在示例 7-7 中，无论选择绝对路径还是相对路径来调用 <code>add_to_waitlist</code> 函数，每次调用时都必须同时指定 <code>front_of_house</code> 和 <code>hosting</code>。幸运的是，有一种简化方法：我们可以使用 <code>use</code> 关键字创建路径的快捷方式，然后在作用域内其他位置使用短名称。</p>
<p>In Listing 7-11, we bring the <code>crate::front_of_house::hosting</code> module into the
scope of the <code>eat_at_restaurant</code> function so we only have to specify
<code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p>在示例 7-11 中，我们将 <code>crate::front_of_house::hosting</code> 模块引入 <code>eat_at_restaurant</code> 函数的作用域，因此在函数内调用 <code>add_to_waitlist</code> 只需指定 <code>hosting::add_to_waitlist</code>。</p>
<figure class="listing" id="listing-7-11">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-11">Listing 7-11</a>: Bringing a module into scope with <code>use</code> 使用 <code>use</code> 将模块引入作用域</figcaption>
</figure>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding <code>use crate::front_of_house::hosting</code> in the crate
root, <code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code>
module had been defined in the crate root. Paths brought into scope with <code>use</code>
also check privacy, like any other paths.</p>
<p>在作用域中添加 <code>use</code> 和路径类似于在文件系统中创建符号链接。通过在 crate 根中添加 <code>use crate::front_of_house::hosting</code>，<code>hosting</code> 在该作用域内成为有效名称，就像 <code>hosting</code> 模块直接定义在 crate 根中一样。使用 <code>use</code> 引入作用域的路径也会像其他路径一样进行私有性检查。</p>
<p>Note that <code>use</code> only creates the shortcut for the particular scope in which the
<code>use</code> occurs. Listing 7-12 moves the <code>eat_at_restaurant</code> function into a new
child module named <code>customer</code>, which is then a different scope than the <code>use</code>
statement, so the function body won’t compile.</p>
<p><span class="highlight">[note]注意 <code>use</code> 仅在其出现的作用域内创建快捷方式。</span>示例 7-12 将 <code>eat_at_restaurant</code> 函数移至名为 <code>customer</code> 的新子模块中，该子模块与 <code>use</code> 语句处于不同作用域，因此函数体无法编译。</p>
<figure class="listing" id="listing-7-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-12">Listing 7-12</a>: A <code>use</code> statement only applies in the scope it’s in. <code>use</code> 语句仅在其所在作用域内生效</figcaption>
</figure>
<p>The compiler error shows that the shortcut no longer applies within the
<code>customer</code> module:</p>
<p>编译器错误表明快捷方式在 <code>customer</code> 模块内不再有效：</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Notice there’s also a warning that the <code>use</code> is no longer used in its scope! To
fix this problem, move the <code>use</code> within the <code>customer</code> module too, or reference
the shortcut in the parent module with <code>super::hosting</code> within the child
<code>customer</code> module.</p>
<p>注意还有一个警告提示 <code>use</code> 在其作用域内未使用！要解决此问题，可将 <code>use</code> 也移至 <code>customer</code> 模块内，或在子模块中通过 <code>super::hosting</code> 引用父模块的快捷方式。</p>
<h3 id="creating-idiomatic-use-paths-创建符合语言习惯的-use-路径"><a class="header" href="#creating-idiomatic-use-paths-创建符合语言习惯的-use-路径">Creating Idiomatic <code>use</code> Paths 创建符合语言习惯的 <code>use</code> 路径</a></h3>
<p>In Listing 7-11, you might have wondered why we specified <code>use  crate::front_of_house::hosting</code> and then called <code>hosting::add_to_waitlist</code> in
<code>eat_at_restaurant</code>, rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing 7-13.</p>
<p>在示例 7-11 中，您可能好奇为何我们指定 <code>use crate::front_of_house::hosting</code> 然后在 <code>eat_at_restaurant</code> 中调用 <code>hosting::add_to_waitlist</code>，而不是像示例 7-13 那样直接指定到 <code>add_to_waitlist</code> 函数的完整路径。</p>
<figure class="listing" id="listing-7-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-13">Listing 7-13</a>: Bringing the <code>add_to_waitlist</code> function into scope with <code>use</code>, which is unidiomatic 使用 <code>use</code> 将 <code>add_to_waitlist</code> 函数引入作用域（不符合语言习惯）</figcaption>
</figure>
<p>Although both Listing 7-11 and Listing 7-13 accomplish the same task, Listing
7-11 is the idiomatic way to bring a function into scope with <code>use</code>. Bringing
the function’s parent module into scope with <code>use</code> means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn’t locally defined
while still minimizing repetition of the full path. The code in Listing 7-13 is
unclear as to where <code>add_to_waitlist</code> is defined.</p>
<p>虽然示例 7-11 和 7-13 都能完成任务，但示例 7-11 是使用 <code>use</code> 引入函数的惯用方式。通过 <code>use</code> 引入函数的父模块意味着调用时需指定父模块。这样能清晰表明函数非本地定义，同时避免重复完整路径。示例 7-13 的代码无法明确看出 <code>add_to_waitlist</code> 的定义位置。</p>
<p>On the other hand, when bringing in structs, enums, and other items with <code>use</code>,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s <code>HashMap</code> struct into the scope of a binary
crate.</p>
<p><span class="highlight">[note]相反地，当引入结构体、枚举等类型时，习惯上指定完整路径。</span>示例 7-14 展示了将标准库的 <code>HashMap</code> 结构体引入二进制 crate 作用域的惯用方式。</p>
<figure class="listing" id="listing-7-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-14">Listing 7-14</a>: Bringing <code>HashMap</code> into scope in an idiomatic way 以符合语言习惯的方式将 <code>HashMap</code> 引入作用域</figcaption>
</figure>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>此惯例没有特别原因，仅是社区形成的共识，开发者已习惯以此方式读写 Rust 代码。</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two <code>Result</code> types into scope that have the same name but
different parent modules, and how to refer to them.</p>
<p>例外情况是当引入两个同名项时，因为 Rust 不允许这样做。示例 7-15 展示了如何引入两个同名但父模块不同的 <code>Result</code> 类型及其引用方式。</p>
<figure class="listing" id="listing-7-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-15">Listing 7-15</a>: Bringing two types with the same name into the same scope requires using their parent modules. 将同名类型引入同一作用域需使用父模块区分</figcaption>
</figure>
<p>As you can see, using the parent modules distinguishes the two <code>Result</code> types.
If instead we specified <code>use std::fmt::Result</code> and <code>use std::io::Result</code>, we’d
have two <code>Result</code> types in the same scope, and Rust wouldn’t know which one we
meant when we used <code>Result</code>.</p>
<p>可见使用父模块能区分两个 <code>Result</code> 类型。若指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，则同一作用域会出现两个 <code>Result</code> 类型，Rust 无法确定使用 <code>Result</code> 时的具体指向。</p>
<h3 id="providing-new-names-with-the-as-keyword-使用-as-关键字提供新名称"><a class="header" href="#providing-new-names-with-the-as-keyword-使用-as-关键字提供新名称">Providing New Names with the <code>as</code> Keyword 使用 <code>as</code> 关键字提供新名称</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or <em>alias</em>, for the type. Listing 7-16 shows another way to write
the code in Listing 7-15 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<p>解决同名类型冲突的另一种方案：在路径后指定 <code>as</code> 及新本地名称（即别名）。示例 7-16 通过 <code>as</code> 重命名其中一个 <code>Result</code> 类型，提供了另一种实现方式。</p>
<figure class="listing" id="listing-7-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-16">Listing 7-16</a>: Renaming a type when it’s brought into scope with the <code>as</code> keyword 使用 <code>as</code> 关键字在引入作用域时重命名类型</figcaption>
</figure>
<p>In the second <code>use</code> statement, we chose the new name <code>IoResult</code> for the
<code>std::io::Result</code> type, which won’t conflict with the <code>Result</code> from <code>std::fmt</code>
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!</p>
<p>第二个 <code>use</code> 语句中，我们将 <code>std::io::Result</code> 重命名为 <code>IoResult</code>，避免与已引入的 <code>std::fmt::Result</code> 冲突。示例 7-15 和 7-16 均符合语言习惯，可自由选择！</p>
<h3 id="re-exporting-names-with-pub-use-使用-pub-use-重导出名称"><a class="header" href="#re-exporting-names-with-pub-use-使用-pub-use-重导出名称">Re-exporting Names with <code>pub use</code> 使用 <code>pub use</code> 重导出名称</a></h3>
<p>When we bring a name into scope with the <code>use</code> keyword, the name is private to
the scope into which we imported it. To enable code outside that scope to refer
to that name as if it had been defined in that scope, we can combine <code>pub</code> and
<code>use</code>. This technique is called <em>re-exporting</em> because we’re bringing an item
into scope but also making that item available for others to bring into their
scope.</p>
<p>使用 <code>use</code> 关键字引入作用域的名称默认私有。若要让外部代码像访问本地定义一样访问该名称，可结合 <code>pub</code> 和 <code>use</code>，此技术称为重导出（re-exporting），因为我们既将项引入作用域，又允许其他代码导入该项。</p>
<p>Listing 7-17 shows the code in Listing 7-11 with <code>use</code> in the root module
changed to <code>pub use</code>.</p>
<p>示例 7-17 将示例 7-11 中根模块的 <code>use</code> 改为 <code>pub use</code>。</p>
<figure class="listing" id="listing-7-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-17">Listing 7-17</a>: Making a name available for any code to use from a new scope with <code>pub use</code> 使用 <code>pub use</code> 使名称可从新作用域公开访问</figcaption>
</figure>
<p>Before this change, external code would have to call the <code>add_to_waitlist</code>
function by using the path
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>, which also would have
required the <code>front_of_house</code> module to be marked as <code>pub</code>. Now that this <code>pub  use</code> has re-exported the <code>hosting</code> module from the root module, external code
can use the path <code>restaurant::hosting::add_to_waitlist()</code> instead.</p>
<p>修改前，外部代码需通过路径 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 调用函数，且 <code>front_of_house</code> 模块需标记为 <code>pub</code>。现在通过 <code>pub use</code> 从根模块重导出 <code>hosting</code> 后，外部代码可使用路径 <code>restaurant::hosting::add_to_waitlist()</code>。</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With <code>pub  use</code>, we can write our code with one structure but expose a different structure.
Doing so makes our library well organized for programmers working on the library
and programmers calling the library. We’ll look at another example of <code>pub use</code>
and how it affects your crate’s documentation in “Exporting a Convenient Public
API with <code>pub use</code>” in Chapter 14.</p>
<p>当代码内部结构与调用者理解的领域模型不同时，重导出非常有用。例如在餐厅隐喻中，经营者考虑的是“前厅”和“后厨”，但顾客可能不会这样区分。通过 <code>pub use</code>，我们可以用一种结构编写代码，却暴露另一种结构。这样既便于库开发者组织代码，也便于库使用者调用。第 14 章将通过“使用 <code>pub use</code> 导出便捷的公共 API”展示另一个案例及其对文档的影响。</p>
<h3 id="using-external-packages-使用外部包"><a class="header" href="#using-external-packages-使用外部包">Using External Packages 使用外部包</a></h3>
<p>In Chapter 2, we programmed a guessing game project that used an external
package called <code>rand</code> to get random numbers. To use <code>rand</code> in our project, we
added this line to <em>Cargo.toml</em>:</p>
<p>在第 2 章的猜数字项目中，我们使用名为 <code>rand</code> 的外部包获取随机数。要在项目中使用 <code>rand</code>，需在 <em>Cargo.toml</em> 中添加：</p>
<figure class="listing">
<span class="file-name">Filename: Cargo.toml</span>
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</figure>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the
<code>rand</code> package and any dependencies from <a href="https://crates.io/">crates.io</a> and
make <code>rand</code> available to our project.</p>
<p>在 <em>Cargo.toml</em> 中添加 <code>rand</code> 依赖会指示 Cargo 从 <a href="https://crates.io/">crates.io</a> 下载该包及其依赖，并使 <code>rand</code> 对我们的项目可用。</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a
<code>use</code> line starting with the name of the crate, <code>rand</code>, and listed the items we
wanted to bring into scope. Recall that in “Generating a Random
Number” in Chapter 2, we brought the <code>Rng</code> trait into
scope and called the <code>rand::thread_rng</code> function:</p>
<p>接着通过以 crate 名 <code>rand</code> 开头的 <code>use</code> 行将定义引入作用域。回顾第 2 章“生成随机数”部分，我们将 <code>Rng</code> 特质引入作用域并调用 <code>rand::thread_rng</code> 函数：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>Members of the Rust community have made many packages available at
<a href="https://crates.io/">crates.io</a>, and pulling any of them into your package
involves these same steps: listing them in your package’s <em>Cargo.toml</em> file and
using <code>use</code> to bring items from their crates into scope.</p>
<p>Rust 社区成员在 <a href="https://crates.io/">crates.io</a> 提供了大量包，将它们引入项目都遵循相同步骤：在 <em>Cargo.toml</em> 列出依赖，并通过 <code>use</code> 将项从它们的 crate 引入作用域。</p>
<p>Note that the standard <code>std</code> library is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change <em>Cargo.toml</em> to include <code>std</code>. But we do need to refer to
it with <code>use</code> to bring items from there into our package’s scope. For example,
with <code>HashMap</code> we would use this line:</p>
<p>注意标准库 <code>std</code> 也是外部 crate。因其随 Rust 语言一同分发，无需修改 <em>Cargo.toml</em> 来包含 <code>std</code>，但仍需通过 <code>use</code> 将其项引入项目作用域。例如引入 <code>HashMap</code> 需使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library
crate.</p>
<p>这是以标准库 crate 名 <code>std</code> 开头的绝对路径。</p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists-使用嵌套路径简化大量-use-列表"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists-使用嵌套路径简化大量-use-列表">Using Nested Paths to Clean Up Large <code>use</code> Lists 使用嵌套路径简化大量 <code>use</code> 列表</a></h3>
<p>If we’re using multiple items defined in the same crate or same module, listing
each item on its own line can take up a lot of vertical space in our files. For
example, these two <code>use</code> statements we had in the guessing game in Listing 2-4
bring items from <code>std</code> into scope:</p>
<p>当使用同一 crate 或模块中定义的多个项时，逐行列出的方式会占用大量垂直空间。例如示例 2-4 猜数字游戏中这两个从 <code>std</code> 引入项的语句：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.</p>
<p>我们可以改用嵌套路径在一行内引入相同项。具体做法是指定路径的共同部分，后跟双冒号和花括号包裹的不同部分列表，如示例 7-18 所示。</p>
<figure class="listing" id="listing-7-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-18">Listing 7-18</a>: Specifying a nested path to bring multiple items with the same prefix into scope 使用嵌套路径将具有相同前缀的多个项引入作用域</figcaption>
</figure>
<p>In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate <code>use</code> statements
needed by a lot!</p>
<p>在大型程序中，使用嵌套路径从同一 crate 或模块引入多项能显著减少单独的 <code>use</code> 语句数量！</p>
<p>We can use a nested path at any level in a path, which is useful when combining
two <code>use</code> statements that share a subpath. For example, Listing 7-19 shows two
<code>use</code> statements: one that brings <code>std::io</code> into scope and one that brings
<code>std::io::Write</code> into scope.</p>
<p>嵌套路径可在路径的任何层级使用，这在合并共享子路径的两个 <code>use</code> 语句时特别有用。例如示例 7-19 的两个语句：一个引入 <code>std::io</code>，另一个引入 <code>std::io::Write</code>。</p>
<figure class="listing" id="listing-7-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-19">Listing 7-19</a>: Two <code>use</code> statements where one is a subpath of the other 两个 <code>use</code> 语句，其中一个是另一个的子路径</figcaption>
</figure>
<p>The common part of these two paths is <code>std::io</code>, and that’s the complete first
path. To merge these two paths into one <code>use</code> statement, we can use <code>self</code> in
the nested path, as shown in Listing 7-20.</p>
<p>这两个路径的共同部分是 <code>std::io</code>（即第一个完整路径）。要合并为一个 <code>use</code> 语句，可在嵌套路径中使用 <code>self</code>，如示例 7-20 所示。</p>
<figure class="listing" id="listing-7-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<figcaption><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#listing-7-20">Listing 7-20</a>: Combining the paths in Listing 7-19 into one <code>use</code> statement 将示例 7-19 的路径合并为单个 <code>use</code> 语句</figcaption>
</figure>
<p>This line brings <code>std::io</code> and <code>std::io::Write</code> into scope.</p>
<p>此行将 <code>std::io</code> 和 <code>std::io::Write</code> 同时引入作用域。</p>
<h3 id="the-glob-operator-全局运算符"><a class="header" href="#the-glob-operator-全局运算符">The Glob Operator 全局运算符</a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by the <code>*</code> glob operator:</p>
<p>若要将路径中所有公共项引入作用域，可在路径后添加 <code>*</code> 全局运算符：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>std::collections</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined. Additionally, if the dependency changes its definitions, what
you’ve imported changes as well, which may lead to compiler errors when you
upgrade the dependency if the dependency adds a definition with the same name
as a definition of yours in the same scope, for example.</p>
<p>此 <code>use</code> 语句将 <code>std::collections</code> 内定义的所有公共项引入当前作用域。使用全局运算符需谨慎！它可能导致作用域内的名称来源不清晰。此外，若依赖项更新定义（例如添加了与您代码中同名的项），升级依赖时可能引发冲突错误。</p>
<p>The glob operator is often used when testing to bring everything under test into
the <code>tests</code> module; we’ll talk about that in “How to Write
Tests” in Chapter 11. The glob operator is also
sometimes used as part of the prelude pattern: see the standard library
documentation for more
information on that pattern.</p>
<p>全局运算符常用于测试场景（将测试模块的所有内容引入 <code>tests</code> 模块），第 11 章“如何编写测试”将详细讨论。它有时也作为预导入模式的一部分使用，详见标准库文档中的模式说明。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="separating-modules-into-different-files-将模块拆分为不同文件"><a class="header" href="#separating-modules-into-different-files-将模块拆分为不同文件">Separating Modules into Different Files 将模块拆分为不同文件</a></h2>
<p>So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.</p>
<p>到目前为止，本章所有示例都在单个文件中定义多个模块。当模块规模增大时，你可能需要将其定义移至单独文件，以便更轻松地浏览代码。</p>
<p>For example, let’s start from the code in Listing 7-17 that had multiple
restaurant modules. We’ll extract modules into files instead of having all the
modules defined in the crate root file. In this case, the crate root file is
<em>src/lib.rs</em>, but this procedure also works with binary crates whose crate root
file is <em>src/main.rs</em>.</p>
<p>例如，我们从代码清单7-17中的多模块餐厅代码开始。我们将把模块提取到文件中，而不是将所有模块都定义在包根文件中。本例中包根文件是 <em>src/lib.rs</em>，但此流程同样适用于包根文件为 <em>src/main.rs</em> 的二进制包。</p>
<p>First we’ll extract the <code>front_of_house</code> module to its own file. Remove the
code inside the curly brackets for the <code>front_of_house</code> module, leaving only
the <code>mod front_of_house;</code> declaration, so that <em>src/lib.rs</em> contains the code
shown in Listing 7-21. Note that this won’t compile until we create the
<em>src/front_of_house.rs</em> file in Listing 7-22.</p>
<p>首先将 <code>front_of_house</code> 模块提取到单独文件。删除 <code>front_of_house</code> 模块花括号内的代码，仅保留 <code>mod front_of_house;</code> 声明。此时 <em>src/lib.rs</em> 内容如代码清单7-21所示。注意：在创建代码清单7-22的 <em>src/front_of_house.rs</em> 文件前，此代码无法编译通过。</p>
<figure class="listing" id="listing-7-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="ch07-05-separating-modules-into-different-files.html#listing-7-21">Listing 7-21</a>: Declaring the <code>front_of_house</code> module whose body will be in <em>src/front_of_house.rs</em> 声明 <code>front_of_house</code> 模块（其内容将位于 <em>src/front_of_house.rs</em>）</figcaption>
</figure>
<p>Next, place the code that was in the curly brackets into a new file named
<em>src/front_of_house.rs</em>, as shown in Listing 7-22. The compiler knows to look
in this file because it came across the module declaration in the crate root
with the name <code>front_of_house</code>.</p>
<p>接下来，将原花括号内的代码放入名为 <em>src/front_of_house.rs</em> 的新文件，如代码清单7-22所示。编译器知道查找此文件，因为它在包根中遇到了名为 <code>front_of_house</code> 的模块声明。</p>
<figure class="listing" id="listing-7-22">
<span class="file-name">Filename: src/front_of_house.rs</span>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
<figcaption><a href="ch07-05-separating-modules-into-different-files.html#listing-7-22">Listing 7-22</a>: Definitions inside the <code>front_of_house</code> module in <em>src/front_of_house.rs</em> <code>front_of_house</code> 模块内部定义（位于 <em>src/front_of_house.rs</em>）</figcaption>
</figure>
<p>Note that you only need to load a file using a <code>mod</code> declaration <em>once</em> in your
module tree. Once the compiler knows the file is part of the project (and knows
where in the module tree the code resides because of where you’ve put the <code>mod</code>
statement), other files in your project should refer to the loaded file’s code
using a path to where it was declared, as covered in the “Paths for Referring
to an Item in the Module Tree” section. In other words,
<code>mod</code> is <em>not</em> an “include” operation that you may have seen in other
programming languages.</p>
<p>注意：在模块树中只需使用 <code>mod</code> 声明加载文件<strong>一次</strong>。编译器知道文件属于项目后（并通过 <code>mod</code> 语句位置确定代码在模块树中的位置），项目中的其他文件应使用声明位置的路径来引用已加载文件的代码（如“在模块树中引用项的路径“章节所述）。换句话说，<code>mod</code> <strong>并非</strong>其他编程语言中常见的“include“操作。</p>
<p>Next, we’ll extract the <code>hosting</code> module to its own file. The process is a bit
different because <code>hosting</code> is a child module of <code>front_of_house</code>, not of the
root module. We’ll place the file for <code>hosting</code> in a new directory that will be
named for its ancestors in the module tree, in this case <em>src/front_of_house</em>.</p>
<p>接下来将 <code>hosting</code> 模块提取到单独文件。此过程略有不同，因为 <code>hosting</code> 是 <code>front_of_house</code> 的子模块而非根模块的子模块。我们将把 <code>hosting</code> 文件放在以其模块树祖先命名的新目录中（本例为 <em>src/front_of_house</em>）。</p>
<p>To start moving <code>hosting</code>, we change <em>src/front_of_house.rs</em> to contain only
the declaration of the <code>hosting</code> module:</p>
<p>移动 <code>hosting</code> 模块时，首先将 <em>src/front_of_house.rs</em> 改为仅包含 <code>hosting</code> 模块声明：</p>
<figure class="listing">
<span class="file-name">Filename: src/front_of_house.rs</span>
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
</figure>
<p>Then we create a <em>src/front_of_house</em> directory and a <em>hosting.rs</em> file to
contain the definitions made in the <code>hosting</code> module:</p>
<p>接着创建 <em>src/front_of_house</em> 目录和 <em>hosting.rs</em> 文件来存放 <code>hosting</code> 模块的定义：</p>
<figure class="listing">
<span class="file-name">Filename: src/front_of_house/hosting.rs</span>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
</figure>
<p>If we instead put <em>hosting.rs</em> in the <em>src</em> directory, the compiler would
expect the <em>hosting.rs</em> code to be in a <code>hosting</code> module declared in the crate
root, and not declared as a child of the <code>front_of_house</code> module. The
compiler’s rules for which files to check for which modules’ code mean the
directories and files more closely match the module tree.</p>
<p>若将 <em>hosting.rs</em> 放在 <em>src</em> 目录，编译器会认为 <em>hosting.rs</em> 属于包根中声明的 <code>hosting</code> 模块，而不是 <code>front_of_house</code> 的子模块。编译器检查模块代码的文件路径规则要求目录结构与模块树保持一致。</p>
<section class="note" aria-role="note">
<h3 id="alternate-file-paths-替代文件路径"><a class="header" href="#alternate-file-paths-替代文件路径">Alternate File Paths 替代文件路径</a></h3>
<p>So far we’ve covered the most idiomatic file paths the Rust compiler uses,
but Rust also supports an older style of file path. For a module named
<code>front_of_house</code> declared in the crate root, the compiler will look for the
module’s code in:</p>
<p>目前我们介绍了Rust编译器最惯用的文件路径，但Rust也支持旧式文件路径。对于包根中声明的 <code>front_of_house</code> 模块，编译器会在以下位置查找模块代码：</p>
<ul>
<li><em>src/front_of_house.rs</em> (what we covered 当前标准)</li>
<li><em>src/front_of_house/mod.rs</em> (older style, still supported path 旧风格，仍支持)</li>
</ul>
<p>For a module named <code>hosting</code> that is a submodule of <code>front_of_house</code>, the
compiler will look for the module’s code in:</p>
<p>对于 <code>front_of_house</code> 的子模块 <code>hosting</code>，编译器会在以下位置查找：</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (what we covered 当前标准)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (older style, still supported path 旧风格，仍支持)</li>
</ul>
<p>If you use both styles for the same module, you’ll get a compiler error.
Using a mix of both styles for different modules in the same project is
allowed, but might be confusing for people navigating your project.</p>
<p>若对同一模块混用两种风格会导致编译错误。同一项目中不同模块混用风格是允许的，但可能影响代码可读性。</p>
<p>The main downside to the style that uses files named <em>mod.rs</em> is that your
project can end up with many files named <em>mod.rs</em>, which can get confusing
when you have them open in your editor at the same time.</p>
<p>使用 <em>mod.rs</em> 命名风格的主要缺点是项目可能出现大量同名文件，在编辑器中同时打开时会引发混淆。</p>
</section>
<p>We’ve moved each module’s code to a separate file, and the module tree remains
the same. The function calls in <code>eat_at_restaurant</code> will work without any
modification, even though the definitions live in different files. This
technique lets you move modules to new files as they grow in size.</p>
<p>现在每个模块的代码都已移至单独文件，而模块树保持不变。<code>eat_at_restaurant</code> 中的函数调用无需任何修改即可正常工作，即使定义位于不同文件。这种技术让你能在模块规模增长时将其移至新文件。</p>
<p>Note that the <code>pub use crate::front_of_house::hosting</code> statement in
<em>src/lib.rs</em> also hasn’t changed, nor does <code>use</code> have any impact on what files
are compiled as part of the crate. The <code>mod</code> keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.</p>
<p>注意 <em>src/lib.rs</em> 中的 <code>pub use crate::front_of_house::hosting</code> 语句同样保持不变，且 <code>use</code> 声明不影响哪些文件作为包的组成部分被编译。<code>mod</code> 关键字用于声明模块，Rust会在与模块同名的文件中查找该模块的代码。</p>
<h2 id="summary-总结-6"><a class="header" href="#summary-总结-6">Summary 总结</a></h2>
<p>Rust lets you split a package into multiple crates and a crate into modules so
you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a <code>use</code> statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the <code>pub</code> keyword.</p>
<p>Rust允许你将包拆分为多个 crate，并将 crate 拆分为模块，从而支持跨模块引用项。可通过绝对路径或相对路径实现，结合 <code>use</code> 语句将路径引入作用域后，可在该作用域内使用短路径多次调用。模块代码默认私有，添加 <code>pub</code> 关键字可使定义公开。</p>
<p>In the next chapter, we’ll look at some collection data structures in the
standard library that you can use in your neatly organized code.</p>
<p>下一章我们将探讨标准库中的集合数据结构，这些工具可应用于你精心组织的代码中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections-常见集合"><a class="header" href="#common-collections-常见集合">Common Collections 常见集合</a></h1>
<p>Rust’s standard library includes a number of very useful data structures called
<em>collections</em>. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data that these collections point to is stored on the heap, which
means the amount of data does not need to be known at compile time and can grow
or shrink as the program runs. Each kind of collection has different
capabilities and costs, and choosing an appropriate one for your current
situation is a skill you’ll develop over time. In this chapter, we’ll discuss
three collections that are used very often in Rust programs:</p>
<p>Rust 的标准库包含一系列被称为<em>集合</em>的实用数据结构。大多数其他数据类型表示单一特定值，但集合可以包含多个值。不同于内置的数组和元组类型，这些集合指向的数据存储在堆上，这意味着数据量在编译时无需确定，并且可以在程序运行时动态增减。每种集合类型具有不同的特性和开销，选择适合当前场景的集合需要经验的积累。本章将讨论 Rust 程序中常用的三种集合：</p>
<ul>
<li>A <em>vector</em> allows you to store a variable number of values next to each other.</li>
<li><em>向量（vector）</em> 允许在相邻位置存储可变数量的值。</li>
<li>A <em>string</em> is a collection of characters. We’ve mentioned the <code>String</code> type
previously, but in this chapter we’ll talk about it in depth.</li>
<li><em>字符串（string）</em> 是字符的集合。我们之前提到过 <code>String</code> 类型，本章将深入探讨它。</li>
<li>A <em>hash map</em> allows you to associate a value with a specific key. It’s a
particular implementation of the more general data structure called a <em>map</em>.</li>
<li><em>哈希映射（hash map）</em> 允许将值与特定键关联。它是更通用的 <em>映射</em>（map）数据结构的一种特定实现。</li>
</ul>
<p>To learn about the other kinds of collections provided by the standard library,
see the documentation.</p>
<p>要了解标准库提供的其他集合类型，请查阅官方文档。</p>
<p>We’ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.</p>
<p>我们将讨论如何创建和更新向量、字符串和哈希映射，以及它们各自的特性。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="storing-lists-of-values-with-vectors-用向量存储值列表"><a class="header" href="#storing-lists-of-values-with-vectors-用向量存储值列表">Storing Lists of Values with Vectors 用向量存储值列表</a></h2>
<p>The first collection type we’ll look at is <code>Vec&lt;T&gt;</code>, also known as a <em>vector</em>.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.</p>
<p>我们将探讨的第一种集合类型是 <code>Vec&lt;T&gt;</code>，也称为<em>向量</em>。向量允许在单一数据结构中存储多个值，这些值在内存中彼此相邻排列。向量只能存储相同类型的值，适用于处理项目列表的场景，例如文件中的文本行或购物车中的商品价格。</p>
<h3 id="creating-a-new-vector-创建新向量"><a class="header" href="#creating-a-new-vector-创建新向量">Creating a New Vector 创建新向量</a></h3>
<p>To create a new empty vector, we call the <code>Vec::new</code> function, as shown in
Listing 8-1.</p>
<p>如示例 8-1 所示，可通过<span class="highlight">[note]调用 <code>Vec::new</code> 函数创建新的空向量</span>。</p>
<figure class="listing" id="listing-8-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-1">Listing 8-1</a>: Creating a new, empty vector to hold values of type <code>i32</code> 创建一个新的空向量用于存储 <code>i32</code> 类型的值</figcaption>
</figure>
<p>Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type.
When we create a vector to hold a specific type, we can specify the type within
angle brackets. In Listing 8-1, we’ve told Rust that the <code>Vec&lt;T&gt;</code> in <code>v</code> will
hold elements of the <code>i32</code> type.</p>
<p>注意此处添加了类型注解。由于未向向量插入任何值，Rust 无法推断我们打算存储的元素类型。这一点很重要：向量通过泛型实现，我们将在第 10 章学习如何为自定义类型使用泛型。目前只需知道，标准库提供的 <code>Vec&lt;T&gt;</code> 类型可容纳任意类型。创建特定类型向量时，可在尖括号内指定类型。示例 8-1 中我们向 Rust 表明，变量 <code>v</code> 中的 <code>Vec&lt;T&gt;</code> 将存储 <code>i32</code> 类型元素。</p>
<p>More often, you’ll create a <code>Vec&lt;T&gt;</code> with initial values and Rust will infer
the type of value you want to store, so you rarely need to do this type
annotation. Rust conveniently provides the <code>vec!</code> macro, which will create a
new vector that holds the values you give it. Listing 8-2 creates a new
<code>Vec&lt;i32&gt;</code> that holds the values <code>1</code>, <code>2</code>, and <code>3</code>. The integer type is <code>i32</code>
because that’s the default integer type, as we discussed in the “Data
Types” section of Chapter 3.</p>
<p>更常见的情况是创建带初始值的 <code>Vec&lt;T&gt;</code>，此时 Rust 能自动推断存储类型，因此很少需要显式注解。<span class="highlight">[note]Rust 提供了便捷的 <code>vec!</code> 宏</span>，它能创建包含指定值的新向量。示例 8-2 创建了存储值 <code>1</code>、<code>2</code> 和 <code>3</code> 的 <code>Vec&lt;i32&gt;</code>，整数类型为 <code>i32</code>（这是默认整型，如第 3 章“数据类型“部分所述）。</p>
<figure class="listing" id="listing-8-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-2">Listing 8-2</a>: Creating a new vector containing values 创建包含值的新向量</figcaption>
</figure>
<p>Because we’ve given initial <code>i32</code> values, Rust can infer that the type of <code>v</code>
is <code>Vec&lt;i32&gt;</code>, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.</p>
<p>由于提供了初始 <code>i32</code> 值，Rust 可推断 <code>v</code> 的类型为 <code>Vec&lt;i32&gt;</code>，无需类型注解。接下来我们将学习如何修改向量。</p>
<h3 id="updating-a-vector-更新向量"><a class="header" href="#updating-a-vector-更新向量">Updating a Vector 更新向量</a></h3>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method,
as shown in Listing 8-3.</p>
<p>如示例 8-3 所示，创建向量后可用 <code>push</code> 方法添加元素。</p>
<figure class="listing" id="listing-8-3">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-3">Listing 8-3</a>: Using the <code>push</code> method to add values to a vector 使用 <code>push</code> 方法向向量添加值</figcaption>
</figure>
<p>As with any variable, if we want to be able to change its value, we need to
make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3. The numbers
we place inside are all of type <code>i32</code>, and Rust infers this from the data, so
we don’t need the <code>Vec&lt;i32&gt;</code> annotation.</p>
<p>如第 3 章所述，若需修改变量值，必须使用 <code>mut</code> 关键字使其可变。放入向量的数字均为 <code>i32</code> 类型，Rust 会根据数据自动推断类型，因此不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h3 id="reading-elements-of-vectors-读取向量元素"><a class="header" href="#reading-elements-of-vectors-读取向量元素">Reading Elements of Vectors 读取向量元素</a></h3>
<p>There are two ways to reference a value stored in a vector: via indexing or by
using the <code>get</code> method. In the following examples, we’ve annotated the types of
the values that are returned from these functions for extra clarity.</p>
<p><span class="highlight">[note]有两种方式引用向量中存储的值：索引访问或 <code>get</code> 方法。</span>以下示例中，我们特别标注了这些函数返回值的类型以增强可读性。</p>
<p>Listing 8-4 shows both methods of accessing a value in a vector, with indexing
syntax and the <code>get</code> method.</p>
<p>示例 8-4 展示了通过索引语法和 <code>get</code> 方法访问向量值的两种方式。</p>
<figure class="listing" id="listing-8-4">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("The third element is {third}"),
        None =&gt; println!("There is no third element."),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-4">Listing 8-4</a>: Using indexing syntax and using the <code>get</code> method to access an item in a vector 使用索引语法和 <code>get</code> 方法访问向量中的元素</figcaption>
</figure>
<p>Note a few details here. We use the index value of <code>2</code> to get the third element
because vectors are indexed by number, starting at zero. Using <code>&amp;</code> and <code>[]</code>
gives us a reference to the element at the index value. When we use the <code>get</code>
method with the index passed as an argument, we get an <code>Option&lt;&amp;T&gt;</code> that we can
use with <code>match</code>.</p>
<p>注意几个细节：向量使用数字索引且从零开始，因此索引值 <code>2</code> 表示获取第三个元素。使用 <code>&amp;</code> 和 <code>[]</code> 会返回索引位置元素的引用。当使用 <code>get</code> 方法并传入索引参数时，会返回一个可与 <code>match</code> 搭配使用的 <code>Option&lt;&amp;T&gt;</code> 类型。</p>
<p>Rust provides these two ways to reference an element so you can choose how the
program behaves when you try to use an index value outside the range of
existing elements. As an example, let’s see what happens when we have a vector
of five elements and then we try to access an element at index 100 with each
technique, as shown in Listing 8-5.</p>
<p>Rust 提供这两种引用元素的方式，是为了让程序在尝试访问超出范围的索引时能有不同的行为。例如示例 8-5 展示了当向量只有五个元素时，尝试访问索引 100 的两种情况。</p>
<figure class="listing" id="listing-8-5">
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-5">Listing 8-5</a>: Attempting to access the element at index 100 in a vector containing five elements 尝试访问包含五个元素的向量中索引为 100 的元素</figcaption>
</figure>
<p>When we run this code, the first <code>[]</code> method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there’s an attempt to access an element past the
end of the vector.</p>
<p>运行此代码时，第一种 <code>[]</code> 方法将导致程序崩溃（panic），因为它引用了不存在的元素。此方法适用于希望在访问越界元素时程序立即终止的场景。</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns
<code>None</code> without panicking. You would use this method if accessing an element
beyond the range of the vector may happen occasionally under normal
circumstances. Your code will then have logic to handle having either
<code>Some(&amp;element)</code> or <code>None</code>, as discussed in Chapter 6. For example, the index
could be coming from a person entering a number. If they accidentally enter a
number that’s too large and the program gets a <code>None</code> value, you could tell the
user how many items are in the current vector and give them another chance to
enter a valid value. That would be more user-friendly than crashing the program
due to a typo!</p>
<p>当 <code>get</code> 方法收到超范围索引时，它会返回 <code>None</code> 而不会崩溃。若在正常情况下偶尔可能发生越界访问，应使用此方法。此时代码可逻辑处理 <code>Some(&amp;element)</code> 或 <code>None</code>（如第 6 章所述）。例如，索引可能来自用户输入的数字。若用户意外输入过大数字导致程序获得 <code>None</code> 值，可以提示当前向量的项目数量，并让用户重新输入有效值。这比因输入错误导致程序崩溃更友好！</p>
<p>When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-6, where we hold an immutable reference
to the first element in a vector and try to add an element to the end. This
program won’t work if we also try to refer to that element later in the
function.</p>
<p>当程序持有有效引用时，借用检查器会强制执行所有权和借用规则（见第 4 章），确保该引用及对向量内容的其他引用保持有效。回顾“同一作用域中不能同时存在可变和不可变引用“的规则，该规则在示例 8-6 中适用：<span class="highlight">[note]当我们持有向量首元素的不可变引用时，尝试向尾部添加元素会导致程序无法编译。</span></p>
<figure class="listing" id="listing-8-6">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("The first element is: {first}");
<span class="boring">}</span></code></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-6">Listing 8-6</a>: Attempting to add an element to a vector while holding a reference to an item 在持有元素引用的同时尝试向向量添加元素</figcaption>
</figure>
<p>Compiling this code will result in this error:</p>
<p>编译此代码将产生错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>The code in Listing 8-6 might look like it should work: why should a reference
to the first element care about changes at the end of the vector? This error is
due to the way vectors work: because vectors put the values next to each other
in memory, adding a new element onto the end of the vector might require
allocating new memory and copying the old elements to the new space, if there
isn’t enough room to put all the elements next to each other where the vector
is currently stored. In that case, the reference to the first element would be
pointing to deallocated memory. The borrowing rules prevent programs from
ending up in that situation.</p>
<p>示例 8-6 的代码看似应能运行：为何首元素的引用要关注向量尾部的修改？此错误源于向量的工作原理：向量将值连续存储在内存中，若当前空间不足，向尾部添加新元素可能需要分配新内存并将旧元素复制到新空间。这种情况下，指向首元素的引用将指向已释放内存。借用规则正是为了防止程序陷入此类情况。</p>
<section class="note" aria-role="note">
<p>Note: For more on the implementation details of the <code>Vec&lt;T&gt;</code> type, see “The
Rustonomicon”.</p>
<p>注意：有关 <code>Vec&lt;T&gt;</code> 类型的实现细节，请参阅《Rust 秘典（The Rustonomicon）》。</p>
</section>
<h3 id="iterating-over-the-values-in-a-vector-遍历向量中的值"><a class="header" href="#iterating-over-the-values-in-a-vector-遍历向量中的值">Iterating Over the Values in a Vector 遍历向量中的值</a></h3>
<p>To access each element in a vector in turn, we would iterate through all of the
elements rather than use indices to access one at a time. Listing 8-7 shows how
to use a <code>for</code> loop to get immutable references to each element in a vector of
<code>i32</code> values and print them.</p>
<p>要依次访问向量中的每个元素，应遍历所有元素而非使用索引逐个访问。<span class="highlight">[note]示例 8-7 展示了如何用 <code>for</code> 循环获取 <code>i32</code> 向量中每个元素的不可变引用并打印。</span></p>
<figure class="listing" id="listing-8-7">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-7">Listing 8-7</a>: Printing each element in a vector by iterating over the elements using a <code>for</code> loop 通过 <code>for</code> 循环遍历元素来打印向量中的每个值</figcaption>
</figure>
<p>We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The <code>for</code> loop in Listing 8-8
will add <code>50</code> to each element.</p>
<p><span class="highlight">[note]对于可变向量，我们也可以遍历可变引用来修改所有元素</span>。示例 8-8 中的 <code>for</code> 循环将为每个元素加 50。</p>
<figure class="listing" id="listing-8-8">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-8">Listing 8-8</a>: Iterating over mutable references to elements in a vector 遍历向量元素的可变引用</figcaption>
</figure>
<p>To change the value that the mutable reference refers to, we have to use the
<code>*</code> dereference operator to get to the value in <code>i</code> before we can use the <code>+=</code>
operator. We’ll talk more about the dereference operator in the “Following the
Reference to the Value” section of Chapter 15.</p>
<p>要修改可变引用指向的值，需先用 <code>*</code> 解引用运算符获取 <code>i</code> 中的值，才能使用 <code>+=</code> 运算符。我们将在第 15 章的“跟随指针到值“章节深入讨论解引用运算符。</p>
<p>Iterating over a vector, whether immutably or mutably, is safe because of the
borrow checker’s rules. If we attempted to insert or remove items in the <code>for</code>
loop bodies in Listing 8-7 and Listing 8-8, we would get a compiler error
similar to the one we got with the code in Listing 8-6. The reference to the
vector that the <code>for</code> loop holds prevents simultaneous modification of the
whole vector.</p>
<p>得益于借用检查器的规则，无论以不可变还是可变方式遍历向量都是安全的。<span class="highlight">[note]若在示例 8-7 和 8-8 的循环体内尝试插入或删除项目，会得到与示例 8-6 类似的编译错误。因为 <code>for</code> 循环持有的向量引用会阻止同时修改整个向量。</span></p>
<h3 id="using-an-enum-to-store-multiple-types-使用枚举存储多种类型"><a class="header" href="#using-an-enum-to-store-multiple-types-使用枚举存储多种类型">Using an Enum to Store Multiple Types 使用枚举存储多种类型</a></h3>
<p>Vectors can only store values that are of the same type. This can be
inconvenient; there are definitely use cases for needing to store a list of
items of different types. Fortunately, the variants of an enum are defined
under the same enum type, so when we need one type to represent elements of
different types, we can define and use an enum!</p>
<p>向量只能存储相同类型的值，这有时会带来不便——实际应用中常需存储不同类型元素的列表。幸运的是，枚举的所有变体都归于同一枚举类型下，因此当需要表示不同类型元素时，可以定义并使用枚举！</p>
<p>For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and all the enum variants will be considered the same type: that
of the enum. Then we can create a vector to hold that enum and so, ultimately,
hold different types. We’ve demonstrated this in Listing 8-9.</p>
<p>例如，假设需要从电子表格行中获取值，其中某些列含整数、浮点数或字符串。可以定义枚举，其变体将持有不同类型的值，且所有枚举变体被视为同类型（即枚举自身类型）。随后创建存储此枚举的向量，最终实现存储不同类型的目标。示例 8-9 演示了此方法。</p>
<figure class="listing" id="listing-8-9">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-9">Listing 8-9</a>: Defining an <code>enum</code> to store values of different types in one vector 定义枚举以在单个向量中存储不同类型的值</figcaption>
</figure>
<p>Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. We
must also be explicit about what types are allowed in this vector. If Rust
allowed a vector to hold any type, there would be a chance that one or more of
the types would cause errors with the operations performed on the elements of
the vector. Using an enum plus a <code>match</code> expression means that Rust will ensure
at compile time that every possible case is handled, as discussed in Chapter 6.</p>
<p>Rust 需在编译时知晓向量中的类型，以精确计算堆上存储每个元素所需内存。同时必须明确允许哪些类型。若允许向量存储任意类型，某些类型可能在元素操作时引发错误。使用枚举配合 <code>match</code> 表达式可确保 Rust 在编译时处理所有可能情况（如第 6 章所述）。</p>
<p>If you don’t know the exhaustive set of types a program will get at runtime to
store in a vector, the enum technique won’t work. Instead, you can use a trait
object, which we’ll cover in Chapter 18.</p>
<p>若无法在编译时穷尽程序运行时会存储在向量中的所有类型，则枚举技术不适用。此时可使用 trait 对象（第 18 章介绍）。</p>
<p>Now that we’ve discussed some of the most common ways to use vectors, be sure
to review the API documentation for all of the many
useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library. For example, in
addition to <code>push</code>, a <code>pop</code> method removes and returns the last element.</p>
<p>现在我们已经讨论了向量的常见用法，请务必查阅标准库中 <code>Vec&lt;T&gt;</code> 的所有实用方法。例如，除 <code>push</code> 外，<code>pop</code> 方法会移除并返回最后一个元素。</p>
<h3 id="dropping-a-vector-drops-its-elements-向量离开作用域时其元素会被丢弃"><a class="header" href="#dropping-a-vector-drops-its-elements-向量离开作用域时其元素会被丢弃">Dropping a Vector Drops Its Elements 向量离开作用域时其元素会被丢弃</a></h3>
<p>Like any other <code>struct</code>, a vector is freed when it goes out of scope, as
annotated in Listing 8-10.</p>
<p>如示例 8-10 所示，向量与任何其他 <code>struct</code> 一样，离开作用域时会被释放。</p>
<figure class="listing" id="listing-8-10">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-01-vectors.html#listing-8-10">Listing 8-10</a>: Showing where the vector and its elements are dropped 展示向量及其元素被丢弃的位置</figcaption>
</figure>
<p>When the vector gets dropped, all of its contents are also dropped, meaning the
integers it holds will be cleaned up. The borrow checker ensures that any
references to contents of a vector are only used while the vector itself is
valid.</p>
<p>当向量被丢弃时，其所有内容也会被丢弃，意味着它存储的整数会被清理。借用检查器确保仅在向量有效期间使用对其内容的引用。</p>
<p>Let’s move on to the next collection type: <code>String</code>!</p>
<p>接下来让我们学习下一个集合类型：<code>String</code>！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="storing-utf-8-encoded-text-with-strings-使用字符串存储-utf-8-编码文本"><a class="header" href="#storing-utf-8-encoded-text-with-strings-使用字符串存储-utf-8-编码文本">Storing UTF-8 Encoded Text with Strings 使用字符串存储 UTF-8 编码文本</a></h2>
<p>We talked about strings in Chapter 4, but we’ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rust’s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you’re
coming from other programming languages.</p>
<p>我们在第 4 章讨论过字符串，现在将更深入地探讨它们。Rust 新手通常会在字符串上遇到困难，原因有三点组合：Rust 倾向于暴露可能的错误、字符串是比许多程序员认为的更复杂的数据结构、以及 UTF-8。当你从其他编程语言转向 Rust 时，这些因素结合在一起可能会显得困难。</p>
<p>We discuss strings in the context of collections because strings are
implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we’ll
talk about the operations on <code>String</code> that every collection type has, such as
creating, updating, and reading. We’ll also discuss the ways in which <code>String</code>
is different from the other collections, namely how indexing into a <code>String</code> is
complicated by the differences between how people and computers interpret
<code>String</code> data.</p>
<p>我们在集合的上下文中讨论字符串，因为字符串本质上是字节的集合，加上一些在将这些字节解释为文本时提供实用功能的方法。本节中，我们将讨论每个集合类型都有的 <code>String</code> 操作，如创建、更新和读取。我们还将探讨 <code>String</code> 与其他集合的不同之处，即由于人和计算机解释 <code>String</code> 数据方式的差异，对 <code>String</code> 进行索引操作会变得复杂。</p>
<h3 id="what-is-a-string-什么是字符串"><a class="header" href="#what-is-a-string-什么是字符串">What Is a String? 什么是字符串？</a></h3>
<p>We’ll first define what we mean by the term <em>string</em>. Rust has only one string
type in the core language, which is the string slice <code>str</code> that is usually seen
in its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the program’s binary and are therefore
string slices.</p>
<p>我们首先定义术语<em>字符串</em>的含义。<span class="highlight">[note]Rust 核心语言中只有一种字符串类型，即字符串切片 <code>str</code>，通常以借用的形式 <code>&amp;str</code> 出现。</span>在第 4 章中，我们讨论过<em>字符串切片</em>，它们是对存储在其他地方的 UTF-8 编码字符串数据的引用。例如，字符串字面值存储在程序二进制文件中，因此属于字符串切片。</p>
<p>The <code>String</code> type, which is provided by Rust’s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to “strings” in Rust, they might be
referring to either the <code>String</code> or the string slice <code>&amp;str</code> types, not just one
of those types. Although this section is largely about <code>String</code>, both types are
used heavily in Rust’s standard library, and both <code>String</code> and string slices
are UTF-8 encoded.</p>
<p><code>String</code> 类型由 Rust 标准库提供（而非内置于核心语言），是一种可增长、可变、拥有所有权的 UTF-8 编码字符串类型。当 Rustacean 提到 Rust 中的“字符串“时，可能指 <code>String</code> 或字符串切片 <code>&amp;str</code> 类型，而非特指其一。虽然本节主要讨论 <code>String</code>，但两种类型在 Rust 标准库中都大量使用，且 <code>String</code> 和字符串切片都是 UTF-8 编码的。</p>
<h3 id="creating-a-new-string-创建新字符串"><a class="header" href="#creating-a-new-string-创建新字符串">Creating a New String 创建新字符串</a></h3>
<p>Many of the same operations available with <code>Vec&lt;T&gt;</code> are available with <code>String</code>
as well because <code>String</code> is actually implemented as a wrapper around a vector
of bytes with some extra guarantees, restrictions, and capabilities. An example
of a function that works the same way with <code>Vec&lt;T&gt;</code> and <code>String</code> is the <code>new</code>
function to create an instance, shown in Listing 8-11.</p>
<p>许多可用于 <code>Vec&lt;T&gt;</code> 的操作同样适用于 <code>String</code>，因为 <code>String</code> 本质上是字节向量的包装器，并具有额外的保证、限制和功能。<code>Vec&lt;T&gt;</code> 和 <code>String</code> 用法相同的函数示例是创建实例的 <code>new</code> 函数，如代码清单 8-11 所示。</p>
<figure class="listing" id="listing-8-11">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-11">Listing 8-11</a>: Creating a new, empty <code>String</code> 创建一个新的空 <code>String</code></figcaption>
</figure>
<p>This line creates a new, empty string called <code>s</code>, into which we can then load
data. Often, we’ll have some initial data with which we want to start the
string. For that, we use the <code>to_string</code> method, which is available on any type
that implements the <code>Display</code> trait, as string literals do. Listing 8-12 shows
two examples.</p>
<p>此行代码创建了一个名为 <code>s</code> 的新空字符串，随后可向其加载数据。通常我们会用初始数据初始化字符串，此时<span class="highlight">[note]可使用 <code>to_string</code> 方法，该方法适用于任何实现了 <code>Display</code> trait 的类型</span>（字符串字面值即属此类）。代码清单 8-12 展示了两个示例。</p>
<figure class="listing" id="listing-8-12">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // The method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-12">Listing 8-12</a>: Using the <code>to_string</code> method to create a <code>String</code> from a string literal 使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code></figcaption>
</figure>
<p>This code creates a string containing <code>initial contents</code>.</p>
<p>此代码创建了包含 <code>initial contents</code> 的字符串。</p>
<p>We can also use the function <code>String::from</code> to create a <code>String</code> from a string
literal. The code in Listing 8-13 is equivalent to the code in Listing 8-12
that uses <code>to_string</code>.</p>
<p>我们也可使用 <code>String::from</code> 函数从字符串字面值创建 <code>String</code>。代码清单 8-13 等效于使用 <code>to_string</code> 的代码清单 8-12。</p>
<figure class="listing" id="listing-8-13">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-13">Listing 8-13</a>: Using the <code>String::from</code> function to create a <code>String</code> from a string literal 使用 <code>String::from</code> 函数从字符串字面值创建 <code>String</code></figcaption>
</figure>
<p>Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, <code>String::from</code> and
<code>to_string</code> do the same thing, so which one you choose is a matter of style and
readability.</p>
<p>由于字符串用途广泛，我们可以使用许多不同的通用 API，提供了多种选择。其中有些看似冗余，但各有适用场景！此处 <code>String::from</code> 和 <code>to_string</code> 功能相同，选择取决于代码风格和可读性。</p>
<p>Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.</p>
<p>请记住字符串是 UTF-8 编码的，因此可以包含任何正确编码的数据，如代码清单 8-14 所示。</p>
<figure class="listing" id="listing-8-14">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-14">Listing 8-14</a>: Storing greetings in different languages in strings 在字符串中存储不同语言的问候语</figcaption>
</figure>
<p>All of these are valid <code>String</code> values.</p>
<p>以上所有字符串都是有效的 <code>String</code> 值。</p>
<h3 id="updating-a-string-更新字符串"><a class="header" href="#updating-a-string-更新字符串">Updating a String 更新字符串</a></h3>
<p>A <code>String</code> can grow in size and its contents can change, just like the contents
of a <code>Vec&lt;T&gt;</code>, if you push more data into it. In addition, you can conveniently
use the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values.</p>
<p><code>String</code> 的大小可以增长，内容也可以更改，就像 <code>Vec&lt;T&gt;</code> 的内容一样——只需向其中推送更多数据。此外，你可以方便地使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h4 id="appending-to-a-string-with-push_str-and-push-使用-push_str-和-push-追加字符串"><a class="header" href="#appending-to-a-string-with-push_str-and-push-使用-push_str-和-push-追加字符串">Appending to a String with <code>push_str</code> and <code>push</code> 使用 <code>push_str</code> 和 <code>push</code> 追加字符串</a></h4>
<p>We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice,
as shown in Listing 8-15.</p>
<p>我们可以使用 <code>push_str</code> 方法追加字符串切片来增长 <code>String</code>，如代码清单 8-15 所示。</p>
<figure class="listing" id="listing-8-15">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-15">Listing 8-15</a>: Appending a string slice to a <code>String</code> using the <code>push_str</code> method 使用 <code>push_str</code> 方法将字符串切片追加到 <code>String</code></figcaption>
</figure>
<p>After these two lines, <code>s</code> will contain <code>foobar</code>. The <code>push_str</code> method takes a
string slice because we don’t necessarily want to take ownership of the
parameter. For example, in the code in Listing 8-16, we want to be able to use
<code>s2</code> after appending its contents to <code>s1</code>.</p>
<p>执行这两行后，<code>s</code> 将包含 <code>foobar</code>。<code>push_str</code> 方法接收字符串切片参数，因为我们不一定需要获取参数的所有权。例如在代码清单 8-16 中，我们希望将 <code>s2</code> 的内容追加到 <code>s1</code> 后仍能使用 <code>s2</code>。</p>
<figure class="listing" id="listing-8-16">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-16">Listing 8-16</a>: Using a string slice after appending its contents to a <code>String</code> 将字符串切片内容追加到 <code>String</code> 后继续使用该切片</figcaption>
</figure>
<p>If the <code>push_str</code> method took ownership of <code>s2</code>, we wouldn’t be able to print
its value on the last line. However, this code works as we’d expect!</p>
<p>如果 <code>push_str</code> 方法获取了 <code>s2</code> 的所有权，我们就无法在最后一行打印其值。但这段代码能按预期工作！</p>
<p>The <code>push</code> method takes a single character as a parameter and adds it to the
<code>String</code>. Listing 8-17 adds the letter <em>l</em> to a <code>String</code> using the <code>push</code>
method.</p>
<p><code>push</code> 方法接收单个字符作为参数并将其添加到 <code>String</code>。代码清单 8-17 使用 <code>push</code> 方法将字母 <em>l</em> 添加到 <code>String</code>。</p>
<figure class="listing" id="listing-8-17">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-17">Listing 8-17</a>: Adding one character to a <code>String</code> value using <code>push</code> 使用 <code>push</code> 向 <code>String</code> 值添加单个字符</figcaption>
</figure>
<p>As a result, <code>s</code> will contain <code>lol</code>.</p>
<p>最终 <code>s</code> 将包含 <code>lol</code>。</p>
<h4 id="concatenation-with-the--operator-or-the-format-macro-使用--运算符或-format-宏进行拼接"><a class="header" href="#concatenation-with-the--operator-or-the-format-macro-使用--运算符或-format-宏进行拼接">Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro 使用 <code>+</code> 运算符或 <code>format!</code> 宏进行拼接</a></h4>
<p>Often, you’ll want to combine two existing strings. One way to do so is to use
the <code>+</code> operator, as shown in Listing 8-18.</p>
<p>通常需要组合两个现有字符串，一种方法是使用 <code>+</code> 运算符，如代码清单 8-18 所示。</p>
<figure class="listing" id="listing-8-18">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-18">Listing 8-18</a>: Using the <code>+</code> operator to combine two <code>String</code> values into a new <code>String</code> value 使用 <code>+</code> 运算符将两个 <code>String</code> 值组合成新的 <code>String</code> 值</figcaption>
</figure>
<p>The string <code>s3</code> will contain <code>Hello, world!</code>. The reason <code>s1</code> is no longer
valid after the addition, and the reason we used a reference to <code>s2</code>, has to do
with the signature of the method that’s called when we use the <code>+</code> operator.
The <code>+</code> operator uses the <code>add</code> method, whose signature looks something like
this:</p>
<p>字符串 <code>s3</code> 将包含 <code>Hello, world!</code>。<span class="highlight">[note]<code>s1</code> 在加法后不再有效以及我们使用 <code>s2</code> 引用的原因，与使用 <code>+</code> 运算符时调用的方法签名有关。<code>+</code> 运算符使用 <code>add</code> 方法，其签名类似如下形式：</span></p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>In the standard library, you’ll see <code>add</code> defined using generics and associated
types. Here, we’ve substituted in concrete types, which is what happens when we
call this method with <code>String</code> values. We’ll discuss generics in Chapter 10.
This signature gives us the clues we need in order to understand the tricky
bits of the <code>+</code> operator.</p>
<p>在标准库中，你会看到 <code>add</code> 使用泛型和关联类型定义。这里我们替换为具体类型（使用 <code>String</code> 值调用此方法时会发生这种替换）。第 10 章将讨论泛型。此签名揭示了 <code>+</code> 运算符的微妙之处。</p>
<p>First, <code>s2</code> has an <code>&amp;</code>, meaning that we’re adding a <em>reference</em> of the second
string to the first string. This is because of the <code>s</code> parameter in the <code>add</code>
function: we can only add a <code>&amp;str</code> to a <code>String</code>; we can’t add two <code>String</code>
values together. But wait—the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as
specified in the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>
<p>首先，<code>s2</code> 带有 <code>&amp;</code>，表示我们将第二个字符串的<em>引用</em>添加到第一个字符串。这是因为 <code>add</code> 函数的 <code>s</code> 参数：只能将 <code>&amp;str</code> 添加到 <code>String</code>，不能直接添加两个 <code>String</code> 值。但请注意——<code>&amp;s2</code> 的类型是 <code>&amp;String</code> 而非 <code>add</code> 第二个参数要求的 <code>&amp;str</code>。为何代码清单 8-18 能编译？</p>
<p>The reason we’re able to use <code>&amp;s2</code> in the call to <code>add</code> is that the compiler
can <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>. When we call the <code>add</code>
method, Rust uses a <em>deref coercion</em>, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.
We’ll discuss deref coercion in more depth in Chapter 15. Because <code>add</code> does
not take ownership of the <code>s</code> parameter, <code>s2</code> will still be a valid <code>String</code>
after this operation.</p>
<p>原因在于编译器能将 <code>&amp;String</code> 参数<em>强制转换</em>为 <code>&amp;str</code>。调用 <code>add</code> 方法时，Rust 使用<em>解引用强制转换</em>（此处将 <code>&amp;s2</code> 转换为 <code>&amp;s2[..]</code>）。第 15 章将深入讨论解引用强制转换。由于 <code>add</code> 不获取参数 <code>s</code> 的所有权，<code>s2</code> 在此操作后仍是有效的 <code>String</code>。</p>
<p>Second, we can see in the signature that <code>add</code> takes ownership of <code>self</code>
because <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be
moved into the <code>add</code> call and will no longer be valid after that. So, although
<code>let s3 = s1 + &amp;s2;</code> looks like it will copy both strings and create a new one,
this statement actually takes ownership of <code>s1</code>, appends a copy of the contents
of <code>s2</code>, and then returns ownership of the result. In other words, it looks
like it’s making a lot of copies, but it isn’t; the implementation is more
efficient than copying.</p>
<p>其次，从签名可见 <code>add</code> 获取了 <code>self</code> 的所有权（因 <code>self</code> 没有 <code>&amp;</code>）。这意味着代码清单 8-18 中的 <code>s1</code> 将被移入 <code>add</code> 调用并在之后失效。因此尽管 <code>let s3 = s1 + &amp;s2;</code> 看似会复制两个字符串并创建新字符串，实际是获取 <code>s1</code> 的所有权，追加 <code>s2</code> 内容的副本，然后返回结果的所有权。换言之，看似执行多次复制，实则不然；其实现比复制更高效。</p>
<p>If we need to concatenate multiple strings, the behavior of the <code>+</code> operator
gets unwieldy:</p>
<p>若需拼接多个字符串，<code>+</code> 运算符会变得笨拙：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>At this point, <code>s</code> will be <code>tic-tac-toe</code>. With all of the <code>+</code> and <code>"</code>
characters, it’s difficult to see what’s going on. For combining strings in
more complicated ways, we can instead use the <code>format!</code> macro:</p>
<p>此时 <code>s</code> 将为 <code>tic-tac-toe</code>。过多的 <code>+</code> 和 <code>"</code> 使代码难以阅读。对于复杂字符串组合，可改用 <code>format!</code> 宏：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>This code also sets <code>s</code> to <code>tic-tac-toe</code>. The <code>format!</code> macro works like
<code>println!</code>, but instead of printing the output to the screen, it returns a
<code>String</code> with the contents. The version of the code using <code>format!</code> is much
easier to read, and the code generated by the <code>format!</code> macro uses references
so that this call doesn’t take ownership of any of its parameters.</p>
<p>此代码同样设置 <code>s</code> 为 <code>tic-tac-toe</code>。<span class="highlight">[note]<code>format!</code> 宏类似 <code>println!</code>，但不输出到屏幕而是返回包含内容的 <code>String</code>。</span>使用 <code>format!</code> 的版本更易读，且其生成的代码使用引用，不会获取任何参数的所有权。</p>
<h3 id="indexing-into-strings-字符串索引"><a class="header" href="#indexing-into-strings-字符串索引">Indexing into Strings 字符串索引</a></h3>
<p>In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a <code>String</code> using indexing syntax in Rust, you’ll
get an error. Consider the invalid code in Listing 8-19.</p>
<p>在许多编程语言中，通过索引访问字符串中的单个字符是有效且常见的操作。但在 Rust 中尝试使用索引语法访问 <code>String</code> 部分内容会导致错误。参考代码清单 8-19 中的无效代码。</p>
<figure class="listing" id="listing-8-19">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hi");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<figcaption><a href="ch08-02-strings.html#listing-8-19">Listing 8-19</a>: Attempting to use indexing syntax with a String 尝试对 String 使用索引语法</figcaption>
</figure>
<p>This code will result in the following error:</p>
<p>此代码将导致以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
          but trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>The error and the note tell the story: Rust strings don’t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.</p>
<p>错误和说明揭示了原因：Rust 字符串不支持索引。但为何如此？要回答此问题，需探讨 Rust 如何在内存中存储字符串。</p>
<h4 id="internal-representation-内部表示"><a class="header" href="#internal-representation-内部表示">Internal Representation 内部表示</a></h4>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:</p>
<p><code>String</code> 是 <code>Vec&lt;u8&gt;</code> 的包装器。观察代码清单 8-14 中正确编码的 UTF-8 示例字符串。首先是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>In this case, <code>len</code> will be <code>4</code>, which means the vector storing the string
<code>"Hola"</code> is 4 bytes long. Each of these letters takes one byte when encoded in
UTF-8. The following line, however, may surprise you (note that this string
begins with the capital Cyrillic letter <em>Ze</em>, not the number 3):</p>
<p>此例中 <code>len</code> 为 <code>4</code>，表示存储字符串 <code>"Hola"</code> 的向量长度为 4 字节（每个字母在 UTF-8 编码中各占 1 字节）。但下面一行可能令人惊讶（注意此字符串以大写西里尔字母 <em>Ze</em> 开头，而非数字 3）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>If you were asked how long the string is, you might say 12. In fact, Rust’s
answer is 24: that’s the number of bytes it takes to encode “Здравствуйте” in
UTF-8, because each Unicode scalar value in that string takes 2 bytes of
storage. Therefore, an index into the string’s bytes will not always correlate
to a valid Unicode scalar value. To demonstrate, consider this invalid Rust
code:</p>
<p>若问此字符串长度，你可能回答 12。但 Rust 给出的答案是 24——这是 “Здравствуйте” 的 UTF-8 编码字节数，因为字符串中每个 Unicode 标量值占 2 字节存储空间。因此，字符串字节的索引并不总是对应有效的 Unicode 标量值。参考以下无效 Rust 代码：</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>You already know that <code>answer</code> will not be <code>З</code>, the first letter. When encoded
in UTF-8, the first byte of <code>З</code> is <code>208</code> and the second is <code>151</code>, so it would
seem that <code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character
on its own. Returning <code>208</code> is likely not what a user would want if they asked
for the first letter of this string; however, that’s the only data that Rust
has at byte index 0. Users generally don’t want the byte value returned, even
if the string contains only Latin letters: if <code>&amp;"hi"[0]</code> were valid code that
returned the byte value, it would return <code>104</code>, not <code>h</code>.</p>
<p>已知 <code>answer</code> 不会是第一个字母 <code>З</code>。<code>З</code> 的 UTF-8 编码首字节为 <code>208</code>，次字节为 <code>151</code>，因此 <code>answer</code> 实际应为 <code>208</code>，但 <code>208</code> 本身不是有效字符。返回 <code>208</code> 很可能不符合用户获取首字母的预期；但这是 Rust 在字节索引 0 处的唯一数据。即使字符串仅含拉丁字母，用户通常也不需要返回字节值：若 <code>&amp;"hi"[0]</code> 是返回字节值的有效代码，将返回 <code>104</code> 而非 <code>h</code>。</p>
<p>The answer, then, is that to avoid returning an unexpected value and causing
bugs that might not be discovered immediately, Rust doesn’t compile this code
at all and prevents misunderstandings early in the development process.</p>
<p>因此，为避免返回意外值并导致可能无法立即发现的错误，Rust 直接拒绝编译此类代码，从而在开发早期防止误解。</p>
<h4 id="bytes-and-scalar-values-and-grapheme-clusters-oh-my-字节标量值和字形簇天哪"><a class="header" href="#bytes-and-scalar-values-and-grapheme-clusters-oh-my-字节标量值和字形簇天哪">Bytes and Scalar Values and Grapheme Clusters! Oh My! 字节、标量值和字形簇！天哪！</a></h4>
<p>Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>关于 UTF-8 的另一点是：从 Rust 视角看字符串有三种相关方式：字节（bytes）、标量值（scalar values）和字形簇（grapheme clusters）（最接近我们所说的<em>字母</em>）。</p>
<p>If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
stored as a vector of <code>u8</code> values that looks like this:</p>
<p>观察梵文书写的印地语单词 “नमस्ते”，其存储的 <code>u8</code> 值向量如下：</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s <code>char</code> type is, those
bytes look like this:</p>
<p>共 18 字节，这是计算机存储的原始数据。若视为 Unicode 标量值（即 Rust 的 <code>char</code> 类型），这些字节呈现为：</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>There are six <code>char</code> values here, but the fourth and sixth are not letters:
they’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:</p>
<p>这里有六个 <code>char</code> 值，但第四和第六个不是独立字母：它们是变音符号。最后，若视为字形簇，将得到组成印地语单词的四个字母单位：</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.</p>
<p>Rust 提供了多种解释计算机原始字符串数据的方式，使每个程序无论数据使用何种人类语言，都能选择所需解释。</p>
<p>A final reason Rust doesn’t allow us to index into a <code>String</code> to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a <code>String</code>,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.</p>
<p>Rust 不允许通过索引获取字符的最终原因是：索引操作预期始终是常数时间 (O(1))。但 <code>String</code> 无法保证此性能，因为 Rust 必须从开头遍历到索引位置才能确定有效字符的数量。</p>
<h3 id="slicing-strings-字符串切片"><a class="header" href="#slicing-strings-字符串切片">Slicing Strings 字符串切片</a></h3>
<p>Indexing into a string is often a bad idea because it’s not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. If you really need to use
indices to create string slices, therefore, Rust asks you to be more specific.</p>
<p>字符串索引通常不可取，因为字符串索引操作的返回类型不明确：字节值、字符、字形簇还是字符串切片？因此若确实需要使用索引创建字符串切片，Rust 要求更明确指定。</p>
<p>Rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a
range to create a string slice containing particular bytes:</p>
<p><span class="highlight">[note]可通过范围索引（而非单数字索引）创建包含特定字节的字符串切片</span>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>s</code> will be a <code>&amp;str</code> that contains the first four bytes of the string.
Earlier, we mentioned that each of these characters was two bytes, which means
<code>s</code> will be <code>Зд</code>.</p>
<p>此处 <code>s</code> 是包含字符串前 4 字节的 <code>&amp;str</code>。前文提到每个字符占 2 字节，因此 <code>s</code> 将为 <code>Зд</code>。</p>
<p>If we were to try to slice only part of a character’s bytes with something like
<code>&amp;hello[0..1]</code>, Rust would panic at runtime in the same way as if an invalid
index were accessed in a vector:</p>
<p>若尝试切片字符的部分字节（如 <code>&amp;hello[0..1]</code>），Rust 会在运行时 panic（类似于访问无效的向量索引）：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>You should use caution when creating string slices with ranges, because doing
so can crash your program.</p>
<p>使用范围创建字符串切片时应谨慎，因其可能导致程序崩溃。</p>
<h3 id="methods-for-iterating-over-strings-字符串遍历方法"><a class="header" href="#methods-for-iterating-over-strings-字符串遍历方法">Methods for Iterating Over Strings 字符串遍历方法</a></h3>
<p>The best way to operate on pieces of strings is to be explicit about whether
you want characters or bytes. For individual Unicode scalar values, use the
<code>chars</code> method. Calling <code>chars</code> on “Зд” separates out and returns two values of
type <code>char</code>, and you can iterate over the result to access each element:</p>
<p>操作字符串片段的最佳方式是明确需要字符还是字节。<span class="highlight">[note]对于单个 Unicode 标量值，使用 <code>chars</code> 方法。</span>在 “Зд” 上调用 <code>chars</code> 会分离并返回两个 <code>char</code> 类型值，可通过遍历结果访问每个元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>This code will print the following:</p>
<p>此代码将打印：</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Alternatively, the <code>bytes</code> method returns each raw byte, which might be
appropriate for your domain:</p>
<p>或者，<span class="highlight">[note]<code>bytes</code> 方法返回每个原始字节</span>（适用于特定场景）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>This code will print the four bytes that make up this string:</p>
<p>此代码将打印组成字符串的四个字节：</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>But be sure to remember that valid Unicode scalar values may be made up of more
than one byte.</p>
<p>但需注意：有效的 Unicode 标量值可能由多个字节组成。</p>
<p>Getting grapheme clusters from strings, as with the Devanagari script, is
complex, so this functionality is not provided by the standard library. Crates
are available on <a href="https://crates.io/">crates.io</a> if this is the
functionality you need.</p>
<p>从字符串获取字形簇（如梵文案例）较为复杂，因此标准库未提供此功能。若需此功能，可在 <a href="https://crates.io/">crates.io</a> 获取相关 crate。</p>
<h3 id="strings-are-not-so-simple-字符串并不简单"><a class="header" href="#strings-are-not-so-simple-字符串并不简单">Strings Are Not So Simple 字符串并不简单</a></h3>
<p>To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of <code>String</code> data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data up front. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.</p>
<p>总结来说，字符串是复杂的。不同编程语言选择以不同方式向程序员呈现这种复杂性。Rust 选择将正确处理 <code>String</code> 数据作为所有 Rust 程序的默认行为，这意味着程序员必须提前投入更多精力处理 UTF-8 数据。这种权衡暴露了比其他语言更明显的字符串复杂性，但能避免在开发周期后期处理非 ASCII 字符相关的错误。</p>
<p>The good news is that the standard library offers a lot of functionality built
off the <code>String</code> and <code>&amp;str</code> types to help handle these complex situations
correctly. Be sure to check out the documentation for useful methods like
<code>contains</code> for searching in a string and <code>replace</code> for substituting parts of a
string with another string.</p>
<p>好消息是标准库基于 <code>String</code> 和 <code>&amp;str</code> 类型提供了丰富功能来正确处理复杂情况。务必查阅文档以了解实用方法，如 <code>contains</code>（字符串搜索）和 <code>replace</code>（字符串部分替换）。</p>
<p>Let’s switch to something a bit less complex: hash maps!</p>
<p>现在让我们转向简单些的内容：哈希映射！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="storing-keys-with-associated-values-in-hash-maps-在哈希映射中存储键值对"><a class="header" href="#storing-keys-with-associated-values-in-hash-maps-在哈希映射中存储键值对">Storing Keys with Associated Values in Hash Maps 在哈希映射中存储键值对</a></h2>
<p>The last of our common collections is the <em>hash map</em>. The type <code>HashMap&lt;K, V&gt;</code>
stores a mapping of keys of type <code>K</code> to values of type <code>V</code> using a <em>hashing
function</em>, which determines how it places these keys and values into memory.
Many programming languages support this kind of data structure, but they often
use a different name, such as <em>hash</em>, <em>map</em>, <em>object</em>, <em>hash table</em>,
<em>dictionary</em>, or <em>associative array</em>, just to name a few.</p>
<p>最后一种常见的集合类型是 <em>哈希映射（hash map）</em>。类型 <code>HashMap&lt;K, V&gt;</code> 通过 <em>哈希函数（hashing function）</em> 存储键类型 <code>K</code> 到值类型 <code>V</code> 的映射，该函数决定了键值对在内存中的存储方式。许多编程语言支持此类数据结构，但命名可能不同，例如 <em>hash</em>、<em>map</em>、<em>object</em>、<em>hash table</em>、<em>dictionary</em> 或 <em>associative array</em> 等。</p>
<p>Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team’s score in a hash map in which
each key is a team’s name and the values are each team’s score. Given a team
name, you can retrieve its score.</p>
<p>当你希望基于任意类型的键（而非像向量那样使用索引）来查找数据时，哈希映射非常有用。例如，在游戏中可以用哈希映射跟踪各队伍分数：键是队伍名，值是对应分数。输入队伍名即可获取其分数。</p>
<p>We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on <code>HashMap&lt;K, V&gt;</code> by the standard library.
As always, check the standard library documentation for more information.</p>
<p>本节将介绍哈希映射的基础 API，但标准库在 <code>HashMap&lt;K, V&gt;</code> 上定义的函数还隐藏着更多功能。请一如既往地查阅标准库文档以获取更多信息。</p>
<h3 id="creating-a-new-hash-map-创建新哈希映射"><a class="header" href="#creating-a-new-hash-map-创建新哈希映射">Creating a New Hash Map 创建新哈希映射</a></h3>
<p>One way to create an empty hash map is to use <code>new</code> and to add elements with
<code>insert</code>. In Listing 8-20, we’re keeping track of the scores of two teams whose
names are <em>Blue</em> and <em>Yellow</em>. The Blue team starts with 10 points, and the
Yellow team starts with 50.</p>
<p>创建空哈希映射的一种方法是使用 <code>new</code> 并通过 <code>insert</code> 添加元素。在示例 8-20 中，我们记录名为 <em>Blue</em> 和 <em>Yellow</em> 的两支队伍分数。蓝队初始 10 分，黄队初始 50 分。</p>
<figure class="listing" id="listing-8-20">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-20">Listing 8-20</a>: Creating a new hash map and inserting some keys and values 创建新哈希映射并插入键值对</figcaption>
</figure>
<p>Note that we need to first <code>use</code> the <code>HashMap</code> from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there’s no built-in macro to construct them, for example.</p>
<p>注意需先从标准库的集合部分 <code>use</code> 引入 <code>HashMap</code>。在三种常见集合中，哈希映射最不常用，因此未被预导入（prelude）自动引入作用域。标准库对其支持也较少，例如没有内置宏来构造它们。</p>
<p>Just like vectors, hash maps store their data on the heap. This <code>HashMap</code> has
keys of type <code>String</code> and values of type <code>i32</code>. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.</p>
<p>与向量类似，哈希映射将数据存储在堆上。此处的 <code>HashMap</code> 键类型为 <code>String</code>，值类型为 <code>i32</code>。同样地，哈希映射是同质的：所有键类型必须相同，所有值类型也必须相同。</p>
<h3 id="accessing-values-in-a-hash-map-访问哈希映射中的值"><a class="header" href="#accessing-values-in-a-hash-map-访问哈希映射中的值">Accessing Values in a Hash Map 访问哈希映射中的值</a></h3>
<p>We can get a value out of the hash map by providing its key to the <code>get</code>
method, as shown in Listing 8-21.</p>
<p><span class="highlight">[note]可通过 <code>get</code> 方法传入键来获取值</span>，如示例 8-21 所示。</p>
<figure class="listing" id="listing-8-21">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-21">Listing 8-21</a>: Accessing the score for the Blue team stored in the hash map 访问哈希映射中蓝队的分数</figcaption>
</figure>
<p>Here, <code>score</code> will have the value that’s associated with the Blue team, and the
result will be <code>10</code>. The <code>get</code> method returns an <code>Option&lt;&amp;V&gt;</code>; if there’s no
value for that key in the hash map, <code>get</code> will return <code>None</code>. This program
handles the <code>Option</code> by calling <code>copied</code> to get an <code>Option&lt;i32&gt;</code> rather than an
<code>Option&lt;&amp;i32&gt;</code>, then <code>unwrap_or</code> to set <code>score</code> to zero if <code>scores</code> doesn’t
have an entry for the key.</p>
<p>此处 <code>score</code> 将获得与蓝队关联的值，结果为 <code>10</code>。<span class="highlight">[note]<code>get</code> 方法返回 <code>Option&lt;&amp;V&gt;</code></span>；若键无对应值则返回 <code>None</code>。此代码通过 <code>copied</code> 将 <code>Option&lt;&amp;i32&gt;</code> 转为 <code>Option&lt;i32&gt;</code>，再用 <code>unwrap_or</code> 在键不存在时将 <code>score</code> 置零。</p>
<p>We can iterate over each key-value pair in a hash map in a similar manner as we
do with vectors, using a <code>for</code> loop:</p>
<p>可用 <code>for</code> 循环遍历键值对，方式类似向量遍历：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>This code will print each pair in an arbitrary order:</p>
<p>此代码会以任意顺序打印各键值对：</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="hash-maps-and-ownership-哈希映射与所有权"><a class="header" href="#hash-maps-and-ownership-哈希映射与所有权">Hash Maps and Ownership 哈希映射与所有权</a></h3>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code>, the values are copied
into the hash map. For owned values like <code>String</code>, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.</p>
<p>对于实现 <code>Copy</code> trait 的类型（如 <code>i32</code>），值会被复制到哈希映射中。对于拥有所有权的值（如 <code>String</code>），值会被移动且哈希映射将成为其新所有者，如示例 8-22 所示。</p>
<figure class="listing" id="listing-8-22">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-22">Listing 8-22</a>: Showing that keys and values are owned by the hash map once they’re inserted 展示键值插入后所有权归哈希映射所有</figcaption>
</figure>
<p>We aren’t able to use the variables <code>field_name</code> and <code>field_value</code> after
they’ve been moved into the hash map with the call to <code>insert</code>.</p>
<p>在通过 <code>insert</code> 调用将 <code>field_name</code> 和 <code>field_value</code> 移入哈希映射后，无法再使用这两个变量。</p>
<p>If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
“Validating References with
Lifetimes” in Chapter 10.</p>
<p>若插入值的引用，则值不会被移入哈希映射。引用指向的值在哈希映射有效期间必须保持有效。第 10 章“生命周期验证引用“将深入讨论此问题。</p>
<h3 id="updating-a-hash-map-更新哈希映射"><a class="header" href="#updating-a-hash-map-更新哈希映射">Updating a Hash Map 更新哈希映射</a></h3>
<p>Although the number of key and value pairs is growable, each unique key can
only have one value associated with it at a time (but not vice versa: for
example, both the Blue team and the Yellow team could have the value <code>10</code>
stored in the <code>scores</code> hash map).</p>
<p>尽管键值对数量可变，但同一时刻每个唯一键只能关联一个值（反之则不然：例如蓝队和黄队可同时在 <code>scores</code> 哈希映射中存储值 <code>10</code>）。</p>
<p>When you want to change the data in a hash map, you have to decide how to
handle the case when a key already has a value assigned. You could replace the
old value with the new value, completely disregarding the old value. You could
keep the old value and ignore the new value, only adding the new value if the
key <em>doesn’t</em> already have a value. Or you could combine the old value and the
new value. Let’s look at how to do each of these!</p>
<p>更新哈希映射数据时，需处理键已存在值的情况：可完全忽略旧值并用新值覆盖；可保留旧值忽略新值，仅当键 <em>无</em> 值时插入新值；亦可合并新旧值。下面分别说明：</p>
<h4 id="overwriting-a-value-覆盖值"><a class="header" href="#overwriting-a-value-覆盖值">Overwriting a Value 覆盖值</a></h4>
<p>If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-23 calls <code>insert</code> twice, the hash map will
only contain one key-value pair because we’re inserting the value for the Blue
team’s key both times.</p>
<p>若对同一键重复插入不同值，旧值会被替换。示例 8-23 虽调用两次 <code>insert</code>，但哈希映射仅存一个键值对，因为两次均为蓝队键插入值。</p>
<figure class="listing" id="listing-8-23">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-23">Listing 8-23</a>: Replacing a value stored with a particular key 替换特定键对应的值</figcaption>
</figure>
<p>This code will print <code>{"Blue": 25}</code>. The original value of <code>10</code> has been
overwritten.</p>
<p>此代码将打印 <code>{"Blue": 25}</code>，原始值 <code>10</code> 已被覆盖。</p>
<h4 id="adding-a-key-and-value-only-if-a-key-isnt-present-仅当键不存在时插入"><a class="header" href="#adding-a-key-and-value-only-if-a-key-isnt-present-仅当键不存在时插入">Adding a Key and Value Only If a Key Isn’t Present 仅当键不存在时插入</a></h4>
<p>It’s common to check whether a particular key already exists in the hash map
with a value and then to take the following actions: if the key does exist in
the hash map, the existing value should remain the way it is; if the key
doesn’t exist, insert it and a value for it.</p>
<p>常见操作是检查特定键是否存在值：若存在则保留原值；若不存在则插入键及其值。</p>
<p>Hash maps have a special API for this called <code>entry</code> that takes the key you
want to check as a parameter. The return value of the <code>entry</code> method is an enum
called <code>Entry</code> that represents a value that might or might not exist. Let’s say
we want to check whether the key for the Yellow team has a value associated
with it. If it doesn’t, we want to insert the value <code>50</code>, and the same for the
Blue team. Using the <code>entry</code> API, the code looks like Listing 8-24.</p>
<p><span class="highlight">[note]哈希映射为此提供 <code>entry</code> API，它以待检查键为参数，返回表示值可能存在的枚举 <code>Entry</code>。</span>假设要检查黄队键是否有值，若无则插入 <code>50</code>，蓝队同理。使用 <code>entry</code> API 的代码如示例 8-24 所示。</p>
<figure class="listing" id="listing-8-24">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-24">Listing 8-24</a>: Using the <code>entry</code> method to only insert if the key does not already have a value 使用 <code>entry</code> 方法仅在键无值时插入</figcaption>
</figure>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to
the value for the corresponding <code>Entry</code> key if that key exists, and if not, it
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.</p>
<p><span class="highlight">[note]<code>Entry</code> 的 <code>or_insert</code> 方法在键存在时返回其值的可变引用，不存在时插入参数作为新值并返回新值的可变引用。</span>此方法比手动实现逻辑更简洁，且更兼容借用检查器。</p>
<p>Running the code in Listing 8-24 will print <code>{"Yellow": 50, "Blue": 10}</code>. The
first call to <code>entry</code> will insert the key for the Yellow team with the value
<code>50</code> because the Yellow team doesn’t have a value already. The second call to
<code>entry</code> will not change the hash map because the Blue team already has the
value <code>10</code>.</p>
<p>运行示例 8-24 将打印 <code>{"Yellow": 50, "Blue": 10}</code>。首次调用 <code>entry</code> 会为黄队插入值 <code>50</code>（因其原无值），第二次调用不会改变哈希映射（因蓝队已有值 <code>10</code>）。</p>
<h4 id="updating-a-value-based-on-the-old-value-基于旧值更新"><a class="header" href="#updating-a-value-based-on-the-old-value-基于旧值更新">Updating a Value Based on the Old Value 基于旧值更新</a></h4>
<p>Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-25 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value <code>0</code>.</p>
<p>哈希映射另一常见用途是查找键的值并基于旧值更新。例如示例 8-25 统计文本中单词出现次数：以单词为键，增加值以跟踪出现频率。若单词首次出现，先插入值 <code>0</code>。</p>
<figure class="listing" id="listing-8-25">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch08-03-hash-maps.html#listing-8-25">Listing 8-25</a>: Counting occurrences of words using a hash map that stores words and counts 使用存储单词和计数的哈希映射进行词频统计</figcaption>
</figure>
<p>This code will print <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. You might see
the same key-value pairs printed in a different order: recall from “Accessing
Values in a Hash Map” that iterating over a hash map
happens in an arbitrary order.</p>
<p>此代码可能打印 <code>{"world": 2, "hello": 1, "wonderful": 1}</code>（顺序可能不同，回忆“访问哈希映射中的值“可知迭代顺序是任意的）。</p>
<p>The <code>split_whitespace</code> method returns an iterator over subslices, separated by
whitespace, of the value in <code>text</code>. The <code>or_insert</code> method returns a mutable
reference (<code>&amp;mut V</code>) to the value for the specified key. Here, we store that
mutable reference in the <code>count</code> variable, so in order to assign to that value,
we must first dereference <code>count</code> using the asterisk (<code>*</code>). The mutable
reference goes out of scope at the end of the <code>for</code> loop, so all of these
changes are safe and allowed by the borrowing rules.</p>
<p><code>split_whitespace</code> 方法返回基于空白分隔的文本子切片迭代器。<code>or_insert</code> 返回键对应值的可变引用（<code>&amp;mut V</code>）。此处将可变引用存入 <code>count</code> 变量，赋值时需先用星号（<code>*</code>）解引用 <code>count</code>。可变引用在 <code>for</code> 循环结束时离开作用域，因此这些变更均符合借用规则且安全。</p>
<h3 id="hashing-functions-哈希函数"><a class="header" href="#hashing-functions-哈希函数">Hashing Functions 哈希函数</a></h3>
<p>By default, <code>HashMap</code> uses a hashing function called <em>SipHash</em> that can provide
resistance to denial-of-service (DoS) attacks involving hash
tables. This is not the fastest hashing algorithm
available, but the trade-off for better security that comes with the drop in
performance is worth it. If you profile your code and find that the default
hash function is too slow for your purposes, you can switch to another function
by specifying a different hasher. A <em>hasher</em> is a type that implements the
<code>BuildHasher</code> trait. We’ll talk about traits and how to implement them in
Chapter 10. You don’t necessarily have to implement
your own hasher from scratch; <a href="https://crates.io/">crates.io</a>
has libraries shared by other Rust users that provide hashers implementing many
common hashing algorithms.</p>
<p>默认情况下，<code>HashMap</code> 使用名为 <em>SipHash</em> 的哈希函数，可抵御涉及哈希表的拒绝服务（DoS）攻击。此非最快的哈希算法，但以性能换取更高安全性是值得的。若性能分析表明默认哈希函数过慢，可通过指定不同的 hasher 切换算法。<em>hasher</em> 是实现了 <code>BuildHasher</code> trait 的类型。第 10 章将讨论 trait 及其实现。不必从头实现自己的 hasher，<a href="https://crates.io/">crates.io</a> 上有其他 Rust 用户共享的提供常见哈希算法的库。</p>
<h2 id="summary-总结-7"><a class="header" href="#summary-总结-7">Summary 总结</a></h2>
<p>Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:</p>
<p>当你需要存储、访问和修改数据时，向量、字符串和哈希映射将提供大量必要功能。现在你已能解决以下练习：</p>
<ul>
<li>Given a list of integers, use a vector and return the median (when sorted,
the value in the middle position) and mode (the value that occurs most
often; a hash map will be helpful here) of the list.</li>
<li>给定整数列表，使用向量返回中位数（排序后位于中间的值）和众数（出现最频繁的值，哈希映射对此很有帮助）。</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to
the end of the word and <em>ay</em> is added, so <em>first</em> becomes <em>irst-fay</em>. Words
that start with a vowel have <em>hay</em> added to the end instead (<em>apple</em> becomes
<em>apple-hay</em>). Keep in mind the details about UTF-8 encoding!</li>
<li>将字符串转换为拉丁猪文：单词首辅音移至末尾并添加 <em>ay</em>（如 <em>first</em> 变为 <em>irst-fay</em>）；元音开头的单词则添加 <em>hay</em>（如 <em>apple</em> 变为 <em>apple-hay</em>）。请注意 UTF-8 编码细节！</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add
employee names to a department in a company; for example, “Add Sally to
Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
people in a department or all people in the company by department, sorted
alphabetically.</li>
<li>使用哈希映射和向量创建文本接口：用户可添加员工姓名到公司部门（如“Add Sally to Engineering“或“Add Amir to Sales“），并支持按部门检索人员列表或按部门排序的全公司人员列表。</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!</p>
<p>标准库 API 文档描述了向量、字符串和哈希映射的有用方法！</p>
<p>We’re getting into more complex programs in which operations can fail, so it’s
a perfect time to discuss error handling. We’ll do that next!</p>
<p>我们正进入更复杂的程序领域，操作可能失败，是时候讨论错误处理了。下一章见！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-错误处理"><a class="header" href="#error-handling-错误处理">Error Handling 错误处理</a></h1>
<p>Errors are a fact of life in software, so Rust has a number of features for
handling situations in which something goes wrong. In many cases, Rust requires
you to acknowledge the possibility of an error and take some action before your
code will compile. This requirement makes your program more robust by ensuring
that you’ll discover errors and handle them appropriately before deploying your
code to production!</p>
<p>软件中的错误是不可避免的，因此 Rust 提供了一系列特性来处理程序出错的情况。在许多情况下，Rust 要求你在代码编译前必须承认错误存在的可能性并采取相应措施。这个要求确保了在将代码部署到生产环境前，你能发现错误并妥善处理它们，从而使程序更加健壮！</p>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em>
errors. For a recoverable error, such as a <em>file not found</em> error, we most
likely just want to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, such as trying to access a
location beyond the end of an array, and so we want to immediately stop the
program.</p>
<p>Rust 将错误分为两大类别：<strong>可恢复错误</strong>和<strong>不可恢复错误</strong>。对于可恢复错误（例如“文件未找到“），我们通常只需向用户报告问题并重试操作即可。不可恢复错误往往是代码缺陷的表现（例如尝试访问超出数组末尾的位置），此时我们希望立即终止程序。</p>
<p>Most languages don’t distinguish between these two kinds of errors and handle
both in the same way, using mechanisms such as exceptions. Rust doesn’t have
exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and
the <code>panic!</code> macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling <code>panic!</code> first and then talks
about returning <code>Result&lt;T, E&gt;</code> values. Additionally, we’ll explore
considerations when deciding whether to try to recover from an error or to stop
execution.</p>
<p>大多数语言不区分这两类错误，而是使用异常等机制统一处理。Rust 没有异常机制，它通过 <code>Result&lt;T, E&gt;</code> 类型处理可恢复错误，而 <code>panic!</code> 宏则用于在程序遇到不可恢复错误时终止执行。本章将先讲解 <code>panic!</code> 的调用，接着讨论如何返回 <code>Result&lt;T, E&gt;</code> 值。此外，我们还将探讨在决定“尝试从错误中恢复“还是“终止程序“时的考量因素。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unrecoverable-errors-with-panic-使用-panic-处理不可恢复错误"><a class="header" href="#unrecoverable-errors-with-panic-使用-panic-处理不可恢复错误">Unrecoverable Errors with <code>panic!</code> 使用 <code>panic!</code> 处理不可恢复错误</a></h2>
<p>Sometimes bad things happen in your code, and there’s nothing you can do about
it. In these cases, Rust has the <code>panic!</code> macro. There are two ways to cause a
panic in practice: by taking an action that causes our code to panic (such as
accessing an array past the end) or by explicitly calling the <code>panic!</code> macro.
In both cases, we cause a panic in our program. By default, these panics will
print a failure message, unwind, clean up the stack, and quit. Via an
environment variable, you can also have Rust display the call stack when a
panic occurs to make it easier to track down the source of the panic.</p>
<p>当代码中发生无法挽回的问题时，Rust 提供了 <code>panic!</code> 宏。实践中触发 panic 有两种方式：执行导致代码 panic 的操作（如越界访问数组），或显式调用 <code>panic!</code> 宏。两种情况下程序都会触发 panic。默认情况下，panic 会打印错误信息、回退栈（unwind）、清理栈数据并退出。通过环境变量，你还可以让 Rust 在 panic 时显示调用栈，便于追踪 panic 根源。</p>
<section class="note" aria-role="note">
<h3 id="unwinding-the-stack-or-aborting-in-response-to-a-panic-回退栈或立即终止"><a class="header" href="#unwinding-the-stack-or-aborting-in-response-to-a-panic-回退栈或立即终止">Unwinding the Stack or Aborting in Response to a Panic 回退栈或立即终止</a></h3>
<p>By default, when a panic occurs the program starts <em>unwinding</em>, which means
Rust walks back up the stack and cleans up the data from each function it
encounters. However, walking back and cleaning up is a lot of work. Rust,
therefore, allows you to choose the alternative of immediately <em>aborting</em>,
which ends the program without cleaning up.</p>
<p><span class="highlight">[note]默认情况下，发生 panic 时程序会启动<strong>回退过程</strong>——Rust 将沿调用栈逐层回溯并清理遇到的函数数据。</span>但回溯清理工作量很大，因此 Rust 允许你选择立即<strong>终止</strong>的替代方案，此时程序直接结束而不进行清理。</p>
<p>Memory that the program was using will then need to be cleaned up by the
operating system. If in your project you need to make the resultant binary as
small as possible, you can switch from unwinding to aborting upon a panic by
adding <code>panic = 'abort'</code> to the appropriate <code>[profile]</code> sections in your
<em>Cargo.toml</em> file. For example, if you want to abort on panic in release mode,
add this:</p>
<p>程序占用的内存将由操作系统回收。若需要生成尽可能小的二进制文件，<span class="highlight">[note]可在 <em>Cargo.toml</em> 文件的相应 <code>[profile]</code> 区域添加 <code>panic = 'abort'</code>，将 panic 行为从回退改为立即终止。</span>例如要在发布模式中启用 panic 终止：</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</section>
<p>Let’s try calling <code>panic!</code> in a simple program:</p>
<p>在简单程序中调用 <code>panic!</code> 的示例：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!("crash and burn");
}</code></pre></pre>
</figure>
<p>When you run the program, you’ll see something like this:</p>
<p>运行程序后将看到类似输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The call to <code>panic!</code> causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: <em>src/main.rs:2:5</em> indicates that it’s the second line,
fifth character of our <em>src/main.rs</em> file.</p>
<p><code>panic!</code> 调用导致最后两行显示错误信息。首行显示 panic 消息及源码位置：<em>src/main.rs:2:5</em> 表示文件第二行第五个字符。</p>
<p>In this case, the line indicated is part of our code, and if we go to that
line, we see the <code>panic!</code> macro call. In other cases, the <code>panic!</code> call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone else’s code where the <code>panic!</code> macro is
called, not the line of our code that eventually led to the <code>panic!</code> call.</p>
<p>此处标记的行属于我们的代码，定位后可看到 <code>panic!</code> 宏调用。但有时 <code>panic!</code> 可能发生在调用链的深层，此时错误信息显示的文件名和行号会是他人调用 <code>panic!</code> 的代码位置，而非最终触发 panic 的源头。</p>
<p>We can use the backtrace of the functions the <code>panic!</code> call came from to figure
out the part of our code that is causing the problem. To understand how to use
a <code>panic!</code> backtrace, let’s look at another example and see what it’s like when
a <code>panic!</code> call comes from a library because of a bug in our code instead of
from our code calling the macro directly. Listing 9-1 has some code that
attempts to access an index in a vector beyond the range of valid indexes.</p>
<p>通过 <code>panic!</code> 调用来源的函数回溯，可定位引发问题的代码段。为理解如何利用 panic 回溯，请看另一个示例——当因代码缺陷导致库函数触发 <code>panic!</code> 时的情况。示例 9-1 尝试访问向量范围外的索引：</p>
<figure class="listing" id="listing-9-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<figcaption><a href="ch09-01-unrecoverable-errors-with-panic.html#listing-9-1">Listing 9-1</a>: Attempting to access an element beyond the end of a vector, which will cause a call to <code>panic!</code> 尝试访问超出向量有效范围的元素将触发 panic</figcaption>
</figure>
<p>Here, we’re attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but the vector has only three
elements. In this situation, Rust will panic. Using <code>[]</code> is supposed to return
an element, but if you pass an invalid index, there’s no element that Rust
could return here that would be correct.</p>
<p>此处我们尝试访问向量的第 100 个元素（索引为 99，因索引从 0 开始），但向量仅有三个元素。此时 Rust 将触发 panic。使用 <code>[]</code> 本应返回元素，但当传入无效索引时，Rust 无法返回有效元素。</p>
<p>In C, attempting to read beyond the end of a data structure is undefined
behavior. You might get whatever is at the location in memory that would
correspond to that element in the data structure, even though the memory
doesn’t belong to that structure. This is called a <em>buffer overread</em> and can
lead to security vulnerabilities if an attacker is able to manipulate the index
in such a way as to read data they shouldn’t be allowed to that is stored after
the data structure.</p>
<p>在 C 语言中，尝试读取数据结构末尾之外的数据属于未定义行为。你可能获得内存中对应位置的任意数据（即便该内存不属于该结构）。这称为<strong>缓冲区越界读取</strong>，若攻击者能操纵索引读取数据结构后的未授权数据，将导致安全漏洞。</p>
<p>To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn’t exist, Rust will stop execution and refuse to
continue. Let’s try it and see:</p>
<p>为防止此类漏洞，当尝试读取不存在的索引时，Rust 会停止执行并拒绝继续。运行结果如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>This error points at line 4 of our <em>main.rs</em> where we attempt to access index
<code>99</code> of the vector in <code>v</code>.</p>
<p>该错误指向 <em>main.rs</em> 第 4 行，即尝试访问向量 <code>v</code> 的第 <code>99</code> 个索引处。</p>
<p>The <code>note:</code> line tells us that we can set the <code>RUST_BACKTRACE</code> environment
variable to get a backtrace of exactly what happened to cause the error. A
<em>backtrace</em> is a list of all the functions that have been called to get to this
point. Backtraces in Rust work as they do in other languages: the key to
reading the backtrace is to start from the top and read until you see files you
wrote. That’s the spot where the problem originated. The lines above that spot
are code that your code has called; the lines below are code that called your
code. These before-and-after lines might include core Rust code, standard
library code, or crates that you’re using. Let’s try getting a backtrace by
setting the <code>RUST_BACKTRACE</code> environment variable to any value except <code>0</code>.
Listing 9-2 shows output similar to what you’ll see.</p>
<p><code>note:</code> 行提示可通过设置 <code>RUST_BACKTRACE</code> 环境变量获取导致错误的详细回溯。<strong>回溯</strong>是列出所有调用函数的链式列表。Rust 的回溯机制与其他语言相同：解读回溯的关键是从顶部开始阅读，直到发现你编写的文件——那就是问题根源。该位置之上是你代码调用的函数，之下是调用你代码的函数（可能包含 Rust 核心库、标准库或第三方库代码）。尝试设置 <code>RUST_BACKTRACE</code> 为任意非 <code>0</code> 值获取回溯，示例 9-2 展示了典型输出：</p>
<figure class="listing" id="listing-9-2">
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<figcaption><a href="ch09-01-unrecoverable-errors-with-panic.html#listing-9-2">Listing 9-2</a>: The backtrace generated by a call to <code>panic!</code> displayed when the environment variable <code>RUST_BACKTRACE</code> is set 设置 RUST_BACKTRACE 环境变量后显示的 panic! 调用回溯</figcaption>
</figure>
<p>That’s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using <code>cargo build</code> or <code>cargo run</code> without the <code>--release</code> flag,
as we have here.</p>
<p>输出信息量很大！具体内容可能因操作系统和 Rust 版本而异。<span class="highlight">[note]要获得带调试信息的回溯，需启用调试符号（debug symbols）。当使用 <code>cargo build</code> 或 <code>cargo run</code> 且不带 <code>--release</code> 标志时（如本例），调试符号默认启用。</span></p>
<p>In the output in Listing 9-2, line 6 of the backtrace points to the line in our
project that’s causing the problem: line 4 of <em>src/main.rs</em>. If we don’t want
our program to panic, we should start our investigation at the location pointed
to by the first line mentioning a file we wrote. In Listing 9-1, where we
deliberately wrote code that would panic, the way to fix the panic is to not
request an element beyond the range of the vector indexes. When your code
panics in the future, you’ll need to figure out what action the code is taking
with what values to cause the panic and what the code should do instead.</p>
<p>在示例 9-2 的输出中，回溯第 6 行指向问题根源：<em>src/main.rs</em> 第 4 行。若不想程序 panic，应首先检查回溯中首次提及的自写文件位置。在示例 9-1 中，我们故意编写了会 panic 的代码，修复方式是避免请求超出向量范围的索引。未来当代码 panic 时，你需要定位代码操作、触发 panic 的值，并修正代码逻辑。</p>
<p>We’ll come back to <code>panic!</code> and when we should and should not use <code>panic!</code> to
handle error conditions in the “To <code>panic!</code> or Not to
<code>panic!</code>” section later in this
chapter. Next, we’ll look at how to recover from an error using <code>Result</code>.</p>
<p>本章后续在《该不该用 panic!》章节将再次讨论 <code>panic!</code> 的使用场景。接下来我们将学习如何用 <code>Result</code> 从错误中恢复。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="recoverable-errors-with-result-可恢复的错误result"><a class="header" href="#recoverable-errors-with-result-可恢复的错误result">Recoverable Errors with <code>Result</code> 可恢复的错误：<code>Result</code></a></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes when a function fails it’s for a reason that you can easily interpret
and respond to. For example, if you try to open a file and that operation fails
because the file doesn’t exist, you might want to create the file instead of
terminating the process.</p>
<p>大多数错误并不严重到需要程序完全停止的程度。有时函数失败的原因可以轻松解读并响应。例如，尝试打开文件时因文件不存在而失败，你可能希望创建文件而非终止进程。</p>
<p>Recall from “Handling Potential Failure with <code>Result</code>” in Chapter 2 that the <code>Result</code> enum is defined as having two
variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<p>回忆第2章中 “用 <code>Result</code> 处理潜在失败” 的内容，<code>Result</code> 枚举定义为两个变体 <code>Ok</code> 和 <code>Err</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that <code>T</code> represents
the type of the value that will be returned in a success case within the <code>Ok</code>
variant, and <code>E</code> represents the type of the error that will be returned in a
failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type
parameters, we can use the <code>Result</code> type and the functions defined on it in
many different situations where the success value and error value we want to
return may differ.</p>
<p><code>T</code> 和 <code>E</code> 是泛型类型参数：第10章将详细讨论泛型。现在只需知道：<code>T</code> 代表成功时 <code>Ok</code> 变体返回的值的类型，<code>E</code> 代表失败时 <code>Err</code> 变体返回的错误类型。由于 <code>Result</code> 具有这些泛型参数，我们可以在多种场景中使用 <code>Result</code> 类型及其定义的方法，这些场景中要返回的成功值和错误值可能不同。</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail. In Listing 9-3 we try to open a file.</p>
<p>调用可能失败的函数时会返回 <code>Result</code> 值。示例9-3尝试打开文件：</p>
<figure class="listing" id="listing-9-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-3">Listing 9-3</a>: Opening a file 打开文件</figcaption>
</figure>
<p>The return type of <code>File::open</code> is a <code>Result&lt;T, E&gt;</code>. The generic parameter <code>T</code>
has been filled in by the implementation of <code>File::open</code> with the type of the
success value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in
the error value is <code>std::io::Error</code>. This return type means the call to
<code>File::open</code> might succeed and return a file handle that we can read from or
write to. The function call also might fail: for example, the file might not
exist, or we might not have permission to access the file. The <code>File::open</code>
function needs to have a way to tell us whether it succeeded or failed and at
the same time give us either the file handle or error information. This
information is exactly what the <code>Result</code> enum conveys.</p>
<p><code>File::open</code> 的返回类型是 <code>Result&lt;T, E&gt;</code>。泛型参数 <code>T</code> 由 <code>File::open</code> 的实现填充为成功值类型 <code>std::fs::File</code>（文件句柄）。错误值中使用的 <code>E</code> 类型是 <code>std::io::Error</code>。此返回类型意味着对 <code>File::open</code> 的调用可能成功并返回可读写的文件句柄，也可能失败（例如文件不存在或无访问权限）。<code>File::open</code> 函数需告知成功与否，同时提供文件句柄或错误信息，这正是 <code>Result</code> 枚举所传递的信息。</p>
<p>In the case where <code>File::open</code> succeeds, the value in the variable
<code>greeting_file_result</code> will be an instance of <code>Ok</code> that contains a file handle.
In the case where it fails, the value in <code>greeting_file_result</code> will be an
instance of <code>Err</code> that contains more information about the kind of error that
occurred.</p>
<p>若 <code>File::open</code> 成功，变量 <code>greeting_file_result</code> 的值将是包含文件句柄的 <code>Ok</code> 实例；若失败，则是包含错误信息的 <code>Err</code> 实例。</p>
<p>We need to add to the code in Listing 9-3 to take different actions depending
on the value <code>File::open</code> returns. Listing 9-4 shows one way to handle the
<code>Result</code> using a basic tool, the <code>match</code> expression that we discussed in
Chapter 6.</p>
<p>我们需要扩展示例9-3的代码，根据 <code>File::open</code> 的返回值执行不同操作。示例9-4展示了用 <code>match</code> 表达式处理 <code>Result</code> 的方法：</p>
<figure class="listing" id="listing-9-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem opening the file: {error:?}"),
    };
}</code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-4">Listing 9-4</a>: Using a <code>match</code> expression to handle the <code>Result</code> variants that might be returned 使用 <code>match</code> 表达式处理可能返回的 <code>Result</code> 变体</figcaption>
</figure>
<p>Note that, like the <code>Option</code> enum, the <code>Result</code> enum and its variants have been
brought into scope by the prelude, so we don’t need to specify <code>Result::</code>
before the <code>Ok</code> and <code>Err</code> variants in the <code>match</code> arms.</p>
<p>注意：与 <code>Option</code> 枚举类似，<code>Result</code> 枚举及其变体已通过预导入（prelude）引入作用域，因此 <code>match</code> 分支中无需在 <code>Ok</code> 和 <code>Err</code> 前指定 <code>Result::</code>。</p>
<p>When the result is <code>Ok</code>, this code will return the inner <code>file</code> value out of
the <code>Ok</code> variant, and we then assign that file handle value to the variable
<code>greeting_file</code>. After the <code>match</code>, we can use the file handle for reading or
writing.</p>
<p>当结果为 <code>Ok</code> 时，此代码从 <code>Ok</code> 变体中取出内部 <code>file</code> 值，并将该文件句柄赋给变量 <code>greeting_file</code>。<code>match</code> 之后即可使用此文件句柄进行读写。</p>
<p>The other arm of the <code>match</code> handles the case where we get an <code>Err</code> value from
<code>File::open</code>. In this example, we’ve chosen to call the <code>panic!</code> macro. If
there’s no file named <em>hello.txt</em> in our current directory and we run this
code, we’ll see the following output from the <code>panic!</code> macro:</p>
<p><code>match</code> 的另一分支处理从 <code>File::open</code> 获取 <code>Err</code> 值的情况。本例选择调用 <code>panic!</code> 宏。若当前目录无 <em>hello.txt</em> 文件时运行此代码，将看到 <code>panic!</code> 宏的输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>As usual, this output tells us exactly what has gone wrong.</p>
<p>此输出精确指出了问题所在。</p>
<h3 id="matching-on-different-errors-匹配不同错误"><a class="header" href="#matching-on-different-errors-匹配不同错误">Matching on Different Errors 匹配不同错误</a></h3>
<p>The code in Listing 9-4 will <code>panic!</code> no matter why <code>File::open</code> failed.
However, we want to take different actions for different failure reasons. If
<code>File::open</code> failed because the file doesn’t exist, we want to create the file
and return the handle to the new file. If <code>File::open</code> failed for any other
reason—for example, because we didn’t have permission to open the file—we still
want the code to <code>panic!</code> in the same way it did in Listing 9-4. For this, we
add an inner <code>match</code> expression, shown in Listing 9-5.</p>
<p>示例9-4的代码无论 <code>File::open</code> 为何失败都会触发 <code>panic!</code>。但我们需要针对不同失败原因采取不同操作：若因文件不存在失败，则创建文件并返回新文件句柄；若因其他原因（如无权限）失败，仍按示例9-4的方式触发 <code>panic!</code>。为此，我们添加内部 <code>match</code> 表达式（见示例9-5）。</p>
<figure class="listing" id="listing-9-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {e:?}"),
            },
            _ =&gt; {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}</code></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-5">Listing 9-5</a>: Handling different kinds of errors in different ways 以不同方式处理不同错误类型</figcaption>
</figure>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is
<code>io::Error</code>, which is a struct provided by the standard library. This struct
has a method <code>kind</code> that we can call to get an <code>io::ErrorKind</code> value. The enum
<code>io::ErrorKind</code> is provided by the standard library and has variants
representing the different kinds of errors that might result from an <code>io</code>
operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates
the file we’re trying to open doesn’t exist yet. So we match on
<code>greeting_file_result</code>, but we also have an inner match on <code>error.kind()</code>.</p>
<p><code>File::open</code> 在 <code>Err</code> 变体中返回的值类型是标准库提供的结构体 <code>io::Error</code>。该结构体有 <code>kind</code> 方法可获取 <code>io::ErrorKind</code> 值。枚举 <code>io::ErrorKind</code> 由标准库提供，其变体表示 <code>io</code> 操作可能导致的不同错误类型。我们需要的变体是 <code>ErrorKind::NotFound</code>，表示要打开的文件尚不存在。因此我们匹配 <code>greeting_file_result</code>，并在 <code>error.kind()</code> 上进行内部匹配。</p>
<p>The condition we want to check in the inner match is whether the value returned
by <code>error.kind()</code> is the <code>NotFound</code> variant of the <code>ErrorKind</code> enum. If it is,
we try to create the file with <code>File::create</code>. However, because <code>File::create</code>
could also fail, we need a second arm in the inner <code>match</code> expression. When the
file can’t be created, a different error message is printed. The second arm of
the outer <code>match</code> stays the same, so the program panics on any error besides
the missing file error.</p>
<p>内部匹配中检查的条件是：<code>error.kind()</code> 返回的值是否为 <code>ErrorKind</code> 枚举的 <code>NotFound</code> 变体。若是，则尝试用 <code>File::create</code> 创建文件。但 <code>File::create</code> 也可能失败，因此内部 <code>match</code> 需要第二个分支处理文件创建失败的情况。外部 <code>match</code> 的第二个分支保持不变，程序对除文件不存在之外的其他错误均触发恐慌。</p>
<section class="note" aria-role="note">
<h4 id="alternatives-to-using-match-with-resultt-e-替代方案resultt-e-的其他处理方法"><a class="header" href="#alternatives-to-using-match-with-resultt-e-替代方案resultt-e-的其他处理方法">Alternatives to Using <code>match</code> with <code>Result&lt;T, E&gt;</code> 替代方案：<code>Result&lt;T, E&gt;</code> 的其他处理方法</a></h4>
<p>That’s a lot of <code>match</code>! The <code>match</code> expression is very useful but also very
much a primitive. In Chapter 13, you’ll learn about closures, which are used
with many of the methods defined on <code>Result&lt;T, E&gt;</code>. These methods can be more
concise than using <code>match</code> when handling <code>Result&lt;T, E&gt;</code> values in your code.</p>
<p><code>match</code> 太多了！<code>match</code> 表达式虽实用但较原始。第13章将学习闭包，其可与 <code>Result&lt;T, E&gt;</code> 的许多方法结合使用。这些方法在处理 <code>Result&lt;T, E&gt;</code> 值时比 <code>match</code> 更简洁。</p>
<p>For example, here’s another way to write the same logic as shown in Listing
9-5, this time using closures and the <code>unwrap_or_else</code> method:</p>
<p>例如，以下是实现与示例9-5相同逻辑的另一种方式（使用闭包和 <code>unwrap_or_else</code> 方法）：</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}</code></pre>
<p>Although this code has the same behavior as Listing 9-5, it doesn’t contain
any <code>match</code> expressions and is cleaner to read. Come back to this example
after you’ve read Chapter 13, and look up the <code>unwrap_or_else</code> method in the
standard library documentation. Many more of these methods can clean up huge
nested <code>match</code> expressions when you’re dealing with errors.</p>
<p>此代码行为与示例9-5相同，但无 <code>match</code> 表达式且更易读。阅读第13章后可回顾此示例，并查阅标准库文档中的 <code>unwrap_or_else</code> 方法。处理错误时，这些方法能大幅简化嵌套的 <code>match</code> 表达式。</p>
</section>
<h4 id="shortcuts-for-panic-on-error-unwrap-and-expect-错误时恐慌的快捷方法unwrap-和-expect"><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect-错误时恐慌的快捷方法unwrap-和-expect">Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code> 错误时恐慌的快捷方法：<code>unwrap</code> 和 <code>expect</code></a></h4>
<p>Using <code>match</code> works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The <code>Result&lt;T, E&gt;</code> type has many helper methods
defined on it to do various, more specific tasks. The <code>unwrap</code> method is a
shortcut method implemented just like the <code>match</code> expression we wrote in
Listing 9-4. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return
the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will
call the <code>panic!</code> macro for us. Here is an example of <code>unwrap</code> in action:</p>
<p><code>match</code> 虽有效但较冗长。<code>Result&lt;T, E&gt;</code> 类型定义了许多辅助方法执行特定任务。<code>unwrap</code> 方法作为快捷方式，其实现类似示例9-4的 <code>match</code>：若 <code>Result</code> 为 <code>Ok</code> 变体，<code>unwrap</code> 返回内部值；若为 <code>Err</code> 变体，则替我们调用 <code>panic!</code> 宏。<code>unwrap</code> 的实例如下：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</figure>
<p>If we run this code without a <em>hello.txt</em> file, we’ll see an error message from
the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<p>若无 <em>hello.txt</em> 文件运行此代码，将看到 <code>unwrap</code> 触发的 <code>panic!</code> 错误信息：</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>Similarly, the <code>expect</code> method lets us also choose the <code>panic!</code> error message.
Using <code>expect</code> instead of <code>unwrap</code> and providing good error messages can convey
your intent and make tracking down the source of a panic easier. The syntax of
<code>expect</code> looks like this:</p>
<p>类似地，<code>expect</code> 方法允许自定义 <code>panic!</code> 错误信息。使用 <code>expect</code> 而非 <code>unwrap</code> 并提供清晰错误信息，能更好表达意图并简化恐慌溯源。<code>expect</code> 语法如下：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}</code></pre></pre>
</figure>
<p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call
the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code>
will be the parameter that we pass to <code>expect</code>, rather than the default
<code>panic!</code> message that <code>unwrap</code> uses. Here’s what it looks like:</p>
<p><code>expect</code> 用法同 <code>unwrap</code>：返回文件句柄或调用 <code>panic!</code> 宏。但 <code>expect</code> 调用 <code>panic!</code> 时使用我们传递的参数而非默认信息。输出如下：</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In production-quality code, most Rustaceans choose <code>expect</code> rather than
<code>unwrap</code> and give more context about why the operation is expected to always
succeed. That way, if your assumptions are ever proven wrong, you have more
information to use in debugging.</p>
<p>在生产级代码中，多数Rust开发者选择 <code>expect</code> 而非 <code>unwrap</code>，以提供更多操作成功预期的上下文。这样在假设错误时，可有更多调试信息。</p>
<h3 id="propagating-errors-传播错误"><a class="header" href="#propagating-errors-传播错误">Propagating Errors 传播错误</a></h3>
<p>When a function’s implementation calls something that might fail, instead of
handling the error within the function itself, you can return the error to the
calling code so that it can decide what to do. This is known as <em>propagating</em>
the error and gives more control to the calling code, where there might be more
information or logic that dictates how the error should be handled than what
you have available in the context of your code.</p>
<p>函数实现调用可能失败的操作时，可不直接处理错误，而将错误返回给调用方决定如何处理。这称为错误传播，赋予调用方更多控制权——相比当前代码上下文，调用方可能掌握更多信息或逻辑来决定错误处理。</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called the function.</p>
<p>例如，示例9-6的函数从文件读取用户名。若文件不存在或读取失败，函数将错误返回给调用方。</p>
<figure class="listing" id="listing-9-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-6">Listing 9-6</a>: A function that returns errors to the calling code using <code>match</code> 使用 <code>match</code> 将错误返回给调用方的函数</figcaption>
</figure>
<p>This function can be written in a much shorter way, but we’re going to start by
doing a lot of it manually in order to explore error handling; at the end,
we’ll show the shorter way. Let’s look at the return type of the function
first: <code>Result&lt;String, io::Error&gt;</code>. This means the function is returning a
value of the type <code>Result&lt;T, E&gt;</code>, where the generic parameter <code>T</code> has been
filled in with the concrete type <code>String</code> and the generic type <code>E</code> has been
filled in with the concrete type <code>io::Error</code>.</p>
<p>此函数可更简洁实现，但为探索错误处理先手动实现，最后展示简洁写法。首先看函数返回类型：<code>Result&lt;String, io::Error&gt;</code>。表示函数返回 <code>Result&lt;T, E&gt;</code> 类型，其中泛型参数 <code>T</code> 替换为具体类型 <code>String</code>，<code>E</code> 替换为 <code>io::Error</code>。</p>
<p>If this function succeeds without any problems, the code that calls this
function will receive an <code>Ok</code> value that holds a <code>String</code>—the <code>username</code> that
this function read from the file. If this function encounters any problems, the
calling code will receive an <code>Err</code> value that holds an instance of <code>io::Error</code>
that contains more information about what the problems were. We chose
<code>io::Error</code> as the return type of this function because that happens to be the
type of the error value returned from both of the operations we’re calling in
this function’s body that might fail: the <code>File::open</code> function and the
<code>read_to_string</code> method.</p>
<p>若函数成功，调用方将收到包含用户名的 <code>Ok</code> 值；若遇到问题，则收到包含 <code>io::Error</code> 实例的 <code>Err</code> 值。选择 <code>io::Error</code> 作为返回类型，因为函数体内可能失败的两个操作（<code>File::open</code> 和 <code>read_to_string</code>）均返回此错误类型。</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then we
handle the <code>Result</code> value with a <code>match</code> similar to the <code>match</code> in Listing 9-4.
If <code>File::open</code> succeeds, the file handle in the pattern variable <code>file</code>
becomes the value in the mutable variable <code>username_file</code> and the function
continues. In the <code>Err</code> case, instead of calling <code>panic!</code>, we use the <code>return</code>
keyword to return early out of the function entirely and pass the error value
from <code>File::open</code>, now in the pattern variable <code>e</code>, back to the calling code as
this function’s error value.</p>
<p>函数体首先调用 <code>File::open</code>，然后用类似示例9-4的 <code>match</code> 处理 <code>Result</code>。若 <code>File::open</code> 成功，模式变量 <code>file</code> 的值将赋给可变变量 <code>username_file</code>，函数继续执行。在 <code>Err</code> 分支中，我们使用 <code>return</code> 关键字提前返回整个函数，并将 <code>File::open</code> 的错误值（现位于模式变量 <code>e</code>）作为函数错误值返回给调用方。</p>
<p>So, if we have a file handle in <code>username_file</code>, the function then creates a
new <code>String</code> in variable <code>username</code> and calls the <code>read_to_string</code> method on
the file handle in <code>username_file</code> to read the contents of the file into
<code>username</code>. The <code>read_to_string</code> method also returns a <code>Result</code> because it
might fail, even though <code>File::open</code> succeeded. So we need another <code>match</code> to
handle that <code>Result</code>: if <code>read_to_string</code> succeeds, then our function has
succeeded, and we return the username from the file that’s now in <code>username</code>
wrapped in an <code>Ok</code>. If <code>read_to_string</code> fails, we return the error value in the
same way that we returned the error value in the <code>match</code> that handled the
return value of <code>File::open</code>. However, we don’t need to explicitly say
<code>return</code>, because this is the last expression in the function.</p>
<p>若 <code>username_file</code> 中有文件句柄，函数在变量 <code>username</code> 中创建新 <code>String</code>，并调用 <code>username_file</code> 的 <code>read_to_string</code> 方法将文件内容读入 <code>username</code>。即使 <code>File::open</code> 成功，<code>read_to_string</code> 也可能失败，故需另一个 <code>match</code> 处理其返回的 <code>Result</code>：若 <code>read_to_string</code> 成功，函数返回包含用户名的 <code>Ok</code>；若失败，则按相同方式返回错误值（此处无需显式 <code>return</code>，因为这是函数最后表达式）。</p>
<p>The code that calls this code will then handle getting either an <code>Ok</code> value
that contains a username or an <code>Err</code> value that contains an <code>io::Error</code>. It’s
up to the calling code to decide what to do with those values. If the calling
code gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.</p>
<p>调用此函数的代码将处理获取用户名（<code>Ok</code>）或 <code>io::Error</code>（<code>Err</code>）。由调用方决定后续操作：可调用 <code>panic!</code> 终止程序、使用默认用户名或从文件外获取用户名等。因无法获知调用方具体意图，故向上传播所有成功或错误信息供其妥善处理。</p>
<p>This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator <code>?</code> to make this easier.</p>
<p>此错误传播模式在Rust中非常常见，因此Rust提供了问号操作符 <code>?</code> 来简化。</p>
<h4 id="a-shortcut-for-propagating-errors-the--operator-传播错误的快捷方式-操作符"><a class="header" href="#a-shortcut-for-propagating-errors-the--operator-传播错误的快捷方式-操作符">A Shortcut for Propagating Errors: The <code>?</code> Operator 传播错误的快捷方式：<code>?</code> 操作符</a></h4>
<p>Listing 9-7 shows an implementation of <code>read_username_from_file</code> that has the
same functionality as in Listing 9-6, but this implementation uses the <code>?</code>
operator.</p>
<p>示例9-7的 <code>read_username_from_file</code> 实现与示例9-6功能相同，但使用了 <code>?</code> 操作符：</p>
<figure class="listing" id="listing-9-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-7">Listing 9-7</a>: A function that returns errors to the calling code using the <code>?</code> operator 使用 <code>?</code> 操作符将错误返回给调用方的函数</figcaption>
</figure>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way
as the <code>match</code> expressions we defined to handle the <code>Result</code> values in Listing
9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will
get returned from this expression, and the program will continue. If the value
is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had
used the <code>return</code> keyword so the error value gets propagated to the calling
code.</p>
<p><code>Result</code> 值后的 <code>?</code> 定义的工作方式几乎与示例9-6中处理 <code>Result</code> 的 <code>match</code> 表达式相同：若 <code>Result</code> 值为 <code>Ok</code>，则返回 <code>Ok</code> 内部值，程序继续；若为 <code>Err</code>，则从整个函数返回 <code>Err</code>（如同使用了 <code>return</code>），错误值传播给调用方。</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 does
and what the <code>?</code> operator does: error values that have the <code>?</code> operator called
on them go through the <code>from</code> function, defined in the <code>From</code> trait in the
standard library, which is used to convert values from one type into another.
When the <code>?</code> operator calls the <code>from</code> function, the error type received is
converted into the error type defined in the return type of the current
function. This is useful when a function returns one error type to represent
all the ways a function might fail, even if parts might fail for many different
reasons.</p>
<p>示例9-6的 <code>match</code> 与 <code>?</code> 操作符的区别在于：<code>?</code> 操作符调用的错误值会通过标准库中 <code>From</code> trait 定义的 <code>from</code> 函数进行类型转换。<code>?</code> 调用 <code>from</code> 函数时，接收的错误类型会被转换为当前函数返回类型所定义的错误类型。当函数需返回统一错误类型代表所有失败可能（即使各部分失败原因不同）时，此机制非常有用。</p>
<p>For example, we could change the <code>read_username_from_file</code> function in Listing
9-7 to return a custom error type named <code>OurError</code> that we define. If we also
define <code>impl From&lt;io::Error&gt; for OurError</code> to construct an instance of
<code>OurError</code> from an <code>io::Error</code>, then the <code>?</code> operator calls in the body of
<code>read_username_from_file</code> will call <code>from</code> and convert the error types without
needing to add any more code to the function.</p>
<p>例如，可将示例9-7中的 <code>read_username_from_file</code> 改为返回自定义错误类型 <code>OurError</code>。若同时为 <code>OurError</code> 实现 <code>impl From&lt;io::Error&gt; for OurError</code>（从 <code>io::Error</code> 构造 <code>OurError</code>），则 <code>read_username_from_file</code> 中的 <code>?</code> 会自动调用 <code>from</code> 转换错误类型，无需额外代码。</p>
<p>In the context of Listing 9-7, the <code>?</code> at the end of the <code>File::open</code> call will
return the value inside an <code>Ok</code> to the variable <code>username_file</code>. If an error
occurs, the <code>?</code> operator will return early out of the whole function and give
any <code>Err</code> value to the calling code. The same thing applies to the <code>?</code> at the
end of the <code>read_to_string</code> call.</p>
<p>在示例9-7上下文中，<code>File::open</code> 调用末尾的 <code>?</code> 将返回 <code>Ok</code> 内部值给变量 <code>username_file</code>；若出错，则提前返回错误值给调用方。<code>read_to_string</code> 调用末尾的 <code>?</code> 同理。</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the <code>?</code>, as shown in Listing 9-8.</p>
<p><code>?</code> 操作符消除了大量样板代码，使函数实现更简洁。我们还可通过链式方法调用来进一步缩短代码（见示例9-8）。</p>
<figure class="listing" id="listing-9-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-8">Listing 9-8</a>: Chaining method calls after the <code>?</code> operator 在 <code>?</code> 操作符后链式调用方法</figcaption>
</figure>
<p>We’ve moved the creation of the new <code>String</code> in <code>username</code> to the beginning of
the function; that part hasn’t changed. Instead of creating a variable
<code>username_file</code>, we’ve chained the call to <code>read_to_string</code> directly onto the
result of <code>File::open("hello.txt")?</code>. We still have a <code>?</code> at the end of the
<code>read_to_string</code> call, and we still return an <code>Ok</code> value containing <code>username</code>
when both <code>File::open</code> and <code>read_to_string</code> succeed rather than returning
errors. The functionality is again the same as in Listing 9-6 and Listing 9-7;
this is just a different, more ergonomic way to write it.</p>
<p>我们将创建新 <code>String</code> 的代码移到函数开头（此部分未变）。不再创建变量 <code>username_file</code>，而是直接在 <code>File::open("hello.txt")?</code> 的结果上链式调用 <code>read_to_string</code>。<code>read_to_string</code> 调用末尾仍有 <code>?</code>，且当两者均成功时返回包含用户名的 <code>Ok</code>。功能与示例9-6和9-7相同，但写法更符合人体工学。</p>
<p>Listing 9-9 shows a way to make this even shorter using <code>fs::read_to_string</code>.</p>
<p>示例9-9展示了使用 <code>fs::read_to_string</code> 的更简洁实现。</p>
<figure class="listing" id="listing-9-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-9">Listing 9-9</a>: Using <code>fs::read_to_string</code> instead of opening and then reading the file 使用 <code>fs::read_to_string</code> 替代先打开后读取</figcaption>
</figure>
<p>Reading a file into a string is a fairly common operation, so the standard
library provides the convenient <code>fs::read_to_string</code> function that opens the
file, creates a new <code>String</code>, reads the contents of the file, puts the contents
into that <code>String</code>, and returns it. Of course, using <code>fs::read_to_string</code>
doesn’t give us the opportunity to explain all the error handling, so we did it
the longer way first.</p>
<p>将文件读入字符串是常见操作，因此标准库提供了便捷的 <code>fs::read_to_string</code> 函数：打开文件、创建新 <code>String</code>、读取内容并返回。当然，使用 <code>fs::read_to_string</code> 无法展示错误处理，故我们先采用较长实现。</p>
<h4 id="where-the--operator-can-be-used--操作符的使用场景"><a class="header" href="#where-the--operator-can-be-used--操作符的使用场景">Where the <code>?</code> Operator Can Be Used <code>?</code> 操作符的使用场景</a></h4>
<p>The <code>?</code> operator can only be used in functions whose return type is compatible
with the value the <code>?</code> is used on. This is because the <code>?</code> operator is defined
to perform an early return of a value out of the function, in the same manner
as the <code>match</code> expression we defined in Listing 9-6. In Listing 9-6, the
<code>match</code> was using a <code>Result</code> value, and the early return arm returned an
<code>Err(e)</code> value. The return type of the function has to be a <code>Result</code> so that
it’s compatible with this <code>return</code>.</p>
<p><code>?</code> 操作符仅可用于返回类型与 <code>?</code> 所作用值兼容的函数。因为 <code>?</code> 定义为从函数中提前返回值，方式类似示例9-6的 <code>match</code>。在示例9-6中，<code>match</code> 处理 <code>Result</code> 值，提前返回分支返回 <code>Err(e)</code>。函数返回类型必须是 <code>Result</code> 才能兼容此 <code>return</code>。</p>
<p>In Listing 9-10, let’s look at the error we’ll get if we use the <code>?</code> operator
in a <code>main</code> function with a return type that is incompatible with the type of
the value we use <code>?</code> on.</p>
<p>在示例9-10中，若在返回类型不兼容的 <code>main</code> 函数中使用 <code>?</code>，将看到错误。</p>
<figure class="listing" id="listing-9-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-10">Listing 9-10</a>: Attempting to use the <code>?</code> in the <code>main</code> function that returns <code>()</code> won’t compile. 尝试在返回 <code>()</code> 的 <code>main</code> 函数中使用 <code>?</code> 将无法编译</figcaption>
</figure>
<p>This code opens a file, which might fail. The <code>?</code> operator follows the <code>Result</code>
value returned by <code>File::open</code>, but this <code>main</code> function has the return type of
<code>()</code>, not <code>Result</code>. When we compile this code, we get the following error
message:</p>
<p>此代码尝试打开可能失败的文件。<code>?</code> 作用于 <code>File::open</code> 返回的 <code>Result</code>，但 <code>main</code> 函数返回类型为 <code>()</code> 而非 <code>Result</code>。编译时报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>This error points out that we’re only allowed to use the <code>?</code> operator in a
function that returns <code>Result</code>, <code>Option</code>, or another type that implements
<code>FromResidual</code>.</p>
<p>此错误指出：<span class="highlight">[note]只能在返回 <code>Result</code>、<code>Option</code> 或实现了 <code>FromResidual</code> 类型的函数中使用 <code>?</code>。</span></p>
<p>To fix the error, you have two choices. One choice is to change the return type
of your function to be compatible with the value you’re using the <code>?</code> operator
on as long as you have no restrictions preventing that. The other choice is to
use a <code>match</code> or one of the <code>Result&lt;T, E&gt;</code> methods to handle the <code>Result&lt;T, E&gt;</code>
in whatever way is appropriate.</p>
<p>修复方法有两种：若无限制，可更改函数返回类型以兼容 <code>?</code> 所作用的值；使用 <code>match</code> 或 <code>Result&lt;T, E&gt;</code> 的方法以适当方式处理值。</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values
as well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a
function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called
on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>:
if the value is <code>None</code>, the <code>None</code> will be returned early from the function at
that point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the
resultant value of the expression, and the function continues. Listing 9-11 has
an example of a function that finds the last character of the first line in the
given text.</p>
<p>错误信息还提到 <code>?</code> 也可用于 <code>Option&lt;T&gt;</code> 值。与 <code>Result</code> 类似，只能在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>。<code>?</code> 作用于 <code>Option&lt;T&gt;</code> 的行为类似作用于 <code>Result&lt;T, E&gt;</code>：若值为 <code>None</code>，则提前从函数返回 <code>None</code>；若为 <code>Some</code>，则 <code>Some</code> 内部的值作为表达式结果，函数继续执行。示例9-11展示在给定文本中查找首行最后一个字符的函数：</p>
<figure class="listing" id="listing-9-11">
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\nHow are you today?"),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-11">Listing 9-11</a>: Using the <code>?</code> operator on an <code>Option&lt;T&gt;</code> value 在 <code>Option&lt;T&gt;</code> 值上使用 <code>?</code> 操作符</figcaption>
</figure>
<p>This function returns <code>Option&lt;char&gt;</code> because it’s possible that there is a
character there, but it’s also possible that there isn’t. This code takes the
<code>text</code> string slice argument and calls the <code>lines</code> method on it, which returns
an iterator over the lines in the string. Because this function wants to
examine the first line, it calls <code>next</code> on the iterator to get the first value
from the iterator. If <code>text</code> is the empty string, this call to <code>next</code> will
return <code>None</code>, in which case we use <code>?</code> to stop and return <code>None</code> from
<code>last_char_of_first_line</code>. If <code>text</code> is not the empty string, <code>next</code> will
return a <code>Some</code> value containing a string slice of the first line in <code>text</code>.</p>
<p>此函数返回 <code>Option&lt;char&gt;</code>，因为可能找到字符，也可能找不到。代码接收字符串切片参数 <code>text</code>，调用 <code>lines</code> 方法获取字符串行的迭代器。为检查首行，调用迭代器的 <code>next</code> 方法获取第一个值。若 <code>text</code> 为空，<code>next</code> 返回 <code>None</code>，此时用 <code>?</code> 停止并返回 <code>None</code>；若不为空，则返回包含首行字符串切片的 <code>Some</code>。</p>
<p>The <code>?</code> extracts the string slice, and we can call <code>chars</code> on that string slice
to get an iterator of its characters. We’re interested in the last character in
this first line, so we call <code>last</code> to return the last item in the iterator.
This is an <code>Option</code> because it’s possible that the first line is the empty
string; for example, if <code>text</code> starts with a blank line but has characters on
other lines, as in <code>"\nhi"</code>. However, if there is a last character on the first
line, it will be returned in the <code>Some</code> variant. The <code>?</code> operator in the middle
gives us a concise way to express this logic, allowing us to implement the
function in one line. If we couldn’t use the <code>?</code> operator on <code>Option</code>, we’d
have to implement this logic using more method calls or a <code>match</code> expression.</p>
<p><code>?</code> 解出字符串切片，调用 <code>chars</code> 获取字符迭代器。我们需要首行最后一个字符，故调用 <code>last</code> 返回迭代器末项。返回 <code>Option</code> 是因为首行可能为空（如 <code>"\nhi"</code>）。若首行存在末字符，则返回 <code>Some</code>。中间的 <code>?</code> 操作符简洁表达了此逻辑，单行即可实现函数。若不能对 <code>Option</code> 使用 <code>?</code>，则需更多方法调用或 <code>match</code> 实现。</p>
<p>Note that you can use the <code>?</code> operator on a <code>Result</code> in a function that returns
<code>Result</code>, and you can use the <code>?</code> operator on an <code>Option</code> in a function that
returns <code>Option</code>, but you can’t mix and match. The <code>?</code> operator won’t
automatically convert a <code>Result</code> to an <code>Option</code> or vice versa; in those cases,
you can use methods like the <code>ok</code> method on <code>Result</code> or the <code>ok_or</code> method on
<code>Option</code> to do the conversion explicitly.</p>
<p>注意：可在返回 <code>Result</code> 的函数中对 <code>Result</code> 使用 <code>?</code>，在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>，但不能混用。<code>?</code> 不会自动转换 <code>Result</code> 和 <code>Option</code>，此时可用 <code>Result</code> 的 <code>ok</code> 方法或 <code>Option</code> 的 <code>ok_or</code> 方法显式转换。</p>
<p>So far, all the <code>main</code> functions we’ve used return <code>()</code>. The <code>main</code> function is
special because it’s the entry point and exit point of an executable program,
and there are restrictions on what its return type can be for the program to
behave as expected.</p>
<p>目前所有 <code>main</code> 函数均返回 <code>()</code>。<code>main</code> 函数特殊，因它是可执行程序的入口和出口点，其返回类型受限以保证程序行为符合预期。</p>
<p>Luckily, <code>main</code> can also return a <code>Result&lt;(), E&gt;</code>. Listing 9-12 has the code
from Listing 9-10, but we’ve changed the return type of <code>main</code> to be
<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> and added a return value <code>Ok(())</code> to the end. This
code will now compile.</p>
<p>幸运的是，<span class="highlight">[note]<code>main</code> 也可返回 <code>Result&lt;(), E&gt;</code>。示例9-12修改了示例9-10中 <code>main</code> 的返回类型为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加返回值 <code>Ok(())</code>。</span>此代码可编译：</p>
<figure class="listing" id="listing-9-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
<figcaption><a href="ch09-02-recoverable-errors-with-result.html#listing-9-12">Listing 9-12</a>: Changing <code>main</code> to return <code>Result&lt;(), E&gt;</code> allows the use of the <code>?</code> operator on <code>Result</code> values. 修改 <code>main</code> 返回 <code>Result&lt;(), E&gt;</code> 允许对 <code>Result</code> 值使用 <code>?</code> 操作符</figcaption>
</figure>
<p>The <code>Box&lt;dyn Error&gt;</code> type is a <em>trait object</em>, which we’ll talk about in “Using
Trait Objects That Allow for Values of Different Types” in Chapter 18. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean “any
kind of error.” Using <code>?</code> on a <code>Result</code> value in a <code>main</code> function with the
error type <code>Box&lt;dyn Error&gt;</code> is allowed because it allows any <code>Err</code> value to be
returned early. Even though the body of this <code>main</code> function will only ever
return errors of type <code>std::io::Error</code>, by specifying <code>Box&lt;dyn Error&gt;</code>, this
signature will continue to be correct even if more code that returns other
errors is added to the body of <code>main</code>.</p>
<p><code>Box&lt;dyn Error&gt;</code> 是 trait对象（第18章讨论）。目前可将其理解为“任何类型的错误“。在错误类型为 <code>Box&lt;dyn Error&gt;</code> 的 <code>main</code> 函数中对 <code>Result</code> 使用 <code>?</code> 是允许的，因为任何 <code>Err</code> 值均可提前返回。即使此 <code>main</code> 函数仅返回 <code>std::io::Error</code> 类型错误，指定 <code>Box&lt;dyn Error&gt;</code> 后，即使函数体添加返回其他错误的代码，签名仍保持正确。</p>
<p>When a <code>main</code> function returns a <code>Result&lt;(), E&gt;</code>, the executable will exit with
a value of <code>0</code> if <code>main</code> returns <code>Ok(())</code> and will exit with a nonzero value if
<code>main</code> returns an <code>Err</code> value. Executables written in C return integers when
they exit: programs that exit successfully return the integer <code>0</code>, and programs
that error return some integer other than <code>0</code>. Rust also returns integers from
executables to be compatible with this convention.</p>
<p>当 <code>main</code> 返回 <code>Result&lt;(), E&gt;</code> 时，若返回 <code>Ok(())</code> 则程序以 <code>0</code> 退出；若返回 <code>Err</code> 则以非零值退出。C语言程序退出时返回整数：成功返回 <code>0</code>，错误返回非 <code>0</code> 整数。为兼容此约定，Rust可执行程序也返回整数。</p>
<p>The <code>main</code> function may return any types that implement the
<code>std::process::Termination</code> trait, which contains
a function <code>report</code> that returns an <code>ExitCode</code>. Consult the standard library
documentation for more information on implementing the <code>Termination</code> trait for
your own types.</p>
<p><span class="highlight">[note]<code>main</code> 函数可返回任何实现了 <code>std::process::Termination</code> trait 的类型，该 trait 包含返回 <code>ExitCode</code> 的 <code>report</code> 函数。</span>有关为自定义类型实现 <code>Termination</code> trait 的更多信息，请查阅标准库文档。</p>
<p>Now that we’ve discussed the details of calling <code>panic!</code> or returning <code>Result</code>,
let’s return to the topic of how to decide which is appropriate to use in which
cases.</p>
<p>至此，我们已讨论调用 <code>panic!</code> 或返回 <code>Result</code> 的细节。现在回到核心问题：如何决定在何种场景使用何种方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="to-panic-or-not-to-panic-该使用-panic-还是不该用-panic"><a class="header" href="#to-panic-or-not-to-panic-该使用-panic-还是不该用-panic">To <code>panic!</code> or Not to <code>panic!</code> 该使用 <code>panic!</code> 还是不该用 <code>panic!</code></a></h2>
<p>So how do you decide when you should call <code>panic!</code> and when you should return
<code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code>
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision that a situation is unrecoverable on behalf of
the calling code. When you choose to return a <code>Result</code> value, you give the
calling code options. The calling code could choose to attempt to recover in a
way that’s appropriate for its situation, or it could decide that an <code>Err</code>
value in this case is unrecoverable, so it can call <code>panic!</code> and turn your
recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a
good default choice when you’re defining a function that might fail.</p>
<p>那么该如何决定何时应该调用 <code>panic!</code> 以及何时应该返回 <code>Result</code> 呢？当代码 panic 时，是没有恢复途径的。你可以在任何错误场景下调用 <code>panic!</code>，无论是否存在可能的恢复方式，但这样做就意味着你代表调用代码做出了该场景不可恢复的决定。当你选择返回 <code>Result</code> 值时，则赋予了调用代码选择权。调用代码可以根据自身情况选择尝试恢复，或者判定此处的 <code>Err</code> 值不可恢复，从而调用 <code>panic!</code> 将你的可恢复错误转为不可恢复错误。因此，在定义可能失败的函数时，返回 <code>Result</code> 是良好的默认选择。</p>
<p>In situations such as examples, prototype code, and tests, it’s more
appropriate to write code that panics instead of returning a <code>Result</code>. Let’s
explore why, then discuss situations in which the compiler can’t tell that
failure is impossible, but you as a human can. The chapter will conclude with
some general guidelines on how to decide whether to panic in library code.</p>
<p>在示例、原型代码和测试等场景中，编写 panic 的代码比返回 <code>Result</code> 更合适。我们将探讨原因，然后讨论编译器无法判断失败不可能发生、但开发者可以确认的情况。本章最后会给出在库代码中决定是否 panic 的通用指导原则。</p>
<h3 id="examples-prototype-code-and-tests-示例原型代码和测试"><a class="header" href="#examples-prototype-code-and-tests-示例原型代码和测试">Examples, Prototype Code, and Tests 示例、原型代码和测试</a></h3>
<p>When you’re writing an example to illustrate some concept, also including
robust error-handling code can make the example less clear. In examples, it’s
understood that a call to a method like <code>unwrap</code> that could panic is meant as a
placeholder for the way you’d want your application to handle errors, which can
differ based on what the rest of your code is doing.</p>
<p>当你编写示例阐述某个概念时，包含健壮的错误处理代码反而会降低示例的清晰度。在示例中，像 <code>unwrap</code> 这类可能 panic 的方法调用，应被理解为应用程序错误处理方式的占位符——具体处理方式可能因代码其他部分而异。</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.</p>
<p>类似地，在原型设计阶段，当你尚未决定如何处理错误时，<code>unwrap</code> 和 <code>expect</code> 方法非常方便。它们会在代码中留下清晰的标记，便于后续改进程序的健壮性。</p>
<p>If a method call fails in a test, you’d want the whole test to fail, even if
that method isn’t the functionality under test. Because <code>panic!</code> is how a test
is marked as a failure, calling <code>unwrap</code> or <code>expect</code> is exactly what should
happen.</p>
<p>如果测试中的方法调用失败，即使该方法并非被测功能，你也希望整个测试失败。因为 <code>panic!</code> 正是标记测试失败的方式，此时调用 <code>unwrap</code> 或 <code>expect</code> 是完全合理的。</p>
<h3 id="cases-in-which-you-have-more-information-than-the-compiler-你比编译器掌握更多信息的情况"><a class="header" href="#cases-in-which-you-have-more-information-than-the-compiler-你比编译器掌握更多信息的情况">Cases in Which You Have More Information Than the Compiler 你比编译器掌握更多信息的情况</a></h3>
<p>It would also be appropriate to call <code>expect</code> when you have some other logic
that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t
something the compiler understands. You’ll still have a <code>Result</code> value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an <code>Err</code> variant, it’s perfectly acceptable to call <code>expect</code> and document
the reason you think you’ll never have an <code>Err</code> variant in the argument text.
Here’s an example:</p>
<p>当你通过其他逻辑确保 <code>Result</code> 必定是 <code>Ok</code> 值，但该逻辑超出编译器理解范围时，调用 <code>expect</code> 也是合适的。此时你仍需处理 <code>Result</code> 值：从普遍角度看，被调用的操作仍有失败可能，尽管在你的特定场景中逻辑上不可能发生。若通过人工检查代码能确保绝不会出现 <code>Err</code> 变体，那么调用 <code>expect</code> 并在参数文本中说明原因完全可接受。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see
that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>expect</code>
here. However, having a hardcoded, valid string doesn’t change the return type
of the <code>parse</code> method: we still get a <code>Result</code> value, and the compiler will
still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility
because the compiler isn’t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore <em>did</em> have a possibility of failure,
we’d definitely want to handle the <code>Result</code> in a more robust way instead.
Mentioning the assumption that this IP address is hardcoded will prompt us to
change <code>expect</code> to better error-handling code if, in the future, we need to get
the IP address from some other source instead.</p>
<p>这里通过解析硬编码字符串创建 <code>IpAddr</code> 实例。显然 <code>127.0.0.1</code> 是有效 IP 地址，因此使用 <code>expect</code> 合理。但硬编码的有效字符串不会改变 <code>parse</code> 方法的返回类型：我们依然得到 <code>Result</code> 值，编译器仍会要求我们处理该 <code>Result</code>（仿佛可能出现 <code>Err</code> 变体），因为编译器无法智能推断此字符串永远有效。如果 IP 地址字符串来自用户输入而非硬编码（即确实可能失败），我们必然需要用更健壮的方式处理 <code>Result</code>。此处注明 IP 地址是硬编码的假设，能促使我们在未来需要从其他来源获取 IP 时，将 <code>expect</code> 升级为更好的错误处理代码。</p>
<h3 id="guidelines-for-error-handling-错误处理指导原则"><a class="header" href="#guidelines-for-error-handling-错误处理指导原则">Guidelines for Error Handling 错误处理指导原则</a></h3>
<p>It’s advisable to have your code panic when it’s possible that your code could
end up in a bad state. In this context, a <em>bad state</em> is when some assumption,
guarantee, contract, or invariant has been broken, such as when invalid values,
contradictory values, or missing values are passed to your code—plus one or
more of the following:</p>
<p>当代码可能陷入坏状态（bad state）时，建议直接 panic。此处的<strong>坏状态</strong>指某些假设、保证、契约或不变量被破坏的情况，例如向代码传入无效值、矛盾值或缺失值，且满足以下至少一个条件：</p>
<ul>
<li>The bad state is something that is unexpected, as opposed to something that
will likely happen occasionally, like a user entering data in the wrong
format.</li>
<li>该坏状态是意外事件，而非偶尔会发生的情况（如用户输入格式错误）</li>
<li>Your code after this point needs to rely on not being in this bad state,
rather than checking for the problem at every step.</li>
<li>后续代码需要依赖不处于此坏状态的前提，而非每一步都检查问题</li>
<li>There’s not a good way to encode this information in the types you use. We’ll
work through an example of what we mean in “Encoding States and Behavior as
Types” in Chapter 18.</li>
<li>无法通过类型系统有效编码此信息（第 18 章“将状态和行为编码为类型“将举例说明）</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, it’s
best to return an error if you can so the user of the library can decide what
they want to do in that case. However, in cases where continuing could be
insecure or harmful, the best choice might be to call <code>panic!</code> and alert the
person using your library to the bug in their code so they can fix it during
development. Similarly, <code>panic!</code> is often appropriate if you’re calling
external code that is out of your control and it returns an invalid state that
you have no way of fixing.</p>
<p>若用户调用代码时传入无意义的值，最佳实践是返回错误（以便库使用者决定处理方式）。但当继续执行可能导致安全隐患时，调用 <code>panic!</code> 告警并提示使用者修复代码缺陷更为合适。同样，当调用不受控的外部代码返回无效状态且无法修复时，<code>panic!</code> 也常适用。</p>
<p>However, when failure is expected, it’s more appropriate to return a <code>Result</code>
than to make a <code>panic!</code> call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a <code>Result</code> indicates that failure is an
expected possibility that the calling code must decide how to handle.</p>
<p>但预期可能失败时（如解析器收到畸形数据、HTTP 请求返回速率限制状态），返回 <code>Result</code> 比调用 <code>panic!</code> 更合适。这表明失败是预期内的可能性，需由调用代码决定处理策略。</p>
<p>When your code performs an operation that could put a user at risk if it’s
called using invalid values, your code should verify the values are valid first
and panic if the values aren’t valid. This is mostly for safety reasons:
attempting to operate on invalid data can expose your code to vulnerabilities.
This is the main reason the standard library will call <code>panic!</code> if you attempt
an out-of-bounds memory access: trying to access memory that doesn’t belong to
the current data structure is a common security problem. Functions often have
<em>contracts</em>: their behavior is only guaranteed if the inputs meet particular
requirements. Panicking when the contract is violated makes sense because a
contract violation always indicates a caller-side bug, and it’s not a kind of
error you want the calling code to have to explicitly handle. In fact, there’s
no reasonable way for calling code to recover; the calling <em>programmers</em> need
to fix the code. Contracts for a function, especially when a violation will
cause a panic, should be explained in the API documentation for the function.</p>
<p>当代码执行可能因无效值危及用户安全的操作时，应优先验证值有效性并在无效时 panic。这主要出于安全考量：无效数据操作可能导致漏洞。标准库在内存越界访问时调用 <code>panic!</code> 正源于此——访问不属于当前数据结构的内存是常见安全问题。函数通常存在<strong>契约</strong>（contract）：仅当输入满足特定要求时行为才有保证。违反契约时 panic 是合理的，因为契约破坏总是调用方 bug，且不应由调用代码显式处理。事实上，调用代码无法合理恢复；需要<strong>程序员</strong>修复代码。函数的契约（尤其是违反会导致 panic 时）应在 API 文档中说明。</p>
<p>However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking done by the compiler) to do many of the checks for you. If your
function has a particular type as a parameter, you can proceed with your code’s
logic knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an <code>Option</code>, your program expects to
have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle
two cases for the <code>Some</code> and <code>None</code> variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type such as <code>u32</code>, which ensures
the parameter is never negative.</p>
<p>然而在所有函数中大量检查错误会冗长繁琐。幸运的是，可利用 Rust 类型系统（及编译器的类型检查）自动完成多数检查。若函数参数为特定类型，可确信编译器已确保值有效。例如，使用非 <code>Option</code> 类型时，程序预期必有值而非空值。代码无需处理 <code>Some</code> 和 <code>None</code> 两种变体，只需处理确定有值的情况。尝试传入空值的代码甚至无法编译，因此函数无需在运行时检查该情况。另一个例子是使用 <code>u32</code> 等无符号整数类型可确保参数永不小于零。</p>
<h3 id="creating-custom-types-for-validation-创建自定义类型进行验证"><a class="header" href="#creating-custom-types-for-validation-创建自定义类型进行验证">Creating Custom Types for Validation 创建自定义类型进行验证</a></h3>
<p>Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when the user guesses a number that’s out of range versus when the
user types, for example, letters instead.</p>
<p>让我们进一步利用 Rust 类型系统确保值有效性，探索如何创建验证用的自定义类型。回顾第 2 章的猜数游戏：代码要求用户猜测 1 到 100 之间的数字，但在与秘密数字比较前从未验证用户猜测值是否在此范围内，仅验证了其为正数。此时后果不严重：“过高/过低“的反馈仍正确。但引导用户有效猜测，并对越界输入与字母输入等行为区别处理，会是实用增强。</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a
<code>u32</code> to allow potentially negative numbers, and then add a check for the
number being in range, like so:</p>
<p>一种实现方式是将猜测值解析为 <code>i32</code>（而非仅 <code>u32</code>）以允许负数，然后检查范围：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</figure>
<p>The <code>if</code> expression checks whether our value is out of range, tells the user
about the problem, and calls <code>continue</code> to start the next iteration of the loop
and ask for another guess. After the <code>if</code> expression, we can proceed with the
comparisons between <code>guess</code> and the secret number knowing that <code>guess</code> is
between 1 and 100.</p>
<p><code>if</code> 表达式检查值是否越界，向用户反馈问题并调用 <code>continue</code> 重启循环等待新输入。此后进行猜测值与秘密数字比较时，可确信 <code>guess</code> 必在 1 到 100 之间。</p>
<p>However, this is not an ideal solution: if it were absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).</p>
<p>但这不是理想方案：若程序必须严格操作 1 到 100 的值，且多个函数有此要求，在每个函数重复此检查将冗长乏味（并可能影响性能）。</p>
<p>Instead, we can make a new type in a dedicated module and put the validations in
a function to create an instance of the type rather than repeating the
validations everywhere. That way, it’s safe for functions to use the new type in
their signatures and confidently use the values they receive. Listing 9-13 shows
one way to define a <code>Guess</code> type that will only create an instance of <code>Guess</code> if
the <code>new</code> function receives a value between 1 and 100.</p>
<p>替代方案是在专用模块中创建新类型，并将验证逻辑放在创建类型实例的函数中（而非到处重复）。这样函数可安全地在签名中使用新类型，并放心使用接收到的值。代码清单 9-13 展示了定义 <code>Guess</code> 类型的方式：仅当 <code>new</code> 函数收到 1 到 100 的值时才创建实例。</p>
<figure class="listing" id="listing-9-13">
<span class="file-name">Filename: src/guessing_game.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch09-03-to-panic-or-not-to-panic.html#listing-9-13">Listing 9-13</a>: A <code>Guess</code> type that will only continue with values between 1 and 100 仅允许值在 1 到 100 之间的 <code>Guess</code> 类型</figcaption>
</figure>
<p>Note that this code in <em>src/guessing_game.rs</em> depends on adding a module
declaration <code>mod guessing_game;</code> in <em>src/lib.rs</em> that we haven’t shown here.
Within this new module’s file, we define a struct in that module named <code>Guess</code>
that has a field named <code>value</code> that holds an <code>i32</code>. This is where the number
will be stored.</p>
<p>注意 <em>src/guessing_game.rs</em> 中的代码依赖于在 <em>src/lib.rs</em> 中添加未展示的模块声明 <code>mod guessing_game;</code>。在此新模块文件中，我们定义包含 <code>i32</code> 类型字段 <code>value</code> 的结构体 <code>Guess</code>（该字段存储数值）。</p>
<p>Then we implement an associated function named <code>new</code> on <code>Guess</code> that creates
instances of <code>Guess</code> values. The <code>new</code> function is defined to have one
parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the
body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100.
If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would
violate the contract that <code>Guess::new</code> is relying on. The conditions in which
<code>Guess::new</code> might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a <code>panic!</code> in the API documentation that you create in Chapter 14. If
<code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set
to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>随后为 <code>Guess</code> 实现关联函数 <code>new</code> 来创建实例。<code>new</code> 函数定义为：接收 <code>i32</code> 类型参数 <code>value</code>，返回 <code>Guess</code>。函数体中的代码会检验 <code>value</code> 是否在 1 到 100 之间。若未通过检验，则调用 <code>panic!</code> 提醒调用代码的开发者修复 bug——因为在此范围外创建 <code>Guess</code> 将违反 <code>Guess::new</code> 依赖的契约。<code>Guess::new</code> <span class="highlight">[note]可能 panic 的条件应在其公开 API 文档中说明</span>；第 14 章将介绍如何在 API 文档中标注 <code>panic!</code> 可能性。若通过检验，则用 <code>value</code> 参数创建新 <code>Guess</code> 并返回。</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any
other parameters, and returns an <code>i32</code>. This kind of method is sometimes called
a <em>getter</em> because its purpose is to get some data from its fields and return
it. This public method is necessary because the <code>value</code> field of the <code>Guess</code>
struct is private. It’s important that the <code>value</code> field be private so code
using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: code outside
the <code>guessing_game</code> module <em>must</em> use the <code>Guess::new</code> function to create an
instance of <code>Guess</code>, thereby ensuring there’s no way for a <code>Guess</code> to have a
<code>value</code> that hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>接着实现方法 <code>value</code>：借用 <code>self</code>，无其他参数，返回 <code>i32</code>。此类方法称为<strong>获取器</strong>（getter），因其用于从字段提取数据。由于 <code>Guess</code> 结构体的 <code>value</code> 字段是私有的，此公开方法很有必要。<code>value</code> 的私有性确保了外部代码无法直接设置该值：<code>guessing_game</code> 模块外的代码<strong>必须</strong>通过 <code>Guess::new</code> 创建实例，从而保证 <code>Guess</code> 的值必已通过 <code>Guess::new</code> 的条件检查。</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a <code>Guess</code> rather than an
<code>i32</code> and wouldn’t need to do any additional checks in its body.</p>
<p>接收或返回 1 到 100 数字的函数，可在签名中声明使用 <code>Guess</code> 类型（而非 <code>i32</code>），无需在函数体内额外检查。</p>
<h2 id="summary-总结-8"><a class="header" href="#summary-总结-8">Summary 总结</a></h2>
<p>Rust’s error-handling features are designed to help you write more robust code.
The <code>panic!</code> macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
<code>Result</code> to tell code that calls your code that it needs to handle potential
success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate
situations will make your code more reliable in the face of inevitable problems.</p>
<p>Rust 的错误处理功能旨在助你编写更健壮的代码。<code>panic!</code> 宏表示程序遇到无法处理的状态，让进程停止而非用无效值继续执行。<code>Result</code> 枚举则利用类型系统表明操作可能失败（但代码可恢复）。通过 <code>Result</code> 可告知调用代码需处理潜在的成功或失败。在适当场景使用 <code>panic!</code> 和 <code>Result</code> 能使代码在面临问题时更可靠。</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with
the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you
can use them in your code.</p>
<p>既然你已见识标准库如何高效利用泛型（通过 <code>Option</code> 和 <code>Result</code> 枚举），接下来我们将探讨泛型的工作原理及如何在代码中使用它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-traits-and-lifetimes-泛型特质与生命周期"><a class="header" href="#generic-types-traits-and-lifetimes-泛型特质与生命周期">Generic Types, Traits, and Lifetimes 泛型、特质与生命周期</a></h1>
<p>Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is <em>generics</em>: abstract stand-ins for
concrete types or other properties. We can express the behavior of generics or
how they relate to other generics without knowing what will be in their place
when compiling and running the code.</p>
<p>每种编程语言都有高效处理概念重复的工具。在 Rust 中，这类工具之一就是<em>泛型</em>（generics）：具体类型或其他属性的抽象占位符。我们可以在编译和运行代码时无需知晓实际类型的情况下，表达泛型的行为或它们与其他泛型的关系。</p>
<p>Functions can take parameters of some generic type, instead of a concrete type
like <code>i32</code> or <code>String</code>, in the same way they take parameters with unknown
values to run the same code on multiple concrete values. In fact, we’ve already
used generics in Chapter 6 with <code>Option&lt;T&gt;</code>, in Chapter 8 with <code>Vec&lt;T&gt;</code> and
<code>HashMap&lt;K, V&gt;</code>, and in Chapter 9 with <code>Result&lt;T, E&gt;</code>. In this chapter, you’ll
explore how to define your own types, functions, and methods with generics!</p>
<p>函数可以接收泛型类型的参数（而非像 <code>i32</code> 或 <code>String</code> 这样的具体类型），就像函数接收未知值的参数以便在多个具体值上运行相同代码那样。实际上，我们在第 6 章的 <code>Option&lt;T&gt;</code>、第 8 章的 <code>Vec&lt;T&gt;</code> 和 <code>HashMap&lt;K, V&gt;</code>，以及第 9 章的 <code>Result&lt;T, E&gt;</code> 中已经使用过泛型。本章将探索如何用泛型定义你自己的类型、函数和方法！</p>
<p>First we’ll review how to extract a function to reduce code duplication. We’ll
then use the same technique to make a generic function from two functions that
differ only in the types of their parameters. We’ll also explain how to use
generic types in struct and enum definitions.</p>
<p>首先我们将回顾如何提取函数以减少代码重复。接着用相同技术，从两个仅在参数类型上不同的函数中创建泛型函数。还会解释如何在结构体和枚举定义中使用泛型类型。</p>
<p>Then you’ll learn how to use <em>traits</em> to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to accept
only those types that have a particular behavior, as opposed to just any type.</p>
<p>然后你将学习使用<em>特质</em>（traits）以泛型方式定义行为。可以将特质与泛型类型结合，约束泛型类型只接受具有特定行为的类型，而非任意类型。</p>
<p>Finally, we’ll discuss <em>lifetimes</em>: a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to give the compiler enough information about borrowed values so that it can
ensure references will be valid in more situations than it could without our
help.</p>
<p>最后，我们将讨论<em>生命周期</em>（lifetimes）：一种向编译器提供引用间关系信息的泛型。生命周期允许我们为借用值提供足够信息，使编译器能在更多场景中确保引用有效性。</p>
<h2 id="removing-duplication-by-extracting-a-function-通过提取函数消除重复"><a class="header" href="#removing-duplication-by-extracting-a-function-通过提取函数消除重复">Removing Duplication by Extracting a Function 通过提取函数消除重复</a></h2>
<p>Generics allow us to replace specific types with a placeholder that represents
multiple types to remove code duplication. Before diving into generics syntax,
let’s first look at how to remove duplication in a way that doesn’t involve
generic types by extracting a function that replaces specific values with a
placeholder that represents multiple values. Then we’ll apply the same
technique to extract a generic function! By looking at how to recognize
duplicated code you can extract into a function, you’ll start to recognize
duplicated code that can use generics.</p>
<p>泛型允许我们用代表多种类型的占位符替换特定类型，从而消除代码重复。在深入泛型语法之前，先看如何通过提取函数（将特定值替换为代表多个值的占位符）来消除重复。然后将应用相同技术提取泛型函数！通过识别可提取到函数中的重复代码，你会开始识别可使用泛型的重复代码。</p>
<p>We’ll begin with the short program in Listing 10-1 that finds the largest
number in a list.</p>
<p>我们从示例 10-1 的简短程序开始，它查找列表中的最大数。</p>
<figure class="listing" id="listing-10-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
<figcaption><a href="ch10-00-generics.html#listing-10-1">Listing 10-1</a>: Finding the largest number in a list of numbers 在数字列表中查找最大数</figcaption>
</figure>
<p>We store a list of integers in the variable <code>number_list</code> and place a reference
to the first number in the list in a variable named <code>largest</code>. We then iterate
through all the numbers in the list, and if the current number is greater than
the number stored in <code>largest</code>, we replace the reference in that variable.
However, if the current number is less than or equal to the largest number seen
so far, the variable doesn’t change, and the code moves on to the next number
in the list. After considering all the numbers in the list, <code>largest</code> should
refer to the largest number, which in this case is 100.</p>
<p>我们将整数列表存入变量 <code>number_list</code>，并将列表中第一个数字的引用存入变量 <code>largest</code>。然后遍历列表中所有数字，若当前数字大于 <code>largest</code> 中的值，则替换该变量的引用。若当前数字小于或等于已见最大值，变量保持不变，代码继续处理下一个数字。处理完所有数字后，<code>largest</code> 应指向最大数（此处为 100）。</p>
<p>We’ve now been tasked with finding the largest number in two different lists of
numbers. To do so, we can choose to duplicate the code in Listing 10-1 and use
the same logic at two different places in the program, as shown in Listing 10-2.</p>
<p>现在我们需要在两个不同数字列表中查找最大值。为此可选择复制示例 10-1 的代码，在程序中两处不同位置使用相同逻辑，如示例 10-2 所示。</p>
<figure class="listing" id="listing-10-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}</code></pre></pre>
<figcaption><a href="ch10-00-generics.html#listing-10-2">Listing 10-2</a>: Code to find the largest number in <em>two</em> lists of numbers 在两个数字列表中查找最大数的代码</figcaption>
</figure>
<p>Although this code works, duplicating code is tedious and error prone. We also
have to remember to update the code in multiple places when we want to change
it.</p>
<p>虽然代码可用，但复制代码冗长且易错。修改时还需记住更新多处代码。</p>
<p>To eliminate this duplication, we’ll create an abstraction by defining a
function that operates on any list of integers passed in as a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.</p>
<p>为消除重复，我们通过定义函数来创建抽象，该函数操作传入的任意整数列表参数。此方案使代码更清晰，并抽象表达了“在列表中查找最大值“的概念。</p>
<p>In Listing 10-3, we extract the code that finds the largest number into a
function named <code>largest</code>. Then we call the function to find the largest number
in the two lists from Listing 10-2. We could also use the function on any other
list of <code>i32</code> values we might have in the future.</p>
<p>在示例 10-3 中，将查找最大值的代码提取到名为 <code>largest</code> 的函数中。然后用该函数处理示例 10-2 的两个列表。未来也可将此函数用于任何其他 <code>i32</code> 值列表。</p>
<figure class="listing" id="listing-10-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
<figcaption><a href="ch10-00-generics.html#listing-10-3">Listing 10-3</a>: Abstracted code to find the largest number in two lists 查找两个列表中最大值的抽象代码</figcaption>
</figure>
<p>The <code>largest</code> function has a parameter called <code>list</code>, which represents any
concrete slice of <code>i32</code> values we might pass into the function. As a result,
when we call the function, the code runs on the specific values that we pass
in.</p>
<p><code>largest</code> 函数有个 <code>list</code> 参数，代表可能传入的任意具体 <code>i32</code> 切片。因此调用函数时，代码会针对传入的具体值运行。</p>
<p>In summary, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:</p>
<p>总结从示例 10-2 改为 10-3 的步骤：</p>
<ul>
<li>Identify duplicate code.</li>
<li>识别重复代码</li>
<li>Extract the duplicate code into the body of the function, and specify the
inputs and return values of that code in the function signature.</li>
<li>将重复代码提取到函数体，并在函数签名中指定输入输出</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
<li>更新重复代码处改为调用函数</li>
</ul>
<p>Next, we’ll use these same steps with generics to reduce code duplication. In
the same way that the function body can operate on an abstract <code>list</code> instead
of specific values, generics allow code to operate on abstract types.</p>
<p>接下来我们将用泛型通过相同步骤减少代码重复。如同函数体能操作抽象 <code>list</code> 而非具体值，泛型允许代码操作抽象类型。</p>
<p>For example, say we had two functions: one that finds the largest item in a
slice of <code>i32</code> values and one that finds the largest item in a slice of <code>char</code>
values. How would we eliminate that duplication? Let’s find out!</p>
<p>例如有两个函数：一个在 <code>i32</code> 切片中查找最大值，另一个在 <code>char</code> 切片中查找最大值。如何消除重复？让我们一探究竟！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generic-data-types-泛型数据类型"><a class="header" href="#generic-data-types-泛型数据类型">Generic Data Types 泛型数据类型</a></h2>
<p>We use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.</p>
<p>我们使用泛型为函数签名或结构体等项创建定义，随后可搭配多种具体数据类型使用。先看如何用泛型定义函数、结构体、枚举和方法，再讨论泛型对代码性能的影响。</p>
<h3 id="in-function-definitions-函数定义中的泛型"><a class="header" href="#in-function-definitions-函数定义中的泛型">In Function Definitions 函数定义中的泛型</a></h3>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.</p>
<p>定义使用泛型的函数时，将泛型放在函数签名中通常指定参数和返回值类型的位置。这样使代码更灵活，为调用者提供更多功能，同时避免代码重复。</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice. We’ll then combine these into a single
function that uses generics.</p>
<p>延续 <code>largest</code> 函数，示例 10-4 展示两个在切片中查找最大值的函数。随后将它们合并为使用泛型的单一函数。</p>
<figure class="listing" id="listing-10-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("The largest char is {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-4">Listing 10-4</a>: Two functions that differ only in their names and in the types in their signatures 仅名称和签名类型不同的两个函数</figcaption>
</figure>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.</p>
<p><code>largest_i32</code> 是示例 10-3 提取的函数，用于查找切片中的最大 <code>i32</code>。<code>largest_char</code> 函数查找切片中的最大 <code>char</code>。由于函数体相同，我们引入泛型类型参数来消除重复。</p>
<p>To parameterize the types in a new single function, we need to name the type
parameter, just as we do for the value parameters to a function. You can use
any identifier as a type parameter name. But we’ll use <code>T</code> because, by
convention, type parameter names in Rust are short, often just one letter, and
Rust’s type-naming convention is CamelCase. Short for <em>type</em>, <code>T</code> is the default
choice of most Rust programmers.</p>
<p>要在新函数中参数化类型，需命名类型参数（如同函数值参数的命名）。可用任意标识符作为类型参数名，但按 Rust 惯例（驼峰命名法），我们使用 <code>T</code>（“type“的缩写）。<code>T</code> 是多数 Rust 程序员的首选。</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, we place type name declarations inside angle brackets,
<code>&lt;&gt;</code>, between the name of the function and the parameter list, like this:</p>
<p>在函数体中使用参数时，需在签名中声明参数名以便编译器理解含义。类似地，在函数签名中使用类型参数名前需先声明。定义泛型 <code>largest</code> 函数时，将类型声明放在函数名与参数列表间的尖括号 <code>&lt;&gt;</code> 中：</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>We read this definition as: the function <code>largest</code> is generic over some type
<code>T</code>. This function has one parameter named <code>list</code>, which is a slice of values
of type <code>T</code>. The <code>largest</code> function will return a reference to a value of the
same type <code>T</code>.</p>
<p>此定义读作：函数 <code>largest</code> 针对类型 <code>T</code> 是泛型的。它有一个 <code>list</code> 参数（类型为 <code>T</code> 的切片），返回同类型 <code>T</code> 值的引用。</p>
<p>Listing 10-5 shows the combined <code>largest</code> function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of <code>i32</code> values or <code>char</code> values. Note that this code won’t
compile yet.</p>
<p>示例 10-5 展示了在签名中使用泛型数据类型的合并 <code>largest</code> 函数定义，以及用 <code>i32</code> 切片或 <code>char</code> 切片调用函数的方式。注意：此代码暂不能编译。</p>
<figure class="listing" id="listing-10-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {result}");
}</code></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-5">Listing 10-5</a>: The <code>largest</code> function using generic type parameters; this doesn’t compile 使用泛型类型参数的 <code>largest</code> 函数（暂不能编译）</figcaption>
</figure>
<p>If we compile this code right now, we’ll get this error:</p>
<p>若现在编译，将出现错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The help text mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>, and we’re
going to talk about traits in the next section. For now, know that this error
states that the body of <code>largest</code> won’t work for all possible types that <code>T</code>
could be. Because we want to compare values of type <code>T</code> in the body, we can
only use types whose values can be ordered. To enable comparisons, the standard
library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types
(see Appendix C for more on this trait). To fix Listing 10-5, we can follow the
help text’s suggestion and restrict the types valid for <code>T</code> to only those that
implement <code>PartialOrd</code>. The listing will then compile, because the standard
library implements <code>PartialOrd</code> on both <code>i32</code> and <code>char</code>.</p>
<p>帮助文本提到 <code>std::cmp::PartialOrd</code>（一种<em>特质</em>），下节将讨论特质。目前只需知道：该错误表明 <code>largest</code> 函数体不能适用于 <code>T</code> 的所有可能类型。因为需在函数体中比较 <code>T</code> 类型值，我们只能使用可排序的类型。为实现比较，标准库提供了可针对类型实现的 <code>std::cmp::PartialOrd</code> 特质（附录 C 有详细信息）。修复示例 10-5 的方法是遵循帮助文本建议，限制 <code>T</code> 为实现了 <code>PartialOrd</code> 的类型（标准库已为 <code>i32</code> 和 <code>char</code> 实现该特质）。</p>
<h3 id="in-struct-definitions-结构体定义中的泛型"><a class="header" href="#in-struct-definitions-结构体定义中的泛型">In Struct Definitions 结构体定义中的泛型</a></h3>
<p>We can also define structs to use a generic type parameter in one or more
fields using the <code>&lt;&gt;</code> syntax. Listing 10-6 defines a <code>Point&lt;T&gt;</code> struct to hold
<code>x</code> and <code>y</code> coordinate values of any type.</p>
<p>我们也可用 <code>&lt;&gt;</code> 语法定义结构体，使其一个或多个字段使用泛型类型参数。示例 10-6 定义了 <code>Point&lt;T&gt;</code> 结构体来保存任意类型的 <code>x</code> 和 <code>y</code> 坐标值。</p>
<figure class="listing" id="listing-10-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-6">Listing 10-6</a>: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code> values of type <code>T</code> 保存 <code>T</code> 类型 <code>x</code> 和 <code>y</code> 值的 <code>Point&lt;T&gt;</code> 结构体</figcaption>
</figure>
<p>The syntax for using generics in struct definitions is similar to that used in
function definitions. First we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we use the generic
type in the struct definition where we would otherwise specify concrete data
types.</p>
<p>结构体定义中使用泛型的语法类似于函数定义。首先在结构体名后的尖括号内声明类型参数名，然后在结构体定义中使用该泛型类型（替代具体类型）。</p>
<p>Note that because we’ve used only one generic type to define <code>Point&lt;T&gt;</code>, this
definition says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code>, and
the fields <code>x</code> and <code>y</code> are <em>both</em> that same type, whatever that type may be. If
we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in
Listing 10-7, our code won’t compile.</p>
<p>注意：因 <code>Point&lt;T&gt;</code> 只使用一个泛型类型定义，该定义表示 <code>Point&lt;T&gt;</code> 结构体针对类型 <code>T</code> 是泛型的，且字段 <code>x</code> 和 <code>y</code> 均为同一类型（无论具体类型是什么）。若创建包含不同类型值的 <code>Point&lt;T&gt;</code> 实例（如示例 10-7），代码将无法编译。</p>
<figure class="listing" id="listing-10-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-7">Listing 10-7</a>: The fields <code>x</code> and <code>y</code> must be the same type because both have the same generic data type <code>T</code>. <code>x</code> 和 <code>y</code> 必须是相同类型，因两者共享泛型数据类型 <code>T</code></figcaption>
</figure>
<p>In this example, when we assign the integer value <code>5</code> to <code>x</code>, we let the
compiler know that the generic type <code>T</code> will be an integer for this instance of
<code>Point&lt;T&gt;</code>. Then when we specify <code>4.0</code> for <code>y</code>, which we’ve defined to have the
same type as <code>x</code>, we’ll get a type mismatch error like this:</p>
<p>此例中，将整数值 <code>5</code> 赋给 <code>x</code> 时，编译器已知该 <code>Point&lt;T&gt;</code> 实例的泛型 <code>T</code> 为整数类型。接着为 <code>y</code> 指定 <code>4.0</code>（定义中要求与 <code>x</code> 同类型）时，会出现类型不匹配错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we change the definition of <code>Point</code> to be generic over types <code>T</code>
and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code>.</p>
<p>要定义 <code>x</code> 和 <code>y</code> 均为泛型但类型可不同的 <code>Point</code> 结构体，可使用多个泛型类型参数。例如示例 10-8 中，将 <code>Point</code> 定义为针对类型 <code>T</code> 和 <code>U</code> 的泛型，其中 <code>x</code> 为 <code>T</code> 类型，<code>y</code> 为 <code>U</code> 类型。</p>
<figure class="listing" id="listing-10-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-8">Listing 10-8</a>: A <code>Point&lt;T, U&gt;</code> generic over two types so that <code>x</code> and <code>y</code> can be values of different types 针对两种类型的 <code>Point&lt;T, U&gt;</code> 泛型，使 <code>x</code> 和 <code>y</code> 可为不同类型的值</figcaption>
</figure>
<p>Now all the instances of <code>Point</code> shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. If you’re finding you need lots of generic types in
your code, it could indicate that your code needs restructuring into smaller
pieces.</p>
<p>现在所有 <code>Point</code> 实例均有效！定义中可使用任意数量的泛型类型参数，但过多会使代码难以阅读。若需大量泛型类型，可能意味着需要重构代码为更小的模块。</p>
<h3 id="in-enum-definitions-枚举定义中的泛型"><a class="header" href="#in-enum-definitions-枚举定义中的泛型">In Enum Definitions 枚举定义中的泛型</a></h3>
<p>As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the <code>Option&lt;T&gt;</code> enum that the standard
library provides, which we used in Chapter 6:</p>
<p>如同结构体，我们可定义枚举使其变体持有泛型数据类型。再看标准库的 <code>Option&lt;T&gt;</code> 枚举（第 6 章用过）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>This definition should now make more sense to you. As you can see, the
<code>Option&lt;T&gt;</code> enum is generic over type <code>T</code> and has two variants: <code>Some</code>, which
holds one value of type <code>T</code>, and a <code>None</code> variant that doesn’t hold any value.
By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of an
optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction
no matter what the type of the optional value is.</p>
<p>现在你应更理解此定义了。如你所见，<code>Option&lt;T&gt;</code> 枚举针对类型 <code>T</code> 是泛型的，有两个变体：<code>Some</code>（持有类型 <code>T</code> 的值）和 <code>None</code>（不持有值）。通过 <code>Option&lt;T&gt;</code> 枚举，我们能表达可选值的抽象概念。由于 <code>Option&lt;T&gt;</code> 是泛型的，无论可选值是什么类型都可使用此抽象。</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<p>枚举也可使用多个泛型类型。第 9 章用过的 <code>Result</code> 枚举定义即为一例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>, and has two variants:
<code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (return a value of some type <code>T</code>) or fail
(return an error of some type <code>E</code>). In fact, this is what we used to open a
file in Listing 9-3, where <code>T</code> was filled in with the type <code>std::fs::File</code> when
the file was opened successfully and <code>E</code> was filled in with the type
<code>std::io::Error</code> when there were problems opening the file.</p>
<p><code>Result</code> 枚举针对 <code>T</code> 和 <code>E</code> 两种类型是泛型的，有两个变体：<code>Ok</code>（持有类型 <code>T</code> 的值）和 <code>Err</code>（持有类型 <code>E</code> 的值）。此定义便于在任何可能成功（返回类型 <code>T</code> 的值）或失败（返回类型 <code>E</code> 的错误）的操作中使用 <code>Result</code> 枚举。实际上，这正是示例 9-3 中打开文件的方式：成功打开时 <code>T</code> 为 <code>std::fs::File</code> 类型，出问题时 <code>E</code> 为 <code>std::io::Error</code> 类型。</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.</p>
<p>当发现代码中有多个结构体或枚举定义仅因所持值类型不同而存在时，可用泛型类型避免重复。</p>
<h3 id="in-method-definitions-方法定义中的泛型"><a class="header" href="#in-method-definitions-方法定义中的泛型">In Method Definitions 方法定义中的泛型</a></h3>
<p>We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions too. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it.</p>
<p>我们可在结构体和枚举上实现方法（如第 5 章），并在定义中使用泛型类型。示例 10-9 展示了在示例 10-6 定义的 <code>Point&lt;T&gt;</code> 结构体上实现名为 <code>x</code> 的方法。</p>
<figure class="listing" id="listing-10-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-9">Listing 10-9</a>: Implementing a method named <code>x</code> on the <code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type <code>T</code> 在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，返回类型 <code>T</code> 的 <code>x</code> 字段引用</figcaption>
</figure>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference
to the data in the field <code>x</code>.</p>
<p>此处我们在 <code>Point&lt;T&gt;</code> 上定义了返回字段 <code>x</code> 数据引用的方法 <code>x</code>。</p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use <code>T</code> to specify
that we’re implementing methods on the type <code>Point&lt;T&gt;</code>. By declaring <code>T</code> as a
generic type after <code>impl</code>, Rust can identify that the type in the angle
brackets in <code>Point</code> is a generic type rather than a concrete type. We could
have chosen a different name for this generic parameter than the generic
parameter declared in the struct definition, but using the same name is
conventional. If you write a method within an <code>impl</code> that declares a generic
type, that method will be defined on any instance of the type, no matter what
concrete type ends up substituting for the generic type.</p>
<p><span class="highlight">[note]注意必须在 <code>impl</code> 后声明 <code>T</code></span>，这样才能用 <code>T</code> 指定我们在 <code>Point&lt;T&gt;</code> 类型上实现方法。通过在 <code>impl</code> 后声明 <code>T</code>，Rust 能识别 <code>Point</code> 尖括号中的类型是泛型而非具体类型。本可为该泛型参数选择与结构体定义中不同的名称，但使用相同名称是惯例。若在 <code>impl</code> 块内声明泛型类型的方法，则无论最终替换泛型的具体类型是什么，该方法都将在该类型的所有实例上定义。</p>
<p>We can also specify constraints on generic types when defining methods on the
type. We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances
rather than on <code>Point&lt;T&gt;</code> instances with any generic type. In Listing 10-10 we
use the concrete type <code>f32</code>, meaning we don’t declare any types after <code>impl</code>.</p>
<p>定义类型方法时也可指定泛型类型的约束。例如可仅为 <code>Point&lt;f32&gt;</code> 实例实现方法，而非任意泛型类型的 <code>Point&lt;T&gt;</code> 实例。示例 10-10 使用了具体类型 <code>f32</code>（<code>impl</code> 后未声明任何类型）。</p>
<figure class="listing" id="listing-10-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-10">Listing 10-10</a>: An <code>impl</code> block that only applies to a struct with a particular concrete type for the generic type parameter <code>T</code> 仅适用于特定具体类型（泛型类型参数 <code>T</code>）结构体的 <code>impl</code> 块</figcaption>
</figure>
<p>This code means the type <code>Point&lt;f32&gt;</code> will have a <code>distance_from_origin</code>
method; other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of type <code>f32</code> will not
have this method defined. The method measures how far our point is from the
point at coordinates (0.0, 0.0) and uses mathematical operations that are
available only for floating-point types.</p>
<p>此代码意味着 <code>Point&lt;f32&gt;</code> 类型将有 <code>distance_from_origin</code> 方法；而 <code>T</code> 非 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则无此方法。该方法计算点距离坐标 (0.0, 0.0) 的远近，使用了仅浮点类型可用的数学运算。</p>
<p>Generic type parameters in a struct definition aren’t always the same as those
you use in that same struct’s method signatures. Listing 10-11 uses the generic
types <code>X1</code> and <code>Y1</code> for the <code>Point</code> struct and <code>X2</code> <code>Y2</code> for the <code>mixup</code> method
signature to make the example clearer. The method creates a new <code>Point</code>
instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>X1</code>) and the <code>y</code>
value from the passed-in <code>Point</code> (of type <code>Y2</code>).</p>
<p>结构体定义中的泛型类型参数不一定与方法签名中的相同。示例 10-11 中为清晰起见，结构体 <code>Point</code> 使用泛型类型 <code>X1</code> 和 <code>Y1</code>，方法 <code>mixup</code> 的签名使用 <code>X2</code> 和 <code>Y2</code>。该方法用 <code>self</code> 的 <code>Point</code>（类型 <code>X1</code>）的 <code>x</code> 值与传入 <code>Point</code>（类型 <code>Y2</code>）的 <code>y</code> 值创建新 <code>Point</code> 实例。</p>
<figure class="listing" id="listing-10-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
<figcaption><a href="ch10-01-syntax.html#listing-10-11">Listing 10-11</a>: A method that uses generic types different from its struct’s definition 使用与结构体定义不同的泛型类型的方法</figcaption>
</figure>
<p>In <code>main</code>, we’ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code>)
and an <code>f64</code> for <code>y</code> (with value <code>10.4</code>). The <code>p2</code> variable is a <code>Point</code> struct
that has a string slice for <code>x</code> (with value <code>"Hello"</code>) and a <code>char</code> for <code>y</code>
(with value <code>c</code>). Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>,
which will have an <code>i32</code> for <code>x</code> because <code>x</code> came from <code>p1</code>. The <code>p3</code> variable
will have a <code>char</code> for <code>y</code> because <code>y</code> came from <code>p2</code>. The <code>println!</code> macro
call will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>在 <code>main</code> 中，我们定义了 <code>x</code> 为 <code>i32</code>（值 <code>5</code>）、<code>y</code> 为 <code>f64</code>（值 <code>10.4</code>）的 <code>Point</code>。变量 <code>p2</code> 是 <code>x</code> 为字符串切片（值 <code>"Hello"</code>）、<code>y</code> 为 <code>char</code>（值 <code>c</code>）的 <code>Point</code> 结构体。以 <code>p2</code> 为参数对 <code>p1</code> 调用 <code>mixup</code> 得到 <code>p3</code>，其 <code>x</code> 来自 <code>p1</code> 故为 <code>i32</code> 类型。变量 <code>p3</code> 的 <code>y</code> 来自 <code>p2</code> 故为 <code>char</code> 类型。<code>println!</code> 宏调用将打印 <code>p3.x = 5, p3.y = c</code>。</p>
<p>The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with <code>impl</code> and some are declared with the method
definition. Here, the generic parameters <code>X1</code> and <code>Y1</code> are declared after
<code>impl</code> because they go with the struct definition. The generic parameters <code>X2</code>
and <code>Y2</code> are declared after <code>fn mixup</code> because they’re only relevant to the
method.</p>
<p>此示例旨在展示：部分泛型参数在 <code>impl</code> 中声明，部分在方法定义中声明。此处泛型参数 <code>X1</code> 和 <code>Y1</code> 在 <code>impl</code> 后声明（因它们与结构体定义相关），而 <code>X2</code> 和 <code>Y2</code> 在 <code>fn mixup</code> 后声明（因它们仅与方法相关）。</p>
<h3 id="performance-of-code-using-generics-使用泛型代码的性能"><a class="header" href="#performance-of-code-using-generics-使用泛型代码的性能">Performance of Code Using Generics 使用泛型代码的性能</a></h3>
<p>You might be wondering whether there is a runtime cost when using generic type
parameters. The good news is that using generic types won’t make your program
run any slower than it would with concrete types.</p>
<p>你可能好奇使用泛型类型参数是否会带来运行时开销。好消息是：使用泛型不会比使用具体类型使程序运行得更慢。</p>
<p>Rust accomplishes this by performing monomorphization of the code using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled. In this process, the compiler does the opposite of the steps we used
to create the generic function in Listing 10-5: the compiler looks at all the
places where generic code is called and generates code for the concrete types
the generic code is called with.</p>
<p>Rust 通过在编译时对使用泛型的代码执行<em>单态化</em>（monomorphization）实现这一点。单态化是将泛型代码转换为特定代码的过程，通过填充编译时使用的具体类型实现。在此过程中，编译器执行与示例 10-5 创建泛型函数相反的步骤：查看所有调用泛型代码的位置，并为调用时使用的具体类型生成代码。</p>
<p>Let’s look at how this works by using the standard library’s generic
<code>Option&lt;T&gt;</code> enum:</p>
<p>通过标准库的泛型 <code>Option&lt;T&gt;</code> 枚举来看其工作原理：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code>
instances and identifies two kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code> and the other
is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into two
definitions specialized to <code>i32</code> and <code>f64</code>, thereby replacing the generic
definition with the specific ones.</p>
<p>Rust 编译此代码时会执行单态化。编译器读取 <code>Option&lt;T&gt;</code> 实例中使用的值，识别出两种 <code>Option&lt;T&gt;</code>：一种是 <code>i32</code>，另一种是 <code>f64</code>。因此它将 <code>Option&lt;T&gt;</code> 的泛型定义扩展为针对 <code>i32</code> 和 <code>f64</code> 特化的两个定义，从而用具体定义替换泛型定义。</p>
<p>The monomorphized version of the code looks similar to the following (the
compiler uses different names than what we’re using here for illustration):</p>
<p>单态化后的代码类似于以下形式（编译器实际使用不同名称，此处为说明）：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</figure>
<p>The generic <code>Option&lt;T&gt;</code> is replaced with the specific definitions created by
the compiler. Because Rust compiles generic code into code that specifies the
type in each instance, we pay no runtime cost for using generics. When the code
runs, it performs just as it would if we had duplicated each definition by
hand. The process of monomorphization makes Rust’s generics extremely efficient
at runtime.</p>
<p>泛型 <code>Option&lt;T&gt;</code> 被编译器创建的具体定义替代。由于 Rust 将泛型代码编译为针对每个实例指定类型的代码，使用泛型不会产生运行时开销。代码运行时，其性能如同手动复制每个定义一般。单态化过程使 Rust 的泛型在运行时极其高效。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traits-defining-shared-behavior-特质定义共享行为"><a class="header" href="#traits-defining-shared-behavior-特质定义共享行为">Traits: Defining Shared Behavior 特质：定义共享行为</a></h2>
<p>A <em>trait</em> defines the functionality a particular type has and can share with
other types. We can use traits to define shared behavior in an abstract way. We
can use <em>trait bounds</em> to specify that a generic type can be any type that has
certain behavior.</p>
<p><strong>特质</strong>定义了特定类型拥有的功能，并能与其他类型共享。我们可以使用特质以抽象方式定义共享行为，并通过<strong>特质限定</strong>来指定泛型类型必须是具有特定行为的任意类型。</p>
<section class="note" aria-role="note">
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other
languages, although with some differences.</p>
<p>注意：特质类似于其他语言中常称为<strong>接口</strong>的特性，但存在一些差异。</p>
</section>
<h3 id="defining-a-trait-定义特质"><a class="header" href="#defining-a-trait-定义特质">Defining a Trait 定义特质</a></h3>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.</p>
<p>类型的行为由可在该类型上调用的方法组成。若能在不同类型上调用相同的方法，则这些类型共享相同的行为。特质定义通过将方法签名分组，定义实现特定目的所需的一组行为。</p>
<p>For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a
particular location and a <code>SocialPost</code> that can have, at most, 280 characters
along with metadata that indicates whether it was a new post, a repost, or a
reply to another post.</p>
<p>例如，假设有多个结构体用于存储不同种类和数量的文本：<code>NewsArticle</code> 结构体存储特定地区提交的新闻报道，<code>SocialPost</code> 最多可存储 280 个字符以及元数据（标明是新帖子、转发还是对其他帖子的回复）。</p>
<p>We want to make a media aggregator library crate named <code>aggregator</code> that can
display summaries of data that might be stored in a <code>NewsArticle</code> or
<code>SocialPost</code> instance. To do this, we need a summary from each type, and we’ll
request that summary by calling a <code>summarize</code> method on an instance. Listing
10-12 shows the definition of a public <code>Summary</code> trait that expresses this
behavior.</p>
<p>我们想创建一个名为 <code>aggregator</code> 的媒体聚合器库 crate，它能显示可能存储在 <code>NewsArticle</code> 或 <code>SocialPost</code> 实例中的数据摘要。为此，我们需要从每种类型获取摘要，并通过调用实例的 <code>summarize</code> 方法来请求摘要。<span class="highlight">[note]代码清单 10-12 展示了表达此行为的公共 <code>Summary</code> 特质定义。</span></p>
<figure class="listing" id="listing-10-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
<figcaption><a href="ch10-02-traits.html#listing-10-12">Listing 10-12</a>: A <code>Summary</code> trait that consists of the behavior provided by a <code>summarize</code> method 包含 <code>summarize</code> 方法行为的 <code>Summary</code> 特质</figcaption>
</figure>
<p>Here, we declare a trait using the <code>trait</code> keyword and then the trait’s name,
which is <code>Summary</code> in this case. We also declare the trait as <code>pub</code> so that
crates depending on this crate can make use of this trait too, as we’ll see in
a few examples. Inside the curly brackets, we declare the method signatures
that describe the behaviors of the types that implement this trait, which in
this case is <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>此处使用 <code>trait</code> 关键字声明特质，后跟特质名称（本例中为 <code>Summary</code>）。同时将特质声明为 <code>pub</code>，以便依赖此 crate 的其他 crate 也能使用该特质（后续示例将展示）。在大括号内声明描述实现此特质的类型行为的方法签名，本例中为 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the <code>Summary</code> trait will have the method <code>summarize</code>
defined with this signature exactly.</p>
<p>在方法签名后，我们使用分号而非在大括号内提供实现。实现此特质的每个类型必须为方法体提供自定义行为。编译器将确保任何拥有 <code>Summary</code> 特质的类型都准确定义了具有此签名的 <code>summarize</code> 方法。</p>
<p>A trait can have multiple methods in its body: the method signatures are listed
one per line, and each line ends in a semicolon.</p>
<p>特质主体可包含多个方法：方法签名逐行列示，每行以分号结尾。</p>
<h3 id="implementing-a-trait-on-a-type-为类型实现特质"><a class="header" href="#implementing-a-trait-on-a-type-为类型实现特质">Implementing a Trait on a Type 为类型实现特质</a></h3>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods,
we can implement it on the types in our media aggregator. Listing 10-13 shows
an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses
the headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>SocialPost</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the post, assuming that the post content is
already limited to 280 characters.</p>
<p>定义了 <code>Summary</code> 特质方法的期望签名后，即可在媒体聚合器中的类型上实现它。代码清单 10-13 展示了在 <code>NewsArticle</code> 结构体上实现 <code>Summary</code> 特质，它使用标题、作者和地点创建 <code>summarize</code> 的返回值。对于 <code>SocialPost</code> 结构体，我们将 <code>summarize</code> 定义为用户名后跟帖子全文（假设内容已限制在 280 字符内）。</p>
<figure class="listing" id="listing-10-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
<figcaption><a href="ch10-02-traits.html#listing-10-13">Listing 10-13</a>: Implementing the <code>Summary</code> trait on the <code>NewsArticle</code> and <code>SocialPost</code> types 在 <code>NewsArticle</code> 和 <code>SocialPost</code> 类型上实现 <code>Summary</code> 特质</figcaption>
</figure>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put the trait name we want to implement,
then use the <code>for</code> keyword, and then specify the name of the type we want to
implement the trait for. Within the <code>impl</code> block, we put the method signatures
that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific
behavior that we want the methods of the trait to have for the particular type.</p>
<p>为类型实现特质类似于实现常规方法。区别在于 <code>impl</code> 后需放置要实现的 trait 名，接着使用 <code>for</code> 关键字，再指定要为其实现特质的类型名。在 <code>impl</code> 块内放置特质定义中的方法签名。此时不在签名后加分号，而是使用大括号填充方法体，定义该特质方法在特定类型上的具体行为。</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and
<code>SocialPost</code>, users of the crate can call the trait methods on instances of
<code>NewsArticle</code> and <code>SocialPost</code> in the same way we call regular methods. The only
difference is that the user must bring the trait into scope as well as the
types. Here’s an example of how a binary crate could use our <code>aggregator</code>
library crate:</p>
<p>库在 <code>NewsArticle</code> 和 <code>SocialPost</code> 上实现 <code>Summary</code> 特质后，crate 用户可在其实例上调用特质方法，方式与常规方法相同。唯一区别是用户需将特质和类型同时引入作用域。以下示例展示二进制 crate 如何使用 <code>aggregator</code> 库 crate：</p>
<pre><code class="language-rust ignore">use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
}</code></pre>
<p>This code prints <code>1 new post: horse_ebooks: of course, as you probably already  know, people</code>.</p>
<p>此代码输出：<code>1 new post: horse_ebooks: of course, as you probably already  know, people</code>。</p>
<p>Other crates that depend on the <code>aggregator</code> crate can also bring the <code>Summary</code>
trait into scope to implement <code>Summary</code> on their own types. One restriction to
note is that we can implement a trait on a type only if either the trait or the
type, or both, are local to our crate. For example, we can implement standard
library traits like <code>Display</code> on a custom type like <code>SocialPost</code> as part of our
<code>aggregator</code> crate functionality because the type <code>SocialPost</code> is local to our
<code>aggregator</code> crate. We can also implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our
<code>aggregator</code> crate because the trait <code>Summary</code> is local to our <code>aggregator</code>
crate.</p>
<p>依赖 <code>aggregator</code> crate 的其他 crate 也可将 <code>Summary</code> 特质引入作用域，以在其类型上实现 <code>Summary</code>。需注意的一个限制是，仅当特质或类型至少其一是本地 crate 所有时，才能为类型实现特质。例如，可在自定义类型 <code>SocialPost</code> 上实现标准库特质（如 <code>Display</code>），因为 <code>SocialPost</code> 是本地 crate 所有；也可在 <code>Vec&lt;T&gt;</code> 上实现 <code>Summary</code>，因为 <code>Summary</code> 是本地 crate 所有。</p>
<p>But we can’t implement external traits on external types. For example, we can’t
implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate because
<code>Display</code> and <code>Vec&lt;T&gt;</code> are both defined in the standard library and aren’t
local to our <code>aggregator</code> crate. This restriction is part of a property called
<em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the
parent type is not present. This rule ensures that other people’s code can’t
break your code and vice versa. Without the rule, two crates could implement
the same trait for the same type, and Rust wouldn’t know which implementation
to use.</p>
<p>但<span class="highlight">[note]无法在外部类型上实现外部特质</span>。例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> 特质，因为两者均定义于标准库。此限制源于<strong>一致性</strong>原则（具体为<strong>孤儿规则</strong>，因父类型不存在）。该规则确保他人代码不会破坏你的代码，反之亦然。若无此规则，两个 crate 可能为同一类型实现相同特质，Rust 将无法确定使用哪个实现。</p>
<h3 id="default-implementations-默认实现"><a class="header" href="#default-implementations-默认实现">Default Implementations 默认实现</a></h3>
<p>Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.</p>
<p>有时为特质的部分或全部方法提供默认行为很有用，无需为每个类型实现所有方法。这样在特定类型上实现特质时，可选择保留或覆盖每个方法的默认行为。</p>
<p>In Listing 10-14, we specify a default string for the <code>summarize</code> method of the
<code>Summary</code> trait instead of only defining the method signature, as we did in
Listing 10-12.</p>
<p>在代码清单 10-14 中，我们为 <code>Summary</code> 特质的 <code>summarize</code> 方法指定了默认字符串，而非仅定义方法签名（如代码清单 10-12）。</p>
<figure class="listing" id="listing-10-14">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch10-02-traits.html#listing-10-14">Listing 10-14</a>: Defining a <code>Summary</code> trait with a default implementation of the <code>summarize</code> method 为 <code>summarize</code> 方法提供默认实现的 <code>Summary</code> 特质</figcaption>
</figure>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code>, we
specify an empty <code>impl</code> block with <code>impl Summary for NewsArticle {}</code>.</p>
<p>要使用默认实现汇总 <code>NewsArticle</code> 实例，需指定一个空的 <code>impl</code> 块：<code>impl Summary for NewsArticle {}</code>。</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code>
directly, we’ve provided a default implementation and specified that
<code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call
the <code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<p>尽管不再直接在 <code>NewsArticle</code> 上定义 <code>summarize</code> 方法，但我们提供了默认实现并声明 <code>NewsArticle</code> 实现了 <code>Summary</code> 特质。因此仍可在其实例上调用 <code>summarize</code> 方法：</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>此代码输出：<code>New article available! (Read more...)</code>。</p>
<p>Creating a default implementation doesn’t require us to change anything about
the implementation of <code>Summary</code> on <code>SocialPost</code> in Listing 10-13. The reason is
that the syntax for overriding a default implementation is the same as the
syntax for implementing a trait method that doesn’t have a default
implementation.</p>
<p>创建默认实现无需更改代码清单 10-13 中 <code>SocialPost</code> 的 <code>Summary</code> 实现，因为覆盖默认实现的语法与实现无默认方法的特质方法相同。</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, and then define a
<code>summarize</code> method that has a default implementation that calls the
<code>summarize_author</code> method:</p>
<p><span class="highlight">[note]默认实现可调用同一特质中的其他方法（即使这些方法无默认实现）。</span>这样，特质可提供大量功能，仅要求实现者指定一小部分。例如，可定义 <code>Summary</code> 特质包含需实现的 <code>summarize_author</code> 方法，再定义调用 <code>summarize_author</code> 的默认 <code>summarize</code> 方法：</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code>
when we implement the trait on a type:</p>
<p>使用此版本 <code>Summary</code> 时，实现特质仅需定义 <code>summarize_author</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Read more from {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for SocialPost {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>SocialPost</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code. Here’s what
that looks like:</p>
<p>定义 <code>summarize_author</code> 后，即可在 <code>SocialPost</code> 实例上调用 <code>summarize</code>。默认实现将调用我们提供的 <code>summarize_author</code> 实现。由于实现了 <code>summarize_author</code>，<code>Summary</code> 特质为我们提供了 <code>summarize</code> 的行为而无需额外编码：</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, SocialPost, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
<span class="boring">}</span></code></pre>
<p>This code prints <code>1 new post: (Read more from @horse_ebooks...)</code>.</p>
<p>此代码输出：<code>1 new post: (Read more from @horse_ebooks...)</code>。</p>
<p>Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.</p>
<p>注意：无法从覆盖实现中调用此方法的默认实现。</p>
<h3 id="traits-as-parameters-特质作为参数"><a class="header" href="#traits-as-parameters-特质作为参数">Traits as Parameters 特质作为参数</a></h3>
<p>Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types. We’ll use the
<code>Summary</code> trait we implemented on the <code>NewsArticle</code> and <code>SocialPost</code> types in
Listing 10-13 to define a <code>notify</code> function that calls the <code>summarize</code> method
on its <code>item</code> parameter, which is of some type that implements the <code>Summary</code>
trait. To do this, we use the <code>impl Trait</code> syntax, like this:</p>
<p>了解如何定义和使用特质后，可探索如何用特质定义接受多种类型的函数。我们将使用代码清单 10-13 中为 <code>NewsArticle</code> 和 <code>SocialPost</code> 实现的 <code>Summary</code> 特质，定义 <code>notify</code> 函数：在其参数 <code>item</code>（某实现 <code>Summary</code> 特质的类型）上调用 <code>summarize</code> 方法。使用 <code>impl Trait</code> 语法实现：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>Instead of a concrete type for the <code>item</code> parameter, we specify the <code>impl</code>
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of <code>notify</code>, we can call any methods on <code>item</code>
that come from the <code>Summary</code> trait, such as <code>summarize</code>. We can call <code>notify</code>
and pass in any instance of <code>NewsArticle</code> or <code>SocialPost</code>. Code that calls the
function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile
because those types don’t implement <code>Summary</code>.</p>
<p><code>item</code> 参数使用 <code>impl</code> 关键字加特质名替代具体类型，接受任何实现指定特质的类型。在 <code>notify</code> 主体中，可调用来自 <code>Summary</code> 特质的任何方法（如 <code>summarize</code>）。可传入 <code>NewsArticle</code> 或 <code>SocialPost</code> 实例调用 <code>notify</code>。若传入 <code>String</code> 或 <code>i32</code> 等未实现 <code>Summary</code> 的类型，代码将无法编译。</p>
<h4 id="trait-bound-syntax-特质限定语法"><a class="header" href="#trait-bound-syntax-特质限定语法">Trait Bound Syntax 特质限定语法</a></h4>
<p>The <code>impl Trait</code> syntax works for straightforward cases but is actually syntax
sugar for a longer form known as a <em>trait bound</em>; it looks like this:</p>
<p><span class="highlight">[note]<code>impl Trait</code> 语法适用于简单情况，实为 <em>特质限定（trait bound）</em> 的语法糖：</span></p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}</code></pre>
<p>This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.</p>
<p>此完整形式等同于上例但更冗长。特质限定位于泛型参数声明后，以冒号分隔并置于尖括号内。</p>
<p>The <code>impl Trait</code> syntax is convenient and makes for more concise code in simple
cases, while the fuller trait bound syntax can express more complexity in other
cases. For example, we can have two parameters that implement <code>Summary</code>. Doing
so with the <code>impl Trait</code> syntax looks like this:</p>
<p><code>impl Trait</code> 语法很方便，并且在简单情况下能够让代码更加简洁，而完整的 trait 约束语法则能在其他情况下表达更多的复杂性。例如，我们可以有两个实现了 <code>Summary</code> 的参数。使用 <code>impl Trait</code> 语法的写法如下：</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Using <code>impl Trait</code> is appropriate if we want this function to allow <code>item1</code> and
<code>item2</code> to have different types (as long as both types implement <code>Summary</code>). If
we want to force both parameters to have the same type, however, we must use a
trait bound, like this:</p>
<p>如果我们希望此函数允许 <code>item1</code> 和 <code>item2</code> 具有不同的类型（只要它们都实现了 <code>Summary</code> 接口），可以使用 <code>impl Trait</code>。但是，如果我们想强制两个参数具有相同的类型，则必须使用 <code>trait bound</code>：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>The generic type <code>T</code> specified as the type of the <code>item1</code> and <code>item2</code>
parameters constrains the function such that the concrete type of the value
passed as an argument for <code>item1</code> and <code>item2</code> must be the same.</p>
<p>这里，泛型类型 <code>T</code> 被指定为 <code>item1</code> 和 <code>item2</code> 参数的类型，限制了该函数，使得传递给 <code>item1</code> 和 <code>item2</code> 的实际类型必须相同。</p>
<h4 id="specifying-multiple-trait-bounds-with-the--syntax-使用--语法指定多个特质限定"><a class="header" href="#specifying-multiple-trait-bounds-with-the--syntax-使用--语法指定多个特质限定">Specifying Multiple Trait Bounds with the <code>+</code> Syntax 使用 <code>+</code> 语法指定多个特质限定</a></h4>
<p>We can also specify more than one trait bound. Say we wanted <code>notify</code> to use
display formatting as well as <code>summarize</code> on <code>item</code>: we specify in the <code>notify</code>
definition that <code>item</code> must implement both <code>Display</code> and <code>Summary</code>. We can do
so using the <code>+</code> syntax:</p>
<p><span class="highlight">[note]可指定多个特质限定。</span>若需 <code>notify</code> 同时使用显示格式化和 <code>summarize</code>，则要求 <code>item</code> 实现 <code>Display</code> 和 <code>Summary</code>：</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>The <code>+</code> syntax is also valid with trait bounds on generic types:</p>
<p><code>+</code> 语法也适用于泛型的特质限定：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>With the two trait bounds specified, the body of <code>notify</code> can call <code>summarize</code>
and use <code>{}</code> to format <code>item</code>.</p>
<p>指定两个特质限定后，<code>notify</code> 主体可调用 <code>summarize</code> 并使用 <code>{}</code> 格式化 <code>item</code>。</p>
<h4 id="clearer-trait-bounds-with-where-clauses-使用-where-子句增强可读性"><a class="header" href="#clearer-trait-bounds-with-where-clauses-使用-where-子句增强可读性">Clearer Trait Bounds with <code>where</code> Clauses 使用 <code>where</code> 子句增强可读性</a></h4>
<p>Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a <code>where</code> clause after the function
signature. So, instead of writing this:</p>
<p>使用过多的特征约束是有缺点的。每个泛型都有自己的特征约束，因此具有多个泛型类型参数的函数可能会在函数名和参数列表之间包含大量特征约束信息，这使得函数签名变得难以阅读。为了解决这个问题，Rust 提供了另一种语法，可以在函数签名后使用 <code>where</code> 子句来指定特征约束。因此，无需写成这样：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>we can use a <code>where</code> clause, like this:</p>
<p>我们可以使用 <code>where</code> 子句，如下所示：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.</p>
<p>这个函数的签名更加简洁：函数名、参数列表和返回类型紧密相连，类似于没有过多特征约束的函数。</p>
<h3 id="returning-types-that-implement-traits-返回实现特质的类型"><a class="header" href="#returning-types-that-implement-traits-返回实现特质的类型">Returning Types That Implement Traits 返回实现特质的类型</a></h3>
<p>We can also use the <code>impl Trait</code> syntax in the return position to return a
value of some type that implements a trait, as shown here:</p>
<p>可在返回位置使用 <code>impl Trait</code> 语法返回实现某特质的类型：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    }
}</code></pre>
<p>By using <code>impl Summary</code> for the return type, we specify that the
<code>returns_summarizable</code> function returns some type that implements the <code>Summary</code>
trait without naming the concrete type. In this case, <code>returns_summarizable</code>
returns a <code>SocialPost</code>, but the code calling this function doesn’t need to know
that.</p>
<p>通过 <code>impl Summary</code> 指定返回类型，表明 <code>returns_summarizable</code> 返回实现 <code>Summary</code> 特质的类型（不指定具体类型）。调用方无需知晓实际返回的是 <code>SocialPost</code>。</p>
<p>The ability to specify a return type only by the trait it implements is
especially useful in the context of closures and iterators, which we cover in
Chapter 13. Closures and iterators create types that only the compiler knows or
types that are very long to specify. The <code>impl Trait</code> syntax lets you concisely
specify that a function returns some type that implements the <code>Iterator</code> trait
without needing to write out a very long type.</p>
<p>此功能在闭包和迭代器场景中尤其有用（第 13 章介绍）。闭包和迭代器生成的类型或由编译器推导或冗长难写。<code>impl Trait</code> 语法可简洁指定函数返回实现 <code>Iterator</code> 特质的类型。</p>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For
example, this code that returns either a <code>NewsArticle</code> or a <code>SocialPost</code> with
the return type specified as <code>impl Summary</code> wouldn’t work:</p>
<p>但 <span class="highlight">[note]<code>impl Trait</code> 仅适用于返回单一类型</span>。以下尝试返回 <code>NewsArticle</code> 或 <code>SocialPost</code> 的代码无效：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            repost: false,
        }
    }
}</code></pre>
<p>Returning either a <code>NewsArticle</code> or a <code>SocialPost</code> isn’t allowed due to
restrictions around how the <code>impl Trait</code> syntax is implemented in the compiler.
We’ll cover how to write a function with this behavior in the “Using Trait
Objects That Allow for Values of Different
Types” section of Chapter 18.</p>
<p>由于编译器中 <code>impl Trait</code> 语法的实现方式的限制，不允许返回 <code>NewsArticle</code> 或 <code>SocialPost</code>。我们将在第18章的“使用允许不同类型值的 Trait 对象”部分中讨论如何编写具有此行为的函数。</p>
<h3 id="using-trait-bounds-to-conditionally-implement-methods-使用特质限定条件实现方法"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods-使用特质限定条件实现方法">Using Trait Bounds to Conditionally Implement Methods 使用特质限定条件实现方法</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-15 always implements the
<code>new</code> function to return a new instance of <code>Pair&lt;T&gt;</code> (recall from the
“Defining Methods” section of Chapter 5 that <code>Self</code>
is a type alias for the type of the <code>impl</code> block, which in this case is
<code>Pair&lt;T&gt;</code>). But in the next <code>impl</code> block, <code>Pair&lt;T&gt;</code> only implements the
<code>cmp_display</code> method if its inner type <code>T</code> implements the <code>PartialOrd</code> trait
that enables comparison <em>and</em> the <code>Display</code> trait that enables printing.</p>
<p><span class="highlight">[note]通过将特质限定与使用泛型参数的 <code>impl</code> 块结合，可以有条件地为满足特质的类型实现方法。</span>例如，代码清单 10-15 中的类型 <code>Pair&lt;T&gt;</code> 总是实现 <code>new</code> 函数，用于返回 <code>Pair&lt;T&gt;</code> 的新实例（回顾一下第 5 章“定义方法”部分，<code>Self</code> 是 <code>impl</code> 块类型的类型别名，在本例中是 <code>Pair&lt;T&gt;</code>）。但在下一个 <code>impl</code> 块中，只有当其内部类型 <code>T</code> 实现了 <code>PartialOrd</code> trait（用于比较）和 <code>Display</code> trait（用于打印）时，<code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法。</p>
<figure class="listing" id="listing-10-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}</code></pre>
<figcaption><a href="ch10-02-traits.html#listing-10-15">Listing 10-15</a>: Conditionally implementing methods on a generic type depending on trait bounds 根据特质限条件为泛型类型实现方法</figcaption>
</figure>
<p>We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called <em>blanket implementations</em> and are used extensively in the
Rust standard library. For example, the standard library implements the
<code>ToString</code> trait on any type that implements the <code>Display</code> trait. The <code>impl</code>
block in the standard library looks similar to this code:</p>
<p>我们还<span class="highlight">[note]可以有条件地为实现了另一个 trait 的任何类型实现一个 trait。对于任何满足 trait 约束的类型的 trait 实现，称为 <em>通用实现（blanket implementations）</em></span>，并在 Rust 标准库中被广泛使用。例如，标准库为实现了 <code>Display</code> trait 的任何类型实现了 <code>ToString</code> trait。标准库中的 <code>impl</code> 块看起来类似于以下代码：</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Because the standard library has this blanket implementation, we can call the
<code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements
the <code>Display</code> trait. For example, we can turn integers into their corresponding
<code>String</code> values like this because integers implement <code>Display</code>:</p>
<p>由于标准库有这个通用实现，我们可以在任何实现了 <code>Display</code> trait 的类型上调用 <code>ToString</code> trait 中定义的 <code>to_string</code> 方法。例如，我们可以像这样将整数转换为对应的 <code>String</code> 值，因为整数实现了 <code>Display</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Blanket implementations appear in the documentation for the trait in the
“Implementors” section.</p>
<p>通用实现会出现在 trait 的文档中的“实现者”部分。</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn’t define the method. But
Rust moves these errors to compile time so we’re forced to fix the problems
before our code is even able to run. Additionally, we don’t have to write code
that checks for behavior at runtime because we’ve already checked at compile
time. Doing so improves performance without having to give up the flexibility
of generics.</p>
<p>traits 和 trait 约束让我们可以编写使用泛型类型参数的代码，以减少重复，同时还可以向编译器指定我们希望泛型类型具有特定的行为。然后，编译器可以使用 trait 约束信息来检查我们代码中使用的所有具体类型是否提供了正确的行为。在动态类型语言中，如果我们在一个没有定义该方法的类型上调用了方法，会在运行时出错。但 Rust 将这些错误移到了编译时，因此我们在代码能够运行之前就被迫修复问题。此外，我们不需要编写在运行时检查行为的代码，因为我们已经在编译时进行了检查。这样做提高了性能，而无需放弃泛型的灵活性。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="validating-references-with-lifetimes-使用生命周期验证引用"><a class="header" href="#validating-references-with-lifetimes-使用生命周期验证引用">Validating References with Lifetimes 使用生命周期验证引用</a></h2>
<p>Lifetimes are another kind of generic that we’ve already been using. Rather
than ensuring that a type has the behavior we want, lifetimes ensure that
references are valid as long as we need them to be.</p>
<p>生命周期是另一种我们已经在使用的泛型。与确保类型具有所需行为不同，生命周期确保引用在需要时保持有效。</p>
<p>One detail we didn’t discuss in the “References and
Borrowing” section in Chapter 4 is
that every reference in Rust has a <em>lifetime</em>, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and inferred,
just like most of the time, types are inferred. We are only required to
annotate types when multiple types are possible. In a similar way, we have to
annotate lifetimes when the lifetimes of references could be related in a few
different ways. Rust requires us to annotate the relationships using generic
lifetime parameters to ensure the actual references used at runtime will
definitely be valid.</p>
<p>在第四章的“引用与借用”部分未讨论的一个细节是：Rust 中的每个引用都有一个<strong>生命周期</strong>（<em>lifetime</em>），即该引用有效的范围。大多数情况下，生命周期是隐式且可推断的，就像类型通常可推断一样。只有在可能存在多种类型时才需要显式标注类型。类似地，当引用的生命周期可能以不同方式关联时，我们必须标注生命周期。Rust 要求我们使用泛型生命周期参数来标注这些关系，以确保运行时使用的实际引用绝对有效。</p>
<p>Annotating lifetimes is not even a concept most other programming languages
have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in
their entirety in this chapter, we’ll discuss common ways you might encounter
lifetime syntax so you can get comfortable with the concept.</p>
<p>生命周期标注在大多数其他编程语言中并不存在，因此这会让人感到陌生。尽管本章不会完整涵盖生命周期，但我们将讨论可能遇到的常见生命周期语法，以便熟悉这一概念。</p>
<h3 id="preventing-dangling-references-with-lifetimes-用生命周期预防悬垂引用"><a class="header" href="#preventing-dangling-references-with-lifetimes-用生命周期预防悬垂引用">Preventing Dangling References with Lifetimes 用生命周期预防悬垂引用</a></h3>
<p>The main aim of lifetimes is to prevent <em>dangling references</em>, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-16, which has an outer scope and an inner
scope.</p>
<p>生命周期的主要目标是防止<strong>悬垂引用</strong>（<em>dangling references</em>），这类引用会导致程序访问非预期的数据。考虑示例 10-16 中的程序，它包含一个外部作用域和一个内部作用域。</p>
<figure class="listing" id="listing-10-16">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-16">Listing 10-16</a>: An attempt to use a reference whose value has gone out of scope 尝试使用一个值已离开作用域的引用</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables
without giving them an initial value, so the variable name exists in the outer
scope. At first glance, this might appear to be in conflict with Rust’s having
no null values. However, if we try to use a variable before giving it a value,
we’ll get a compile-time error, which shows that Rust indeed does not allow
null values.</p>
<p>注意：示例 10-16、10-17 和 10-23 中声明的变量未赋予初始值，因此变量名存在于外部作用域。乍看之下，这可能与 Rust 不允许空值相冲突。然而，若在赋值前使用变量，将引发编译时错误，这表明 Rust 确实不允许空值。</p>
</section>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of <code>5</code>. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t
compile because the value that <code>r</code> is referring to has gone out of scope before
we try to use it. Here is the error message:</p>
<p>外部作用域声明了未初始化的变量 <code>r</code>，内部作用域声明了初始值为 <code>5</code> 的变量 <code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 设为 <code>x</code> 的引用。随后内部作用域结束，我们尝试打印 <code>r</code> 的值。此代码无法编译，因为 <code>r</code> 引用的值在我们尝试使用时已离开作用域。错误信息如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The error message says that the variable <code>x</code> “does not live long enough.” The
reason is that <code>x</code> will be out of scope when the inner scope ends on line 7.
But <code>r</code> is still valid for the outer scope; because its scope is larger, we say
that it “lives longer.” If Rust allowed this code to work, <code>r</code> would be
referencing memory that was deallocated when <code>x</code> went out of scope, and
anything we tried to do with <code>r</code> wouldn’t work correctly. So how does Rust
determine that this code is invalid? It uses a borrow checker.</p>
<p>错误信息指出变量 <code>x</code> “存活时间不够长”。原因是当内部作用域在第 7 行结束时，<code>x</code> 将离开作用域。但 <code>r</code> 在外部作用域中仍然有效；因其作用域更大，我们称其“活得更久”。若 Rust 允许此代码运行，<code>r</code> 将指向 <code>x</code> 离开作用域时已被释放的内存，任何对 <code>r</code> 的操作都将失败。那么 Rust 如何判定此代码无效？它使用借用检查器。</p>
<h3 id="the-borrow-checker-借用检查器"><a class="header" href="#the-borrow-checker-借用检查器">The Borrow Checker 借用检查器</a></h3>
<p>The Rust compiler has a <em>borrow checker</em> that compares scopes to determine
whether all borrows are valid. Listing 10-17 shows the same code as Listing
10-16 but with annotations showing the lifetimes of the variables.</p>
<p>Rust 编译器有一个<strong>借用检查器</strong>（<em>borrow checker</em>），通过比较作用域来判断所有借用是否有效。示例 10-17 展示了与示例 10-16 相同的代码，但添加了变量生命周期的标注。</p>
<figure class="listing" id="listing-10-17">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-17">Listing 10-17</a>: Annotations of the lifetimes of <code>r</code> and <code>x</code>, named <code>'a</code> and <code>'b</code>, respectively 标注变量 <code>r</code> 和 <code>x</code> 的生命周期，分别命名为 <code>'a</code> 和 <code>'b</code></figcaption>
</figure>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code>
with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer
<code>'a</code> lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory
with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than
<code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p>
<p>这里我们将 <code>r</code> 的生命周期标注为 <code>'a</code>，<code>x</code> 的生命周期标注为 <code>'b</code>。如你所见，内部的 <code>'b</code> 块远小于外部的 <code>'a</code> 生命周期块。编译时，Rust 比较两个生命周期的大小，发现 <code>r</code> 拥有生命周期 <code>'a</code>，但它引用的内存的生命周期为 <code>'b</code>。程序被拒绝是因为 <code>'b</code> 比 <code>'a</code> 短：被引用的对象不如引用存活得久。</p>
<p>Listing 10-18 fixes the code so it doesn’t have a dangling reference and it
compiles without any errors.</p>
<p>示例 10-18 修复了代码，消除了悬垂引用，可无错编译。</p>
<figure class="listing" id="listing-10-18">
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-18">Listing 10-18</a>: A valid reference because the data has a longer lifetime than the reference 有效引用：数据的生命周期比引用长</figcaption>
</figure>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will
always be valid while <code>x</code> is valid.</p>
<p>此处 <code>x</code> 的生命周期 <code>'b</code> 大于 <code>'a</code>。这意味着 <code>r</code> 可引用 <code>x</code>，因为 Rust 知道只要 <code>x</code> 有效，<code>r</code> 中的引用就始终有效。</p>
<p>Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.</p>
<p>现在你已了解引用的生命周期位置及 Rust 如何分析生命周期以确保引用有效，接下来让我们探索函数上下文中的参数和返回值的泛型生命周期。</p>
<h3 id="generic-lifetimes-in-functions-函数中的泛型生命周期"><a class="header" href="#generic-lifetimes-in-functions-函数中的泛型生命周期">Generic Lifetimes in Functions 函数中的泛型生命周期</a></h3>
<p>We’ll write a function that returns the longer of two string slices. This
function will take two string slices and return a single string slice. After
we’ve implemented the <code>longest</code> function, the code in Listing 10-19 should
print <code>The longest string is abcd</code>.</p>
<p>我们将编写返回两个字符串切片中较长者的函数。该函数接收两个字符串切片并返回单个字符串切片。实现 <code>longest</code> 函数后，示例 10-19 中的代码应打印 <code>The longest string is abcd</code>。</p>
<figure class="listing" id="listing-10-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-19">Listing 10-19</a>: A <code>main</code> function that calls the <code>longest</code> function to find the longer of two string slices 调用 <code>longest</code> 函数以比较两个字符串切片长度的 <code>main</code> 函数</figcaption>
</figure>
<p>Note that we want the function to take string slices, which are references,
rather than strings, because we don’t want the <code>longest</code> function to take
ownership of its parameters. Refer to “String Slices as
Parameters” in Chapter 4 for more
discussion about why the parameters we use in Listing 10-19 are the ones we
want.</p>
<p>注意我们希望函数接收字符串切片（即引用）而非字符串，因为不希望 <code>longest</code> 函数获取参数的所有权。更多讨论请参阅第四章的“字符串切片作为参数”部分。</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-20, it
won’t compile.</p>
<p>若按示例 10-20 实现 <code>longest</code> 函数，将无法编译。</p>
<figure class="listing" id="listing-10-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-20">Listing 10-20</a>: An implementation of the <code>longest</code> function that returns the longer of two string slices but does not yet compile <code>longest</code> 函数实现（尚未能编译）</figcaption>
</figure>
<p>Instead, we get the following error that talks about lifetimes:</p>
<p>编译器会返回关于生命周期的错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
<code>x</code> or <code>y</code>. Actually, we don’t know either, because the <code>if</code> block in the body
of this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>帮助文本指出返回类型需泛型生命周期参数，因为 Rust 无法判断返回的引用指向 <code>x</code> 还是 <code>y</code>。实际上，由于函数体的 <code>if</code> 块返回 <code>x</code> 的引用而 <code>else</code> 块返回 <code>y</code> 的引用，我们同样无法确定！</p>
<p>When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the <code>if</code> case or the
<code>else</code> case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-17 and 10-18 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.</p>
<p>定义函数时，我们不知道将传入的具体值，因此无法预知执行 <code>if</code> 还是 <code>else</code> 分支。我们也不知道传入引用的具体生命周期，故无法像示例 10-17 和 10-18 那样通过作用域判断返回的引用是否始终有效。借用检查器也无法判断，因为它不清楚 <code>x</code> 和 <code>y</code> 的生命周期与返回值的生命周期如何关联。为修复此错误，我们将添加定义引用间关系的泛型生命周期参数，以便借用检查器进行分析。</p>
<h3 id="lifetime-annotation-syntax-生命周期标注语法"><a class="header" href="#lifetime-annotation-syntax-生命周期标注语法">Lifetime Annotation Syntax 生命周期标注语法</a></h3>
<p>Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. Just as functions can accept any type
when the signature specifies a generic type parameter, functions can accept
references with any lifetime by specifying a generic lifetime parameter.</p>
<p>生命周期标注不改变任何引用的存活时间，而是描述多个引用的生命周期关系而不影响其时长。正如函数在签名中指定泛型类型参数时可接受任意类型，函数也可通过指定泛型生命周期参数接受任意生命周期的引用。</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase
and very short, like generic types. Most people use the name <code>'a</code> for the first
lifetime annotation. We place lifetime parameter annotations after the <code>&amp;</code> of a
reference, using a space to separate the annotation from the reference’s type.</p>
<p>生命周期标注语法略特殊：生命周期参数名必须以撇号（<code>'</code>）开头，通常全小写且非常简短（如泛型类型）。多数人用 <code>'a</code> 作为第一个生命周期标注。我们将<span class="highlight">[note]生命周期参数标注放在引用符号 <code>&amp;</code> 之后，并用空格分隔标注与引用类型</span>。</p>
<p>Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>.</p>
<p>示例如下：无生命周期参数的 <code>i32</code> 引用，带生命周期参数 <code>'a</code> 的 <code>i32</code> 引用，以及同具生命周期 <code>'a</code> 的可变 <code>i32</code> 引用。</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. Let’s examine how the lifetime annotations
relate to each other in the context of the <code>longest</code> function.</p>
<p>单个生命周期标注本身意义不大，因其旨在告知 Rust 多个引用的泛型生命周期参数如何关联。接下来探讨 <code>longest</code> 函数中生命周期标注的关联方式。</p>
<h3 id="lifetime-annotations-in-function-signatures-函数签名中的生命周期标注"><a class="header" href="#lifetime-annotations-in-function-signatures-函数签名中的生命周期标注">Lifetime Annotations in Function Signatures 函数签名中的生命周期标注</a></h3>
<p>To use lifetime annotations in function signatures, we need to declare the
generic <em>lifetime</em> parameters inside angle brackets between the function name
and the parameter list, just as we did with generic <em>type</em> parameters.</p>
<p>要在函数签名中使用生命周期标注，需在函数名与参数列表间的尖括号内声明泛型<strong>生命周期</strong>参数，如同处理泛型<strong>类型</strong>参数。</p>
<p>We want the signature to express the following constraint: the returned
reference will be valid as long as both the parameters are valid. This is the
relationship between lifetimes of the parameters and the return value. We’ll
name the lifetime <code>'a</code> and then add it to each reference, as shown in Listing
10-21.</p>
<p>我们希望签名表达以下约束：返回的引用在参数均有效时保持有效。这是参数与返回值的生命周期关系。我们将生命周期命名为 <code>'a</code> 并添加到每个引用，如示例 10-21 所示。</p>
<figure class="listing" id="listing-10-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-21">Listing 10-21</a>: The <code>longest</code> function definition specifying that all the references in the signature must have the same lifetime <code>'a</code> <code>longest</code> 函数定义：要求签名中所有引用具有相同生命周期 <code>'a</code></figcaption>
</figure>
<p>This code should compile and produce the result we want when we use it with the
<code>main</code> function in Listing 10-19.</p>
<p>结合示例 10-19 的 <code>main</code> 函数使用此代码时，应能编译并产生预期结果。</p>
<p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime <code>'a</code>. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime <code>'a</code>.
In practice, it means that the lifetime of the reference returned by the
<code>longest</code> function is the same as the smaller of the lifetimes of the values
referred to by the function arguments. These relationships are what we want
Rust to use when analyzing this code.</p>
<p><span class="highlight">[note]函数签名现向 Rust 表明：存在某个生命周期 <code>'a</code>，函数接收的两个参数均为至少存活 <code>'a</code> 的字符串切片，且返回的字符串切片也至少存活 <code>'a</code>。</span>实际上意味着 <code>longest</code> 函数返回引用的生命周期等于函数参数所引用值中较短的生命周期。这正是我们希望 Rust 在代码分析中使用的关系。</p>
<p>Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the <code>longest</code> function doesn’t need to
know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be
substituted for <code>'a</code> that will satisfy this signature.</p>
<p>记住，<span class="highlight">[note]在函数签名中指定生命周期参数时，并未改变任何传入或返回值的实际生命周期，而是规定借用检查器应拒绝不满足这些约束的值。</span>注意 <code>longest</code> 函数无需知道 <code>x</code> 和 <code>y</code> 的具体存活时间，只需存在满足此签名的某个作用域可替代 <code>'a</code>。</p>
<p>When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. The lifetime annotations become part of
the contract of the function, much like the types in the signature. Having
function signatures contain the lifetime contract means the analysis the Rust
compiler does can be simpler. If there’s a problem with the way a function is
annotated or the way it is called, the compiler errors can point to the part of
our code and the constraints more precisely. If, instead, the Rust compiler
made more inferences about what we intended the relationships of the lifetimes
to be, the compiler might only be able to point to a use of our code many steps
away from the cause of the problem.</p>
<p>函数生命周期标注位于函数签名而非函数体。这些标注成为函数契约的一部分，类似于签名中的类型。函数签名包含生命周期契约意味着 Rust 编译器的分析更简单。若函数标注或调用方式有问题，编译器错误可更精确地定位代码位置及约束。反之，若 Rust 对我们期望的生命周期关系进行更多推断，编译器可能仅能指向问题根源的远处代码。</p>
<p>When we pass concrete references to <code>longest</code>, the concrete lifetime that is
substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with the
scope of <code>y</code>. In other words, the generic lifetime <code>'a</code> will get the concrete
lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>. Because
we’ve annotated the returned reference with the same lifetime parameter <code>'a</code>,
the returned reference will also be valid for the length of the smaller of the
lifetimes of <code>x</code> and <code>y</code>.</p>
<p>向 <code>longest</code> 传递具体引用时，替代 <code>'a</code> 的具体生命周期是 <code>x</code> 与 <code>y</code> 作用域的重叠部分。换言之，泛型生命周期 <code>'a</code> 将获得等于 <code>x</code> 和 <code>y</code> 生命周期中较小者的具体生命周期。由于我们以相同生命周期参数 <code>'a</code> 标注返回的引用，该引用在 <code>x</code> 和 <code>y</code> 中较小者的生命周期内均有效。</p>
<p>Let’s look at how the lifetime annotations restrict the <code>longest</code> function by
passing in references that have different concrete lifetimes. Listing 10-22 is
a straightforward example.</p>
<p>让我们通过传入具有不同具体生命周期的引用，观察生命周期标注如何约束 <code>longest</code> 函数。示例 10-22 是一个直观的例子。</p>
<figure class="listing" id="listing-10-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-22">Listing 10-22</a>: Using the <code>longest</code> function with references to <code>String</code> values that have different concrete lifetimes 对具有不同生命周期的 <code>String</code> 值使用 <code>longest</code> 函数</figcaption>
</figure>
<p>In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code>
is valid until the end of the inner scope, and <code>result</code> references something
that is valid until the end of the inner scope. Run this code and you’ll see
that the borrow checker approves; it will compile and print <code>The longest string  is long string is long</code>.</p>
<p>此例中，<code>string1</code> 在外部作用域结束前有效，<code>string2</code> 在内部作用域结束前有效，而 <code>result</code> 引用的内容在内部作用域结束前有效。运行此代码可见借用检查器通过：它将编译并打印 <code>The longest string is long string is long</code>。</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We’ll move the
declaration of the <code>result</code> variable outside the inner scope but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Then we’ll move the <code>println!</code> that uses <code>result</code> to outside the
inner scope, after the inner scope has ended. The code in Listing 10-23 will
not compile.</p>
<p>接下来尝试证明 <code>result</code> 引用的生命周期必须是两个参数中较短者的例子。我们将 <code>result</code> 变量的声明移至内部作用域外，但将其赋值保留在 <code>string2</code> 所在的作用域内。然后将使用 <code>result</code> 的 <code>println!</code> 移至内部作用域结束后。示例 10-23 的代码无法编译。</p>
<figure class="listing" id="listing-10-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-23">Listing 10-23</a>: Attempting to use <code>result</code> after <code>string2</code> has gone out of scope 尝试在 <code>string2</code> 离开作用域后使用 <code>result</code></figcaption>
</figure>
<p>When we try to compile this code, we get this error:</p>
<p>编译时错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The error shows that for <code>result</code> to be valid for the <code>println!</code> statement,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter <code>'a</code>.</p>
<p>错误表明：为使 <code>result</code> 在 <code>println!</code> 语句中有效，<code>string2</code> 需存活至外部作用域结束。Rust 知晓这一点，因为我们用相同生命周期参数 <code>'a</code> 标注了函数参数和返回值。</p>
<p>As humans, we can look at this code and see that <code>string1</code> is longer than
<code>string2</code>, and therefore, <code>result</code> will contain a reference to <code>string1</code>.
Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will
still be valid for the <code>println!</code> statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the <code>longest</code> function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-23 as possibly having an invalid reference.</p>
<p>作为人类可看出 <code>string1</code> 比 <code>string2</code> 长，因此 <code>result</code> 将包含指向 <code>string1</code> 的引用。由于 <code>string1</code> 尚未离开作用域，其引用在 <code>println!</code> 中仍有效。但编译器无法在此情况下识别引用的有效性。我们已告知 Rust：<code>longest</code> 函数返回引用的生命周期等于所传入引用中较短者的生命周期。因此借用检查器禁止示例 10-23 的代码，因其可能存在无效引用。</p>
<p>Try designing more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!</p>
<p>请尝试设计更多实验：改变传入 <code>longest</code> 函数的引用值和生命周期，并改变返回引用的使用方式。编译前预测试验能否通过借用检查器，然后验证你的判断！</p>
<h3 id="thinking-in-terms-of-lifetimes-生命周期思考模式"><a class="header" href="#thinking-in-terms-of-lifetimes-生命周期思考模式">Thinking in Terms of Lifetimes 生命周期思考模式</a></h3>
<p>The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
<code>longest</code> function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the <code>y</code> parameter. The
following code will compile:</p>
<p>生命周期参数的指定方式取决于函数功能。例如，若将 <code>longest</code> 函数改为始终返回第一个参数而非较长字符串切片，则无需在 <code>y</code> 参数上标注生命周期。以下代码可编译：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</figure>
<p>We’ve specified a lifetime parameter <code>'a</code> for the parameter <code>x</code> and the return
type, but not for the parameter <code>y</code>, because the lifetime of <code>y</code> does not have
any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>我们为参数 <code>x</code> 和返回类型标注了生命周期参数 <code>'a</code>，但未标注参数 <code>y</code>，因为 <code>y</code> 的生命周期与 <code>x</code> 或返回值的生命周期无关。</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does <em>not</em> refer to one of the parameters, it must refer
to a value created within this function. However, this would be a dangling
reference because the value will go out of scope at the end of the function.
Consider this attempted implementation of the <code>longest</code> function that won’t
compile:</p>
<p><span class="highlight">[note]从函数返回引用时，返回类型的生命周期参数必须与某个参数的生命周期参数匹配。</span>若返回的引用<strong>未</strong>指向任何参数，则必须指向此函数内创建的值。但该值将在函数结束时离开作用域，导致悬垂引用。考虑以下无法编译的 <code>longest</code> 函数实现：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</figure>
<p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:</p>
<p>此处尽管为返回类型指定了生命周期参数 <code>'a</code>，实现仍无法编译，因为返回值生命周期与参数生命周期完全无关。错误信息如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end
of the <code>longest</code> function. We’re also trying to return a reference to <code>result</code>
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.</p>
<p>问题在于 <code>result</code> 在 <code>longest</code> 函数结束时离开作用域并被清理。而我们试图从函数返回 <code>result</code> 的引用。无法通过指定生命周期参数来改变悬垂引用，且 Rust 不允许创建悬垂引用。此时最佳解决方案是返回自有数据类型而非引用，让调用函数负责清理该值。</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<p>归根结底，<span class="highlight">[note]生命周期语法旨在连接函数的各参数及返回值的生命周期。</span>一旦建立连接，Rust 便拥有足够信息确保内存安全操作，并禁止可能导致悬垂指针或内存安全违规的操作。</p>
<h3 id="lifetime-annotations-in-struct-definitions-结构体定义中的生命周期标注"><a class="header" href="#lifetime-annotations-in-struct-definitions-结构体定义中的生命周期标注">Lifetime Annotations in Struct Definitions 结构体定义中的生命周期标注</a></h3>
<p>So far, the structs we’ve defined all hold owned types. We can define structs
to hold references, but in that case we would need to add a lifetime annotation
on every reference in the struct’s definition. Listing 10-24 has a struct named
<code>ImportantExcerpt</code> that holds a string slice.</p>
<p>目前我们定义的结构体均持有自有类型。也可定义持有引用的结构体，但需在结构体定义中为每个引用添加生命周期标注。示例 10-24 展示了持有字符串切片的结构体 <code>ImportantExcerpt</code>。</p>
<figure class="listing" id="listing-10-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-24">Listing 10-24</a>: A struct that holds a reference, requiring a lifetime annotation 需生命周期标注的持有引用的结构体</figcaption>
</figure>
<p>This struct has the single field <code>part</code> that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference
it holds in its <code>part</code> field.</p>
<p>此结构体的唯一字段 <code>part</code> 是字符串切片（引用）。与泛型数据类型类似，我们在结构体名后的尖括号内声明泛型生命周期参数名，以便在结构体定义体内使用。此标注意味着 <code>ImportantExcerpt</code> 实例的存活时间不能超过其 <code>part</code> 字段的引用。</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>. The data in <code>novel</code> exists before the <code>ImportantExcerpt</code>
instance is created. In addition, <code>novel</code> doesn’t go out of scope until after
the <code>ImportantExcerpt</code> goes out of scope, so the reference in the
<code>ImportantExcerpt</code> instance is valid.</p>
<p><code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 实例，它持有变量 <code>novel</code> 所拥 <code>String</code> 中第一句的引用。<code>novel</code> 的数据在 <code>ImportantExcerpt</code> 实例创建前已存在。此外，<code>novel</code> 在 <code>ImportantExcerpt</code> 离开作用域后才失效，因此该实例中的引用有效。</p>
<h3 id="lifetime-elision-生命周期省略"><a class="header" href="#lifetime-elision-生命周期省略">Lifetime Elision 生命周期省略</a></h3>
<p>You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, we
had a function in Listing 4-9, shown again in Listing 10-25, that compiled
without lifetime annotations.</p>
<p>我们已知每个引用都有生命周期，且需为使用引用的函数或结构体指定生命周期参数。但第四章的示例 4-9（重现为示例 10-25）中的函数在无生命周期标注的情况下编译通过。</p>
<figure class="listing" id="listing-10-25">
<span class="file-name">Filename: src/lib.rs</span>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch10-03-lifetime-syntax.html#listing-10-25">Listing 10-25</a>: A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references 参数和返回类型均为引用却无需生命周期标注的函数</figcaption>
</figure>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:</p>
<p>此函数能免于生命周期标注有其历史原因：在 Rust 早期版本（1.0 之前），所有引用均需显式生命周期，此代码无法编译。当时函数签名需写作：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.</p>
<p>随着 Rust 代码的积累，Rust 团队发现特定场景下程序员会重复编写相同的生命周期标注。这些场景可预测且遵循确定的模式。<span class="highlight">[note]开发者将这些模式编码至编译器中，使借用检查器能推断这些场景的生命周期，从而无需显式标注。</span></p>
<p>This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>这段 Rust 历史很重要，因为<span class="highlight">[note]未来可能有更多确定性模式被识别并加入编译器。</span>届时生命周期标注的需求会更少。</p>
<p>The patterns programmed into Rust’s analysis of references are called the
<em>lifetime elision rules</em>. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.</p>
<p>这些编码进 Rust 引用分析的模式称为<strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。它们并非供程序员遵循的规则，而是编译器考虑的一组特定场景。若代码符合这些场景，就无需显式标注生命周期。</p>
<p>The elision rules don’t provide full inference. If there is still ambiguity
about what lifetimes the references have after Rust applies the rules, the
compiler won’t guess what the lifetime of the remaining references should be.
Instead of guessing, the compiler will give you an error that you can resolve by
adding the lifetime annotations.</p>
<p>省略规则不提供完整推断。若应用规则后仍存在引用生命周期的歧义，编译器不会猜测剩余引用的生命周期，而是报错要求添加生命周期标注。</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and
lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>函数或方法参数的生命周期称为输入生命周期，返回值的生命周期称为输出生命周期。</p>
<p>The compiler uses three rules to figure out the lifetimes of the references
when there aren’t explicit annotations. The first rule applies to input
lifetimes, and the second and third rules apply to output lifetimes. If the
compiler gets to the end of the three rules and there are still references for
which it can’t figure out lifetimes, the compiler will stop with an error.
These rules apply to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>
<p>当无显式标注时，编译器通过三条规则推断引用的生命周期。第一条规则适用于输入生命周期，第二、三条规则适用于输出生命周期。若应用三条规则后仍有无法确定生命周期的引用，编译器将报错。这些规则适用于 <code>fn</code> 定义和 <code>impl</code> 块。</p>
<p>The first rule is that the compiler assigns a lifetime parameter to each
parameter that’s a reference. In other words, a function with one parameter
gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two
parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32,  y: &amp;'b i32)</code>; and so on.</p>
<p><span class="highlight">[note]第一条规则：编译器为每个引用参数分配一个生命周期参数。</span>即单参数函数获得一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>；双参数函数获得两个独立生命周期参数：<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>；依此类推。</p>
<p>The second rule is that, if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)  -&gt; &amp;'a i32</code>.</p>
<p><span class="highlight">[note]第二条规则：若仅有一个输入生命周期参数，则该生命周期被赋予所有输出生命周期参数</span>：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<p>The third rule is that, if there are multiple input lifetime parameters, but
one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of
<code>self</code> is assigned to all output lifetime parameters. This third rule makes
methods much nicer to read and write because fewer symbols are necessary.</p>
<p><span class="highlight">[note]第三条规则：若存在多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>（因是方法），则 <code>self</code> 的生命周期被赋予所有输出生命周期参数。</span>此规则使方法更易读写，因为所需符号更少。</p>
<p>Let’s pretend we’re the compiler. We’ll apply these rules to figure out the
lifetimes of the references in the signature of the <code>first_word</code> function in
Listing 10-25. The signature starts without any lifetimes associated with the
references:</p>
<p>假设我们是编译器，对示例 10-25 中 <code>first_word</code> 函数签名的引用应用这些规则。签名初始无关联生命周期：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it <code>'a</code> as usual, so now the signature is
this:</p>
<p>应用第一条规则：每个参数分配独立生命周期。按惯例称为 <code>'a</code>，签名变为：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:</p>
<p>因仅有一个输入生命周期，应用第二条规则：输入参数的生命周期被赋予输出生命周期，签名变为：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>现在函数签名中的所有引用均具有生命周期，编译器可继续分析而无需程序员标注此函数签名中的生命周期。</p>
<p>Let’s look at another example, this time using the <code>longest</code> function that had
no lifetime parameters when we started working with it in Listing 10-20:</p>
<p>再看另一示例，使用示例 10-20 中无生命周期参数的 <code>longest</code> 函数：</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:</p>
<p>应用第一条规则：每个参数分配独立生命周期。因有两个参数，故有两个生命周期：</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because <code>longest</code> is a
function rather than a method, so none of the parameters are <code>self</code>. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-20: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.</p>
<p>可见第二条规则不适用（输入生命周期超过一个）。第三条规则也不适用（<code>longest</code> 是函数而非方法，无 <code>self</code> 参数）。应用三条规则后，仍未确定返回类型的生命周期。这就是示例 10-20 编译错误的根源：编译器应用生命周期省略规则后仍无法确定签名中所有引用的生命周期。</p>
<p>Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.</p>
<p>因第三条规则仅适用于方法签名，接下来将在该上下文中探索生命周期，以理解为何此规则能减少方法签名中的生命周期标注。</p>
<h3 id="lifetime-annotations-in-method-definitions-方法定义中的生命周期标注"><a class="header" href="#lifetime-annotations-in-method-definitions-方法定义中的生命周期标注">Lifetime Annotations in Method Definitions 方法定义中的生命周期标注</a></h3>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters, as shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.</p>
<p>在为具有生命周期的结构体实现方法时，语法与示例 10-11 所示的泛型类型参数一致。生命周期参数的声明位置和使用方式取决于其与结构体字段或方法参数及返回值的关联。</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct’s name because those lifetimes are part
of the struct’s type.</p>
<p><span class="highlight">[note]结构体字段的生命周期名必须在 <code>impl</code> 关键字后声明，并在结构体名后使用</span>，因为这些生命周期是结构体类型的一部分。</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-24.</p>
<p>在 <code>impl</code> 块的方法签名中，引用可能与结构体字段的引用生命周期相关联，也可能独立。此外，生命周期省略规则常使方法签名无需生命周期标注。让我们以示例 10-24 定义的 <code>ImportantExcerpt</code> 结构体为例。</p>
<p>First we’ll use a method named <code>level</code> whose only parameter is a reference to
<code>self</code> and whose return value is an <code>i32</code>, which is not a reference to anything:</p>
<p>首先定义方法 <code>level</code>：其唯一参数是 <code>self</code> 的引用，返回值是 <code>i32</code>（非引用类型）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to <code>self</code> because of the first elision rule.</p>
<p><code>impl</code> 后的生命周期参数声明及类型名后的使用是必需的，但无需标注 <code>self</code> 引用的生命周期（因第一条省略规则）。</p>
<p>Here is an example where the third lifetime elision rule applies:</p>
<p>以下是应用第三条生命周期省略规则的示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<p>存在两个输入生命周期，故 Rust 应用第一条规则为 <code>&amp;self</code> 和 <code>announcement</code> 分配独立生命周期。随后因参数之一是 <code>&amp;self</code>，返回类型获得 <code>&amp;self</code> 的生命周期，所有生命周期均得到处理。</p>
<h3 id="the-static-lifetime-静态生命周期"><a class="header" href="#the-static-lifetime-静态生命周期">The Static Lifetime 静态生命周期</a></h3>
<p>One special lifetime we need to discuss is <code>'static</code>, which denotes that the
affected reference <em>can</em> live for the entire duration of the program. All
string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<p>需讨论的一个特殊生命周期是 <code>'static</code>，其表示引用<strong>可能</strong>存活于整个程序期间。所有字符串字面值均具有 <code>'static</code> 生命周期，可标注如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre></pre>
<p>The text of this string is stored directly in the program’s binary, which is
always available. Therefore, the lifetime of all string literals is <code>'static</code>.</p>
<p>此字符串文本直接存储在程序二进制文件中，始终可用。因此所有字符串字面值的生命周期为 <code>'static</code>。</p>
<p>You might see suggestions in error messages to use the <code>'static</code> lifetime. But
before specifying <code>'static</code> as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not, and whether you want it to. Most of the time, an error message
suggesting the <code>'static</code> lifetime results from attempting to create a dangling
reference or a mismatch of the available lifetimes. In such cases, the solution
is to fix those problems, not to specify the <code>'static</code> lifetime.</p>
<p>错误信息中可能出现建议使用 <code>'static</code> 生命周期的提示。但在为引用指定 <code>'static</code> 生命周期前，请思考该引用是否确实存活于整个程序期间。多数情况下，建议 <code>'static</code> 生命周期的错误源于尝试创建悬垂引用或生命周期不匹配。此时解决方案是修复问题而非指定 <code>'static</code> 生命周期。</p>
<h2 id="generic-type-parameters-trait-bounds-and-lifetimes-together-泛型类型参数trait-约束与生命周期的结合"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together-泛型类型参数trait-约束与生命周期的结合">Generic Type Parameters, Trait Bounds, and Lifetimes Together 泛型类型参数、Trait 约束与生命周期的结合</a></h2>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<p>让我们简要了解在单个函数中指定泛型类型参数、trait 约束和生命周期的语法！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-21 that returns the longer of
two string slices. But now it has an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which can be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
using <code>{}</code>, which is why the <code>Display</code> trait bound is necessary. Because
lifetimes are a type of generic, the declarations of the lifetime parameter
<code>'a</code> and the generic type parameter <code>T</code> go in the same list inside the angle
brackets after the function name.</p>
<p>这是示例 10-21 中返回较长字符串切片的 <code>longest</code> 函数。但现在增加了泛型类型 <code>T</code> 的额外参数 <code>ann</code>，该参数可由任何实现 <code>Display</code> trait 的类型填充（通过 <code>where</code> 子句指定）。此额外参数将用 <code>{}</code> 打印，故需 <code>Display</code> trait 约束。因生命周期是一种泛型，生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 的声明置于函数名后同一尖括号列表中。</p>
<h2 id="summary-总结-9"><a class="header" href="#summary-总结-9">Summary 总结</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>本章涵盖了大量内容！现在你已了解泛型类型参数、trait 与 trait 约束及泛型生命周期参数，可以编写无重复代码以适应多种不同场景。泛型类型参数使代码可应用于不同类型。trait 和 trait 约束确保即使类型是泛型的，代码也能获得所需行为。你学会了使用生命周期标注保证灵活代码不产生悬垂引用。所有这些分析均在编译时完成，不影响运行时性能！</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 18 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the Rust Reference. But next, you’ll learn how to write tests in
Rust so you can make sure your code is working the way it should.</p>
<p>信不信由你，关于本章讨论的主题还有更多内容：第十八章将讨论 trait 对象（使用 trait 的另一方式）。也可能遇到更复杂的生命周期标注场景（仅在非常高级的场景需要），此时应查阅《Rust 参考手册》。接下来你将学习如何在 Rust 中编写测试，以确保代码按预期运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-automated-tests-编写自动化测试"><a class="header" href="#writing-automated-tests-编写自动化测试">Writing Automated Tests 编写自动化测试</a></h1>
<p>In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that “program
testing can be a very effective way to show the presence of bugs, but it is
hopelessly inadequate for showing their absence.” That doesn’t mean we shouldn’t
try to test as much as we can!</p>
<p>在1972年的文章《谦卑的程序员》中，Edsger W. Dijkstra 提到：“程序测试能有效证明错误的存在，但完全不足以证明其不存在。”但这并不意味着我们不该尽可能多地测试！</p>
<p>Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rust’s type
system shoulders a huge part of this burden, but the type system cannot catch
everything. As such, Rust includes support for writing automated software tests.</p>
<p>程序的正确性是指代码按预期执行的程度。Rust 在设计时高度关注程序正确性，但正确性复杂且难以证明。Rust 的类型系统承担了大部分工作，但它无法捕获所有问题。因此，Rust 支持编写自动化软件测试。</p>
<p>Say we write a function <code>add_two</code> that adds 2 to whatever number is passed to
it. This function’s signature accepts an integer as a parameter and returns an
integer as a result. When we implement and compile that function, Rust does all
the type checking and borrow checking that you’ve learned so far to ensure
that, for instance, we aren’t passing a <code>String</code> value or an invalid reference
to this function. But Rust <em>can’t</em> check that this function will do precisely
what we intend, which is return the parameter plus 2 rather than, say, the
parameter plus 10 or the parameter minus 50! That’s where tests come in.</p>
<p>假设我们编写函数 <code>add_two</code>，它将传入的数字加 2。该函数签名接受整数参数并返回整数结果。当我们实现并编译该函数时，Rust 会执行所有类型检查和借用检查（正如你目前所学），以确保不会向此函数传递 <code>String</code> 值或无效引用。但 Rust <strong>无法</strong>检查该函数是否精确执行了我们的意图——即返回参数加 2，而不是参数加 10 或减 50！这正是测试的用武之地。</p>
<p>We can write tests that assert, for example, that when we pass <code>3</code> to the
<code>add_two</code> function, the returned value is <code>5</code>. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.</p>
<p>我们可以编写测试来断言：当向 <code>add_two</code> 函数传入 <code>3</code> 时，返回值是 <code>5</code>。每当修改代码时，我们都可以运行这些测试，以确保现有正确行为未被改变。</p>
<p>Testing is a complex skill: although we can’t cover in one chapter every detail
about how to write good tests, in this chapter we will discuss the mechanics of
Rust’s testing facilities. We’ll talk about the annotations and macros
available to you when writing your tests, the default behavior and options
provided for running your tests, and how to organize tests into unit tests and
integration tests.</p>
<p>测试是项复杂技能：虽然本章无法涵盖编写优秀测试的所有细节，但我们将讨论 Rust 测试工具的核心机制。我们会介绍编写测试时可用的注解和宏、运行测试的默认行为和选项，以及如何将测试组织为单元测试和集成测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-to-write-tests-如何编写测试"><a class="header" href="#how-to-write-tests-如何编写测试">How to Write Tests 如何编写测试</a></h2>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<p>测试是用于验证非测试代码是否按预期方式运行的 Rust 函数。测试函数通常执行以下三个操作：</p>
<ul>
<li>Set up any needed data or state.</li>
<li>设置所需数据或状态</li>
<li>Run the code you want to test.</li>
<li>运行要测试的代码</li>
<li>Assert that the results are what you expect.</li>
<li>断言结果符合预期</li>
</ul>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<p>让我们看看 Rust 为这些操作提供的功能，包括 <code>test</code> 属性、几个宏和 <code>should_panic</code> 属性。</p>
<h3 id="the-anatomy-of-a-test-function-测试函数剖析"><a class="header" href="#the-anatomy-of-a-test-function-测试函数剖析">The Anatomy of a Test Function 测试函数剖析</a></h3>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the annotated functions and reports on whether each test function passes or
fails.</p>
<p>最简单的 Rust 测试是一个用 <code>test</code> 属性标注的函数。属性是 Rust 代码的元数据；例如我们在第五章为结构体使用的 <code>derive</code> 属性。<span class="highlight">[note]要将函数转为测试函数，需在 <code>fn</code> 前添加 <code>#[test]</code>。</span>当使用 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试运行程序二进制文件来执行带注解的函数，并报告每个测试函数的通过或失败情况。</p>
<p>Whenever we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module gives you a
template for writing your tests so you don’t have to look up the exact
structure and syntax every time you start a new project. You can add as many
additional test functions and as many test modules as you want!</p>
<p>当我们用 Cargo 创建新的库项目时，它会自动生成包含测试函数的测试模块。该模块为编写测试提供了模板，无需每次新建项目时都查找确切结构和语法。你可以根据需要添加任意数量的测试函数和测试模块！</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test before we actually test any code. Then we’ll write some real-world tests
that call some code that we’ve written and assert that its behavior is correct.</p>
<p>我们将通过模板测试实验测试的工作机制，然后再实际测试代码。接着会编写调用已实现代码的真实测试，并断言其行为正确。</p>
<p>Let’s create a new library project called <code>adder</code> that will add two numbers:</p>
<p>创建名为 <code>adder</code> 的新库项目来对数字求和：</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like
Listing 11-1.</p>
<p><code>adder</code> 库中 <em>src/lib.rs</em> 文件的内容应如示例 11-1 所示。</p>
<figure class="listing" id="listing-11-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-1">Listing 11-1</a>: The code generated automatically by <code>cargo new</code> <code>cargo new</code> 自动生成的代码</figcaption>
</figure>
<p>The file starts with an example <code>add</code> function, so that we have something
to test.</p>
<p>文件以示例 <code>add</code> 函数开头，以便我们有测试目标。</p>
<p>For now, let’s focus solely on the <code>it_works</code> function. Note the <code>#[test]</code>
annotation: this attribute indicates this is a test function, so the test
runner knows to treat this function as a test. We might also have non-test
functions in the <code>tests</code> module to help set up common scenarios or perform
common operations, so we always need to indicate which functions are tests.</p>
<p>现在，让我们专注于 <code>it_works</code> 函数。注意 <code>#[test]</code> 注解：该属性表示这是测试函数，测试运行器会将其视为测试。<code>tests</code> 模块中可能还有用于设置公共场景或执行公共操作的非测试函数，因此我们始终需要标注哪些函数是测试。</p>
<p>The example function body uses the <code>assert_eq!</code> macro to assert that <code>result</code>,
which contains the result of calling <code>add</code> with 2 and 2, equals 4. This
assertion serves as an example of the format for a typical test. Let’s run it
to see that this test passes.</p>
<p>示例函数体使用 <code>assert_eq!</code> 宏断言调用 <code>add(2, 2)</code> 的结果 <code>result</code> 等于 4。该断言展示了典型测试的格式。运行它可以看到测试通过。</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2.</p>
<p><code>cargo test</code> 命令运行项目中的所有测试，如示例 11-2 所示。</p>
<figure class="listing" id="listing-11-2">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-2">Listing 11-2</a>: The output from running the automatically generated test 运行自动生成测试的输出</figcaption>
</figure>
<p>Cargo compiled and ran the test. We see the line <code>running 1 test</code>. The next
line shows the name of the generated test function, called <code>tests::it_works</code>,
and that the result of running that test is <code>ok</code>. The overall summary <code>test  result: ok.</code> means that all the tests passed, and the portion that reads <code>1  passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>Cargo 编译并运行了测试。我们看到 <code>running 1 test</code> 行。下一行显示生成的测试函数名 <code>tests::it_works</code>，其运行结果为 <code>ok</code>。总结行 <code>test result: ok.</code> 表示所有测试通过，<code>1 passed; 0 failed</code> 部分统计了通过和失败的测试数。</p>
<p>It’s possible to mark a test as ignored so it doesn’t run in a particular
instance; we’ll cover that in the “Ignoring Some Tests Unless Specifically
Requested” section later in this chapter. Because we
haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an
argument to the <code>cargo test</code> command to run only tests whose name matches a
string; this is called <em>filtering</em> and we’ll cover it in the “Running a
Subset of Tests by Name” section. Here we haven’t
filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>可以将测试标记为忽略（ignored）使其在特定情况下不运行；本章稍后的“除非特别指定否则忽略某些测试”部分将介绍这一点。由于我们未使用该功能，总结显示 <code>0 ignored</code>。我们还可以向 <code>cargo test</code> 命令传递参数，仅运行名称匹配字符串的测试（称为<em>过滤</em>），这将在“按名称运行测试子集”部分介绍。这里未过滤运行的测试，因此总结末尾显示 <code>0 filtered out</code>。</p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
the documentation about benchmark tests to learn more.</p>
<p>基准测试的统计数据 <code>0 measured</code> 用于衡量性能。基准测试目前仅在 Rust 的 nightly 版本中可用。请参阅基准测试的文档以了解更多信息。</p>
<p>The next part of the test output starting at <code>Doc-tests adder</code> is for the
results of any documentation tests. We don’t have any documentation tests yet,
but Rust can compile any code examples that appear in our API documentation.
This feature helps keep your docs and your code in sync! We’ll discuss how to
write documentation tests in the “Documentation Comments as
Tests” section of Chapter 14. For now, we’ll
ignore the <code>Doc-tests</code> output.</p>
<p>测试输出中从 <code>Doc-tests adder</code> 开始的部分是文档测试的结果。我们尚无文档测试，但 Rust 可以编译 API 文档中出现的任何代码示例。此功能有助于保持文档与代码同步！我们将在第十四章的“将文档注释作为测试”部分讨论如何编写文档测试。现在暂时忽略 <code>Doc-tests</code> 输出。</p>
<p>Let’s start to customize the test to our own needs. First, change the name of
the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p>现在开始根据需求定制测试。首先将 <code>it_works</code> 函数重命名为 <code>exploration</code>：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<p>再次运行 <code>cargo test</code>，输出现在显示 <code>exploration</code> 而非 <code>it_works</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Now we’ll add another test, but this time we’ll make a test that fails! Tests
fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. In Chapter 9, we talked about how the simplest way to panic
is to call the <code>panic!</code> macro. Enter the new test as a function named
<code>another</code>, so your <em>src/lib.rs</em> file looks like Listing 11-3.</p>
<p>现在添加另一个测试，但这次让它失败！当测试函数中出现 panic 时测试失败。<span class="highlight">[note]每个测试在新线程中运行</span>，当主线程检测到测试线程终止时，该测试被标记为失败。第九章提到，触发 panic 最简单的方式是调用 <code>panic!</code> 宏。添加名为 <code>another</code> 的新测试，使 <em>src/lib.rs</em> 如示例 11-3 所示。</p>
<figure class="listing" id="listing-11-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-3">Listing 11-3</a>: Adding a second test that will fail because we call the <code>panic!</code> macro 添加第二个会因调用 <code>panic!</code> 宏而失败的测试</figcaption>
</figure>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<p>再次运行 <code>cargo test</code>，输出应如示例 11-4 所示，表明 <code>exploration</code> 测试通过而 <code>another</code> 失败。</p>
<figure class="listing" id="listing-11-4">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-4">Listing 11-4</a>: Test results when one test passes and one test fails 一个测试通过、一个测试失败时的测试结果</figcaption>
</figure>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
displays the detailed reason for each test failure. In this case, we get the
details that <code>tests::another</code> failed because it panicked with the message <code>Make  this test fail</code> on line 17 in the <em>src/lib.rs</em> file. The next section lists
just the names of all the failing tests, which is useful when there are lots of
tests and lots of detailed failing test output. We can use the name of a
failing test to run just that test to more easily debug it; we’ll talk more
about ways to run tests in the “Controlling How Tests Are
Run” section.</p>
<p><code>test tests::another</code> 行显示 <code>FAILED</code> 而非 <code>ok</code>。单个结果和总结之间出现两个新部分：第一部分详细说明每个测试失败的原因。本例中，<code>tests::another</code> 在 <em>src/lib.rs</em> 文件的第 17 行因 <code>Make this test fail</code> 消息而 panic。下一部分仅列出所有失败测试的名称，这在测试众多且失败输出详细时非常有用。我们可以使用失败测试的名称单独运行它以方便调试；“控制测试的运行方式”部分将详细介绍运行测试的方法。</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We
had one test pass and one test fail.</p>
<p>总结行显示在最后：总体测试结果为 <code>FAILED</code>。我们有一个测试通过，一个测试失败。</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<p>现在你已了解不同场景下的测试结果，让我们看看除 <code>panic!</code> 外其他在测试中有用的宏。</p>
<h3 id="checking-results-with-the-assert-macro-使用-assert-宏检查结果"><a class="header" href="#checking-results-with-the-assert-macro-使用-assert-宏检查结果">Checking Results with the <code>assert!</code> Macro 使用 <code>assert!</code> 宏检查结果</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the
<code>assert!</code> macro calls <code>panic!</code> to cause the test to fail. Using the <code>assert!</code>
macro helps us check that our code is functioning in the way we intend.</p>
<p>标准库提供的 <code>assert!</code> 宏用于确保测试中的条件评估为 <code>true</code>。我们向 <code>assert!</code> 宏传递一个布尔值参数。若值为 <code>true</code>，无事发生且测试通过；若为 <code>false</code>，<code>assert!</code> 宏调用 <code>panic!</code> 导致测试失败。使用 <code>assert!</code> 宏有助于验证代码是否按预期运行。</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file, then write some tests for it using the <code>assert!</code> macro.</p>
<p>第五章的示例 5-15 使用了 <code>Rectangle</code> 结构体和 <code>can_hold</code> 方法，它们在示例 11-5 中重复出现。我们将此代码放入 <em>src/lib.rs</em> 文件，然后用 <code>assert!</code> 宏为其编写测试。</p>
<figure class="listing" id="listing-11-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-5">Listing 11-5</a>: The <code>Rectangle</code> struct and its <code>can_hold</code> method from Chapter 5 来自第五章的 <code>Rectangle</code> 结构体及其 <code>can_hold</code> 方法</figcaption>
</figure>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and
a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that
has a width of 5 and a height of 1.</p>
<p><code>can_hold</code> 方法返回布尔值，是 <code>assert!</code> 宏的完美用例。在示例 11-6 中，我们通过创建宽 8 高 7 的 <code>Rectangle</code> 实例来测试 <code>can_hold</code> 方法，并断言它可以容纳宽 5 高 1 的另一个 <code>Rectangle</code> 实例。</p>
<figure class="listing" id="listing-11-6">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-6">Listing 11-6</a>: A test for <code>can_hold</code> that checks whether a larger rectangle can indeed hold a smaller rectangle 测试 <code>can_hold</code>：检查较大矩形是否能容纳较小矩形</figcaption>
</figure>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is
a regular module that follows the usual visibility rules we covered in Chapter
7 in the “Paths for Referring to an Item in the Module
Tree”
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here, so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>注意 <code>tests</code> 模块内的 <code>use super::*;</code> 行。<code>tests</code> 是遵循第七章“模块树中引用项的路径”部分介绍的常规可见性规则的普通模块。由于 <code>tests</code> 是内部模块，我们需要将外部模块中待测试的代码引入内部模块的作用域。这里使用全局导入（glob），因此外部模块定义的任何内容对 <code>tests</code> 模块都可用。</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<p>我们将测试命名为 <code>larger_can_hold_smaller</code>，并创建所需两个 <code>Rectangle</code> 实例。接着调用 <code>assert!</code> 宏并传入 <code>larger.can_hold(&amp;smaller)</code> 的结果。该表达式应返回 <code>true</code>，因此测试应通过。让我们验证一下！</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p>确实通过了！现在添加另一个测试，断言较小矩形无法容纳较大矩形：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<p>由于此场景中 <code>can_hold</code> 的正确结果是 <code>false</code>，我们需要在传递给 <code>assert!</code> 宏前取反该结果。因此，若 <code>can_hold</code> 返回 <code>false</code>，测试将通过：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code>
method by replacing the greater-than sign with a less-than sign when it
compares the widths:</p>
<p>两个测试均通过！现在看看在代码中引入错误时测试结果如何变化。我们将 <code>can_hold</code> 方法中比较宽度的大于号改为小于号：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running the tests now produces the following:</p>
<p>现在运行测试会产生以下结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is
<code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<p>测试捕获了错误！因为 <code>larger.width</code> 是 <code>8</code> 而 <code>smaller.width</code> 是 <code>5</code>，<code>can_hold</code> 中的宽度比较现在返回 <code>false</code>：8 不小于 5。</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros-使用-assert_eq-和-assert_ne-宏测试相等性"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros-使用-assert_eq-和-assert_ne-宏测试相等性">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros 使用 <code>assert_eq!</code> 和 <code>assert_ne!</code> 宏测试相等性</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could
do this by using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, without printing the values that led to the <code>false</code> value.</p>
<p>验证功能的常见方法是测试被测代码的结果与预期返回值是否相等。可以使用 <code>assert!</code> 宏传递 <code>==</code> 运算符的表达式实现。但这是如此常见的测试，以至于标准库提供了一对宏——<code>assert_eq!</code> 和 <code>assert_ne!</code>——来更便捷地执行此测试。这些宏分别比较两个参数是否相等或不相等。若断言失败，它们还会打印两个值，便于查看失败<em>原因</em>；而 <code>assert!</code> 宏仅显示 <code>==</code> 表达式得到 <code>false</code> 值，不打印导致 <code>false</code> 的值。</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter, then we test this function using the <code>assert_eq!</code> macro.</p>
<p>在示例 11-7 中，我们编写函数 <code>add_two</code> 将参数加 <code>2</code>，然后用 <code>assert_eq!</code> 宏测试该函数。</p>
<figure class="listing" id="listing-11-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-7">Listing 11-7</a>: Testing the function <code>add_two</code> using the <code>assert_eq!</code> macro 使用 <code>assert_eq!</code> 宏测试函数 <code>add_two</code></figcaption>
</figure>
<p>Let’s check that it passes!</p>
<p>运行验证是否通过：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We create a variable named <code>result</code> that holds the result of calling
<code>add_two(2)</code>. Then we pass <code>result</code> and <code>4</code> as the arguments to the
<code>assert_eq!</code> macro. The output line for this test is <code>test tests::it_adds_two  ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>我们创建变量 <code>result</code> 保存调用 <code>add_two(2)</code> 的结果，然后将 <code>result</code> 和 <code>4</code> 作为参数传递给 <code>assert_eq!</code> 宏。该测试的输出行是 <code>test tests::it_adds_two ... ok</code>，其中 <code>ok</code> 表示测试通过！</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<p>现在在代码中引入错误，将 <code>add_two</code> 函数的实现改为加 <code>3</code>：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Run the tests again:</p>
<p>再次运行测试：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our test caught the bug! The <code>tests::it_adds_two</code> test failed, and the message
tells us that the assertion that failed was <code>left == right</code> and what the <code>left</code>
and <code>right</code> values are. This message helps us start debugging: the <code>left</code>
argument, where we had the result of calling <code>add_two(2)</code>, was <code>5</code> but the
<code>right</code> argument was <code>4</code>. You can imagine that this would be especially helpful
when we have a lot of tests going on.</p>
<p>测试捕获了错误！<code>tests::it_adds_two</code> 测试失败，消息指出失败的断言是 <code>left == right</code> 并显示了 <code>left</code> 和 <code>right</code> 的值。这有助于我们开始调试：<code>left</code> 参数（即 <code>add_two(2)</code> 的调用结果）是 <code>5</code>，而 <code>right</code> 参数是 <code>4</code>。可以想象，这在测试众多时尤其有用。</p>
<p>Note that in some languages and test frameworks, the parameters to equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Rust, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value
the code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(4, result)</code>, which would result in the same failure message that
displays <code> assertion `left == right` failed</code>.</p>
<p>注意，在某些语言和测试框架中，相等断言函数的参数称为 <code>expected</code> 和 <code>actual</code>，指定参数的顺序很重要。但在 Rust 中，它们称为 <code>left</code> 和 <code>right</code>，指定期望值和代码产生值的顺序无关紧要。本测试中的断言可写为 <code>assert_eq!(4, result)</code>，失败消息同样显示 <code> assertion `left == right` failed</code>。</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but the way in which the input is changed depends on the day of
the week that we run our tests, the best thing to assert might be that the
output of the function is not equal to the input.</p>
<p><code>assert_ne!</code> 宏在给定两个值不相等时通过，相等时失败。当我们不确定值<em>将</em>是什么，但明确知道它<em>不应</em>是什么时，此宏最有用。例如，若测试一个保证会以某种方式修改输入的函数，而修改方式取决于运行测试的星期几，此时最好的断言可能是函数的输出不等于输入。</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of
the standard library types implement these traits. For structs and enums that
you define yourself, you’ll need to implement <code>PartialEq</code> to assert equality of
those types. You’ll also need to implement <code>Debug</code> to print the values when the
assertion fails. Because both traits are derivable traits, as mentioned in
Listing 5-12 in Chapter 5, this is usually as straightforward as adding the
<code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See
Appendix C, “Derivable Traits,” for more
details about these and other derivable traits.</p>
<p><span class="highlight">[note]在底层，<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏分别使用 <code>==</code> 和 <code>!=</code> 运算符。断言失败时，这些宏使用调试格式打印参数，这意味着被比较的值必须实现 <code>PartialEq</code> 和 <code>Debug</code> 特征。</span>所有基本类型和大多数标准库类型都实现了这些特征。对于自定义的结构体和枚举，需要实现 <code>PartialEq</code> 才能断言其相等性，还需实现 <code>Debug</code> 才能在断言失败时打印值。由于这两个特征都是可派生的（如第五章的示例 5-12 所述），通常只需在结构体或枚举定义中添加 <code>#[derive(PartialEq, Debug)]</code> 注解即可。更多细节见附录 C 的“可派生特征”。</p>
<h3 id="adding-custom-failure-messages-添加自定义失败消息"><a class="header" href="#adding-custom-failure-messages-添加自定义失败消息">Adding Custom Failure Messages 添加自定义失败消息</a></h3>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in “Concatenation with the <code>+</code> Operator or the
<code>format!</code> Macro” in Chapter 8), so you can pass a format string that contains <code>{}</code>
placeholders and values to go in those placeholders. Custom messages are useful
for documenting what an assertion means; when a test fails, you’ll have a better
idea of what the problem is with the code.</p>
<p>你还<span class="highlight">[note]可以向 <code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏传递可选参数作为自定义消息，随失败消息一起打印。在必需参数后指定的任何参数都会传递给 <code>format!</code> 宏</span>（第八章“使用 <code>+</code> 运算符或 <code>format!</code> 宏进行拼接”中讨论过），因此可以传递包含 <code>{}</code> 占位符的格式字符串及其填充值。自定义消息有助于记录断言的含义；测试失败时，你能更好地理解代码的问题所在。</p>
<p>For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:</p>
<p>例如，假设有函数根据名字问候他人，我们需要测试传入函数的名字是否出现在输出中：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
<code>greeting</code> function, we’ll just assert that the output contains the text of the
input parameter.</p>
<p>该程序的需求尚未确定，我们非常确定问候语开头的 <code>Hello</code> 文本会更改。为避免需求变更时更新测试，我们决定不检查 <code>greeting</code> 函数返回值的完全相等性，仅断言输出包含输入参数的文本。</p>
<p>Now let’s introduce a bug into this code by changing <code>greeting</code> to exclude
<code>name</code> to see what the default test failure looks like:</p>
<p>现在通过修改 <code>greeting</code> 函数排除 <code>name</code> 来引入错误，观察默认测试失败情况：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running this test produces the following:</p>
<p>运行此测试产生以下结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message would print the value from the
<code>greeting</code> function. Let’s add a custom failure message composed of a format
string with a placeholder filled in with the actual value we got from the
<code>greeting</code> function:</p>
<p>此结果仅表明断言失败及其所在行号。更有用的失败消息应打印 <code>greeting</code> 函数的值。让我们添加由格式字符串和实际值填充的自定义失败消息：</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<p>现在运行测试时，会得到信息更丰富的错误消息：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<p>我们可以在测试输出中看到实际获得的值，这有助于调试实际发生的情况与预期情况的差异。</p>
<h3 id="checking-for-panics-with-should_panic-使用-should_panic-检查-panic"><a class="header" href="#checking-for-panics-with-should_panic-使用-should_panic-检查-panic">Checking for Panics with <code>should_panic</code> 使用 <code>should_panic</code> 检查 panic</a></h3>
<p>In addition to checking return values, it’s important to check that our code
handles error conditions as we expect. For example, consider the <code>Guess</code> type
that we created in Chapter 9, Listing 9-13. Other code that uses <code>Guess</code>
depends on the guarantee that <code>Guess</code> instances will contain only values
between 1 and 100. We can write a test that ensures that attempting to create a
<code>Guess</code> instance with a value outside that range panics.</p>
<p>除了检查返回值，确保代码按预期处理错误条件也很重要。例如，回顾第九章示例 9-13 创建的 <code>Guess</code> 类型。使用 <code>Guess</code> 的其他代码依赖于 <code>Guess</code> 实例仅包含 1 到 100 之间值的保证。我们可以编写测试来确保尝试在此范围外创建 <code>Guess</code> 实例会触发 panic。</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The
test passes if the code inside the function panics; the test fails if the code
inside the function doesn’t panic.</p>
<p>为此，需将 <code>should_panic</code> 属性添加到测试函数。如果函数内的代码触发 panic，测试通过；如果未触发 panic，测试失败。</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect them to.</p>
<p><span class="highlight">[note]示例 11-8 展示了测试 <code>Guess::new</code> 在预期条件下触发错误的测试。</span></p>
<figure class="listing" id="listing-11-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-8">Listing 11-8</a>: Testing that a condition will cause a <code>panic!</code> 测试条件是否导致 <code>panic!</code></figcaption>
</figure>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<p>我们将 <code>#[should_panic]</code> 属性放在 <code>#[test]</code> 属性之后、测试函数之前。观察测试通过时的结果：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<p>运行良好！现在通过移除 <code>new</code> 函数在值大于 100 时触发 panic 的条件来引入错误：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<p>运行示例 11-8 的测试时，它将失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>此情况下我们未获得非常有用的消息，但查看测试函数可见其标注了 <code>#[should_panic]</code>。得到的失败意味着测试函数中的代码未触发 panic。</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would
pass even if the test panics for a different reason from the one we were
expecting. To make <code>should_panic</code> tests more precise, we can add an optional
<code>expected</code> parameter to the <code>should_panic</code> attribute. The test harness will
make sure that the failure message contains the provided text. For example,
consider the modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function
panics with different messages depending on whether the value is too small or
too large.</p>
<p>使用 <code>should_panic</code> 的测试可能不够精确。即使测试因非预期原因 panic，<code>should_panic</code> 测试也会通过。<span class="highlight">[note]为使 <code>should_panic</code> 测试更精确，可向 <code>should_panic</code> 属性添加可选的 <code>expected</code> 参数。</span>测试工具将确保失败消息包含提供的文本。例如，修改示例 11-9 中 <code>Guess</code> 的代码，使 <code>new</code> 函数根据值过小或过大触发不同的消息。</p>
<figure class="listing" id="listing-11-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="ch11-01-writing-tests.html#listing-11-9">Listing 11-9</a>: Testing for a <code>panic!</code> with a panic message containing a specified substring 测试 <code>panic!</code> 消息是否包含指定子串</figcaption>
</figure>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to  100, got 200</code>. What you choose to specify depends on how much of the panic
message is unique or dynamic and how precise you want your test to be. In this
case, a substring of the panic message is enough to ensure that the code in the
test function executes the <code>else if value &gt; 100</code> case.</p>
<p>此测试将通过，因为我们在 <code>should_panic</code> 属性的 <code>expected</code> 参数中提供的文本是 <code>Guess::new</code> 函数 panic 消息的子串。我们可以指定完整的预期 panic 消息（本例中为 <code>Guess value must be less than or equal to 100, got 200</code>）。具体指定内容取决于 panic 消息的唯一性或动态性程度，以及你期望测试的精确度。本例中，panic 消息的子串足以确保测试函数执行了 <code>else if value &gt; 100</code> 分支。</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<p>为观察带 <code>expected</code> 消息的 <code>should_panic</code> 测试失败的情况，让我们再次引入错误——交换 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 块的内容：</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<p>此时运行 <code>should_panic</code> 测试将失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>less than or equal  to 100</code>. The panic message that we did get in this case was <code>Guess value must  be greater than or equal to 1, got 200.</code> Now we can start figuring out where
our bug is!</p>
<p>失败消息表明测试确实如预期 panic 了，但 panic 消息未包含预期的 <code>less than or equal to 100</code> 字符串。实际得到的 panic 消息是 <code>Guess value must be greater than or equal to 1, got 200.</code>。现在我们可以开始定位错误了！</p>
<h3 id="using-resultt-e-in-tests-在测试中使用-resultt-e"><a class="header" href="#using-resultt-e-in-tests-在测试中使用-resultt-e">Using <code>Result&lt;T, E&gt;</code> in Tests 在测试中使用 <code>Result&lt;T, E&gt;</code></a></h3>
<p>Our tests so far all panic when they fail. We can also write tests that use
<code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code>Result&lt;T,  E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<p>目前的测试在失败时都会 panic。我们也可以编写使用 <code>Result&lt;T, E&gt;</code> 的测试！下面是示例 11-1 的测试改写为使用 <code>Result&lt;T, E&gt;</code> 并在失败时返回 <code>Err</code> 而非 panic 的版本：</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>The <code>it_works</code> function now has the <code>Result&lt;(), String&gt;</code> return type. In the
body of the function, rather than calling the <code>assert_eq!</code> macro, we return
<code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test
fails.</p>
<p><code>it_works</code> 函数现在返回 <code>Result&lt;(), String&gt;</code> 类型。在函数体中，不再调用 <code>assert_eq!</code> 宏，而是在测试通过时返回 <code>Ok(())</code>，失败时返回包含 <code>String</code> 的 <code>Err</code>。</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p><span class="highlight">[note]将测试编写为返回 <code>Result&lt;T, E&gt;</code> 的形式，允许在测试体中使用问号运算符</span>，这在测试内部操作返回 <code>Err</code> 变体时应失败的情况下非常方便。</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T,  E&gt;</code>. To assert that an operation returns an <code>Err</code> variant, <em>don’t</em> use the
question mark operator on the <code>Result&lt;T, E&gt;</code> value. Instead, use
<code>assert!(value.is_err())</code>.</p>
<p><span class="highlight">[note]不能对使用 <code>Result&lt;T, E&gt;</code> 的测试使用 <code>#[should_panic]</code> 注解。</span>要断言操作返回 <code>Err</code> 变体，请<em>勿</em>对 <code>Result&lt;T, E&gt;</code> 值使用问号运算符，而应使用 <code>assert!(value.is_err())</code>。</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo  test</code>.</p>
<p>现在你已了解多种编写测试的方法，接下来让我们探索运行测试时发生的情况及 <code>cargo test</code> 的不同选项。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlling-how-tests-are-run-控制测试的运行方式"><a class="header" href="#controlling-how-tests-are-run-控制测试的运行方式">Controlling How Tests Are Run 控制测试的运行方式</a></h2>
<p>Just as <code>cargo run</code> compiles your code and then runs the resultant binary,
<code>cargo test</code> compiles your code in test mode and runs the resultant test
binary. The default behavior of the binary produced by <code>cargo test</code> is to run
all the tests in parallel and capture output generated during test runs,
preventing the output from being displayed and making it easier to read the
output related to the test results. You can, however, specify command line
options to change this default behavior.</p>
<p>正如 <code>cargo run</code> 会编译代码并运行生成的二进制文件，<code>cargo test</code> 会在测试模式下编译代码并运行生成的测试二进制文件。<code>cargo test</code> 生成的二进制文件<span class="highlight">[note]默认行为是并行运行所有测试</span>，并捕获测试运行期间的输出，防止输出显示在终端上，从而更易于阅读与测试结果相关的输出。但您也可以通过命令行选项更改此默认行为。</p>
<p>Some command line options go to <code>cargo test</code>, and some go to the resultant test
binary. To separate these two types of arguments, you list the arguments that
go to <code>cargo test</code> followed by the separator <code>--</code> and then the ones that go to
the test binary. Running <code>cargo test --help</code> displays the options you can use
with <code>cargo test</code>, and running <code>cargo test -- --help</code> displays the options you
can use after the separator. Those options are also documented in the “Tests”
section of the the rustc book.</p>
<p><span class="highlight">[note]部分命令行选项传递给 <code>cargo test</code>，部分则传递给生成的测试二进制文件。为区分这两类参数，需先列出传递给 <code>cargo test</code> 的参数，后跟分隔符 <code>--</code>，再列出传递给测试二进制文件的参数。</span>运行 <code>cargo test --help</code> 可查看 <code>cargo test</code> 支持的选项，运行 <code>cargo test -- --help</code> 则显示分隔符后可用的选项。这些选项也记录在 rustc 文档的 “Tests” 部分。</p>
<h3 id="running-tests-in-parallel-or-consecutively-并行或串行运行测试"><a class="header" href="#running-tests-in-parallel-or-consecutively-并行或串行运行测试">Running Tests in Parallel or Consecutively 并行或串行运行测试</a></h3>
<p>When you run multiple tests, by default they run in parallel using threads,
meaning they finish running faster and you get feedback quicker. Because the
tests are running at the same time, you must make sure your tests don’t depend
on each other or on any shared state, including a shared environment, such as
the current working directory or environment variables.</p>
<p>当运行多个测试时，默认会使用线程并行执行，这意味着它们能更快完成并提供更快的反馈。由于测试同时运行，必须确保测试不相互依赖，也不依赖任何共享状态（包括共享环境，如当前工作目录或环境变量）。</p>
<p>For example, say each of your tests runs some code that creates a file on disk
named <em>test-output.txt</em> and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file in the time between another test writing and
reading the file. The second test will then fail, not because the code is
incorrect but because the tests have interfered with each other while running
in parallel. One solution is to make sure each test writes to a different file;
another solution is to run the tests one at a time.</p>
<p>例如，假设每个测试都执行创建磁盘文件 <em>test-output.txt</em> 并写入数据的代码，随后读取该文件并断言其包含特定值（各测试的值不同）。由于测试并行运行，一个测试可能在另一个测试写入后读取前覆盖该文件，导致后者失败——并非代码有误，而是并行运行时测试相互干扰。解决方案之一是确保每个测试写入不同文件；另一种方案是每次只运行一个测试。</p>
<p>If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the <code>--test-threads</code> flag
and the number of threads you want to use to the test binary. Take a look at
the following example:</p>
<p>若不想并行运行测试，或需更精细控制线程数，可<span class="highlight">[note]向测试二进制文件传递 <code>--test-threads</code> 标志及所需线程数</span>。示例如下：</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to <code>1</code>, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.</p>
<p>将测试线程数设为 <code>1</code> 表示禁用并行。单线程运行测试虽比并行耗时更长，但能避免共享状态时的相互干扰。</p>
<h3 id="showing-function-output-显示函数输出"><a class="header" href="#showing-function-output-显示函数输出">Showing Function Output 显示函数输出</a></h3>
<p>By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call <code>println!</code> in a test and the test
passes, we won’t see the <code>println!</code> output in the terminal; we’ll see only the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.</p>
<p>默认情况下，若测试通过，Rust 测试库会捕获所有标准输出。例如，测试中调用 <code>println!</code> 且测试通过时，终端不会显示 <code>println!</code> 的输出，仅显示测试通过的提示行。若测试失败，则会在失败信息中显示标准输出的内容。</p>
<p>As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.</p>
<p>例如，示例 11-10 包含一个输出参数值并返回 10 的简单函数，以及一个通过测试和一个失败测试。</p>
<figure class="listing" id="listing-11-10">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
<figcaption><a href="ch11-02-running-tests.html#listing-11-10">Listing 11-10</a>: Tests for a function that calls <code>println!</code> 调用 <code>println!</code> 的函数的测试</figcaption>
</figure>
<p>When we run these tests with <code>cargo test</code>, we’ll see the following output:</p>
<p>使用 <code>cargo test</code> 运行这些测试时，输出如下：</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is
printed when the test that passes runs. That output has been captured. The
output from the test that failed, <code>I got the value 8</code>, appears in the section
of the test summary output, which also shows the cause of the test failure.</p>
<p>注意输出中未出现 <code>I got the value 4</code>（通过测试时的打印内容），该输出已被捕获。失败测试的输出 <code>I got the value 8</code> 出现在测试摘要中，并显示了失败原因。</p>
<p>If we want to see printed values for passing tests as well, we can tell Rust to
also show the output of successful tests with <code>--show-output</code>:</p>
<p>若需查看通过测试的打印值，可<span class="highlight">[note]通过 <code>--show-output</code> 标志让 Rust 显示成功测试的输出</span>：</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>When we run the tests in Listing 11-10 again with the <code>--show-output</code> flag, we
see the following output:</p>
<p>使用 <code>--show-output</code> 标志再次运行示例 11-10 的测试，输出如下：</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="running-a-subset-of-tests-by-name-按名称运行测试子集"><a class="header" href="#running-a-subset-of-tests-by-name-按名称运行测试子集">Running a Subset of Tests by Name 按名称运行测试子集</a></h3>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>cargo test</code> the name
or names of the test(s) you want to run as an argument.</p>
<p>完整测试套件可能耗时较长。若仅需测试特定代码，可向 <code>cargo test</code> 传递要运行的测试名称作为参数。</p>
<p>To demonstrate how to run a subset of tests, we’ll first create three tests for
our <code>add_two</code> function, as shown in Listing 11-11, and choose which ones to run.</p>
<p>为演示如何运行测试子集，我们先为 <code>add_two</code> 函数创建三个测试（如示例 11-11 所示），并选择运行部分测试。</p>
<figure class="listing" id="listing-11-11">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
<figcaption><a href="ch11-02-running-tests.html#listing-11-11">Listing 11-11</a>: Three tests with three different names 三个不同名称的测试</figcaption>
</figure>
<p>If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:</p>
<p>不传递参数运行测试时，所有测试会并行执行：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="running-single-tests-运行单个测试"><a class="header" href="#running-single-tests-运行单个测试">Running Single Tests 运行单个测试</a></h4>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<p>向 <code>cargo test</code> 传递单个测试函数名可仅运行该测试：</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Only the test with the name <code>one_hundred</code> ran; the other two tests didn’t match
that name. The test output lets us know we had more tests that didn’t run by
displaying <code>2 filtered out</code> at the end.</p>
<p>仅名为 <code>one_hundred</code> 的测试运行，其他测试因名称不匹配而被跳过。输出末尾的 <code>2 filtered out</code> 提示有两个测试未执行。</p>
<p>We can’t specify the names of multiple tests in this way; only the first value
given to <code>cargo test</code> will be used. But there is a way to run multiple tests.</p>
<p>此方式不能指定多个测试名，只有 <code>cargo test</code> 接收的第一个参数有效。但仍有方法运行多个测试。</p>
<h4 id="filtering-to-run-multiple-tests-过滤运行多个测试"><a class="header" href="#filtering-to-run-multiple-tests-过滤运行多个测试">Filtering to Run Multiple Tests 过滤运行多个测试</a></h4>
<p>We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain <code>add</code>, we can
run those two by running <code>cargo test add</code>:</p>
<p>指定测试名的部分匹配值，所有名称包含该值的测试都会运行。例如，有两个测试名含 <code>add</code>，可通过 <code>cargo test add</code> 运行它们：</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>This command ran all tests with <code>add</code> in the name and filtered out the test
named <code>one_hundred</code>. Also note that the module in which a test appears becomes
part of the test’s name, so we can run all the tests in a module by filtering
on the module’s name.</p>
<p>此命令运行了所有名称含 <code>add</code> 的测试，并过滤了名为 <code>one_hundred</code> 的测试。注意：<span class="highlight">[note]测试所在模块名会成为测试全名的一部分，因此可通过模块名过滤运行该模块所有测试。</span></p>
<h3 id="ignoring-some-tests-unless-specifically-requested-忽略特定测试除非显式要求"><a class="header" href="#ignoring-some-tests-unless-specifically-requested-忽略特定测试除非显式要求">Ignoring Some Tests Unless Specifically Requested 忽略特定测试（除非显式要求）</a></h3>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>cargo test</code>. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown
here:</p>
<p>某些测试执行非常耗时，可能需要在大多数 <code>cargo test</code> 运行中排除。无需列出所有要运行的测试，可<span class="highlight">[note]使用 <code>ignore</code> 属性标记耗时测试以排除它们</span>，如下所示：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>After <code>#[test]</code>, we add the <code>#[ignore]</code> line to the test we want to exclude.
Now when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<p>在 <code>#[test]</code> 后为需排除的测试添加 <code>#[ignore]</code> 行。现在运行测试时，<code>it_works</code> 执行而 <code>expensive_test</code> 被忽略：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The <code>expensive_test</code> function is listed as <code>ignored</code>. If we want to run only
the ignored tests, we can use <code>cargo test -- --ignored</code>:</p>
<p><code>expensive_test</code> 被标记为 <code>ignored</code>。若需<span class="highlight">[note]仅运行被忽略的测试，可使用 <code>cargo test -- --ignored</code></span>：</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results
will be returned quickly. When you’re at a point where it makes sense to check
the results of the <code>ignored</code> tests and you have time to wait for the results,
you can run <code>cargo test -- --ignored</code> instead. If you want to run all tests
whether they’re ignored or not, you can run <code>cargo test -- --include-ignored</code>.</p>
<p>通过控制测试执行范围，可确保 <code>cargo test</code> 快速返回结果。当需要检查被忽略测试且有时间等待结果时，可运行 <code>cargo test -- --ignored</code>。若要<span class="highlight">[note]运行所有测试（无论是否忽略），可执行 <code>cargo test -- --include-ignored</code>。</span></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test-organization-测试组织"><a class="header" href="#test-organization-测试组织">Test Organization 测试组织</a></h2>
<p>As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: unit tests and integration
tests. <em>Unit tests</em> are small and more focused, testing one module in isolation
at a time, and can test private interfaces. <em>Integration tests</em> are entirely
external to your library and use your code in the same way any other external
code would, using only the public interface and potentially exercising multiple
modules per test.</p>
<p>正如本章开头所述，测试是一个复杂的领域，不同的人使用不同的术语和组织方式。Rust社区将测试分为两大类：单元测试和集成测试。<strong>单元测试</strong>规模小且更聚焦，每次独立测试一个模块，并能测试私有接口。<span class="highlight">[note]<strong>集成测试</strong>则完全位于库的外部，像其他外部代码一样使用你的代码，仅通过公共接口操作</span>，单个测试可能涉及多个模块。</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.</p>
<p>编写这两种测试对确保库的各个部分能独立且协同地按预期工作至关重要。</p>
<h3 id="unit-tests-单元测试"><a class="header" href="#unit-tests-单元测试">Unit Tests 单元测试</a></h3>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. You’ll put unit tests in the <em>src</em> directory in each file with the
code that they’re testing. The convention is to create a module named <code>tests</code>
in each file to contain the test functions and to annotate the module with
<code>cfg(test)</code>.</p>
<p>单元测试的目的是将代码单元与其余代码隔离测试，以便快速定位代码是否符合预期行为。单元测试通常放在 <em>src</em> 目录中，与所测试的代码位于同一文件。约定是在每个文件中创建名为 <code>tests</code> 的模块来存放测试函数，并用 <code>cfg(test)</code> 标注该模块。</p>
<h4 id="the-tests-module-and-cfgtest-测试模块与-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest-测试模块与-cfgtest">The Tests Module and <code>#[cfg(test)]</code> 测试模块与 <code>#[cfg(test)]</code></a></h4>
<p>The <code>#[cfg(test)]</code> annotation on the <code>tests</code> module tells Rust to compile and
run the test code only when you run <code>cargo test</code>, not when you run <code>cargo  build</code>. This saves compile time when you only want to build the library and
saves space in the resultant compiled artifact because the tests are not
included. You’ll see that because integration tests go in a different
directory, they don’t need the <code>#[cfg(test)]</code> annotation. However, because unit
tests go in the same files as the code, you’ll use <code>#[cfg(test)]</code> to specify
that they shouldn’t be included in the compiled result.</p>
<p><span class="highlight">[note]<code>tests</code> 模块上的 <code>#[cfg(test)]</code> 注解告诉Rust仅在运行 <code>cargo test</code> 时编译和执行测试代码</span>，运行 <code>cargo build</code> 时则不会。这能在仅构建库时节省编译时间，并减少最终编译产物体积（因为测试代码未被包含）。由于集成测试位于不同目录，它们不需要 <code>#[cfg(test)]</code> 注解。但单元测试与代码在同一文件，需用 <code>#[cfg(test)]</code> 确保其不包含在编译结果中。</p>
<p>Recall that when we generated the new <code>adder</code> project in the first section of
this chapter, Cargo generated this code for us:</p>
<p>回顾本章第一节生成新 <code>adder</code> 项目时，Cargo自动生成的代码：</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>On the automatically generated <code>tests</code> module, the attribute <code>cfg</code> stands for
<em>configuration</em> and tells Rust that the following item should only be included
given a certain configuration option. In this case, the configuration option is
<code>test</code>, which is provided by Rust for compiling and running tests. By using the
<code>cfg</code> attribute, Cargo compiles our test code only if we actively run the tests
with <code>cargo test</code>. This includes any helper functions that might be within this
module, in addition to the functions annotated with <code>#[test]</code>.</p>
<p>在自动生成的 <code>tests</code> 模块上，属性 <code>cfg</code> 表示 <em>配置</em>，它告知Rust：仅在特定配置选项下才包含后续条目。此处配置选项是 <code>test</code>（由Rust提供用于编译和运行测试）。通过 <code>cfg</code> 属性，Cargo仅在主动运行 <code>cargo test</code> 时编译测试代码，包括该模块内的辅助函数和 <code>#[test]</code> 标注的函数。</p>
<h4 id="testing-private-functions-测试私有函数"><a class="header" href="#testing-private-functions-测试私有函数">Testing Private Functions 测试私有函数</a></h4>
<p>There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function <code>internal_adder</code>.</p>
<p>测试圈内对是否应直接测试私有函数存在争议，某些语言使此操作困难或无法实现。无论你遵循哪种测试理念，Rust的隐私规则都允许测试私有函数。参考示例11-12中测试私有函数 <code>internal_adder</code> 的代码：</p>
<figure class="listing" id="listing-11-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    internal_adder(a, 2)
}

fn internal_adder(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="ch11-03-test-organization.html#listing-11-12">Listing 11-12</a>: Testing a private function 测试私有函数</figcaption>
</figure>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>. Tests are just
Rust code, and the <code>tests</code> module is just another module. As we discussed in
“Paths for Referring to an Item in the Module Tree”,
items in child modules can use the items in their ancestor modules. In this
test, we bring all of the <code>tests</code> module’s parent’s items into scope with <code>use  super::*</code>, and then the test can call <code>internal_adder</code>. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel you
to do so.</p>
<p>注意 <code>internal_adder</code> 未标记为 <code>pub</code>。测试本质是Rust代码，<code>tests</code> 模块也仅是普通模块。如第7章“模块树中引用项的路径”所述，子模块可使用祖先模块中的项。此测试通过 <code>use super::*</code> 将 <code>tests</code> 模块的父模块所有项引入作用域，从而调用 <code>internal_adder</code>。若你认为无需测试私有函数，Rust不会强制要求。</p>
<h3 id="integration-tests-集成测试"><a class="header" href="#integration-tests-集成测试">Integration Tests 集成测试</a></h3>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<p>在Rust中，集成测试完全独立于库的外部。它们像其他代码一样使用库，意味着只能调用库公共API中的函数。其目的是测试库多个部分能否正确协同工作——独立正确的代码单元在集成时仍可能出问题，因此集成代码的测试覆盖同样重要。创建集成测试需先建立 <em>tests</em> 目录。</p>
<h4 id="the-tests-directory-tests-目录"><a class="header" href="#the-tests-directory-tests-目录">The <em>tests</em> Directory <em>tests</em> 目录</a></h4>
<p>We create a <em>tests</em> directory at the top level of our project directory, next
to <em>src</em>. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want, and Cargo will compile each of the
files as an individual crate.</p>
<p>我们<span class="highlight">[note]在项目根目录（与 <em>src</em> 同级）创建 <em>tests</em> 目录。Cargo会自动在此目录查找集成测试文件。可创建任意数量测试文件，Cargo会将每个文件编译为独立crate。</span></p>
<p>Let’s create an integration test. With the code in Listing 11-12 still in the
<em>src/lib.rs</em> file, make a <em>tests</em> directory, and create a new file named
<em>tests/integration_test.rs</em>. Your directory structure should look like this:</p>
<p>创建集成测试示例：保持示例11-12代码在 <em>src/lib.rs</em> 中，新建 <em>tests</em> 目录并创建 <em>tests/integration_test.rs</em> 文件。目录结构如下：</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│         └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>Enter the code in Listing 11-13 into the <em>tests/integration_test.rs</em> file.</p>
<p>将示例11-13代码写入 <em>tests/integration_test.rs</em>：</p>
<figure class="listing" id="listing-11-13">
<span class="file-name">Filename: tests/integration_test.rs</span>
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<figcaption><a href="ch11-03-test-organization.html#listing-11-13">Listing 11-13</a>: An integration test of a function in the <code>adder</code> crate 测试<code>adder</code>crate中的函数</figcaption>
</figure>
<p>Each file in the <em>tests</em> directory is a separate crate, so we need to bring our
library into each test crate’s scope. For that reason we add <code>use  adder::add_two;</code> at the top of the code, which we didn’t need in the unit tests.</p>
<p><em>tests</em> 目录中每个文件都是独立crate，因此需将库引入各测试crate作用域。故在代码顶部添加 <code>use adder::add_two;</code>（单元测试中无需此操作）。</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.rs</em> with
<code>#[cfg(test)]</code>. Cargo treats the <em>tests</em> directory specially and compiles files
in this directory only when we run <code>cargo test</code>. Run <code>cargo test</code> now:</p>
<p>无需在 <em>tests/integration_test.rs</em> 中使用 <code>#[cfg(test)]</code> 注解。Cargo特殊处理 <em>tests</em> 目录，仅在 <code>cargo test</code> 时编译其中文件。现在运行 <code>cargo test</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The three sections of output include the unit tests, the integration test, and
the doc tests. Note that if any test in a section fails, the following sections
will not be run. For example, if a unit test fails, there won’t be any output
for integration and doc tests because those tests will only be run if all unit
tests are passing.</p>
<p>输出包含三部分：单元测试、集成测试和文档测试。注意若某部分有测试失败，后续部分不会执行（例如单元测试失败时，集成测试和文档测试无输出结果）。</p>
<p>The first section for the unit tests is the same as we’ve been seeing: one line
for each unit test (one named <code>internal</code> that we added in Listing 11-12) and
then a summary line for the unit tests.</p>
<p>单元测试部分格式与前文一致：每个测试一行（含示例11-12添加的 <code>internal</code> 测试），最后是单元测试的摘要行。</p>
<p>The integration tests section starts with the line <code>Running  tests/integration_test.rs</code>. Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the <code>Doc-tests adder</code> section starts.</p>
<p>集成测试部分以 <code>Running tests/integration_test.rs</code> 开头，随后列出该文件中的每个测试函数，并在 <code>Doc-tests adder</code> 部分前给出集成测试结果摘要。</p>
<p>Each integration test file has its own section, so if we add more files in the
<em>tests</em> directory, there will be more integration test sections.</p>
<p>每个集成测试文件有独立输出段，若在 <em>tests</em> 目录添加更多文件，将出现更多集成测试段。</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument to <code>cargo test</code>. To run all the tests in a
particular integration test file, use the <code>--test</code> argument of <code>cargo test</code>
followed by the name of the file:</p>
<p>可通过指定测试函数名运行特定集成测试。<span class="highlight">[note]要运行特定文件中的所有测试，使用 <code>cargo test --test</code> 后跟文件名</span>：</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<p>此命令仅运行 <em>tests/integration_test.rs</em> 中的测试。</p>
<h4 id="submodules-in-integration-tests-集成测试中的子模块"><a class="header" href="#submodules-in-integration-tests-集成测试中的子模块">Submodules in Integration Tests 集成测试中的子模块</a></h4>
<p>As you add more integration tests, you might want to make more files in the
<em>tests</em> directory to help organize them; for example, you can group the test
functions by the functionality they’re testing. As mentioned earlier, each file
in the <em>tests</em> directory is compiled as its own separate crate, which is useful
for creating separate scopes to more closely imitate the way end users will be
using your crate. However, this means files in the <em>tests</em> directory don’t
share the same behavior as files in <em>src</em> do, as you learned in Chapter 7
regarding how to separate code into modules and files.</p>
<p>随着集成测试增多，你可能需要在 <em>tests</em> 目录创建更多文件来组织测试（例如按测试功能分组）。如前所述，<em>tests</em> 目录中每个文件都编译为独立crate，这有助于创建独立作用域以模拟用户使用crate的场景。但这也意味着 <em>tests</em> 目录文件的行为与 <em>src</em> 不同（如第7章所述模块分离机制）。</p>
<p>The different behavior of <em>tests</em> directory files is most noticeable when you
have a set of helper functions to use in multiple integration test files and
you try to follow the steps in the “Separating Modules into Different
Files” section of Chapter 7 to
extract them into a common module. For example, if we create <em>tests/common.rs</em>
and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that
we want to call from multiple test functions in multiple test files:</p>
<p>当需要在多个集成测试文件中复用辅助函数时，<em>tests</em> 目录的特殊性尤为明显。若尝试按第7章“将模块拆分到不同文件”的步骤提取公共模块，例如创建 <em>tests/common.rs</em> 并添加 <code>setup</code> 函数：</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>When we run the tests again, we’ll see a new section in the test output for the
<em>common.rs</em> file, even though this file doesn’t contain any test functions nor
did we call the <code>setup</code> function from anywhere:</p>
<p>再次运行测试时，输出会包含 <em>common.rs</em> 的段落（尽管该文件不含测试函数且未调用 <code>setup</code>）：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files. To avoid having <code>common</code> appear in the test output,
instead of creating <em>tests/common.rs</em>, we’ll create <em>tests/common/mod.rs</em>. The
project directory now looks like this:</p>
<p><code>common</code> 出现在测试结果中并显示 <code>running 0 tests</code> 不符合预期。我们仅希望共享代码给其他集成测试文件。为避免此问题，应创建 <em>tests/common/mod.rs</em> 而非 <em>tests/common.rs</em>。项目目录如下：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│         └── lib.rs
└── tests
    ├── common
    │         └── mod.rs
    └── integration_test.rs
</code></pre>
<p>This is the older naming convention that Rust also understands that we mentioned
in “Alternate File Paths” in Chapter 7. Naming the
file this way tells Rust not to treat the <code>common</code> module as an integration test
file. When we move the <code>setup</code> function code into <em>tests/common/mod.rs</em> and
delete the <em>tests/common.rs</em> file, the section in the test output will no longer
appear. Files in subdirectories of the <em>tests</em> directory don’t get compiled as
separate crates or have sections in the test output.</p>
<p>这是第7章“替代文件路径”中提到的旧命名约定，Rust同样支持。此命名方式告知Rust勿将 <code>common</code> 模块视为集成测试文件。将 <code>setup</code> 函数移至 <em>tests/common/mod.rs</em> 并删除 <em>tests/common.rs</em> 后，该输出段落将消失。<em>tests</em> 子目录中的文件不会被编译为独立crate，也不会出现在测试输出中。</p>
<p>After we’ve created <em>tests/common/mod.rs</em>, we can use it from any of the
integration test files as a module. Here’s an example of calling the <code>setup</code>
function from the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p>创建 <em>tests/common/mod.rs</em> 后，可在集成测试文件中作为模块使用。以下示例展示从 <em>tests/integration_test.rs</em> 的 <code>it_adds_two</code> 测试调用 <code>setup</code> 函数：</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>Note that the <code>mod common;</code> declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then, in the test function, we can call the
<code>common::setup()</code> function.</p>
<p>注意 <code>mod common;</code> 声明与示例7-21的模块声明方式相同。测试函数中可通过 <code>common::setup()</code> 调用函数。</p>
<h4 id="integration-tests-for-binary-crates-二进制crate的集成测试"><a class="header" href="#integration-tests-for-binary-crates-二进制crate的集成测试">Integration Tests for Binary Crates 二进制crate的集成测试</a></h4>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and
doesn’t have a <em>src/lib.rs</em> file, we can’t create integration tests in the
<em>tests</em> directory and bring functions defined in the <em>src/main.rs</em> file into
scope with a <code>use</code> statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.</p>
<p>若项目是仅含 <em>src/main.rs</em> 的二进制crate（无 <em>src/lib.rs</em>），则无法在 <em>tests</em> 目录创建集成测试，也无法通过 <code>use</code> 语句引入 <em>src/main.rs</em> 定义的函数。只有库crate会暴露函数给外部使用，二进制crate旨在独立运行。</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> file that calls logic that lives in the
<em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the
library crate with <code>use</code> to make the important functionality available. If the
important functionality works, the small amount of code in the <em>src/main.rs</em>
file will work as well, and that small amount of code doesn’t need to be tested.</p>
<p>这正是提供二进制文件的Rust项目通常采用简洁 <em>src/main.rs</em> 调用 <em>src/lib.rs</em> 逻辑的原因。通过此结构，集成测试可用 <code>use</code> 测试库crate的核心功能。若核心功能正常，<em>src/main.rs</em> 中的少量代码也能正常工作，且无需额外测试。</p>
<h2 id="summary-总结-10"><a class="header" href="#summary-总结-10">Summary 总结</a></h2>
<p>Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Rust的测试功能提供了一种规范代码行为的方式，确保其在修改后仍符合预期。单元测试独立验证库的各个部分，可测试私有实现细节；集成测试检查多个部分的协同工作，通过公共API以用户使用方式验证代码。尽管Rust的类型系统和所有权规则能预防特定类型错误，测试对减少代码逻辑错误仍至关重要。</p>
<p>Let’s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!</p>
<p>让我们结合本章及之前所学知识，开启一个新项目吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-io-project-building-a-command-line-program-一个-io-项目构建命令行程序"><a class="header" href="#an-io-project-building-a-command-line-program-一个-io-项目构建命令行程序">An I/O Project: Building a Command Line Program 一个 I/O 项目：构建命令行程序</a></h1>
<p>This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.</p>
<p>本章将回顾你目前学到的多项技能，并探索更多标准库功能。我们将构建一个与文件和命令行输入/输出交互的命令行工具，以练习你现已掌握的 Rust 概念。</p>
<p>Rust’s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line search tool <code>grep</code>
(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). In the
simplest use case, <code>grep</code> searches a specified file for a specified string. To
do so, <code>grep</code> takes as its arguments a file path and a string. Then it reads
the file, finds lines in that file that contain the string argument, and prints
those lines.</p>
<p>Rust 的速度、安全性、单一二进制输出和跨平台支持使其成为创建命令行工具的绝佳语言。因此在这个项目中，我们将制作经典命令行搜索工具 <code>grep</code> 的自制版本（<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint - 全局搜索正则表达式并打印）。在最简单的使用场景中，<code>grep</code> 会在指定文件中搜索特定字符串。为此，<code>grep</code> 将文件路径和字符串作为参数，然后读取文件，找到包含该字符串参数的行并打印这些行。</p>
<p>Along the way, we’ll show how to make our command line tool use the terminal
features that many other command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print error messages to the standard error console stream (<code>stderr</code>)
instead of standard output (<code>stdout</code>) so that, for example, the user can
redirect successful output to a file while still seeing error messages onscreen.</p>
<p>在此过程中，我们将展示如何让命令行工具使用许多其他命令行工具共有的终端功能。我们将读取环境变量的值，允许用户配置工具的行为。我们还会将错误消息打印到标准错误控制台流 (<code>stderr</code>) 而非标准输出 (<code>stdout</code>)，这样用户就可以将成功输出重定向到文件，同时在屏幕上查看错误消息。</p>
<p>One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison, our
version will be fairly simple, but this chapter will give you some of the
background knowledge you need to understand a real-world project such as
<code>ripgrep</code>.</p>
<p>Rust 社区成员 Andrew Gallant 已经创建了一个功能齐全、速度极快的 <code>grep</code> 版本，名为 <code>ripgrep</code>。相比之下，我们的版本将相当简单，但本章将提供理解真实项目（如 <code>ripgrep</code>）所需的背景知识。</p>
<p>Our <code>grep</code> project will combine a number of concepts you’ve learned so far:</p>
<p>我们的 <code>grep</code> 项目将结合你目前已学到的多个概念：</p>
<ul>
<li>Organizing code (Chapter 7)</li>
<li>代码组织（第 7 章）</li>
<li>Using vectors and strings (Chapter 8)</li>
<li>使用向量和字符串（第 8 章）</li>
<li>Handling errors (Chapter 9)</li>
<li>错误处理（第 9 章）</li>
<li>Using traits and lifetimes where appropriate (Chapter 10)</li>
<li>在适当场景使用 trait 和生命周期（第 10 章）</li>
<li>Writing tests (Chapter 11)</li>
<li>编写测试（第 11 章）</li>
</ul>
<p>We’ll also briefly introduce closures, iterators, and trait objects, which
Chapter 13 and Chapter 18 will
cover in detail.</p>
<p>我们还将简要介绍闭包、迭代器和 trait 对象，这些概念将在第 13 章和第 18 章详细讲解。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="accepting-command-line-arguments-接受命令行参数"><a class="header" href="#accepting-command-line-arguments-接受命令行参数">Accepting Command Line Arguments 接受命令行参数</a></h2>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<p>让我们使用 <code>cargo new</code> 创建一个新项目（一如既往）。我们将项目命名为 <code>minigrep</code>，以便与系统中可能已存在的 <code>grep</code> 工具区分开。</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
file path and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, two hyphens to indicate the following arguments are
for our program rather than for <code>cargo</code>, a string to search for, and a path to
a file to search in, like so:</p>
<p>首要任务是让 <code>minigrep</code> 接受两个命令行参数：文件路径和要搜索的字符串。也就是说，我们希望能够使用 <code>cargo run</code> 运行程序，两个连字符表示后续参数是传递给我们的程序而非 <code>cargo</code> 的，包括要搜索的字符串和要搜索的文件路径，如下所示：</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. Some existing libraries on <a href="https://crates.io/">crates.io</a> can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.</p>
<p>目前，由 <code>cargo new</code> 生成的程序无法处理我们提供的参数。<a href="https://crates.io/">crates.io</a> 上的一些现有库可以帮助编写接受命令行参数的程序，但既然你正在学习这个概念，我们就自己实现这个功能。</p>
<h3 id="reading-the-argument-values-读取参数值"><a class="header" href="#reading-the-argument-values-读取参数值">Reading the Argument Values 读取参数值</a></h3>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to
it, we’ll need the <code>std::env::args</code> function provided in Rust’s standard
library. This function returns an iterator of the command line arguments passed
to <code>minigrep</code>. We’ll cover iterators fully in Chapter 13. For now, you only need to know two details about iterators: iterators
produce a series of values, and we can call the <code>collect</code> method on an iterator
to turn it into a collection, such as a vector, that contains all the elements
the iterator produces.</p>
<p>为了让 <code>minigrep</code> 能够读取传递给它的命令行参数值，我们需要使用 Rust 标准库提供的 <code>std::env::args</code> 函数。该函数返回传递给 <code>minigrep</code> 的命令行参数的迭代器。我们将在第 13 章全面介绍迭代器。现在你只需了解关于迭代器的两个细节：迭代器会产生一系列值，我们可以在迭代器上调用 <code>collect</code> 方法将其转换为集合（如向量），其中包含迭代器生成的所有元素。</p>
<p>The code in Listing 12-1 allows your <code>minigrep</code> program to read any command
line arguments passed to it, and then collect the values into a vector.</p>
<p>清单 12-1 中的代码允许你的 <code>minigrep</code> 程序读取传递给它的任何命令行参数，然后将值收集到向量中。</p>
<figure class="listing" id="listing-12-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<figcaption><a href="ch12-01-accepting-command-line-arguments.html#listing-12-1">Listing 12-1</a>: Collecting the command line arguments into a vector and printing them 将命令行参数收集到向量中并打印它们</figcaption>
</figure>
<p>First we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in Chapter
7, in cases where the desired function is
nested in more than one module, we’ve chosen to bring the parent module into
scope rather than the function. By doing so, we can easily use other functions
from <code>std::env</code>. It’s also less ambiguous than adding <code>use std::env::args</code> and
then calling the function with just <code>args</code>, because <code>args</code> might easily be
mistaken for a function that’s defined in the current module.</p>
<p>首先我们通过 <code>use</code> 语句将 <code>std::env</code> 模块引入作用域，以便使用其 <code>args</code> 函数。注意 <code>std::env::args</code> 函数嵌套在两层模块中。如第 7 章所述，当所需函数嵌套在多个模块中时，我们选择将父模块而非函数引入作用域。这样，我们可以轻松使用 <code>std::env</code> 中的其他函数。这比添加 <code>use std::env::args</code> 然后仅用 <code>args</code> 调用函数更清晰，因为 <code>args</code> 很容易被误认为是当前模块中定义的函数。</p>
<section class="note" aria-role="note">
<h3 id="the-args-function-and-invalid-unicode-args-函数与无效-unicode"><a class="header" href="#the-args-function-and-invalid-unicode-args-函数与无效-unicode">The <code>args</code> Function and Invalid Unicode <code>args</code> 函数与无效 Unicode</a></h3>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator
that produces <code>OsString</code> values instead of <code>String</code> values. We’ve chosen to
use <code>std::env::args</code> here for simplicity because <code>OsString</code> values differ per
platform and are more complex to work with than <code>String</code> values.</p>
<p>注意：<span class="highlight">[note]如果任何参数包含无效 Unicode，<code>std::env::args</code> 将会 panic。如果你的程序需要接受包含无效 Unicode 的参数，请改用 <code>std::env::args_os</code>。</span>该函数返回生成 <code>OsString</code> 值而非 <code>String</code> 值的迭代器。为简化起见，我们在此选择使用 <code>std::env::args</code>，因为 <code>OsString</code> 值因平台而异，且比 <code>String</code> 值更复杂。</p>
</section>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use
<code>collect</code> to turn the iterator into a vector containing all the values produced
by the iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although you very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>在 <code>main</code> 的第一行，我们调用 <code>env::args</code>，并立即使用 <code>collect</code> 将迭代器转换为包含迭代器生成的所有值的向量。我们可以使用 <code>collect</code> 函数创建多种集合，因此显式注解 <code>args</code> 的类型以指定我们需要字符串向量。虽然在 Rust 中很少需要注解类型，但 <code>collect</code> 是你经常需要注解的函数之一，因为 Rust 无法推断你想要的集合类型。</p>
<p>Finally, we print the vector using the debug macro. Let’s try running the code
first with no arguments and then with two arguments:</p>
<p>最后，我们使用调试宏打印向量。让我们先尝试不带参数运行代码，然后带两个参数运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>Notice that the first value in the vector is <code>"target/debug/minigrep"</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change the behavior of the program based on what
command line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<p>注意向量中的第一个值是 <code>"target/debug/minigrep"</code>，这是我们的二进制文件名称。这与 C 语言中的参数列表行为一致，允许程序在执行时使用调用它们的名称。能够访问程序名称通常很方便，例如在消息中打印它，或根据调用程序时使用的命令行别名更改程序行为。但就本章而言，我们将忽略它，仅保存我们需要的两个参数。</p>
<h3 id="saving-the-argument-values-in-variables-将参数值保存到变量中"><a class="header" href="#saving-the-argument-values-in-variables-将参数值保存到变量中">Saving the Argument Values in Variables 将参数值保存到变量中</a></h3>
<p>The program is currently able to access the values specified as command line
arguments. Now we need to save the values of the two arguments in variables so
we can use the values throughout the rest of the program. We do that in Listing
12-2.</p>
<p>程序现在能够访问指定为命令行参数的值。接下来我们需要将两个参数的值保存到变量中，以便在程序其余部分使用这些值。我们在清单 12-2 中实现这一点。</p>
<figure class="listing" id="listing-12-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
<figcaption><a href="ch12-01-accepting-command-line-arguments.html#listing-12-2">Listing 12-2</a>: Creating variables to hold the query argument and file path argument 创建变量保存查询参数和文件路径参数</figcaption>
</figure>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting arguments at index 1. The
first argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the file path, so we put a reference to the second argument in the
variable <code>file_path</code>.</p>
<p>如我们打印向量时所看到的，程序名称占据向量中的第一个值 <code>args[0]</code>，因此我们从索引 1 开始获取参数。<code>minigrep</code> 接受的第一个参数是我们要搜索的字符串，因此我们将第一个参数的引用放入变量 <code>query</code> 中。第二个参数是文件路径，因此我们将第二个参数的引用放入变量 <code>file_path</code> 中。</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<p>我们暂时打印这些变量的值以证明代码按预期工作。让我们再次使用参数 <code>test</code> 和 <code>sample.txt</code> 运行此程序：</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.</p>
<p>很好，程序运行正常！我们所需的参数值已保存到正确的变量中。稍后我们将添加一些错误处理来应对某些可能的错误情况（例如用户未提供任何参数）；现在，我们将忽略这种情况，转而添加文件读取功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reading-a-file-读取文件"><a class="header" href="#reading-a-file-读取文件">Reading a File 读取文件</a></h2>
<p>Now we’ll add functionality to read the file specified in the <code>file_path</code>
argument. First we need a sample file to test it with: we’ll use a file with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
<em>poem.txt</em> at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”</p>
<p>现在我们将添加功能来读取 <code>file_path</code> 参数中指定的文件。首先我们需要一个测试用的示例文件：我们将使用一个包含少量文本的多行文件，其中有一些重复单词。清单 12-3 的 Emily Dickinson 诗歌非常合适！在项目根目录创建名为 <em>poem.txt</em> 的文件，并输入诗歌《我是无名之辈！你是谁？》</p>
<figure class="listing" id="listing-12-3">
<span class="file-name">Filename: poem.txt</span>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<figcaption><a href="ch12-02-reading-a-file.html#listing-12-3">Listing 12-3</a>: A poem by Emily Dickinson makes a good test case. Emily Dickinson 的诗歌是很好的测试用例。</figcaption>
</figure>
<p>With the text in place, edit <em>src/main.rs</em> and add code to read the file, as
shown in Listing 12-4.</p>
<p>文本就位后，编辑 <em>src/main.rs</em> 并添加读取文件的代码，如清单 12-4 所示。</p>
<figure class="listing" id="listing-12-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}</code></pre>
<figcaption><a href="ch12-02-reading-a-file.html#listing-12-4">Listing 12-4</a>: Reading the contents of the file specified by the second argument 读取第二个参数指定文件的内容</figcaption>
</figure>
<p>First we bring in a relevant part of the standard library with a <code>use</code>
statement: we need <code>std::fs</code> to handle files.</p>
<p>首先通过 <code>use</code> 语句引入标准库的相关部分：我们需要 <code>std::fs</code> 来处理文件。</p>
<p>In <code>main</code>, the new statement <code>fs::read_to_string</code> takes the <code>file_path</code>, opens
that file, and returns a value of type <code>std::io::Result&lt;String&gt;</code> that contains
the file’s contents.</p>
<p>在 <code>main</code> 中，新语句 <code>fs::read_to_string</code> 接受 <code>file_path</code>，打开该文件，并返回包含文件内容的 <code>std::io::Result&lt;String&gt;</code> 类型值。</p>
<p>After that, we again add a temporary <code>println!</code> statement that prints the value
of <code>contents</code> after the file is read, so we can check that the program is
working so far.</p>
<p>之后，我们再次添加临时的 <code>println!</code> 语句，在文件读取后打印 <code>contents</code> 的值，以便检查程序目前是否正常工作。</p>
<p>Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the <em>poem.txt</em> file as the
second argument:</p>
<p>让我们使用任意字符串作为第一个命令行参数（因为我们尚未实现搜索部分）和 <em>poem.txt</em> 文件作为第二个参数运行此代码：</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Great! The code read and then printed the contents of the file. But the code
has a few flaws. At the moment, the <code>main</code> function has multiple
responsibilities: generally, functions are clearer and easier to maintain if
each function is responsible for only one idea. The other problem is that we’re
not handling errors as well as we could. The program is still small, so these
flaws aren’t a big problem, but as the program grows, it will be harder to fix
them cleanly. It’s a good practice to begin refactoring early on when
developing a program because it’s much easier to refactor smaller amounts of
code. We’ll do that next.</p>
<p>很好！代码成功读取并打印了文件内容。但代码存在一些缺陷。目前，<code>main</code> 函数承担了多个职责：通常，如果每个函数仅负责一个功能，代码会更清晰且更易于维护。另一个问题是我们未能很好地处理错误。程序尚小，这些缺陷不是大问题，但随着程序增长，修复它们会变得更加困难。在开发程序时尽早开始重构是良好的实践，因为重构少量代码要容易得多。接下来我们将进行重构。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refactoring-to-improve-modularity-and-error-handling-重构以提升模块化与错误处理能力"><a class="header" href="#refactoring-to-improve-modularity-and-error-handling-重构以提升模块化与错误处理能力">Refactoring to Improve Modularity and Error Handling 重构以提升模块化与错误处理能力</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors. First, our <code>main</code>
function now performs two tasks: it parses arguments and reads files. As our
program grows, the number of separate tasks the <code>main</code> function handles will
increase. As a function gains responsibilities, it becomes more difficult to
reason about, harder to test, and harder to change without breaking one of its
parts. It’s best to separate functionality so each function is responsible for
one task.</p>
<p>为了改进程序，我们将修复四个涉及程序结构及其处理潜在错误方式的问题。首先，当前的 <code>main</code> 函数承担了两项任务：解析参数和读取文件。随着程序增长，<code>main</code> 函数处理的独立任务数量会增加。当函数职责增多时，其逻辑会变得更难理解、更难测试，且更难在不破坏部分功能的情况下修改。最好将功能分离，使每个函数只负责单一任务。</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>file_path</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>此问题也关联到第二个问题：尽管 <code>query</code> 和 <code>file_path</code> 是程序的配置变量，但像 <code>contents</code> 这样的变量用于执行程序逻辑。<code>main</code> 函数越长，需要引入作用域的变量就越多；作用域中的变量越多，跟踪每个变量的用途就越困难。最好将配置变量分组到一个结构中，以明确其目的。</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints <code>Should have been  able to read the file</code>. Reading a file can fail in a number of ways: for
example, the file could be missing, or we might not have permission to open it.
Right now, regardless of the situation, we’d print the same error message for
everything, which wouldn’t give the user any information!</p>
<p>第三个问题是：读取文件失败时我们使用 <code>expect</code> 打印错误消息，但消息仅显示 <code>Should have been  able to read the file</code>。文件读取可能因多种原因失败：例如文件不存在或没有打开权限。当前无论何种情况，我们都打印相同的错误消息，这无法向用户提供有效信息！</p>
<p>Fourth, we use <code>expect</code> to handle an error, and if the user runs our program
without specifying enough arguments, they’ll get an <code>index out of bounds</code> error
from Rust that doesn’t clearly explain the problem. It would be best if all the
error-handling code were in one place so future maintainers had only one place
to consult the code if the error-handling logic needed to change. Having all the
error-handling code in one place will also ensure that we’re printing messages
that will be meaningful to our end users.</p>
<p>第四个问题是我们用 <code>expect</code> 处理错误，若用户运行时未提供足够参数，将收到 Rust 的 <code>index out of bounds</code> 错误，但该错误未清晰说明问题。最好将所有错误处理代码集中在一处，这样未来维护者在需要修改错误处理逻辑时只需查看一个位置。集中错误处理代码还能确保打印对最终用户有意义的提示信息。</p>
<p>Let’s address these four problems by refactoring our project.</p>
<p>让我们通过重构项目来解决这四个问题。</p>
<h3 id="separation-of-concerns-for-binary-projects-二进制项目的职责分离"><a class="header" href="#separation-of-concerns-for-binary-projects-二进制项目的职责分离">Separation of Concerns for Binary Projects 二进制项目的职责分离</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, many Rust
programmers find it useful to split up the separate concerns of a binary
program when the <code>main</code> function starts getting large. This process has the
following steps:</p>
<p>将多个任务分配给 <code>main</code> 函数的组织问题是许多二进制项目的通病。因此，当 <code>main</code> 函数变得庞大时，许多 Rust 开发者发现拆分二进制程序的独立关注点很有用。此过程包含以下步骤：</p>
<ul>
<li>Split your program into a <em>main.rs</em> file and a <em>lib.rs</em> file and move your
program’s logic to <em>lib.rs</em>.</li>
<li>将程序拆分为 <em>main.rs</em> 和 <em>lib.rs</em> 文件，并将程序逻辑移至 <em>lib.rs</em></li>
<li>As long as your command line parsing logic is small, it can remain in
the <code>main</code> function.</li>
<li>只要命令行解析逻辑简单，可保留在 <code>main</code> 函数中</li>
<li>When the command line parsing logic starts getting complicated, extract it
from the <code>main</code> function into other functions or types.</li>
<li>当命令行解析逻辑变复杂时，将其从 <code>main</code> 函数提取到其他函数或类型中</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<p>此过程后保留在 <code>main</code> 函数中的职责应限于：</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>使用参数值调用命令行解析逻辑</li>
<li>Setting up any other configuration</li>
<li>设置其他配置</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>调用 <em>lib.rs</em> 中的 <code>run</code> 函数</li>
<li>Handling the error if <code>run</code> returns an error</li>
<li>若 <code>run</code> 返回错误则处理该错误</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it out of the <code>main</code> function. The code that
remains in the <code>main</code> function will be small enough to verify its correctness
by reading it. Let’s rework our program by following this process.</p>
<p>此模式的核心是分离关注点：<em>main.rs</em> 负责运行程序，而 <em>lib.rs</em> 处理所有实际任务逻辑。由于无法直接测试 <code>main</code> 函数，此结构允许你将所有程序逻辑移出 <code>main</code> 函数进行测试。保留在 <code>main</code> 中的代码量足够小，可通过阅读验证正确性。让我们按此流程改造程序。</p>
<h4 id="extracting-the-argument-parser-提取参数解析器"><a class="header" href="#extracting-the-argument-parser-提取参数解析器">Extracting the Argument Parser 提取参数解析器</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call. Listing 12-5 shows the new start of the <code>main</code> function that
calls a new function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em>.</p>
<p>我们将参数解析功能提取到 <code>main</code> 调用的函数中。清单 12-5 展示了新的 <code>main</code> 函数起始部分，它调用新定义的 <code>parse_config</code> 函数（在 <em>src/main.rs</em> 中）。</p>
<figure class="listing" id="listing-12-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-5">Listing 12-5</a>: Extracting a <code>parse_config</code> function from <code>main</code> 从 <code>main</code> 中提取 <code>parse_config</code> 函数</figcaption>
</figure>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable <code>query</code> and the
argument value at index 2 to the variable <code>file_path</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>file_path</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>我们仍将命令行参数收集到向量中，但不再在 <code>main</code> 函数中将索引 1 的值赋给 <code>query</code>、索引 2 的值赋给 <code>file_path</code>，而是将整个向量传递给 <code>parse_config</code> 函数。<code>parse_config</code> 函数包含确定参数与变量对应关系的逻辑，并将值传回 <code>main</code>。我们仍在 <code>main</code> 中创建 <code>query</code> 和 <code>file_path</code> 变量，但 <code>main</code> 不再负责确定命令行参数与变量的对应关系。</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<p>对小程序来说这种改造可能显得过度，但我们正以小步增量方式进行重构。修改后请再次运行程序以验证参数解析仍正常工作。经常检查进展有助于快速定位问题根源。</p>
<h4 id="grouping-configuration-values-分组配置值"><a class="header" href="#grouping-configuration-values-分组配置值">Grouping Configuration Values 分组配置值</a></h4>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>我们可以进一步改进 <code>parse_config</code> 函数。当前返回元组后立即将其拆分为独立部分，这表明当前的抽象可能不够合理。</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we’ll instead put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<p>另一个可改进的迹象是 <code>parse_config</code> 中的 <code>config</code> 部分，暗示返回的两个值相关且同属一个配置值。当前仅通过元组分组来传递这种关联性，我们将把这两个值放入结构体，并为每个字段赋予有意义的名称。这样做将使未来代码维护者更容易理解不同值间的关联及其用途。</p>
<p>Listing 12-6 shows the improvements to the <code>parse_config</code> function.</p>
<p>清单 12-6 展示了对 <code>parse_config</code> 函数的改进。</p>
<figure class="listing" id="listing-12-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-6">Listing 12-6</a>: Refactoring <code>parse_config</code> to return an instance of a <code>Config</code> struct 重构 <code>parse_config</code> 返回 <code>Config</code> 结构体实例</figcaption>
</figure>
<p>We’ve added a struct named <code>Config</code> defined to have fields named <code>query</code> and
<code>file_path</code>. The signature of <code>parse_config</code> now indicates that it returns a
<code>Config</code> value. In the body of <code>parse_config</code>, where we used to return
string slices that reference <code>String</code> values in <code>args</code>, we now define <code>Config</code>
to contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of
the argument values and is only letting the <code>parse_config</code> function borrow
them, which means we’d violate Rust’s borrowing rules if <code>Config</code> tried to take
ownership of the values in <code>args</code>.</p>
<p>我们添加了包含 <code>query</code> 和 <code>file_path</code> 字段的 <code>Config</code> 结构体。<code>parse_config</code> 的签名现表明它返回 <code>Config</code> 值。在函数体中，过去返回引用 <code>args</code> 中 <code>String</code> 值的字符串切片，现在改为定义 <code>Config</code> 包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者，仅借给 <code>parse_config</code> 使用，这意味着若 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权，将违反 Rust 的借用规则。</p>
<p>There are a number of ways we could manage the <code>String</code> data; the easiest,
though somewhat inefficient, route is to call the <code>clone</code> method on the values.
This will make a full copy of the data for the <code>Config</code> instance to own, which
takes more time and memory than storing a reference to the string data.
However, cloning the data also makes our code very straightforward because we
don’t have to manage the lifetimes of the references; in this circumstance,
giving up a little performance to gain simplicity is a worthwhile trade-off.</p>
<p>有多种方式管理 <code>String</code> 数据；最简单（但效率较低）的方法是调用值的 <code>clone</code> 方法。这会为 <code>Config</code> 实例创建数据的完整副本，比存储字符串数据的引用更耗时间和内存。但克隆数据也使代码更简洁，因为我们无需管理引用的生命周期；在此情况下，牺牲少量性能换取简单性是值得的。</p>
<section class="note" aria-role="note">
<h3 id="the-trade-offs-of-using-clone-使用-clone-的权衡"><a class="header" href="#the-trade-offs-of-using-clone-使用-clone-的权衡">The Trade-Offs of Using <code>clone</code> 使用 <code>clone</code> 的权衡</a></h3>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In
Chapter 13, you’ll learn how to use more efficient
methods in this type of situation. But for now, it’s okay to copy a few
strings to continue making progress because you’ll make these copies only
once and your file path and query string are very small. It’s better to have
a working program that’s a bit inefficient than to try to hyperoptimize code
on your first pass. As you become more experienced with Rust, it’ll be
easier to start with the most efficient solution, but for now, it’s
perfectly acceptable to call <code>clone</code>.</p>
<p>许多 Rust 开发者倾向于避免用 <code>clone</code> 解决所有权问题，因其有运行时开销。在第 13 章，你将学习在此类情况下使用更高效的方法。但当前复制少量字符串以继续推进是可以接受的，因为这些复制仅发生一次，且文件路径和查询字符串非常小。拥有稍低效但可工作的程序，比首次尝试就过度优化更好。随着 Rust 经验增长，你会更易从高效方案起步，但目前调用 <code>clone</code> 完全可接受。</p>
</section>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>file_path</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>我们更新了 <code>main</code>，将 <code>parse_config</code> 返回的 <code>Config</code> 实例存入变量 <code>config</code>，并将之前使用独立变量 <code>query</code> 和 <code>file_path</code> 的代码改为使用 <code>Config</code> 结构体的字段。</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>file_path</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<p>现在代码更清晰地表明 <code>query</code> 和 <code>file_path</code> 相关，其目的是配置程序工作方式。使用这些值的代码只需在 <code>config</code> 实例的对应字段中查找即可。</p>
<h4 id="creating-a-constructor-for-config-为-config-创建构造函数"><a class="header" href="#creating-a-constructor-for-config-为-config-创建构造函数">Creating a Constructor for <code>Config</code> 为 <code>Config</code> 创建构造函数</a></h4>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us see that the <code>query</code> and <code>file_path</code> values were related, and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>file_path</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>至此，我们已将参数解析逻辑从 <code>main</code> 提取到 <code>parse_config</code> 函数。这让我们看到 <code>query</code> 和 <code>file_path</code> 的关联性应体现在代码中。接着添加 <code>Config</code> 结构体命名其关联目的，并从 <code>parse_config</code> 返回字段名。</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make.</p>
<p>既然 <code>parse_config</code> 的目的是创建 <code>Config</code> 实例，可将其从普通函数改为与 <code>Config</code> 结构体关联的 <code>new</code> 函数。此变更使代码更符合 Rust 惯例。创建标准库类型（如 <code>String</code>）的实例可调用 <code>String::new</code>。类似地，将 <code>parse_config</code> 改为 <code>Config</code> 的关联函数 <code>new</code> 后，可通过 <code>Config::new</code> 创建实例。清单 12-7 展示了需要做的更改。</p>
<figure class="listing" id="listing-12-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-7">Listing 12-7</a>: Changing <code>parse_config</code> into <code>Config::new</code> 将 <code>parse_config</code> 改为 <code>Config::new</code></figcaption>
</figure>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<p>我们将 <code>main</code> 中调用 <code>parse_config</code> 的地方改为调用 <code>Config::new</code>。把 <code>parse_config</code> 重命名为 <code>new</code> 并移至 <code>impl</code> 块内，使 <code>new</code> 函数与 <code>Config</code> 关联。请再次编译此代码确保其工作。</p>
<h3 id="fixing-the-error-handling-修复错误处理"><a class="header" href="#fixing-the-error-handling-修复错误处理">Fixing the Error Handling 修复错误处理</a></h3>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:</p>
<p>现在我们来修复错误处理。回想一下，若向量包含少于三项时访问索引 1 或 2 会导致程序 panic。尝试不带参数运行程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
they should do instead. Let’s fix that now.</p>
<p><code>index out of bounds: the len is 1 but the index is 1</code> 这条面向程序员的消息对终端用户无帮助。现在修复它。</p>
<h4 id="improving-the-error-message-改进错误消息"><a class="header" href="#improving-the-error-message-改进错误消息">Improving the Error Message 改进错误消息</a></h4>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index 1 and index 2. If the slice isn’t
long enough, the program panics and displays a better error message.</p>
<p>在清单 12-8 中，我们在 <code>new</code> 函数添加检查，确保在访问索引 1 和 2 前切片足够长。若长度不足，程序 panic 并显示更好的错误消息。</p>
<figure class="listing" id="listing-12-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-8">Listing 12-8</a>: Adding a check for the number of arguments 添加参数数量检查</figcaption>
</figure>
<p>This code is similar to the <code>Guess::new</code> function we wrote in Listing
9-13, where we called <code>panic!</code> when the
<code>value</code> argument was out of the range of valid values. Instead of checking for
a range of values here, we’re checking that the length of <code>args</code> is at least
<code>3</code> and the rest of the function can operate under the assumption that this
condition has been met. If <code>args</code> has fewer than three items, this condition
will be <code>true</code>, and we call the <code>panic!</code> macro to end the program immediately.</p>
<p>此代码类似清单 9-13 的 <code>Guess::new</code> 函数（当 <code>value</code> 参数超出有效范围时调用 <code>panic!</code>）。这里不检查值范围，而检查 <code>args</code> 长度是否至少为 3，函数其余部分可基于此条件运行。若 <code>args</code> 少于三项，此条件为真，调用 <code>panic!</code> 宏立即终止程序。</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<p>在 <code>new</code> 中添加这几行后，再次不带参数运行程序查看错误信息：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps the
technique we used in Listing 9-13 isn’t the best one to use here: a call to
<code>panic!</code> is more appropriate for a programming problem than a usage problem,
as discussed in Chapter 9. Instead,
we’ll use the other technique you learned about in Chapter 9—returning a
<code>Result</code> that indicates either success or an error.</p>
<p>此输出更合理，但仍有冗余信息。清单 9-13 的技术可能不适用：如第 9 章所述，<code>panic!</code> 更适合编程问题而非用法问题。我们将改用第 9 章的另一技术——返回表示成功或错误的 <code>Result</code>。</p>
<h4 id="returning-a-result-instead-of-calling-panic-返回-result-而非调用-panic"><a class="header" href="#returning-a-result-instead-of-calling-panic-返回-result-而非调用-panic">Returning a <code>Result</code> Instead of Calling <code>panic!</code> 返回 <code>Result</code> 而非调用 <code>panic!</code></a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. We’re also
going to change the function name from <code>new</code> to <code>build</code> because many
programmers expect <code>new</code> functions to never fail. When <code>Config::build</code> is
communicating to <code>main</code>, we can use the <code>Result</code> type to signal there was a
problem. Then we can change <code>main</code> to convert an <code>Err</code> variant into a more
practical error for our users without the surrounding text about <code>thread  'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>我们改为返回 <code>Result</code>，成功时包含 <code>Config</code> 实例，错误时描述问题。同时将函数名从 <code>new</code> 改为 <code>build</code>，因为<span class="highlight">[note]许多开发者期望 <code>new</code> 函数永不失败</span>。当 <code>Config::build</code> 与 <code>main</code> 通信时，可用 <code>Result</code> 类型表示问题。接着修改 <code>main</code>，将 <code>Err</code> 变体转换为对用户更友好的错误，避免 <code>panic!</code> 引起的 <code>thread 'main'</code> 和 <code>RUST_BACKTRACE</code> 等文本。</p>
<p>Listing 12-9 shows the changes we need to make to the return value of the
function we’re now calling <code>Config::build</code> and the body of the function needed
to return a <code>Result</code>. Note that this won’t compile until we update <code>main</code> as
well, which we’ll do in the next listing.</p>
<p>清单 12-9 展示了需对 <code>Config::build</code> 返回值和函数体做的更改（返回 <code>Result</code>）。注意在更新 <code>main</code>（下个清单）前此代码无法编译。</p>
<figure class="listing" id="listing-12-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-9">Listing 12-9</a>: Returning a <code>Result</code> from <code>Config::build</code> 从 <code>Config::build</code> 返回 <code>Result</code></figcaption>
</figure>
<p>Our <code>build</code> function returns a <code>Result</code> with a <code>Config</code> instance in the success
case and a string literal in the error case. Our error values will always be
string literals that have the <code>'static</code> lifetime.</p>
<p><code>build</code> 函数返回 <code>Result</code>，成功时包含 <code>Config</code> 实例，错误时为字符串字面量（具有 <code>'static</code> 生命周期）。</p>
<p>We’ve made two changes in the body of the function: instead of calling <code>panic!</code>
when the user doesn’t pass enough arguments, we now return an <code>Err</code> value, and
we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes make the
function conform to its new type signature.</p>
<p>函数体内有两处改动：用户未提供足够参数时不再调用 <code>panic!</code> 而是返回 <code>Err</code> 值，并将 <code>Config</code> 返回值包装在 <code>Ok</code> 中。这些变更使函数符合新签名。</p>
<p>Returning an <code>Err</code> value from <code>Config::build</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>build</code> function and exit the
process more cleanly in the error case.</p>
<p>从 <code>Config::build</code> 返回 <code>Err</code> 允许 <code>main</code> 处理返回的 <code>Result</code>，并在错误时更清晰地退出进程。</p>
<h4 id="calling-configbuild-and-handling-errors-调用-configbuild-并处理错误"><a class="header" href="#calling-configbuild-and-handling-errors-调用-configbuild-并处理错误">Calling <code>Config::build</code> and Handling Errors 调用 <code>Config::build</code> 并处理错误</a></h4>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::build</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code away from <code>panic!</code> and instead implement it by
hand. A nonzero exit status is a convention to signal to the process that
called our program that the program exited with an error state.</p>
<p>为处理错误并打印用户友好消息，需更新 <code>main</code> 处理 <code>Config::build</code> 返回的 <code>Result</code>，如清单 12-10 所示。我们还将手动实现以非零错误码退出的逻辑（而非依赖 <code>panic!</code>）。非零退出状态是向调用进程表明程序以错误状态终止的约定。</p>
<figure class="listing" id="listing-12-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-10">Listing 12-10</a>: Exiting with an error code if building a <code>Config</code> fails 构建 <code>Config</code> 失败时带错误码退出</figcaption>
</figure>
<p>In this listing, we’ve used a method we haven’t covered in detail yet:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value that <code>Ok</code> is wrapping. However, if the
value is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is
an anonymous function we define and pass as an argument to <code>unwrap_or_else</code>.
We’ll cover closures in more detail in Chapter 13. For
now, you just need to know that <code>unwrap_or_else</code> will pass the inner value of
the <code>Err</code>, which in this case is the static string <code>"not enough arguments"</code>
that we added in Listing 12-9, to our closure in the argument <code>err</code> that
appears between the vertical pipes. The code in the closure can then use the
<code>err</code> value when it runs.</p>
<p>此清单使用了标准库为 <code>Result&lt;T, E&gt;</code> 定义的 <code>unwrap_or_else</code> 方法（尚未详细讲解）。该方法允许自定义非 <code>panic!</code> 的错误处理：若 <code>Result</code> 是 <code>Ok</code> 值，其行为类似 <code>unwrap</code>——返回 <code>Ok</code> 包装的内部值；若是 <code>Err</code> 值，则调用闭包（作为参数传递的匿名函数）中的代码。第 13 章将深入讲解闭包。现在只需知道：<code>unwrap_or_else</code> 会将 <code>Err</code> 的内部值（此处为清单 12-9 添加的 <code>"not enough arguments"</code> 静态字符串）传递给闭包参数 <code>err</code>（竖线间）。闭包代码运行时可使用 <code>err</code> 值。</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the <code>err</code> value and then call <code>process::exit</code>. The
<code>process::exit</code> function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
<code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:</p>
<p>我们添加了 <code>use</code> 行将标准库的 <code>process</code> 引入作用域。错误情况下的闭包代码仅两行：打印 <code>err</code> 值并<span class="highlight">[note]调用 <code>process::exit</code></span>。该函数会立即停止程序并返回传入的退出状态码。这类似清单 12-8 基于 <code>panic!</code> 的处理，但不再有额外输出。尝试运行：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<p>输出对用户友好多了！</p>
<h3 id="extracting-logic-from-the-main-function-从-main-提取逻辑"><a class="header" href="#extracting-logic-from-the-main-function-从-main-提取逻辑">Extracting Logic from the <code>main</code> Function 从 <code>main</code> 提取逻辑</a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll
extract a function named <code>run</code> that will hold all the logic currently in the
<code>main</code> function that isn’t involved with setting up configuration or handling
errors. When we’re done, the <code>main</code> function will be concise and easy to verify
by inspection, and we’ll be able to write tests for all the other logic.</p>
<p>完成配置解析的重构后，现在处理程序逻辑。如“二进制项目的职责分离”所述，我们将提取名为 <code>run</code> 的函数，包含当前 <code>main</code> 中与配置设置或错误处理无关的所有逻辑。完成后，<code>main</code> 函数将简洁易验证，其他逻辑均可测试。</p>
<p>Listing 12-11 shows the small, incremental improvement of extracting a <code>run</code>
function.</p>
<p>清单 12-11 展示了提取 <code>run</code> 函数的渐进改进。</p>
<figure class="listing" id="listing-12-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-11">Listing 12-11</a>: Extracting a <code>run</code> function containing the rest of the program logic 提取包含剩余程序逻辑的 <code>run</code> 函数</figcaption>
</figure>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<p><code>run</code> 函数现在包含从文件读取开始的 <code>main</code> 所有剩余逻辑，并以 <code>Config</code> 实例为参数。</p>
<h4 id="returning-errors-from-the-run-function-从-run-函数返回错误"><a class="header" href="#returning-errors-from-the-run-function-从-run-函数返回错误">Returning Errors from the <code>run</code> Function 从 <code>run</code> 函数返回错误</a></h4>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::build</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate the logic around handling errors into <code>main</code> in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>.</p>
<p>将剩余逻辑分离到 <code>run</code> 函数后，可改进错误处理（类似清单 12-9 对 <code>Config::build</code> 的改进）。不再通过 <code>expect</code> 调用引发 panic，而是让 <code>run</code> 在出错时返回 <code>Result&lt;T, E&gt;</code>。这让我们能将错误处理逻辑集中到 <code>main</code>，以更友好的方式处理。清单 12-12 展示了需对 <code>run</code> 签名和函数体做的更改。</p>
<figure class="listing" id="listing-12-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-12">Listing 12-12</a>: Changing the <code>run</code> function to return <code>Result</code> 修改 <code>run</code> 函数返回 <code>Result</code></figcaption>
</figure>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>我们在这里做了三处重要的修改。首先，我们将 <code>run</code> 函数的返回类型更改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。这个函数之前返回的是单位类型 <code>()</code>，我们保留了在 <code>Ok</code> 情况下返回的值。</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we’ve
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We’ll cover trait objects in Chapter 18. For now, just
know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that
implements the <code>Error</code> trait, but we don’t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The <code>dyn</code> keyword is short
for <em>dynamic</em>.</p>
<p>对于错误类型，我们使用了 <em>特征对象</em> <code>Box&lt;dyn Error&gt;</code>（并且我们在顶部通过 <code>use</code> 语句引入了 <code>std::error::Error</code>）。我们将在第18章讨论特征对象。现在，只需要知道 <code>Box&lt;dyn Error&gt;</code> 表示函数将返回一个实现了 <code>Error</code> 特征的类型，但我们不需要指定返回值的具体类型。这让我们可以灵活地返回不同错误情况可能出现的不同类型的错误值。<code>dyn</code> 关键字是 <em>动态</em> 的缩写。</p>
<p>Second, we’ve removed the call to <code>expect</code> in favor of the <code>?</code> operator, as we
talked about in Chapter 9. Rather than
<code>panic!</code> on an error, <code>?</code> will return the error value from the current function
for the caller to handle.</p>
<p>第二，我们删除了对 <code>expect</code> 的调用，改用了 <code>?</code> 运算符，正如我们在第9章讨论的那样。与其在出错时调用 <code>panic!</code>，<code>?</code> 会将错误值从当前函数返回，供调用者处理。</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case.
We’ve declared the <code>run</code> function’s success type as <code>()</code> in the signature,
which means we need to wrap the unit type value in the <code>Ok</code> value. This
<code>Ok(())</code> syntax might look a bit strange at first, but using <code>()</code> like this is
the idiomatic way to indicate that we’re calling <code>run</code> for its side effects
only; it doesn’t return a value we need.</p>
<p>第三，<code>run</code> 函数现在在成功的情况下返回一个 <code>Ok</code> 值。我们在函数签名中将 <code>run</code> 函数的成功类型声明为 <code>()</code>，这意味着我们需要将单位类型值包裹在 <code>Ok</code> 中。这个 <code>Ok(())</code> 语法起初可能看起来有点奇怪，但像这样使用 <code>()</code> 是表示我们仅仅是为了副作用调用 <code>run</code> 的惯用方式；它并没有返回我们需要的值。</p>
<p>When you run this code, it will compile but will display a warning:</p>
<p>运行此代码时会产生警告：</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.</p>
<p>Rust 告诉我们我们的代码忽略了 <code>Result</code> 值，而 <code>Result</code> 值可能表明发生了错误。但我们没有检查是否发生了错误，编译器提醒我们可能在这里漏掉了错误处理代码！让我们现在来解决这个问题。</p>
<h4 id="handling-errors-returned-from-run-in-main-在-main-中处理-run-返回的错误"><a class="header" href="#handling-errors-returned-from-run-in-main-在-main-中处理-run-返回的错误">Handling Errors Returned from <code>run</code> in <code>main</code> 在 <code>main</code> 中处理 <code>run</code> 返回的错误</a></h4>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::build</code> in Listing 12-10, but with a slight difference:</p>
<p>我们将用类似清单 12-10 处理 <code>Config::build</code> 的技术处理错误，但略有不同：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and to call <code>process::exit(1)</code> if it does. The <code>run</code> function
doesn’t return a value that we want to <code>unwrap</code> in the same way that
<code>Config::build</code> returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in
the success case, we only care about detecting an error, so we don’t need
<code>unwrap_or_else</code> to return the unwrapped value, which would only be <code>()</code>.</p>
<p>这里使用 <code>if let</code> 而非 <code>unwrap_or_else</code> 检查 <code>run</code> 是否返回 <code>Err</code>，是则调用 <code>process::exit(1)</code>。因为 <code>run</code> 成功时返回 <code>()</code>（而 <code>Config::build</code> 返回 <code>Config</code> 实例），我们只关心是否出错，无需像 <code>unwrap_or_else</code> 那样解包值（解包结果只会是 <code>()</code>）。</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<p><code>if let</code> 和 <code>unwrap_or_else</code> 的函数体相同：打印错误并退出。</p>
<h3 id="splitting-code-into-a-library-crate-将代码拆分为库-crate"><a class="header" href="#splitting-code-into-a-library-crate-将代码拆分为库-crate">Splitting Code into a Library Crate 将代码拆分为库 crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file. That way, we
can test the code and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>目前 <code>minigrep</code> 项目进展顺利！现在我们将拆分 <em>src/main.rs</em> 文件，把部分代码放入 <em>src/lib.rs</em>。这样即可测试代码，并让 <em>src/main.rs</em> 职责更少。</p>
<p>Let’s define the code responsible for searching text in <em>src/lib.rs</em> rather
than in <em>src/main.rs</em>, which will let us (or anyone else using our
<code>minigrep</code> library) call the searching function from more contexts than our
<code>minigrep</code> binary.</p>
<p>让我们在 <em>src/lib.rs</em> 中定义文本搜索逻辑（而非 <em>src/main.rs</em>），这样我们（或其他使用 <code>minigrep</code> 库的人）就能在更多上下文中调用搜索函数。</p>
<p>First, let’s define the <code>search</code> function signature in <em>src/lib.rs</em> as shown in
Listing 12-13, with a body that calls the <code>unimplemented!</code> macro. We’ll explain
the signature in more detail when we fill in the implementation.</p>
<p>首先在 <em>src/lib.rs</em> 中定义 <code>search</code> 函数签名（如清单 12-13），其函数体调用 <code>unimplemented!</code> 宏。实现时会详细解释签名。</p>
<figure class="listing" id="listing-12-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    unimplemented!();
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-13">Listing 12-13</a>: Defining the <code>search</code> function in  <em>src/lib.rs</em> 在 <em>src/lib.rs</em> 中定义 <code>search</code> 函数</figcaption>
</figure>
<p>We’ve used the <code>pub</code> keyword on the function definition to designate <code>search</code>
as part of our library crate’s public API. We now have a library crate that we
can use from our binary crate and that we can test!</p>
<p>在函数定义中使用 <code>pub</code> 关键字将 <code>search</code> 设为库 crate 公共 API 的一部分。现在有了可从二进制 crate 使用且可测试的库 crate！</p>
<p>Now we need to bring the code defined in <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em> and call it, as shown in Listing 12-14.</p>
<p>接下来需将 <em>src/lib.rs</em> 中的代码引入二进制 crate（在 <em>src/main.rs</em> 中）并调用，如清单 12-14 所示。</p>
<figure class="listing" id="listing-12-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>// --snip--
use minigrep::search;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="ch12-03-improving-error-handling-and-modularity.html#listing-12-14">Listing 12-14</a>: Using the <code>minigrep</code> library crate’s <code>search</code> function in <em>src/main.rs</em> 在 <em>src/main.rs</em> 使用 <code>minigrep</code> 库的 <code>search</code> 函数</figcaption>
</figure>
<p>We add a <code>use minigrep::search</code> line to bring the <code>search</code> function from
the library crate into the binary crate’s scope. Then, in the <code>run</code> function,
rather than printing out the contents of the file, we call the <code>search</code>
function and pass the <code>config.query</code> value and <code>contents</code> as arguments. Then
<code>run</code> will use a <code>for</code> loop to print each line returned from <code>search</code> that
matched the query. This is also a good time to remove the <code>println!</code> calls in
the <code>main</code> function that displayed the query and the file path so that our
program only prints the search results (if no errors occur).</p>
<p>添加 <code>use minigrep::search</code> 将库 crate 的 <code>search</code> 函数引入二进制 crate 作用域。接着在 <code>run</code> 函数中，不再打印文件内容，而是调用 <code>search</code> 函数（传入 <code>config.query</code> 和 <code>contents</code> 参数）。<code>run</code> 函数通过 <code>for</code> 循环打印 <code>search</code> 返回的每个匹配行。同时移除 <code>main</code> 中打印查询和文件路径的 <code>println!</code> 调用，使程序仅输出搜索结果（无错误时）。</p>
<p>Note that the search function will be collecting all the results into a vector
it returns before any printing happens. This implementation could be slow to
display results when searching large files because results aren’t printed as
they’re found; we’ll discuss a possible way to fix this using iterators in
Chapter 13.</p>
<p>注意：<code>search</code> 函数会在打印前将所有结果收集到返回的向量中。当搜索大文件时，此实现可能因无法实时打印而显慢；第 13 章将讨论用迭代器修复此问题的方法。</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>哇！虽然工作量很大，但我们为未来成功奠定了基础。现在错误处理更简单，代码也更模块化。此后几乎所有工作都将在 <em>src/lib.rs</em> 中完成。</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<p>让我们利用新获得的模块化优势做些旧代码难以实现的事：编写测试！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="developing-the-librarys-functionality-with-test-driven-development-使用测试驱动开发完善库功能"><a class="header" href="#developing-the-librarys-functionality-with-test-driven-development-使用测试驱动开发完善库功能">Developing the Library’s Functionality with Test-Driven Development 使用测试驱动开发完善库功能</a></h2>
<p>Now that we have the search logic in <em>src/lib.rs</em> separate from the <code>main</code>
function, it’s much easier to write tests for the core functionality of our
code. We can call functions directly with various arguments and check return
values without having to call our binary from the command line.</p>
<p>现在我们已经将 <em>src/lib.rs</em> 中的搜索逻辑与 <code>main</code> 函数分离，这让我们更容易为代码的核心功能编写测试。我们可以直接使用各种参数调用函数并检查返回值，而无需从命令行调用二进制文件。</p>
<p>In this section, we’ll add the searching logic to the <code>minigrep</code> program using
the test-driven development (TDD) process with the following steps:</p>
<p>本节我们将通过测试驱动开发（TDD）流程向 <code>minigrep</code> 程序添加搜索逻辑，步骤如下：</p>
<ul>
<li>Write a test that fails and run it to make sure it fails for the reason you
expect.</li>
<li>编写一个失败的测试并运行它，确保它因预期原因失败。</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>编写或修改最少量的代码使新测试通过。</li>
<li>Refactor the code you just added or changed and make sure the tests continue
to pass.</li>
<li>重构刚添加或修改的代码，并确保测试继续通过。</li>
<li>Repeat from step 1!</li>
<li>从步骤1开始重复！</li>
</ul>
<p>Though it’s just one of many ways to write software, TDD can help drive code
design. Writing the test before you write the code that makes the test pass
helps to maintain high test coverage throughout the process.</p>
<p>虽然这只是众多软件开发方法之一，但TDD有助于驱动代码设计。在编写使测试通过的代码之前先编写测试，有助于在整个过程中保持高测试覆盖率。</p>
<p>We’ll test-drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
<code>search</code>.</p>
<p>我们将通过测试驱动的方式实现实际功能：在文件内容中搜索查询字符串并生成匹配查询的行列表。我们将在一个名为 <code>search</code> 的函数中添加此功能。</p>
<h3 id="writing-a-failing-test-编写失败测试"><a class="header" href="#writing-a-failing-test-编写失败测试">Writing a Failing Test 编写失败测试</a></h3>
<p>In <em>src/lib.rs</em>, we’ll add a <code>tests</code> module with a test function, as we did in
Chapter 11. The test function specifies the
behavior we want the <code>search</code> function to have: it will take a query and the
text to search, and it will return only the lines from the text that contain
the query. Listing 12-15 shows this test.</p>
<p>在 <em>src/lib.rs</em> 中，我们将添加一个包含测试函数的 <code>tests</code> 模块（如第11章所做）。该测试函数明确了期望 <code>search</code> 函数具备的行为：它接收查询词和待搜索文本，仅返回文本中包含查询词的行。代码清单12-15展示了这个测试。</p>
<figure class="listing" id="listing-12-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
<figcaption><a href="ch12-04-testing-the-librarys-functionality.html#listing-12-15">Listing 12-15</a>: Creating a failing test for the <code>search</code> function for the functionality we wish we had 为期望实现的<code>search</code>功能创建失败测试</figcaption>
</figure>
<p>This test searches for the string <code>"duct"</code>. The text we’re searching is three
lines, only one of which contains <code>"duct"</code> (note that the backslash after the
opening double quote tells Rust not to put a newline character at the beginning
of the contents of this string literal). We assert that the value returned from
the <code>search</code> function contains only the line we expect.</p>
<p>该测试搜索字符串 <code>"duct"</code>。待搜索文本有三行，其中只有一行包含 <code>"duct"</code>（注意<span class="highlight">[note]开头双引号后的反斜杠告诉 Rust 不要在此字符串字面量开头添加换行符</span>）。我们断言 <code>search</code> 函数返回的值仅包含预期的那一行。</p>
<p>If we run this test, it will currently fail because the <code>unimplemented!</code> macro
panics with the message “not implemented”. In accordance with TDD principles,
we’ll take a small step of adding just enough code to get the test to not panic
when calling the function by defining the <code>search</code> function to always return an
empty vector, as shown in Listing 12-16. Then the test should compile and fail
because an empty vector doesn’t match a vector containing the line <code>"safe,  fast, productive."</code></p>
<p>如果运行此测试，它当前会失败，因为 <code>unimplemented!</code> 宏会因“未实现“的消息而恐慌（panic）。遵循TDD原则，我们将采取一个小步骤：添加刚好足够的代码使函数调用时不恐慌，如代码清单12-16所示，将 <code>search</code> 函数定义为始终返回空向量。此时测试应能编译但会失败，因为空向量与包含行 <code>"safe, fast, productive."</code> 的向量不匹配。</p>
<figure class="listing" id="listing-12-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-04-testing-the-librarys-functionality.html#listing-12-16">Listing 12-16</a>: Defining just enough of the <code>search</code> function so calling it won’t panic 定义<code>search</code>函数的最小实现使其可被调用（不恐慌）</figcaption>
</figure>
<p>Now let’s discuss why we need to define an explicit lifetime <code>'a</code> in the
signature of <code>search</code> and use that lifetime with the <code>contents</code> argument and
the return value. Recall in Chapter 10 that
the lifetime parameters specify which argument lifetime is connected to the
lifetime of the return value. In this case, we indicate that the returned
vector should contain string slices that reference slices of the argument
<code>contents</code> (rather than the argument <code>query</code>).</p>
<p>现在讨论为何需要在 <code>search</code> 签名中定义显式生命周期 <code>'a</code>，并在 <code>contents</code> 参数和返回值中使用它。回顾第10章，生命周期参数指定哪个参数生命周期与返回值生命周期相关联。此处我们指明返回的向量应包含引用参数 <code>contents</code>（而非参数 <code>query</code>）切片的字符串切片。</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function
will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking
incorrectly.</p>
<p>换句话说，我们告诉 Rust：<code>search</code> 函数返回的数据存活时间将与传入 <code>search</code> 函数的 <code>contents</code> 参数数据一样长。这很重要！切片引用的数据必须有效，引用才能有效；若编译器假定我们创建的是 <code>query</code> 而非 <code>contents</code> 的字符串切片，其安全检查将出错。</p>
<p>If we forget the lifetime annotations and try to compile this function, we’ll
get this error:</p>
<p>如果忘记生命周期注解尝试编译此函数，将得到以下错误：</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:1:51
  |
1 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                      ----            ----         ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
  |
1 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
  |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust can’t know which of the two parameters we need for the output, so we need
to tell it explicitly. Note that the help text suggests specifying the same
lifetime parameter for all the parameters and the output type, which is
incorrect! Because <code>contents</code> is the parameter that contains all of our text
and we want to return the parts of that text that match, we know <code>contents</code> is
the only parameter that should be connected to the return value using the
lifetime syntax.</p>
<p>Rust 无法确定输出需要哪个参数，因此需要显式告知。注意帮助文本建议为所有参数和输出类型指定相同的生命周期参数，这是错误的！由于 <code>contents</code> 是包含全部文本的参数，且我们要返回匹配该文本的部分，因此只有 <code>contents</code> 应通过生命周期语法与返回值关联。</p>
<p>Other programming languages don’t require you to connect arguments to return
values in the signature, but this practice will get easier over time. You might
want to compare this example with the examples in the “Validating References
with Lifetimes” section
in Chapter 10.</p>
<p>其他编程语言不要求在签名中连接参数与返回值，但这种实践会随时间推移变得容易。建议将此示例与第10章“使用生命周期验证引用“部分的示例进行比较。</p>
<h3 id="writing-code-to-pass-the-test-编写通过测试的代码"><a class="header" href="#writing-code-to-pass-the-test-编写通过测试的代码">Writing Code to Pass the Test 编写通过测试的代码</a></h3>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<p>当前测试因始终返回空向量而失败。为实现 <code>search</code> 功能，程序需遵循以下步骤：</p>
<ul>
<li>Iterate through each line of the contents.</li>
<li>遍历内容的每一行。</li>
<li>Check whether the line contains our query string.</li>
<li>检查行是否包含查询字符串。</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>若包含，则将其添加到返回的值列表中。</li>
<li>If it doesn’t, do nothing.</li>
<li>若不包含，则不执行操作。</li>
<li>Return the list of results that match.</li>
<li>返回匹配的结果列表。</li>
</ul>
<p>Let’s work through each step, starting with iterating through lines.</p>
<p>让我们逐步实现，从遍历行开始。</p>
<h4 id="iterating-through-lines-with-the-lines-method-使用-lines-方法逐行迭代"><a class="header" href="#iterating-through-lines-with-the-lines-method-使用-lines-方法逐行迭代">Iterating Through Lines with the <code>lines</code> Method 使用 <code>lines</code> 方法逐行迭代</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note that
this won’t compile yet.</p>
<p>Rust 提供了便捷的 <code>lines</code> 方法处理字符串的逐行迭代，如代码清单12-17所示。注意此代码尚不能编译。</p>
<figure class="listing" id="listing-12-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-04-testing-the-librarys-functionality.html#listing-12-17">Listing 12-17</a>: Iterating through each line in <code>contents</code> 遍历<code>contents</code>中的每一行</figcaption>
</figure>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in
Chapter 13, but recall that you saw this way
of using an iterator in Listing 3-5, where we used a
<code>for</code> loop with an iterator to run some code on each item in a collection.</p>
<p><code>lines</code> 方法返回一个迭代器。我们将在第13章深入讨论迭代器，但回忆一下在代码清单3-5中曾用 <code>for</code> 循环配合迭代器对集合中每个元素执行代码。</p>
<h4 id="searching-each-line-for-the-query-在每行中搜索查询词"><a class="header" href="#searching-each-line-for-the-query-在每行中搜索查询词">Searching Each Line for the Query 在每行中搜索查询词</a></h4>
<p>Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named <code>contains</code> that does this for
us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in
Listing 12-18. Note that this still won’t compile yet.</p>
<p>接下来检查当前行是否包含查询字符串。幸运的是，字符串提供了 <code>contains</code> 方法！如代码清单12-18所示，在 <code>search</code> 函数中添加对 <code>contains</code> 的调用。注意此代码仍不能编译。</p>
<figure class="listing" id="listing-12-18">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-04-testing-the-librarys-functionality.html#listing-12-18">Listing 12-18</a>: Adding functionality to see whether the line contains the string in <code>query</code> 添加检查行是否包含<code>query</code>字符串的功能</figcaption>
</figure>
<p>At the moment, we’re building up functionality. To get the code to compile, we
need to return a value from the body as we indicated we would in the function
signature.</p>
<p>目前我们正在构建功能。为使代码编译，需从函数体返回签名中声明的值。</p>
<h4 id="storing-matching-lines-存储匹配行"><a class="header" href="#storing-matching-lines-存储匹配行">Storing Matching Lines 存储匹配行</a></h4>
<p>To finish this function, we need a way to store the matching lines that we want
to return. For that, we can make a mutable vector before the <code>for</code> loop and
call the <code>push</code> method to store a <code>line</code> in the vector. After the <code>for</code> loop,
we return the vector, as shown in Listing 12-19.</p>
<p>要完成此函数，需要存储要返回的匹配行。为此，在 <code>for</code> 循环前创建可变向量，并调用 <code>push</code> 方法将 <code>line</code> 存入向量。<code>for</code> 循环后返回该向量，如代码清单12-19所示。</p>
<figure class="listing" id="listing-12-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-04-testing-the-librarys-functionality.html#listing-12-19">Listing 12-19</a>: Storing the lines that match so we can return them 存储匹配行以便返回</figcaption>
</figure>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>,
and our test should pass. Let’s run the test:</p>
<p>现在 <code>search</code> 函数应仅返回包含 <code>query</code> 的行，测试应能通过。运行测试：</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Our test passed, so we know it works!</p>
<p>测试通过，确认功能正常！</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in Chapter 13, where
we’ll explore iterators in detail, and look at how to improve it.</p>
<p>此时，可以考虑重构 <code>search</code> 函数的实现，同时保持测试通过以维持相同功能。当前实现尚可，但未充分利用迭代器的特性。我们将在第13章重新探讨此示例，详细研究迭代器并改进实现。</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem: <em>frog</em>.</p>
<p>现在整个程序应能工作！让我们用 Emily Dickinson 诗中应返回单行的词测试：<em>frog</em>。</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like <em>body</em>:</p>
<p>很好！现在尝试匹配多行的词，如 <em>body</em>：</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as <em>monomorphization</em>:</p>
<p>最后确认搜索诗中不存在的词（如 <em>monomorphization</em>）时不返回任何行：</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>完美！我们构建了自己的经典工具简化版，并学习了应用结构设计。同时还学习了文件输入输出、生命周期、测试和命令行解析。</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
<p>作为项目收尾，我们将简要演示如何处理环境变量及打印到标准错误流，这两者在编写命令行程序时非常实用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="working-with-environment-variables-使用环境变量"><a class="header" href="#working-with-environment-variables-使用环境变量">Working with Environment Variables 使用环境变量</a></h2>
<p>We’ll improve the <code>minigrep</code> binary by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but by instead making it an
environment variable, we allow our users to set the environment variable once
and have all their searches be case insensitive in that terminal session.</p>
<p>我们将通过额外功能改进 <code>minigrep</code>：允许用户通过环境变量开启大小写不敏感搜索。虽然可以将其设为命令行选项要求用户每次输入，但改用环境变量允许用户设置一次，即可在整个终端会话中进行大小写不敏感搜索。</p>
<h3 id="writing-a-failing-test-for-the-case-insensitive-search-function-为大小写不敏感的-search-函数编写失败测试"><a class="header" href="#writing-a-failing-test-for-the-case-insensitive-search-function-为大小写不敏感的-search-函数编写失败测试">Writing a Failing Test for the Case-Insensitive <code>search</code> Function 为大小写不敏感的 <code>search</code> 函数编写失败测试</a></h3>
<p>We first add a new <code>search_case_insensitive</code> function to the <code>minigrep</code> library
that will be called when the environment variable has a value. We’ll continue
to follow the TDD process, so the first step is again to write a failing test.
We’ll add a new test for the new <code>search_case_insensitive</code> function and rename
our old test from <code>one_result</code> to <code>case_sensitive</code> to clarify the differences
between the two tests, as shown in Listing 12-20.</p>
<p>首先在 <code>minigrep</code> 库中添加新的 <code>search_case_insensitive</code> 函数，当环境变量存在时调用它。继续遵循TDD流程，第一步仍是编写失败测试。如代码清单12-20所示，为新函数添加测试，并将旧测试从 <code>one_result</code> 重命名为 <code>case_sensitive</code> 以区分两者。</p>
<figure class="listing" id="listing-12-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
<figcaption><a href="ch12-05-working-with-environment-variables.html#listing-12-20">Listing 12-20</a>: Adding a new failing test for the case-insensitive function we’re about to add 为即将添加的大小写不敏感函数编写新失败测试</figcaption>
</figure>
<p>Note that we’ve edited the old test’s <code>contents</code> too. We’ve added a new line
with the text <code>"Duct tape."</code> using a capital <em>D</em> that shouldn’t match the query
<code>"duct"</code> when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>注意我们也修改了旧测试的 <code>contents</code>，添加了带大写 <em>D</em> 的新行 <code>"Duct tape."</code>，它在大小写敏感搜索中不应匹配查询 <code>"duct"</code>。这样修改旧测试能确保不破坏已实现的大小写敏感搜索功能。该测试现在应通过，并在处理大小写不敏感搜索时保持通过。</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>"rUsT"</code> as its query. In
the <code>search_case_insensitive</code> function we’re about to add, the query <code>"rUsT"</code>
should match the line containing <code>"Rust:"</code> with a capital <em>R</em> and match the
line <code>"Trust me."</code> even though both have different casing from the query. This
is our failing test, and it will fail to compile because we haven’t yet defined
the <code>search_case_insensitive</code> function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<p>大小写不敏感测试使用 <code>"rUsT"</code> 作为查询。在即将添加的 <code>search_case_insensitive</code> 函数中，查询 <code>"rUsT"</code> 应匹配包含大写 <em>R</em> 的 <code>"Rust:"</code> 行，以及 <code>"Trust me."</code> 行，尽管它们的大小写与查询不同。这是失败的测试，由于尚未定义 <code>search_case_insensitive</code> 函数，编译将失败。可以添加一个始终返回空向量的骨架实现（类似代码清单12-16中 <code>search</code> 的做法）来观察测试编译和失败。</p>
<h3 id="implementing-the-search_case_insensitive-function-实现-search_case_insensitive-函数"><a class="header" href="#implementing-the-search_case_insensitive-function-实现-search_case_insensitive-函数">Implementing the <code>search_case_insensitive</code> Function 实现 <code>search_case_insensitive</code> 函数</a></h3>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we’ll lowercase
the <code>query</code> and each <code>line</code> so that whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.</p>
<p>如代码清单12-21所示，<code>search_case_insensitive</code> 函数与 <code>search</code> 几乎相同，唯一区别是将 <code>query</code> 和每行 <code>line</code> 转为小写，使得无论输入参数大小写如何，检查行是否包含查询时都保持相同大小写。</p>
<figure class="listing" id="listing-12-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-05-working-with-environment-variables.html#listing-12-21">Listing 12-21</a>: Defining the <code>search_case_insensitive</code> function to lowercase the query and the line before comparing them 定义<code>search_case_insensitive</code>函数：比较前将查询和行转为小写</figcaption>
</figure>
<p>First we lowercase the <code>query</code> string and store it in a new variable with the
same name, shadowing the original <code>query</code>. Calling <code>to_lowercase</code> on the query
is necessary so that no matter whether the user’s query is <code>"rust"</code>, <code>"RUST"</code>,
<code>"Rust"</code>, or <code>"``rUsT``"</code>, we’ll treat the query as if it were <code>"rust"</code> and be
insensitive to the case. While <code>to_lowercase</code> will handle basic Unicode, it
won’t be 100 percent accurate. If we were writing a real application, we’d want
to do a bit more work here, but this section is about environment variables,
not Unicode, so we’ll leave it at that here.</p>
<p>首先将 <code>query</code> 字符串转为小写并存入同名新变量（遮蔽原始 <code>query</code>）。调用 <code>to_lowercase</code> 是必要的，这样无论用户查询是 <code>"rust"</code>、<code>"RUST"</code>、<code>"Rust"</code> 还是 <code>"rUsT"</code>，都会视为 <code>"rust"</code> 并忽略大小写。虽然 <code>to_lowercase</code> 能处理基础 Unicode，但并非 100% 精确。在真实应用中需更多处理，但本节重点在环境变量而非 Unicode，故暂不深入。</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is <code>"rUsT"</code>, as an example: that string slice doesn’t contain a lowercase
<code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing
<code>"rust"</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>注意 <code>query</code> 现在是 <code>String</code> 而非字符串切片，因为调用 <code>to_lowercase</code> 会创建新数据而非引用现有数据。以查询 <code>"rUsT"</code> 为例：该字符串切片不含小写 <code>u</code> 或 <code>t</code>，因此需分配包含 <code>"rust"</code> 的新 <code>String</code>。现在将 <code>query</code> 作为参数传递给 <code>contains</code> 时需添加 <code>&amp;</code>，因为 <code>contains</code> 签名定义为接收字符串切片。</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> to lowercase all
characters. Now that we’ve converted <code>line</code> and <code>query</code> to lowercase, we’ll
find matches no matter what the case of the query is.</p>
<p>接着在每行 <code>line</code> 上调用 <code>to_lowercase</code> 转为小写。现在无论查询大小写如何，都能找到匹配项。</p>
<p>Let’s see if this implementation passes the tests:</p>
<p>检查实现是否通过测试：</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Great! They passed. Now, let’s call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First we’ll add a configuration option to the <code>Config</code>
struct to switch between case-sensitive and case-insensitive search. Adding
this field will cause compiler errors because we aren’t initializing this field
anywhere yet:</p>
<p>很好！测试通过。现在从 <code>run</code> 函数调用新的 <code>search_case_insensitive</code> 函数。首先在 <code>Config</code> 结构体中添加配置选项来切换大小写敏感搜索。添加此字段会导致编译错误，因为尚未初始化该字段：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>We added the <code>ignore_case</code> field that holds a Boolean. Next, we need the <code>run</code>
function to check the <code>ignore_case</code> field’s value and use that to decide
whether to call the <code>search</code> function or the <code>search_case_insensitive</code>
function, as shown in Listing 12-22. This still won’t compile yet.</p>
<p>我们添加了布尔类型字段 <code>ignore_case</code>。接下来需要 <code>run</code> 函数检查 <code>ignore_case</code> 值，决定调用 <code>search</code> 还是 <code>search_case_insensitive</code>，如代码清单12-22所示。此代码仍不能编译。</p>
<figure class="listing" id="listing-12-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>use minigrep::{search, search_case_insensitive};

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="ch12-05-working-with-environment-variables.html#listing-12-22">Listing 12-22</a>: Calling either <code>search</code> or <code>search_case_insensitive</code> based on the value in <code>config.ignore_case</code> 根据<code>config.ignore_case</code>的值调用<code>search</code>或<code>search_case_insensitive</code></figcaption>
</figure>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, which is already in scope at the top of <em>src/main.rs</em>. We’ll use the
<code>var</code> function from the <code>env</code> module to check to see if any value has been set
for an environment variable named <code>IGNORE_CASE</code>, as shown in Listing 12-23.</p>
<p>最后需要检查环境变量。标准库的 <code>env</code> 模块包含环境变量处理函数（已通过 <em>src/main.rs</em> 顶部作用域引入）。如代码清单12-23所示，使用 <code>env</code> 模块的 <code>var</code> 函数检查名为 <code>IGNORE_CASE</code> 的环境变量是否被设置。</p>
<figure class="listing" id="listing-12-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-05-working-with-environment-variables.html#listing-12-23">Listing 12-23</a>: Checking for any value in an environment variable named <code>IGNORE_CASE</code> 检查名为<code>IGNORE_CASE</code>的环境变量是否有值</figcaption>
</figure>
<p>Here, we create a new variable, <code>ignore_case</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>IGNORE_CASE</code> environment
variable. The <code>env::var</code> function returns a <code>Result</code> that will be the
successful <code>Ok</code> variant that contains the value of the environment variable if
the environment variable is set to any value. It will return the <code>Err</code> variant
if the environment variable is not set.</p>
<p>这里创建新变量 <code>ignore_case</code>。为设置其值，<span class="highlight">[note]调用 <code>env::var</code> 函数并传入环境变量名</span> <code>IGNORE_CASE</code>。<code>env::var</code> 返回 <code>Result</code>：若环境变量设为任意值，则为包含其值的成功 <code>Ok</code> 变体；若未设置，则为 <code>Err</code> 变体。</p>
<p>We’re using the <code>is_ok</code> method on the <code>Result</code> to check whether the environment
variable is set, which means the program should do a case-insensitive search.
If the <code>IGNORE_CASE</code> environment variable isn’t set to anything, <code>is_ok</code> will
return <code>false</code> and the program will perform a case-sensitive search. We don’t
care about the <em>value</em> of the environment variable, just whether it’s set or
unset, so we’re checking <code>is_ok</code> rather than using <code>unwrap</code>, <code>expect</code>, or any
of the other methods we’ve seen on <code>Result</code>.</p>
<p>我们在 <code>Result</code> 上使用 <code>is_ok</code> 方法检查环境变量是否设置（即程序应执行大小写不敏感搜索）。若 <code>IGNORE_CASE</code> 未设置，<code>is_ok</code> 返回 <code>false</code>，程序执行大小写敏感搜索。我们不关心环境变量的值，只关心是否设置，因此检查 <code>is_ok</code> 而非 <code>unwrap</code>、<code>expect</code> 等 <code>Result</code> 方法。</p>
<p>We pass the value in the <code>ignore_case</code> variable to the <code>Config</code> instance so the
<code>run</code> function can read that value and decide whether to call
<code>search_case_insensitive</code> or <code>search</code>, as we implemented in Listing 12-22.</p>
<p>将 <code>ignore_case</code> 的值传递给 <code>Config</code> 实例，以便 <code>run</code> 函数读取该值并决定调用 <code>search_case_insensitive</code> 还是 <code>search</code>（如代码清单12-22实现）。</p>
<p>Let’s give it a try! First we’ll run our program without the environment
variable set and with the query <code>to</code>, which should match any line that contains
the word <em>to</em> in all lowercase:</p>
<p>尝试运行！首先不设置环境变量，用查询词 <code>to</code> 运行（应匹配所有含小写 <em>to</em> 的行）：</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now let’s run the program with <code>IGNORE_CASE</code> set
to <code>1</code> but with the same query <em>to</em>:</p>
<p>运行正常！现在设置 <code>IGNORE_CASE=1</code> 并用相同查询词 <em>to</em> 运行：</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>If you’re using PowerShell, you will need to set the environment variable and
run the program as separate commands:</p>
<p>若使用 PowerShell，需分设环境变量和运行命令：</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>This will make <code>IGNORE_CASE</code> persist for the remainder of your shell session.
It can be unset with the <code>Remove-Item</code> cmdlet:</p>
<p>这将使 <code>IGNORE_CASE</code> 在剩余 shell 会话中持续生效。可用 <code>Remove-Item</code> cmdlet 取消设置：</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>We should get lines that contain <em>to</em> that might have uppercase letters:</p>
<p>现在应得到包含 <em>to</em> 且可能有大写字母的行：</p>
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing <em>To</em>! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.</p>
<p>很好，我们也得到了包含 <em>To</em> 的行！<code>minigrep</code> 程序现在可通过环境变量控制大小写不敏感搜索。现在你已掌握如何管理命令行参数或环境变量设置的选项。</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case sensitivity
through either a command line argument or an environment variable. Decide
whether the command line argument or the environment variable should take
precedence if the program is run with one set to case sensitive and one set to
ignore case.</p>
<p>某些程序允许同时使用参数和环境变量配置相同功能。此时程序需决定优先级。作为额外练习，尝试通过命令行参数或环境变量控制大小写敏感性，并决定当两者设置冲突（一个大小写敏感，一个忽略大小写）时哪个优先级更高。</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<p><code>std::env</code> 模块包含更多处理环境变量的实用功能：请查阅文档了解可用内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writing-error-messages-to-standard-error-instead-of-standard-output-将错误信息写入标准错误流而非标准输出流"><a class="header" href="#writing-error-messages-to-standard-error-instead-of-standard-output-将错误信息写入标准错误流而非标准输出流">Writing Error Messages to Standard Error Instead of Standard Output 将错误信息写入标准错误流而非标准输出流</a></h2>
<p>At the moment, we’re writing all of our output to the terminal using the
<code>println!</code> macro. In most terminals, there are two kinds of output: <em>standard
output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>) for
error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.</p>
<p>目前我们使用 <code>println!</code> 宏将所有输出写入终端。多数终端有两种输出：<em>标准输出流</em>（<code>stdout</code>）用于常规信息，<em>标准错误流</em>（<code>stderr</code>）用于错误信息。这种区分使用户可将程序成功输出重定向到文件，同时在屏幕显示错误信息。</p>
<p>The <code>println!</code> macro is only capable of printing to standard output, so we have
to use something else to print to standard error.</p>
<p><code>println!</code> 宏仅能打印到标准输出流，因此需使用其他方式打印到标准错误流。</p>
<h3 id="checking-where-errors-are-written-检查错误写入位置"><a class="header" href="#checking-where-errors-are-written-检查错误写入位置">Checking Where Errors Are Written 检查错误写入位置</a></h3>
<p>First let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while intentionally causing an error. We won’t redirect the standard
error stream, so any content sent to standard error will continue to display on
the screen.</p>
<p>首先观察 <code>minigrep</code> 的内容如何被写入标准输出（包括本应写入标准错误流的错误信息）。通过将标准输出流重定向到文件并故意引发错误来演示。我们不重定向标准错误流，因此其内容仍会显示在屏幕上。</p>
<p>Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well behaved:
we’re about to see that it saves the error message output to a file instead!</p>
<p>命令行程序应将错误信息发送到标准错误流，这样即使重定向标准输出流，仍能在屏幕上看到错误信息。但当前程序行为不符合预期：我们将看到错误信息被保存到文件中！</p>
<p>To demonstrate this behavior, we’ll run the program with <code>&gt;</code> and the file path,
<em>output.txt</em>, that we want to redirect the standard output stream to. We won’t
pass any arguments, which should cause an error:</p>
<p>为演示此行为，我们将不带参数运行程序（这会引发错误），并使用 <code>&gt;</code> 和文件路径 <em>output.txt</em> 重定向标准输出流：</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<p><code>&gt;</code> 语法告诉 shell 将标准输出流内容写入 <em>output.txt</em> 而非屏幕。我们未在屏幕看到预期的错误信息，说明它被写入文件。以下是 <em>output.txt</em> 的内容：</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We’ll change that.</p>
<p>是的，错误信息被打印到标准输出流。此类错误信息打印到标准错误流更合理，这样只有成功运行的数据会进入文件。我们将修改这一点。</p>
<h3 id="printing-errors-to-standard-error-将错误打印到标准错误流"><a class="header" href="#printing-errors-to-standard-error-将错误打印到标准错误流">Printing Errors to Standard Error 将错误打印到标准错误流</a></h3>
<p>We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, <code>main</code>. The standard library provides
the <code>eprintln!</code> macro that prints to the standard error stream, so let’s change
the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code>
instead.</p>
<p>使用代码清单12-24的代码修改错误信息打印方式。得益于本章早前的重构，所有错误打印代码都在 <code>main</code> 函数中。<span class="highlight">[note]标准库提供 <code>eprintln!</code> 宏用于打印到标准错误流</span>，因此将两处调用 <code>println!</code> 打印错误的地方改为 <code>eprintln!</code>。</p>
<figure class="listing" id="listing-12-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch12-06-writing-to-stderr-instead-of-stdout.html#listing-12-24">Listing 12-24</a>: Writing error messages to standard error instead of standard output using <code>eprintln!</code> 使用<code>eprintln!</code>将错误信息写入标准错误流而非标准输出流</figcaption>
</figure>
<p>Let’s now run the program again in the same way, without any arguments and
redirecting standard output with <code>&gt;</code>:</p>
<p>现在以相同方式再次运行程序（不带参数并用 <code>&gt;</code> 重定向标准输出）：</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the
behavior we expect of command line programs.</p>
<p>现在屏幕上看到错误，且 <em>output.txt</em> 为空，符合命令行程序的预期行为。</p>
<p>Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:</p>
<p>再次用不会引发错误的参数运行程序，但仍重定向标准输出到文件：</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>We won’t see any output to the terminal, and <em>output.txt</em> will contain our
results:</p>
<p>终端无输出，且 <em>output.txt</em> 包含结果：</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.</p>
<p>这表明我们已将成功输出用于标准输出流，错误输出用于标准错误流。</p>
<h2 id="summary-总结-11"><a class="header" href="#summary-总结-11">Summary 总结</a></h2>
<p>This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the <code>eprintln!</code> macro for printing
errors, you’re now prepared to write command line applications. Combined with
the concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.</p>
<p>本章回顾了目前所学的核心概念，并介绍了如何在 Rust 中执行常见 I/O 操作。通过使用命令行参数、文件、环境变量和 <code>eprintln!</code> 宏打印错误，你已为编写命令行应用做好准备。结合前几章的概念，你的代码将组织良好、高效存储数据、优雅处理错误且经过充分测试。</p>
<p>Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.</p>
<p>接下来，我们将探索受函数式语言影响的 Rust 特性：闭包和迭代器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-features-iterators-and-closures-函数式语言特性迭代器与闭包"><a class="header" href="#functional-language-features-iterators-and-closures-函数式语言特性迭代器与闭包">Functional Language Features: Iterators and Closures 函数式语言特性：迭代器与闭包</a></h1>
<p>Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.</p>
<p>Rust 的设计从许多现有语言和技术中汲取了灵感，其中一个重要影响来自<strong>函数式编程</strong>。函数式编程风格通常包括将函数作为值使用：通过参数传递函数、从其他函数返回函数、将函数赋值给变量以便后续执行等。</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.</p>
<p>本章中，我们不会探讨函数式编程的具体定义，而是讨论 Rust 中与常被称为函数式的语言相似的一些特性。</p>
<p>More specifically, we’ll cover:</p>
<p>具体来说，我们将涵盖：</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><strong>闭包</strong>：一种可存储在变量中的类函数结构</li>
<li><em>Iterators</em>, a way of processing a series of elements</li>
<li><strong>迭代器</strong>：处理元素序列的方法</li>
<li>How to use closures and iterators to improve the I/O project in Chapter 12</li>
<li>如何利用闭包和迭代器改进第 12 章的 I/O 项目</li>
<li>The performance of closures and iterators (spoiler alert: they’re faster than
you might think!)</li>
<li>闭包和迭代器的性能（剧透警告：它们比你想象的更快！）</li>
</ul>
<p>We’ve already covered some other Rust features, such as pattern matching and
enums, that are also influenced by the functional style. Because mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, we’ll devote this entire chapter to them.</p>
<p>我们已经介绍过的其他 Rust 特性（如模式匹配和枚举）同样受到函数式风格的影响。由于掌握闭包和迭代器是编写地道、高效 Rust 代码的关键，我们将用整章篇幅深入探讨它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="closures-anonymous-functions-that-capture-their-environment-闭包可捕获环境的匿名函数"><a class="header" href="#closures-anonymous-functions-that-capture-their-environment-闭包可捕获环境的匿名函数">Closures: Anonymous Functions That Capture Their Environment 闭包：可捕获环境的匿名函数</a></h2>
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure elsewhere to evaluate it in a different context. Unlike
functions, closures can capture values from the scope in which they’re defined.
We’ll demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<p>Rust 的闭包是可存储在变量中或作为参数传递给其他函数的匿名函数。你可以在一处创建闭包，然后在另一处调用闭包以在不同上下文中求值。与函数不同，闭包能捕获其定义作用域中的值。我们将展示这些闭包特性如何实现代码复用和行为定制。</p>
<h3 id="capturing-the-environment-with-closures-使用闭包捕获环境"><a class="header" href="#capturing-the-environment-with-closures-使用闭包捕获环境">Capturing the Environment with Closures 使用闭包捕获环境</a></h3>
<p>We’ll first examine how we can use closures to capture values from the
environment they’re defined in for later use. Here’s the scenario: every so
often, our T-shirt company gives away an exclusive, limited-edition shirt to
someone on our mailing list as a promotion. People on the mailing list can
optionally add their favorite color to their profile. If the person chosen for
a free shirt has their favorite color set, they get that color shirt. If the
person hasn’t specified a favorite color, they get whatever color the company
currently has the most of.</p>
<p>首先我们探究如何用闭包捕获其定义环境中的值以供后续使用。假设场景：我们的 T 恤公司定期向邮件列表用户赠送独家限量版 T 恤作为促销。邮件列表用户可选择在个人资料中添加喜爱的颜色。若中奖用户设置了喜爱颜色，将获得该颜色的 T 恤；若未指定，则获得公司当前库存最多的颜色。</p>
<p>There are many ways to implement this. For this example, we’re going to use an
enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the
number of colors available for simplicity). We represent the company’s
inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that
contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.
The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt
color preference of the free-shirt winner, and returns the shirt color the
person will get. This setup is shown in Listing 13-1.</p>
<p>实现方式多种多样。本例中，我们将使用名为 <code>ShirtColor</code> 的枚举，包含 <code>Red</code> 和 <code>Blue</code> 变体（为简化限制可选颜色）。用 <code>Inventory</code> 结构体表示公司库存，其 <code>shirts</code> 字段包含表示当前库存颜色的 <code>Vec&lt;ShirtColor&gt;</code>。<code>Inventory</code> 上定义的 <code>giveaway</code> 方法获取中奖者的可选颜色偏好，并返回该用户将获得的颜色。如示例 13-1 所示。</p>
<figure class="listing" id="listing-13-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-1">Listing 13-1</a>: Shirt company giveaway situation T恤公司赠送场景</figcaption>
</figure>
<p>The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt remaining
to distribute for this limited-edition promotion. We call the <code>giveaway</code> method
for a user with a preference for a red shirt and a user without any preference.</p>
<p><code>main</code> 中定义的 <code>store</code> 有两件蓝 T 恤和一件红 T 恤可用于此次限量促销。我们为有红 T 恤偏好和无偏好的用户调用 <code>giveaway</code> 方法。</p>
<p>Again, this code could be implemented in many ways, and here, to focus on
closures, we’ve stuck to concepts you’ve already learned, except for the body of
the <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the
user preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the
<code>unwrap_or_else</code> method on <code>user_preference</code>. The  is defined by the standard library.
It takes one argument: a closure without any arguments that returns a value <code>T</code>
(the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case
<code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code>
returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code>
variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by
the closure.</p>
<p>重申：此代码有多种实现方式。此处为聚焦闭包，除 <code>giveaway</code> 方法体内使用了闭包外，我们仅使用已学概念。在 <code>giveaway</code> 方法中，我们获取 <code>Option&lt;ShirtColor&gt;</code> 类型的用户偏好，并在 <code>user_preference</code> 上调用 <code>unwrap_or_else</code> 方法。此方法由标准库定义，接收一个参数：无参数且返回值 <code>T</code> 的闭包（与 <code>Option&lt;T&gt;</code> 中 <code>Some</code> 变体存储的类型相同，此处为 <code>ShirtColor</code>）。若 <code>Option&lt;T&gt;</code> 为 <code>Some</code> 变体，<code>unwrap_or_else</code> 返回其内部值；若为 <code>None</code> 变体，则调用闭包并返回其结果。</p>
<p>We specify the closure expression <code>|| self.most_stocked()</code> as the argument to
<code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the
closure had parameters, they would appear between the two vertical pipes). The
body of the closure calls <code>self.most_stocked()</code>. We’re defining the closure
here, and the implementation of <code>unwrap_or_else</code> will evaluate the closure
later if the result is needed.</p>
<p>我们指定闭包表达式 <code>|| self.most_stocked()</code> 作为 <code>unwrap_or_else</code> 的参数。这是一个无参闭包（若有参数，将出现在两个竖线之间）。闭包体调用 <code>self.most_stocked()</code>。我们在此定义闭包，而 <code>unwrap_or_else</code> 的实现会在需要结果时求值该闭包。</p>
<p>Running this code prints the following:</p>
<p>运行此代码输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>One interesting aspect here is that we’ve passed a closure that calls
<code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library
didn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we
defined, or the logic we want to use in this scenario. The closure captures an
immutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the
code we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand,
are not able to capture their environment in this way.</p>
<p>此处值得注意的是：我们传递了调用当前 <code>Inventory</code> 实例上 <code>self.most_stocked()</code> 的闭包。标准库无需知晓我们定义的 <code>Inventory</code> 或 <code>ShirtColor</code> 类型，也无需知晓此场景的业务逻辑。闭包捕获了 <code>self</code>（即 <code>Inventory</code> 实例）的不可变引用，并将其与我们指定的代码一同传递给 <code>unwrap_or_else</code> 方法。而普通函数无法以这种方式捕获环境。</p>
<h3 id="closure-type-inference-and-annotation-闭包类型推断与注解"><a class="header" href="#closure-type-inference-and-annotation-闭包类型推断与注解">Closure Type Inference and Annotation 闭包类型推断与注解</a></h3>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>函数与闭包还有更多差异。闭包通常不像 <code>fn</code> 函数那样要求标注参数或返回值类型。函数需要类型标注是因为类型是暴露给用户的显式接口的一部分，严格定义此接口对于确保函数使用的值类型和返回类型达成共识至关重要。闭包则不会暴露在此类接口中：它们存储在变量中，使用时无需命名或暴露给库用户。</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>闭包通常简短且仅适用于狭窄的上下文。在此有限上下文中，编译器可推断参数和返回类型，类似于推断大多数变量类型的方式（极少数情况也需要闭包类型注解）。</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 13-2. In this example, we’re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument, as we did in Listing 13-1.</p>
<p>与变量类似，我们<span class="highlight">[note]可为闭包添加类型注解以提升明确性</span>，代价是比严格必要的更冗长。注解闭包类型如示例 13-2 所示。此例中，我们定义闭包并将其存储在变量中，而非如示例 13-1 在传参处定义。</p>
<figure class="listing" id="listing-13-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-2">Listing 13-2</a>: Adding optional type annotations of the parameter and return value types in the closure 在闭包中添加可选的参数和返回值类型注解</figcaption>
</figure>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here, we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<p>添加类型注解后，闭包语法更接近函数语法。下面对比了参数加 1 的函数和相同行为的闭包（添加空格对齐相关部分）。这展示了闭包语法与函数语法的相似性（除管道符和可选语法量外）：</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>The first line shows a function definition and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let v = Vec::new();</code> needing either type annotations or values of
some type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>
<p>第一行是函数定义，第二行是完整注解的闭包定义。第三行移除闭包定义的类型注解。第四行移除大括号（因闭包体仅有一个表达式而可选）。这些都是调用时行为相同的有效定义。<code>add_one_v3</code> 和 <code>add_one_v4</code> 行需在编译时求值闭包，因为类型将通过使用场景推断（类似于 <code>let v = Vec::new();</code> 需要类型注解或向 <code>Vec</code> 插入值供 Rust 推断类型）。</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 13-3 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with <code>String</code> the first time. If we then try to call
<code>example_closure</code> with an integer, we’ll get an error.</p>
<p>对于闭包定义，编译器会为其每个参数和返回值推断一个具体类型。例如示例 13-3 定义了一个仅返回接收参数的短闭包（此闭包除演示外并不实用）。注意定义中未添加任何类型注解。因无类型注解，我们可用任意类型调用闭包（此处首次用 <code>String</code>）。若尝试用整数再次调用 <code>example_closure</code>，将报错。</p>
<figure class="listing" id="listing-13-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-3">Listing 13-3</a>: Attempting to call a closure whose types are inferred with two different types 尝试用两种不同类型调用类型推断的闭包</figcaption>
</figure>
<p>The compiler gives us this error:</p>
<p>编译器报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
<p>首次用 <code>String</code> 值调用 <code>example_closure</code> 时，编译器推断 <code>x</code> 和闭包返回类型为 <code>String</code>。这些类型随后被锁定在 <code>example_closure</code> 中，导致下次用不同类型调用同一闭包时产生类型错误。</p>
<h3 id="capturing-references-or-moving-ownership-捕获引用或转移所有权"><a class="header" href="#capturing-references-or-moving-ownership-捕获引用或转移所有权">Capturing References or Moving Ownership 捕获引用或转移所有权</a></h3>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: borrowing
immutably, borrowing mutably, and taking ownership. The closure will decide
which of these to use based on what the body of the function does with the
captured values.</p>
<p>闭包可通过三种方式从环境中捕获值，直接对应函数获取参数的三种方式：不可变借用、可变借用和获取所有权。闭包将根据函数体如何处理捕获值来决定使用哪种方式。</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to
the vector named <code>list</code> because it only needs an immutable reference to print
the value.</p>
<p>示例 13-4 中，定义了一个捕获向量 <code>list</code> 不可变引用的闭包，因其仅需不可变引用打印值。</p>
<figure class="listing" id="listing-13-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-4">Listing 13-4</a>: Defining and calling a closure that captures an immutable reference 定义并调用捕获不可变引用的闭包</figcaption>
</figure>
<p>This example also illustrates that a variable can bind to a closure definition,
and we can later call the closure by using the variable name and parentheses as
if the variable name were a function name.</p>
<p>此例还说明：变量可绑定到闭包定义，之后可通过变量名加括号调用闭包（如同函数名）。</p>
<p>Because we can have multiple immutable references to <code>list</code> at the same time,
<code>list</code> is still accessible from the code before the closure definition, after
the closure definition but before the closure is called, and after the closure
is called. This code compiles, runs, and prints:</p>
<p>因可同时存在多个 <code>list</code> 的不可变引用，在闭包定义前、定义后但调用前、调用后均可访问 <code>list</code>。此代码编译运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to
the <code>list</code> vector. The closure now captures a mutable reference.</p>
<p>接下来在示例 13-5 中，修改闭包体使其向 <code>list</code> 向量添加元素。此时闭包捕获可变引用。</p>
<figure class="listing" id="listing-13-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-5">Listing 13-5</a>: Defining and calling a closure that captures a mutable reference 定义并调用捕获可变引用的闭包</figcaption>
</figure>
<p>This code compiles, runs, and prints:</p>
<p>此代码编译运行后输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Note that there’s no longer a <code>println!</code> between the definition and the call of
the <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a
mutable reference to <code>list</code>. We don’t use the closure again after the closure
is called, so the mutable borrow ends. Between the closure definition and the
closure call, an immutable borrow to print isn’t allowed because no other
borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code>
there to see what error message you get!</p>
<p>注意定义和调用 <code>borrows_mutably</code> 闭包之间无 <code>println!</code>：当 <code>borrows_mutably</code> 定义时，它捕获了 <code>list</code> 的可变引用。闭包调用后不再使用，故可变借用结束。在闭包定义和调用之间，不可变借用打印不被允许（因存在可变借用时不允许其他借用）。尝试在此处添加 <code>println!</code> 查看错误信息！</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment even though the body of the closure doesn’t strictly need
ownership, you can use the <code>move</code> keyword before the parameter list.</p>
<p>若需强制闭包获取其使用值的所有权（即使闭包体并不严格需要所有权），可在参数列表前使用 <code>move</code> 关键字。</p>
<p>This technique is mostly useful when passing a closure to a new thread to move
the data so that it’s owned by the new thread. We’ll discuss threads and why
you would want to use them in detail in Chapter 16 when we talk about
concurrency, but for now, let’s briefly explore spawning a new thread using a
closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified
to print the vector in a new thread rather than in the main thread.</p>
<p>此技术主要用于将闭包传递给新线程以转移数据所有权。我们将在第 16 章讨论并发时详细解释线程及其用途。现在，我们简要探索使用需要 <code>move</code> 关键字的闭包生成新线程。示例 13-6 修改自示例 13-4，改为在新线程而非主线程打印向量。</p>
<figure class="listing" id="listing-13-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-6">Listing 13-6</a>: Using <code>move</code> to force the closure for the thread to take ownership of <code>list</code> 使用 <code>move</code> 强制线程闭包获取 <code>list</code> 的所有权</figcaption>
</figure>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The
closure body prints out the list. In Listing 13-4, the closure only captured
<code>list</code> using an immutable reference because that’s the least amount of access
to <code>list</code> needed to print it. In this example, even though the closure body
still only needs an immutable reference, we need to specify that <code>list</code> should
be moved into the closure by putting the <code>move</code> keyword at the beginning of the
closure definition. If the main thread performed more operations before calling
<code>join</code> on the new thread, the new thread might finish before the rest of the
main thread finishes, or the main thread might finish first. If the main thread
maintained ownership of <code>list</code> but ended before the new thread and drops
<code>list</code>, the immutable reference in the thread would be invalid. Therefore, the
compiler requires that <code>list</code> be moved into the closure given to the new thread
so the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code>
in the main thread after the closure is defined to see what compiler errors you
get!</p>
<p>我们生成新线程，将闭包作为参数传递给线程运行。闭包体打印 <code>list</code>。在示例 13-4 中，闭包仅通过不可变引用捕获 <code>list</code>（这是打印所需的最小访问权限）。本例中，即使闭包体仍只需不可变引用，仍需在闭包定义开头添加 <code>move</code> 关键字指定将 <code>list</code> 移入闭包。若主线程在调用新线程的 <code>join</code> 前执行更多操作，新线程可能在主线程结束前完成，或主线程先结束。若主线程保留 <code>list</code> 所有权但先于新线程结束并丢弃 <code>list</code>，线程中的不可变引用将失效。因此，编译器要求将 <code>list</code> 移入给新线程的闭包以保证引用有效。尝试移除 <code>move</code> 关键字或在定义闭包后于主线程使用 <code>list</code>，观察编译器错误！</p>
<h3 id="moving-captured-values-out-of-closures-and-the-fn-traits-将捕获值移出闭包与-fn-特质"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits-将捕获值移出闭包与-fn-特质">Moving Captured Values Out of Closures and the <code>Fn</code> Traits 将捕获值移出闭包与 <code>Fn</code> 特质</a></h3>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure).</p>
<p>当闭包从定义环境中捕获引用或值所有权后（影响值<strong>移入</strong>闭包的方式），闭包体中的代码决定了后续求值时如何处理这些引用或值（影响值<strong>移出</strong>闭包的方式）。</p>
<p>A closure body can do any of the following: move a captured value out of the
closure, mutate the captured value, neither move nor mutate the value, or
capture nothing from the environment to begin with.</p>
<p>闭包体可执行以下操作：将捕获值移出闭包、改变捕获值、既不移动也不改变值，或根本不从环境捕获值。</p>
<p>The way a closure captures and handles values from the environment affects
which traits the closure implements, and traits are how functions and structs
can specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<p>闭包从环境中捕获和处理值的方式决定了其实现哪些特质。特质是函数和结构体指定可使用哪些闭包的方式。根据闭包体处理值的方式，闭包会自动实现一个、两个或全部三个 <code>Fn</code> 特质（以叠加方式）：</p>
<ul>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement
at least this trait because all closures can be called. A closure that moves
captured values out of its body will only implement <code>FnOnce</code> and none of the
other <code>Fn</code> traits because it can only be called once.</li>
<li><span class="highlight">[note]<code>FnOnce</code> 适用于可调用一次的闭包。所有闭包至少实现此特质（因所有闭包均可调用）。将捕获值移出体的闭包<strong>仅</strong>实现 <code>FnOnce</code>（因只能调用一次）。</span></li>
<li><code>FnMut</code> applies to closures that don’t move captured values out of their
body, but that might mutate the captured values. These closures can be
called more than once.</li>
<li><span class="highlight">[note]<code>FnMut</code> 适用于不移出捕获值但可能修改值的闭包。这些闭包可多次调用。</span></li>
<li><code>Fn</code> applies to closures that don’t move captured values out of their body
and that don’t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.</li>
<li><span class="highlight">[note]<code>Fn</code> 适用于不移出捕获值、不修改捕获值的闭包，以及不捕获任何环境值的闭包。这些闭包可多次调用且不改变环境（这在并发多次调用闭包时很重要）。</span></li>
</ul>
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that
we used in Listing 13-1:</p>
<p>回顾示例 13-1 中 <code>Option&lt;T&gt;</code> 的 <code>unwrap_or_else</code> 方法定义：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the
<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the
<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an
<code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>
<p>回想 <code>T</code> 是表示 <code>Option</code> 的 <code>Some</code> 变体值类型的泛型。该类型 <code>T</code> 也是 <code>unwrap_or_else</code> 的返回类型：例如在 <code>Option&lt;String&gt;</code> 上调用 <code>unwrap_or_else</code> 将返回 <code>String</code>。</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type
parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is
the closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>注意 <code>unwrap_or_else</code> 函数有额外的泛型参数 <code>F</code>。类型 <code>F</code> 是参数 <code>f</code> 的类型（即调用 <code>unwrap_or_else</code> 时提供的闭包）。</p>
<p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which
means <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>.
Using <code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of
<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be
called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all
closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all three kinds of
closures and is as flexible as it can be.</p>
<p>泛型 <code>F</code> 的特质限定为 <code>FnOnce() -&gt; T</code>，表示 <code>F</code> 必须可调用一次、无参数且返回 <code>T</code>。在特质限定中使用 <code>FnOnce</code> 表达了 <code>unwrap_or_else</code> 最多调用 <code>f</code> 一次的约束。在 <code>unwrap_or_else</code> 体中可见：若 <code>Option</code> 为 <code>Some</code>，<code>f</code> 不会被调用；若为 <code>None</code>，<code>f</code> 会被调用一次。因所有闭包都实现 <code>FnOnce</code>，<code>unwrap_or_else</code> 接受所有三类闭包，具有最大灵活性。</p>
<section class="note" aria-role="note">
<p>Note: If what we want to do doesn’t require capturing a value from the
environment, we can use the name of a function rather than a closure where we
need something that implements one of the <code>Fn</code> traits. For example, on an
<code>Option&lt;Vec&lt;T&gt;&gt;</code> value, we could call <code>unwrap_or_else(Vec::new)</code> to get a
new, empty vector if the value is <code>None</code>. The compiler automatically
implements whichever of the <code>Fn</code> traits is applicable for a function
definition.</p>
<p>注意：若操作无需从环境捕获值，可在需要实现 <code>Fn</code> 特质的地方使用函数名而非闭包。例如在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 值上，可调用 <code>unwrap_or_else(Vec::new)</code> 在值为 <code>None</code> 时获取新的空向量。编译器会自动为函数定义实现适用的 <code>Fn</code> 特质。</p>
</section>
<p>Now let’s look at the standard library method <code>sort_by_key</code>, defined on slices,
to see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses
<code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument
in the form of a reference to the current item in the slice being considered,
and returns a value of type <code>K</code> that can be ordered. This function is useful
when you want to sort a slice by a particular attribute of each item. In
Listing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code>
to order them by their <code>width</code> attribute from low to high.</p>
<p>现在查看标准库中切片定义的 <code>sort_by_key</code> 方法，探究其与 <code>unwrap_or_else</code> 的差异及使用 <code>FnMut</code> 而非 <code>FnOnce</code> 的原因。该闭包接收一个参数（即切片当前项的引用），并返回可排序的 <code>K</code> 类型值。当你需要按某项特定属性排序切片时，此函数非常有用。示例 13-7 中，我们使用 <code>sort_by_key</code> 将矩形列表按宽度属性从低到高排序。</p>
<figure class="listing" id="listing-13-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-7">Listing 13-7</a>: Using <code>sort_by_key</code> to order rectangles by width 使用 <code>sort_by_key</code> 按宽度排序矩形</figcaption>
</figure>
<p>This code prints:</p>
<p>此代码输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls
the closure multiple times: once for each item in the slice. The closure <code>|r|  r.width</code> doesn’t capture, mutate, or move anything out from its environment, so
it meets the trait bound requirements.</p>
<p><code>sort_by_key</code> 定义为接收 <code>FnMut</code> 闭包的原因是它会多次调用闭包（对切片中每个项调用一次）。闭包 <code>|r| r.width</code> 未捕获、修改或移出环境中的任何值，故满足特质限定要求。</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just
the <code>FnOnce</code> trait, because it moves a value out of the environment. The
compiler won’t let us use this closure with <code>sort_by_key</code>.</p>
<p>相反，示例 13-8 展示了仅实现 <code>FnOnce</code> 特质的闭包（因其从环境中移出值）。编译器不允许此闭包与 <code>sort_by_key</code> 一起使用。</p>
<figure class="listing" id="listing-13-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-8">Listing 13-8</a>: Attempting to use an <code>FnOnce</code> closure with <code>sort_by_key</code> 尝试将 <code>FnOnce</code> 闭包用于 <code>sort_by_key</code></figcaption>
</figure>
<p>This is a contrived, convoluted way (that doesn’t work) to try and count the
number of times <code>sort_by_key</code> calls the closure when sorting <code>list</code>. This code
attempts to do this counting by pushing <code>value</code>—a <code>String</code> from the closure’s
environment—into the <code>sort_operations</code> vector. The closure captures <code>value</code> and
then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to
the <code>sort_operations</code> vector. This closure can be called once; trying to call
it a second time wouldn’t work because <code>value</code> would no longer be in the
environment to be pushed into <code>sort_operations</code> again! Therefore, this closure
only implements <code>FnOnce</code>. When we try to compile this code, we get this error
that <code>value</code> can’t be moved out of the closure because the closure must
implement <code>FnMut</code>:</p>
<p>这是一种人为设计的复杂方式（无效）尝试统计 <code>sort_by_key</code> 排序 <code>list</code> 时调用闭包的次数。此代码尝试通过将闭包环境中的 <code>value</code>（<code>String</code> 类型）推入 <code>sort_operations</code> 向量来实现计数。闭包捕获 <code>value</code> 后，通过转移 <code>value</code> 所有权到 <code>sort_operations</code> 向量将其移出闭包。此闭包只能调用一次！再次调用将失败（因 <code>value</code> 已不在环境中无法再次推入 <code>sort_operations</code>）。因此，该闭包仅实现 <code>FnOnce</code>。编译时产生 “<code>value</code> 无法移出闭包” 的错误（因闭包必须实现 <code>FnMut</code>）：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the
environment. To fix this, we need to change the closure body so that it doesn’t
move values out of the environment. Keeping a counter in the environment and
incrementing its value in the closure body is a more straightforward way to
count the number of times the closure is called. The closure in Listing 13-9
works with <code>sort_by_key</code> because it is only capturing a mutable reference to the
<code>num_sort_operations</code> counter and can therefore be called more than once:</p>
<p>错误指向闭包体中移出 <code>value</code> 的代码行。修复需更改闭包体使其不移出环境中的值。更直接的方式是在环境中维护计数器并在闭包体中递增其值。示例 13-9 的闭包可与 <code>sort_by_key</code> 协作（因仅捕获 <code>num_sort_operations</code> 计数器的可变引用，可多次调用）：</p>
<figure class="listing" id="listing-13-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
<figcaption><a href="ch13-01-closures.html#listing-13-9">Listing 13-9</a>: Using an <code>FnMut</code> closure with <code>sort_by_key</code> is allowed 允许将 <code>FnMut</code> 闭包用于 <code>sort_by_key</code></figcaption>
</figure>
<p>The <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
<p><code>Fn</code> 特质在定义或使用涉及闭包的函数或类型时至关重要。下一节我们将讨论迭代器。许多迭代器方法接收闭包参数，请牢记这些闭包细节！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="processing-a-series-of-items-with-iterators-使用迭代器处理序列"><a class="header" href="#processing-a-series-of-items-with-iterators-使用迭代器处理序列">Processing a Series of Items with Iterators 使用迭代器处理序列</a></h2>
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.</p>
<p>迭代器模式允许你依次对序列中的每个元素执行任务。迭代器负责遍历每个元素的逻辑，并判断序列何时终止。使用迭代器时，你无需自行重新实现这些逻辑。</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-10 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code>. This code by itself doesn’t do anything
useful.</p>
<p>在 Rust 中，迭代器是<strong>惰性</strong>的，这意味着除非调用消耗迭代器的方法，否则它们不会产生任何效果。例如，示例 13-10 中的代码通过在 <code>Vec&lt;T&gt;</code> 上调用 <code>iter</code> 方法，创建了一个针对向量 <code>v1</code> 元素的迭代器。这段代码本身并不执行任何有效操作。</p>
<figure class="listing" id="listing-13-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-10">Listing 13-10</a>: Creating an iterator 创建迭代器</figcaption>
</figure>
<p>The iterator is stored in the <code>v1_iter</code> variable. Once we’ve created an
iterator, we can use it in a variety of ways. In Listing 3-5, we iterated over
an array using a <code>for</code> loop to execute some code on each of its items. Under
the hood, this implicitly created and then consumed an iterator, but we glossed
over how exactly that works until now.</p>
<p>迭代器存储在变量 <code>v1_iter</code> 中。创建迭代器后，可以通过多种方式使用它。在示例 3-5 中，我们使<span class="highlight">[note]用 <code>for</code> 循环遍历数组，对每个元素执行代码。其底层机制隐式创建并消耗了迭代器</span>，但直到现在才深入探讨其工作原理。</p>
<p>In the example in Listing 13-11, we separate the creation of the iterator from
the use of the iterator in the <code>for</code> loop. When the <code>for</code> loop is called using
the iterator in <code>v1_iter</code>, each element in the iterator is used in one
iteration of the loop, which prints out each value.</p>
<p>在示例 13-11 中，我们将迭代器的创建与 <code>for</code> 循环中的使用分离。当使用 <code>v1_iter</code> 中的迭代器调用 <code>for</code> 循环时，迭代器的每个元素会在循环的一次迭代中被使用，打印出每个值。</p>
<figure class="listing" id="listing-13-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-11">Listing 13-11</a>: Using an iterator in a <code>for</code> loop 在 <code>for</code> 循环中使用迭代器</figcaption>
</figure>
<p>In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.</p>
<p>在标准库未提供迭代器的语言中，你可能需要通过以下方式实现相同功能：初始化一个索引变量为 0，用该变量索引向量获取值，并在循环中递增该变量值，直至达到向量元素总数。</p>
<p>Iterators handle all of that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.</p>
<p>迭代器为你处理了所有这些逻辑，减少了可能出错的重复代码。迭代器提供了更灵活的通用逻辑，可应用于多种序列（不仅限于向量等可通过索引访问的数据结构）。下面我们探究迭代器如何实现这一点。</p>
<h3 id="the-iterator-trait-and-the-next-method-iterator-特质与-next-方法"><a class="header" href="#the-iterator-trait-and-the-next-method-iterator-特质与-next-方法">The <code>Iterator</code> Trait and the <code>next</code> Method <code>Iterator</code> 特质与 <code>next</code> 方法</a></h3>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<p><span class="highlight">[note]所有迭代器均实现了标准库中定义的 <code>Iterator</code> 特质。该特质的定义如下：</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>,
which are defining an <em>associated type</em> with this trait. We’ll talk about
associated types in depth in Chapter 20. For now, all you need to know is that
this code says implementing the <code>Iterator</code> trait requires that you also define
an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code>
method. In other words, the <code>Item</code> type will be the type returned from the
iterator.</p>
<p>注意此定义使用了新语法：<code>type Item</code> 和 <code>Self::Item</code>，它们通过此特质定义了<strong>关联类型</strong>。我们将在第 20 章深入讨论关联类型。目前只需知道：实现 <code>Iterator</code> 特质要求同时定义 <code>Item</code> 类型，且该 <code>Item</code> 类型用于 <code>next</code> 方法的返回类型。换言之，<code>Item</code> 类型是迭代器返回的元素类型。</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the
<code>next</code> method, which returns one item of the iterator at a time, wrapped in
<code>Some</code>, and, when iteration is over, returns <code>None</code>.</p>
<p><code>Iterator</code> 特质仅要求实现者定义一个方法：<code>next</code> 方法。该方法每次返回一个包裹在 <code>Some</code> 中的迭代器元素，迭代结束后返回 <code>None</code>。</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-12 demonstrates
what values are returned from repeated calls to <code>next</code> on the iterator created
from the vector.</p>
<p>可直接在迭代器上调用 <code>next</code> 方法。示例 13-12 展示了从向量创建的迭代器上重复调用 <code>next</code> 的返回值。</p>
<figure class="listing" id="listing-13-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-12">Listing 13-12</a>: Calling the <code>next</code> method on an iterator 在迭代器上调用 <code>next</code> 方法</figcaption>
</figure>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the
iterator. Each call to <code>next</code> eats up an item from the iterator. We didn’t need
to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took
ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>注意需将 <code>v1_iter</code> 声明为可变：调用迭代器的 <code>next</code> 方法会改变其内部状态（用于跟踪序列中的位置）。换言之，此代码会<strong>消耗</strong>迭代器。每次调用 <code>next</code> 会消耗迭代器中的一个元素。使用 <code>for</code> 循环时无需将 <code>v1_iter</code> 设为可变，因为<span class="highlight">[note]循环会获取 <code>v1_iter</code> 的所有权</span>并在幕后将其变为可变。</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<p>还需注意：从 <code>next</code> 调用获取的值是对向量中值的不可变引用。<span class="highlight">[note]<code>iter</code> 方法生成的是针对不可变引用的迭代器。若需创建获取 <code>v1</code> 所有权并返回自有值的迭代器，可调用 <code>into_iter</code> 替代 <code>iter</code>。类似地，若需遍历可变引用，可调用 <code>iter_mut</code> 替代 <code>iter</code>。</span></p>
<h3 id="methods-that-consume-the-iterator-消耗迭代器的方法"><a class="header" href="#methods-that-consume-the-iterator-消耗迭代器的方法">Methods That Consume the Iterator 消耗迭代器的方法</a></h3>
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the <code>Iterator</code>
trait. Some of these methods call the <code>next</code> method in their definition, which
is why you’re required to implement the <code>next</code> method when implementing the
<code>Iterator</code> trait.</p>
<p><code>Iterator</code> 特质包含多个标准库提供默认实现的方法；可通过查阅标准库 API 文档了解这些方法。其中部分方法在其定义中调用了 <code>next</code> 方法，因此在实现 <code>Iterator</code> 特质时必须实现 <code>next</code> 方法。</p>
<p>Methods that call <code>next</code> are called <em>consuming adapters</em>, because calling them
uses up the iterator. One example is the <code>sum</code> method, which takes ownership of
the iterator and iterates through the items by repeatedly calling <code>next</code>, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-13 has a
test illustrating a use of the <code>sum</code> method.</p>
<p>调用 <code>next</code> 的方法称为<strong>消费型适配器</strong>，因为调用它们会消耗迭代器。例如 <code>sum</code> 方法：它获取迭代器所有权，通过重复调用 <code>next</code> 遍历元素从而消耗迭代器。遍历过程中，它累加每个元素到运行总和，并在迭代完成后返回总和。示例 13-13 的测试展示了 <code>sum</code> 方法的使用。</p>
<figure class="listing" id="listing-13-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-13">Listing 13-13</a>: Calling the <code>sum</code> method to get the total of all items in the iterator 调用 <code>sum</code> 方法获取迭代器所有元素的总和</figcaption>
</figure>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes
ownership of the iterator we call it on.</p>
<p>调用 <code>sum</code> 后不允许再使用 <code>v1_iter</code>，因为 <code>sum</code> 获取了我们所调用迭代器的所有权。</p>
<h3 id="methods-that-produce-other-iterators-生成其他迭代器的方法"><a class="header" href="#methods-that-produce-other-iterators-生成其他迭代器的方法">Methods That Produce Other Iterators 生成其他迭代器的方法</a></h3>
<p><em>Iterator adapters</em> are methods defined on the <code>Iterator</code> trait that don’t
consume the iterator. Instead, they produce different iterators by changing
some aspect of the original iterator.</p>
<p><strong>迭代器适配器</strong>是定义在 <code>Iterator</code> 特质上不消耗迭代器的方法。它们通过改变原始迭代器的某些方面来生成不同的迭代器。</p>
<p>Listing 13-14 shows an example of calling the iterator adapter method <code>map</code>,
which takes a closure to call on each item as the items are iterated through.
The <code>map</code> method returns a new iterator that produces the modified items. The
closure here creates a new iterator in which each item from the vector will be
incremented by 1.</p>
<p>示例 13-14 展示了调用迭代器适配器方法 <code>map</code> 的示例，该方法接受一个闭包，在遍历每个元素时调用。<code>map</code> 方法返回生成修改后元素的新迭代器。此处的闭包创建了一个新迭代器，其中向量的每个元素将增加 1。</p>
<figure class="listing" id="listing-13-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-14">Listing 13-14</a>: Calling the iterator adapter <code>map</code> to create a new iterator 调用迭代器适配器 <code>map</code> 创建新迭代器</figcaption>
</figure>
<p>However, this code produces a warning:</p>
<p>但此代码会产生警告：</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>The code in Listing 13-14 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adapters are lazy, and
we need to consume the iterator here.</p>
<p>示例 13-14 的代码未执行任何操作，因为我们指定的闭包从未被调用。该警告提示了原因：迭代器适配器是惰性的，此处需要消耗迭代器。</p>
<p>To fix this warning and consume the iterator, we’ll use the <code>collect</code> method,
which we used with <code>env::args</code> in Listing 12-1. This method consumes the
iterator and collects the resultant values into a collection data type.</p>
<p>为消除此警告并消耗迭代器，我们使用 <code>collect</code> 方法（曾在示例 12-1 的 <code>env::args</code> 中使用过）。此方法消耗迭代器并将结果值收集到集合数据类型中。</p>
<p>In Listing 13-15, we collect the results of iterating over the iterator that’s
returned from the call to <code>map</code> into a vector. This vector will end up
containing each item from the original vector, incremented by 1.</p>
<p>在示例 13-15 中，我们将调用 <code>map</code> 返回的迭代器结果收集到向量中。该向量最终包含原始向量中每个元素加 1 后的值。</p>
<figure class="listing" id="listing-13-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-15">Listing 13-15</a>: Calling the <code>map</code> method to create a new iterator, and then calling the <code>collect</code> method to consume the new iterator and create a vector 调用 <code>map</code> 方法创建新迭代器，再调用 <code>collect</code> 方法消耗新迭代器并创建向量</figcaption>
</figure>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the <code>Iterator</code> trait
provides.</p>
<p>由于 <code>map</code> 接受闭包，因此可指定对每个元素执行的任意操作。这充分展示了闭包如何让你在复用 <code>Iterator</code> 特质的迭代行为的同时，定制特定行为。</p>
<p>You can chain multiple calls to iterator adapters to perform complex actions in
a readable way. But because all iterators are lazy, you have to call one of the
consuming adapter methods to get results from calls to iterator adapters.</p>
<p>可通过链式调用多个迭代器适配器来执行复杂操作，保持代码可读性。但由于所有迭代器都是惰性的，必须调用一个消费型适配器方法才能从迭代器适配器调用中获取结果。</p>
<h3 id="using-closures-that-capture-their-environment-使用捕获环境的闭包"><a class="header" href="#using-closures-that-capture-their-environment-使用捕获环境的闭包">Using Closures That Capture Their Environment 使用捕获环境的闭包</a></h3>
<p>Many iterator adapters take closures as arguments, and commonly the closures
we’ll specify as arguments to iterator adapters will be closures that capture
their environment.</p>
<p>许多迭代器适配器以闭包为参数，通常这些闭包会捕获它们所在的环境。</p>
<p>For this example, we’ll use the <code>filter</code> method that takes a closure. The
closure gets an item from the iterator and returns a <code>bool</code>. If the closure
returns <code>true</code>, the value will be included in the iteration produced by
<code>filter</code>. If the closure returns <code>false</code>, the value won’t be included.</p>
<p>在此示例中，我们将使用接受闭包的 <code>filter</code> 方法。该闭包从迭代器中获取元素并返回 <code>bool</code>。若闭包返回 <code>true</code>，该值将包含在 <code>filter</code> 生成的迭代中；若返回 <code>false</code>，则排除该值。</p>
<p>In Listing 13-16, we use <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment to iterate over a collection of <code>Shoe</code> struct
instances. It will return only shoes that are the specified size.</p>
<p>在示例 13-16 中，我们结合 <code>filter</code> 与捕获环境变量 <code>shoe_size</code> 的闭包，遍历 <code>Shoe</code> 结构体实例的集合。它将仅返回指定尺码的鞋子。</p>
<figure class="listing" id="listing-13-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
<figcaption><a href="ch13-02-iterators.html#listing-13-16">Listing 13-16</a>: Using the <code>filter</code> method with a closure that captures <code>shoe_size</code> 将 <code>filter</code> 方法与捕获 <code>shoe_size</code> 的闭包结合使用</figcaption>
</figure>
<p>The <code>shoes_in_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.</p>
<p>函数 <code>shoes_in_size</code> 获取鞋子向量和鞋码作为参数，返回仅包含指定尺码鞋子的向量。</p>
<p>In the body of <code>shoes_in_size</code>, we call <code>into_iter</code> to create an iterator
that takes ownership of the vector. Then we call <code>filter</code> to adapt that
iterator into a new iterator that only contains elements for which the closure
returns <code>true</code>.</p>
<p>在 <code>shoes_in_size</code> 函数体中，调用 <code>into_iter</code> 创建获取向量所有权的迭代器。接着调用 <code>filter</code> 将该迭代器适配为新迭代器，仅保留闭包返回 <code>true</code> 的元素。</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling <code>collect</code> gathers the values returned by the
adapted iterator into a vector that’s returned by the function.</p>
<p>闭包从环境中捕获 <code>shoe_size</code> 参数，并将其与每只鞋的尺码比较，仅保留指定尺码的鞋。最后，调用 <code>collect</code> 收集适配后迭代器的返回值到向量中并返回。</p>
<p>The test shows that when we call <code>shoes_in_size</code>, we get back only shoes
that have the same size as the value we specified.</p>
<p>测试表明：调用 <code>shoes_in_size</code> 时，仅返回与我们指定值相同尺码的鞋子。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="improving-our-io-project-改进-io-项目"><a class="header" href="#improving-our-io-project-改进-io-项目">Improving Our I/O Project 改进 I/O 项目</a></h2>
<p>With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
<code>Config::build</code> function and the <code>search</code> function.</p>
<p>掌握了迭代器的新知识后，可改进第 12 章的 I/O 项目，使用迭代器使代码更清晰简洁。下面探讨如何用迭代器优化 <code>Config::build</code> 函数和 <code>search</code> 函数的实现。</p>
<h3 id="removing-a-clone-using-an-iterator-使用迭代器消除-clone-调用"><a class="header" href="#removing-a-clone-using-an-iterator-使用迭代器消除-clone-调用">Removing a <code>clone</code> Using an Iterator 使用迭代器消除 <code>clone</code> 调用</a></h3>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-17,
we’ve reproduced the implementation of the <code>Config::build</code> function as it was
in Listing 12-23.</p>
<p>在示例 12-6 中，我们添加了获取 <code>String</code> 值切片的代码，并通过索引切片和克隆值创建 <code>Config</code> 结构体实例，使 <code>Config</code> 结构体拥有这些值。示例 13-17 再现了示例 12-23 中的 <code>Config::build</code> 函数实现。</p>
<figure class="listing" id="listing-13-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-17">Listing 13-17</a>: Reproduction of the <code>Config::build</code> function from Listing 12-23 示例 12-23 中 <code>Config::build</code> 函数的再现</figcaption>
</figure>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because
we would remove them in the future. Well, that time is now!</p>
<p>当时我们说不必担心低效的 <code>clone</code> 调用，因为后续会移除它们。现在就是时候了！</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the
parameter <code>args</code>, but the <code>build</code> function doesn’t own <code>args</code>. To return
ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code>
and <code>file_path</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>此处需要 <code>clone</code> 是因为参数 <code>args</code> 是包含 <code>String</code> 元素的切片，但 <code>build</code> 函数不拥有 <code>args</code>。为使 <code>Config</code> 实例拥有所有权，我们克隆了 <code>Config</code> 中 <code>query</code> 和 <code>file_path</code> 字段的值。</p>
<p>With our new knowledge about iterators, we can change the <code>build</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
<code>Config::build</code> function is doing because the iterator will access the values.</p>
<p>借助迭代器的新知识，可将 <code>build</code> 函数改为获取迭代器所有权作为参数，而非借用切片。我们将用迭代器功能替代检查切片长度和索引特定位置的代码，这将更清晰地体现 <code>Config::build</code> 函数的意图，因为迭代器会直接访问值。</p>
<p>Once <code>Config::build</code> takes ownership of the iterator and stops using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<p>一旦 <code>Config::build</code> 获取迭代器所有权并停止使用借用性质的索引操作，就能直接将迭代器中的 <code>String</code> 值移入 <code>Config</code>，而无需调用 <code>clone</code> 进行新分配。</p>
<h4 id="using-the-returned-iterator-directly-直接使用返回的迭代器"><a class="header" href="#using-the-returned-iterator-directly-直接使用返回的迭代器">Using the Returned Iterator Directly 直接使用返回的迭代器</a></h4>
<p>Open your I/O project’s <em>src/main.rs</em> file, which should look like this:</p>
<p>打开 I/O 项目的 <em>src/main.rs</em> 文件，内容应如下所示：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>We’ll first change the start of the <code>main</code> function that we had in Listing
12-24 to the code in Listing 13-18, which this time uses an iterator. This
won’t compile until we update <code>Config::build</code> as well.</p>
<p>我们首先将示例 12-24 中的 <code>main</code> 函数起始部分改为示例 13-18 的代码（这次使用迭代器）。在更新 <code>Config::build</code> 前，此代码尚不能编译。</p>
<figure class="listing" id="listing-13-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-18">Listing 13-18</a>: Passing the return value of <code>env::args</code> to <code>Config::build</code> 将 <code>env::args</code> 的返回值传递给 <code>Config::build</code></figcaption>
</figure>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::build</code>, now
we’re passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::build</code> directly.</p>
<p><code>env::args</code> 函数返回一个迭代器！现在我们不再将迭代器值收集到向量再传递切片给 <code>Config::build</code>，而是直接将 <code>env::args</code> 返回的迭代器所有权传递给 <code>Config::build</code>。</p>
<p>Next, we need to update the definition of <code>Config::build</code>. Let’s change the
signature of <code>Config::build</code> to look like Listing 13-19. This still won’t
compile, because we need to update the function body.</p>
<p>接下来需要更新 <code>Config::build</code> 的定义。如示例 13-19 所示修改 <code>Config::build</code> 的签名。由于还需更新函数体，此代码仍不能编译。</p>
<figure class="listing" id="listing-13-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let config = Config::build(env::args()).unwrap_or_else(|err| {
</span><span class="boring">        eprintln!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-19">Listing 13-19</a>: Updating the signature of <code>Config::build</code> to expect an iterator 更新 <code>Config::build</code> 的签名以接受迭代器</figcaption>
</figure>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>, and that type implements
the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p><code>env::args</code> 的标准库文档显示：其返回的迭代器类型为 <code>std::env::Args</code>，该类型实现了 <code>Iterator</code> 特质并返回 <code>String</code> 值。</p>
<p>We’ve updated the signature of the <code>Config::build</code> function so the parameter
<code>args</code> has a generic type with the trait bounds <code>impl Iterator&lt;Item = String&gt;</code>
instead of <code>&amp;[String]</code>. This usage of the <code>impl Trait</code> syntax we discussed in
the  section of Chapter 10
means that <code>args</code> can be any type that implements the <code>Iterator</code> trait and
returns <code>String</code> items.</p>
<p>我们更新了 <code>Config::build</code> 的签名：参数 <code>args</code> 现在是一个泛型类型，其特质约束为 <code>impl Iterator&lt;Item = String&gt;</code>，替代了原来的 <code>&amp;[String]</code>。此处使用的 <code>impl Trait</code> 语法（第 10 章讨论过）表示 <code>args</code> 可以是任何实现了 <code>Iterator</code> 特质且返回 <code>String</code> 元素的类型。</p>
<p>Because we’re taking ownership of <code>args</code> and we’ll be mutating <code>args</code> by
iterating over it, we can add the <code>mut</code> keyword into the specification of the
<code>args</code> parameter to make it mutable.</p>
<p>由于我们要获取 <code>args</code> 的所有权并通过迭代改变其状态，可在 <code>args</code> 参数前添加 <code>mut</code> 关键字使其可变。</p>
<h4 id="using-iterator-trait-methods-instead-of-indexing-使用-iterator-特质方法替代索引"><a class="header" href="#using-iterator-trait-methods-instead-of-indexing-使用-iterator-特质方法替代索引">Using <code>Iterator</code> Trait Methods Instead of Indexing 使用 <code>Iterator</code> 特质方法替代索引</a></h4>
<p>Next, we’ll fix the body of <code>Config::build</code>. Because <code>args</code> implements the
<code>Iterator</code> trait, we know we can call the <code>next</code> method on it! Listing 13-20
updates the code from Listing 12-23 to use the <code>next</code> method.</p>
<p>接下来修复 <code>Config::build</code> 的函数体。因为 <code>args</code> 实现了 <code>Iterator</code> 特质，我们知道可以在其上调用 <code>next</code> 方法！示例 13-20 将示例 12-23 的代码更新为使用 <code>next</code> 方法。</p>
<figure class="listing" id="listing-13-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let config = Config::build(env::args()).unwrap_or_else(|err| {
</span><span class="boring">        eprintln!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-20">Listing 13-20</a>: Changing the body of <code>Config::build</code> to use iterator methods 修改 <code>Config::build</code> 的函数体以使用迭代器方法</figcaption>
</figure>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Then we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns <code>Some</code>,
we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means not enough
arguments were given and we return early with an <code>Err</code> value. We do the same
thing for the <code>file_path</code> value.</p>
<p>记住 <code>env::args</code> 返回值的首项是程序名。我们忽略它并获取下一项，因此先调用 <code>next</code> 但不使用返回值。接着调用 <code>next</code> 获取要放入 <code>Config</code> 的 <code>query</code> 字段的值。若 <code>next</code> 返回 <code>Some</code>，则用 <code>match</code> 提取值；若返回 <code>None</code>，表示参数不足，我们提前返回 <code>Err</code>。对 <code>file_path</code> 值进行相同处理。</p>
<h3 id="making-code-clearer-with-iterator-adapters-用迭代器适配器提升代码清晰度"><a class="header" href="#making-code-clearer-with-iterator-adapters-用迭代器适配器提升代码清晰度">Making Code Clearer with Iterator Adapters 用迭代器适配器提升代码清晰度</a></h3>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-21 as it was in Listing 12-19.</p>
<p>在 I/O 项目的 <code>search</code> 函数中也可利用迭代器。示例 13-21 再现了示例 12-19 中的该函数。</p>
<figure class="listing" id="listing-13-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-21">Listing 13-21</a>: The implementation of the <code>search</code> function from Listing 12-19 示例 12-19 中的 <code>search</code> 函数实现</figcaption>
</figure>
<p>We can write this code in a more concise way using iterator adapter methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel because we wouldn’t have to manage
concurrent access to the <code>results</code> vector. Listing 13-22 shows this change.</p>
<p>使用迭代器适配器方法可更简洁地编写此代码，同时避免可变中间结果向量 <code>results</code>。函数式编程风格倾向于最小化可变状态以提升代码清晰度。消除可变状态可能为将来实现并行搜索提供便利，因为无需管理对 <code>results</code> 向量的并发访问。示例 13-22 展示了这一修改。</p>
<figure class="listing" id="listing-13-22">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch13-03-improving-our-io-project.html#listing-13-22">Listing 13-22</a>: Using iterator adapter methods in the implementation of the <code>search</code> function 在 <code>search</code> 函数实现中使用迭代器适配器方法</figcaption>
</figure>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing
13-16, this code uses the <code>filter</code> adapter to keep only the lines for which
<code>line.contains(query)</code> returns <code>true</code>. We then collect the matching lines into
another vector with <code>collect</code>. Much simpler! Feel free to make the same change
to use iterator methods in the <code>search_case_insensitive</code> function as well.</p>
<p>回顾 <code>search</code> 函数的目的是返回 <code>contents</code> 中包含 <code>query</code> 的所有行。类似于示例 13-16 的 <code>filter</code> 用法，此代码使用 <code>filter</code> 适配器仅保留满足 <code>line.contains(query)</code> 的行。接着用 <code>collect</code> 将匹配行收集到新向量中。如此简洁多了！可对 <code>search_case_insensitive</code> 函数进行相同修改以使用迭代器方法。</p>
<p>For a further improvement, return an iterator from the <code>search</code> function by
removing the call to <code>collect</code> and changing the return type to <code>impl Iterator&lt;Item = &amp;'a str&gt;</code> so that the function becomes an iterator adapter.
Note that you’ll also need to update the tests! Search through a large file
using your <code>minigrep</code> tool before and after making this change to observe the
difference in behavior. Before this change, the program won’t print any results
until it has collected all of the results, but after the change, the results
will be printed as each matching line is found because the <code>for</code> loop in the
<code>run</code> function is able to take advantage of the laziness of the iterator.</p>
<p>进一步优化：移除 <code>collect</code> 调用并将返回类型改为 <code>impl Iterator&lt;Item = &amp;'a str&gt;</code>，使 <code>search</code> 函数成为迭代器适配器。注意还需更新测试！在 <code>minigrep</code> 工具中搜索大文件，比较此修改前后的行为差异。修改前，程序会收集所有结果后才打印；修改后，由于 <code>run</code> 函数中的 <code>for</code> 循环利用了迭代器的惰性特性，会在找到每个匹配行时立即打印结果。</p>
<h3 id="choosing-between-loops-and-iterators-循环与迭代器的选择"><a class="header" href="#choosing-between-loops-and-iterators-循环与迭代器的选择">Choosing Between Loops and Iterators 循环与迭代器的选择</a></h3>
<p>The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-21 or the version using
iterators in Listing 13-22 (assuming we’re collecting all the results before
returning them rather than returning the iterator). Most Rust programmers
prefer to use the iterator style. It’s a bit tougher to get the hang of at
first, but once you get a feel for the various iterator adapters and what they
do, iterators can be easier to understand. Instead of fiddling with the various
bits of looping and building new vectors, the code focuses on the high-level
objective of the loop. This abstracts away some of the commonplace code so it’s
easier to see the concepts that are unique to this code, such as the filtering
condition each element in the iterator must pass.</p>
<p>接下来的核心问题是：在自己的代码中应选择哪种风格（示例 13-21 的原始实现还是示例 13-22 的迭代器版本）？大多数 Rust 程序员倾向于迭代器风格。虽然初学有一定难度，但熟悉各种迭代器适配器及其功能后，迭代器会更易理解。它避免了繁琐的循环控制和新建向量操作，聚焦于循环的高级目标，从而抽象了通用代码，突显了特定于当前代码的概念（如每个元素必须通过的过滤条件）。</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the lower-level loop will be faster. Let’s talk about performance.</p>
<p>但两种实现是否真正等效？直观上可能认为底层循环更快。下面讨论性能问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="comparing-performance-loops-vs-iterators-性能对比循环-vs-迭代器"><a class="header" href="#comparing-performance-loops-vs-iterators-性能对比循环-vs-迭代器">Comparing Performance: Loops vs. Iterators 性能对比：循环 vs 迭代器</a></h2>
<p>To determine whether to use loops or iterators, you need to know which
implementation is faster: the version of the <code>search</code> function with an explicit
<code>for</code> loop or the version with iterators.</p>
<p>要决定使用循环还是迭代器，需明确哪种实现更快：显式 <code>for</code> 循环的 <code>search</code> 函数版本，还是迭代器版本。</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of
Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word <em>the</em> in the contents. Here are the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<p>我们通过基准测试，将阿瑟·柯南·道尔的《福尔摩斯探案集》全文加载到 <code>String</code> 中，搜索单词 <em>the</em>。以下是 <code>for</code> 循环版本与迭代器版本的基准测试结果：</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The two implementations have similar performance! We won’t explain the
benchmark code here because the point is not to prove that the two versions
are equivalent but to get a general sense of how these two implementations
compare performance-wise.</p>
<p>两种实现性能相近！此处不解释基准测试代码，因为重点并非证明两者完全等效，而是比较其性能表现。</p>
<p>For a more comprehensive benchmark, you should check using various texts of
various sizes as the <code>contents</code>, different words and words of different lengths
as the <code>query</code>, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s <em>zero-cost abstractions</em>, by which we mean that using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
<em>zero-overhead</em> in “Foundations of C++” (2012):</p>
<p>更全面的基准测试应使用不同大小文本作为 <code>contents</code>、不同单词及长度作为 <code>query</code> 等。关键在于：迭代器虽是高级抽象，但编译后生成的代码与手写的底层代码大致相同。迭代器是 Rust 的<strong>零成本抽象</strong>之一，意味着使用该抽象不会引入额外运行时开销。这类似于 C++ 的原始设计者 Bjarne Stroustrup 在《Foundations of C++》(2012) 中对<strong>零开销</strong>的定义：</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
<p>通常，C++ 实现遵循零开销原则：未使用的部分无需付出代价。更重要的是：使用的部分也无法通过手动编码更优。</p>
</blockquote>
<p>In many cases, Rust code using iterators compiles to the same assembly you’d
write by hand. Optimizations such as loop unrolling and eliminating bounds
checking on array access apply and make the resultant code extremely efficient.
Now that you know this, you can use iterators and closures without fear! They
make code seem like it’s higher level but don’t impose a runtime performance
penalty for doing so.</p>
<p>多数情况下，使用迭代器的 Rust 代码会编译为与手写相同的汇编指令。循环展开和数组访问边界检查消除等优化手段均可应用，使最终代码极其高效。了解这一点后，可放心使用迭代器和闭包！它们使代码看似高层级，却不会牺牲运行时性能。</p>
<h2 id="summary-总结-12"><a class="header" href="#summary-总结-12">Summary 总结</a></h2>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.</p>
<p>闭包和迭代器是受函数式编程思想启发的 Rust 特性。它们助力 Rust 以底层性能清晰表达高层思想。闭包和迭代器的实现确保运行时性能不受影响，这体现了 Rust 提供零成本抽象的目标。</p>
<p>Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of <code>cargo</code> that will help us share the project with the
world.</p>
<p>现在已提升了 I/O 项目的表现力，接下来探讨更多 <code>cargo</code> 功能，它们将帮助我们将项目分享给全世界。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-cargo-and-cratesio-深入理解-cargo-和-cratesio"><a class="header" href="#more-about-cargo-and-cratesio-深入理解-cargo-和-cratesio">More About Cargo and Crates.io 深入理解 Cargo 和 Crates.io</a></h1>
<p>So far, we’ve used only the most basic features of Cargo to build, run, and
test our code, but it can do a lot more. In this chapter, we’ll discuss some of
its other, more advanced features to show you how to do the following:</p>
<p>到目前为止，我们仅使用了 Cargo 最基本的功能来构建、运行和测试代码，但它远不止于此。本章将探讨它的一些更高级功能，展示如何实现以下操作：</p>
<ul>
<li>Customize your build through release profiles</li>
<li>通过发布配置自定义构建过程</li>
<li>Publish libraries on <a href="https://crates.io/">crates.io</a></li>
<li>在 <a href="https://crates.io/">crates.io</a> 上发布库</li>
<li>Organize large projects with workspaces</li>
<li>使用工作空间组织大型项目</li>
<li>Install binaries from <a href="https://crates.io/">crates.io</a></li>
<li>从 <a href="https://crates.io/">crates.io</a> 安装二进制文件</li>
<li>Extend Cargo using custom commands</li>
<li>通过自定义命令扩展 Cargo</li>
</ul>
<p>Cargo can do even more than the functionality we cover in this chapter, so for
a full explanation of all its features, see <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<p>Cargo 的功能远不止本章所涵盖的内容，有关其全部功能的完整说明，请参阅<a href="https://doc.rust-lang.org/cargo/">官方文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="customizing-builds-with-release-profiles-使用发布配置自定义构建"><a class="header" href="#customizing-builds-with-release-profiles-使用发布配置自定义构建">Customizing Builds with Release Profiles 使用发布配置自定义构建</a></h2>
<p>In Rust, <em>release profiles</em> are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.</p>
<p>在 Rust 中，<span class="highlight">[note]<strong>发布配置</strong>（release profiles）是预定义且可自定义的配置方案，它们包含不同的编译设置</span>，让开发者能更精细地控制代码编译选项。每个配置都是独立设置的。</p>
<p>Cargo has two main profiles: the <code>dev</code> profile Cargo uses when you run <code>cargo  build</code>, and the <code>release</code> profile Cargo uses when you run <code>cargo build  --release</code>. The <code>dev</code> profile is defined with good defaults for development,
and the <code>release</code> profile has good defaults for release builds.</p>
<p>Cargo 有两个主要配置，执行 <code>cargo build</code> 时使用 <code>dev</code> 配置，执行 <code>cargo build --release</code> 时使用 <code>release</code> 配置。<code>dev</code> 配置为开发环境提供了合理的默认值，而 <code>release</code> 配置则为发布版本优化了默认设置。</p>
<p>These profile names might be familiar from the output of your builds:</p>
<p>构建输出中会显示这些配置名称：</p>
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
</code></pre>
<p>The <code>dev</code> and <code>release</code> are these different profiles used by the compiler.</p>
<p>这里的 <code>dev</code> 和 <code>release</code> 就是编译器使用的不同配置方案。</p>
<p>Cargo has default settings for each of the profiles that apply when you haven’t
explicitly added any <code>[profile.*]</code> sections in the project’s <em>Cargo.toml</em> file.
By adding <code>[profile.*]</code> sections for any profile you want to customize, you
override any subset of the default settings. For example, here are the default
values for the <code>opt-level</code> setting for the <code>dev</code> and <code>release</code> profiles:</p>
<p>当项目的 <em>Cargo.toml</em> 文件中未显式添加 <code>[profile.*]</code> 配置段时，Cargo 会应用各配置的默认设置。<span class="highlight">[note]通过为需要自定义的配置添加 <code>[profile.*]</code> 段，可以覆盖默认设置的任意子集。</span>例如，以下是 <code>dev</code> 和 <code>release</code> 配置中 <code>opt-level</code> 参数的默认值：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. Applying more optimizations extends
compiling time, so if you’re in development and compiling your code often,
you’ll want fewer optimizations to compile faster even if the resultant code
runs slower. The default <code>opt-level</code> for <code>dev</code> is therefore <code>0</code>. When you’re
ready to release your code, it’s best to spend more time compiling. You’ll only
compile in release mode once, but you’ll run the compiled program many times,
so release mode trades longer compile time for code that runs faster. That is
why the default <code>opt-level</code> for the <code>release</code> profile is <code>3</code>.</p>
<p><code>opt-level</code> 参数控制 Rust 对代码应用的优化级别，范围从 0 到 3。更高级别的优化会延长编译时间。在开发阶段频繁编译代码时，较低的优化级别能加快编译速度（即使生成的代码运行较慢），因此 <code>dev</code> 配置的默认 <code>opt-level</code> 设为 <code>0</code>。准备发布代码时，更适合增加编译时间投入：发布模式只需编译一次，但编译后的程序会多次运行。因此发布模式<strong>用更长的编译时间换取运行更快的代码</strong>，这就是 <code>release</code> 配置默认 <code>opt-level</code> 为 <code>3</code> 的原因。</p>
<p>You can override a default setting by adding a different value for it in
<em>Cargo.toml</em>. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project’s <em>Cargo.toml</em>
file:</p>
<p>通过在 <em>Cargo.toml</em> 中指定新值可以覆盖默认设置。例如要在开发配置中使用优化级别 1，可在项目的 <em>Cargo.toml</em> 中添加：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This code overrides the default setting of <code>0</code>. Now when we run <code>cargo build</code>,
Cargo will use the defaults for the <code>dev</code> profile plus our customization to
<code>opt-level</code>. Because we set <code>opt-level</code> to <code>1</code>, Cargo will apply more
optimizations than the default, but not as many as in a release build.</p>
<p>这段代码覆盖了默认的 <code>0</code> 设置。现在执行 <code>cargo build</code> 时，Cargo 会采用 <code>dev</code> 配置的默认值加上我们对 <code>opt-level</code> 的自定义设置。将 <code>opt-level</code> 设为 <code>1</code> 后，Cargo 应用的优化将高于默认级别，但仍低于发布构建的优化强度。</p>
<p>For the full list of configuration options and defaults for each profile, see
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo’s documentation</a>.</p>
<p>有关各配置的完整选项列表及默认值，请参阅 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 官方文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publishing-a-crate-to-cratesio-发布包到-cratesio"><a class="header" href="#publishing-a-crate-to-cratesio-发布包到-cratesio">Publishing a Crate to Crates.io 发布包到 Crates.io</a></h2>
<p>We’ve used packages from <a href="https://crates.io/">crates.io</a> as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
<a href="https://crates.io/">crates.io</a> distributes the source code of
your packages, so it primarily hosts code that is open source.</p>
<p>我们使用过 <a href="https://crates.io/">crates.io</a> 上的包作为项目的依赖项，但你也可以通过发布自己的包来与他人分享你的代码。<a href="https://crates.io/">crates.io</a> 上的包注册表会分发你包的源代码，因此它主要托管开源的代码。</p>
<p>Rust and Cargo have features that make your published package easier for people
to find and use. We’ll talk about some of these features next and then explain
how to publish a package.</p>
<p>Rust 和 Cargo 提供了一些功能，使你发布的包更容易被他人发现和使用。接下来我们将讨论其中一些功能，然后解释如何发布一个包。</p>
<h3 id="making-useful-documentation-comments-编写有用的文档注释"><a class="header" href="#making-useful-documentation-comments-编写有用的文档注释">Making Useful Documentation Comments 编写有用的文档注释</a></h3>
<p>Accurately documenting your packages will help other users know how and when to
use them, so it’s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, <code>//</code>. Rust also has
a particular kind of comment for documentation, known conveniently as a
<em>documentation comment</em>, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to <em>use</em> your crate as opposed to how
your crate is <em>implemented</em>.</p>
<p>准确为你的包编写文档有助于其他用户了解如何以及何时使用它们，因此值得投入时间编写文档。在第 3 章中，我们讨论了如何使用双斜杠 <code>//</code> 注释 Rust 代码。Rust 还有一种特定用于文档的注释，方便地称为<em>文档注释</em>，它可以生成 HTML 文档。该 HTML 会显示公共 API 项的文档注释内容，供那些希望了解如何<em>使用</em>你的包，而不是包如何<em>实现</em>的程序员阅读。</p>
<p>Documentation comments use three slashes, <code>///</code>, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting. Listing 14-1 shows documentation comments
for an <code>add_one</code> function in a crate named <code>my_crate</code>.</p>
<p><span class="highlight">[note]文档注释使用三个斜杠</span> <code>///</code> 而不是两个，并支持 Markdown 符号来格式化文本。将文档注释放在它们所记录的项之前。清单 14-1 展示了一个名为 <code>my_crate</code> 的包中 <code>add_one</code> 函数的文档注释。</p>
<figure class="listing" id="listing-14-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-1">Listing 14-1</a>: A documentation comment for a function 一个函数的文档注释</figcaption>
</figure>
<p>Here, we give a description of what the <code>add_one</code> function does, start a
section with the heading <code>Examples</code>, and then provide code that demonstrates
how to use the <code>add_one</code> function. We can generate the HTML documentation from
this documentation comment by running <code>cargo doc</code>. This command runs the
<code>rustdoc</code> tool distributed with Rust and puts the generated HTML documentation
in the <em>target/doc</em> directory.</p>
<p>这里，我们描述了 <code>add_one</code> 函数的功能，以一个标题为 <code>Examples</code> 的部分开始，然后提供了演示如何使用 <code>add_one</code> 函数的代码。我们可以通过运行 <code>cargo doc</code> 从这个文档注释生成 HTML 文档。这个命令运行 Rust 分发的 <code>rustdoc</code> 工具，并将生成的 HTML 文档放在 <em>target/doc</em> 目录下。</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1.</p>
<p>为了方便起见，运行 <code>cargo doc --open</code> 会为你当前包的文档（以及你包所有依赖项的文档）构建 HTML，并在 Web 浏览器中打开结果。导航到 <code>add_one</code> 函数，你将看到文档注释中的文本是如何渲染的，如图 14-1 所示。</p>
<img alt="" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code>
function. <code>add_one</code> 函数的 HTML 文档</span></p>
<h4 id="commonly-used-sections-常用部分"><a class="header" href="#commonly-used-sections-常用部分">Commonly Used Sections 常用部分</a></h4>
<p>We used the <code># Examples</code> Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Here are some other sections that crate
authors commonly use in their documentation:</p>
<p>我们在清单 14-1 中使用了 Markdown 标题 <code># Examples</code> 在 HTML 中创建了一个标题为 “Examples” 的部分。以下是包作者在文档中常用的<span class="highlight">[note]其他一些部分</span>：</p>
<ul>
<li><strong>Panics</strong>: The scenarios in which the function being documented could
panic. Callers of the function who don’t want their programs to panic should
make sure they don’t call the function in these situations.</li>
<li><strong>Panics (恐慌)</strong>: 被记录的函数可能发生恐慌的场景。不希望程序恐慌的调用者应确保不会在这些情况下调用该函数。</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of
errors that might occur and what conditions might cause those errors to be
returned can be helpful to callers so they can write code to handle the
different kinds of errors in different ways.</li>
<li><strong>Errors (错误)</strong>: 如果函数返回 <code>Result</code>，描述可能发生的错误类型以及什么条件可能导致这些错误被返回，对调用者很有帮助，这样他们可以编写代码以不同方式处理不同类型的错误。</li>
<li><strong>Safety</strong>: If the function is <code>unsafe</code> to call (we discuss unsafety in
Chapter 20), there should be a section explaining why the function is unsafe
and covering the invariants that the function expects callers to uphold.</li>
<li><strong>Safety (安全性)</strong>: 如果调用函数是 <code>unsafe</code>（我们将在第 20 章讨论不安全代码），那么应该有一个部分解释为什么该函数是不安全的，并涵盖函数期望调用者维护的不变性。</li>
</ul>
<p>Most documentation comments don’t need all of these sections, but this is a
good checklist to remind you of the aspects of your code users will be
interested in knowing about.</p>
<p>大多数文档注释不需要所有这些部分，但这是一个很好的清单，可以提醒你用户会有兴趣了解的代码方面。</p>
<h4 id="documentation-comments-as-tests-文档注释作为测试"><a class="header" href="#documentation-comments-as-tests-文档注释作为测试">Documentation Comments as Tests 文档注释作为测试</a></h4>
<p>Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running <code>cargo  test</code> will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code>
function from Listing 14-1, we will see a section in the test results that looks
like this:</p>
<p>在你的文档注释中添加示例代码块有助于演示如何使用你的库，这样做还有一个额外的好处：运行 <code>cargo test</code> 会将你文档中的代码示例作为测试运行！没有什么比带示例的文档更好的了。但也没有什么比文档写好之后代码发生了变化导致示例无法工作更糟糕的了。如果我们使用清单 14-1 中 <code>add_one</code> 函数的文档运行 <code>cargo test</code>，我们将在测试结果中看到一个类似这样的部分：</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Now, if we change either the function or the example so the <code>assert_eq!</code> in the
example panics, and run <code>cargo test</code> again, we’ll see that the doc tests catch
that the example and the code are out of sync with each other!</p>
<p>现在，如果我们更改函数或示例，使得示例中的 <code>assert_eq!</code> 宏发生恐慌，然后再次运行 <code>cargo test</code>，我们会看到文档测试捕获到了示例和代码不同步的情况！</p>
<h4 id="commenting-contained-items-注释包含的项"><a class="header" href="#commenting-contained-items-注释包含的项">Commenting Contained Items 注释包含的项</a></h4>
<p>The style of doc comment <code>//!</code> adds documentation to the item that <em>contains</em>
the comments rather than to the items <em>following</em> the comments. We typically use
these doc comments inside the crate root file (<em>src/lib.rs</em> by convention) or
inside a module to document the crate or the module as a whole.</p>
<p><span class="highlight">[note]文档注释样式 <code>//!</code> 将文档添加到<em>包含</em>这些注释的项</span>，而不是添加到<em>跟随</em>这些注释的项。我们通常在包根文件（约定为 <em>src/lib.rs</em>）内部或模块内部使用这些文档注释来记录整个包或模块。</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code>
crate that contains the <code>add_one</code> function, we add documentation comments that
start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing
14-2.</p>
<p>例如，要为包含 <code>add_one</code> 函数的 <code>my_crate</code> 包添加描述其用途的文档，我们在 <em>src/lib.rs</em> 文件的开头添加以 <code>//!</code> 开头的文档注释，如清单 14-2 所示。</p>
<figure class="listing" id="listing-14-2">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-2">Listing 14-2</a>: Documentation for the <code>my_crate</code> crate as a whole 整个 <code>my_crate</code> 包的文档</figcaption>
</figure>
<p>Notice there isn’t any code after the last line that begins with <code>//!</code>. Because
we started the comments with <code>//!</code> instead of <code>///</code>, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, that item is the <em>src/lib.rs</em> file, which is the crate root. These
comments describe the entire crate.</p>
<p>请注意，在以 <code>//!</code> 开头的最后一行之后没有任何代码。因为我们以 <code>//!</code> 而不是 <code>///</code> 开始注释，所以我们是在记录包含此注释的项，而不是在此注释之后的项。在这种情况下，该项是 <em>src/lib.rs</em> 文件，也就是包根。这些注释描述了整个包。</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-2.</p>
<p>当我们运行 <code>cargo doc --open</code> 时，这些注释将显示在 <code>my_crate</code> 文档的首页，位于包中公共项列表的上方，如图 14-2 所示。</p>
<img alt="" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figure 14-2: Rendered documentation for <code>my_crate</code>,
including the comment describing the crate as a whole. <code>my_crate</code> 的渲染文档，包括描述整个包的注释</span></p>
<p>Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crate’s organization.</p>
<p>容器项内部的文档注释对于描述包和模块尤其有用。使用它们来解释容器的整体目的，以帮助用户理解包的组织结构。</p>
<h3 id="exporting-a-convenient-public-api-with-pub-use-使用-pub-use-导出一个方便的公共-api"><a class="header" href="#exporting-a-convenient-public-api-with-pub-use-使用-pub-use-导出一个方便的公共-api">Exporting a Convenient Public API with <code>pub use</code> 使用 <code>pub use</code> 导出一个方便的公共 API</a></h3>
<p>The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.</p>
<p>当你发布一个包时，公共 API 的结构是一个主要的考虑因素。使用你包的人不如你熟悉其结构，如果你的包有一个庞大的模块层次结构，他们可能会难以找到他们想要使用的部分。</p>
<p>In Chapter 7, we covered how to make items public using the <code>pub</code> keyword, and
how to bring items into a scope with the <code>use</code> keyword. However, the structure
that makes sense to you while you’re developing a crate might not be very
convenient for your users. You might want to organize your structs in a
hierarchy containing multiple levels, but then people who want to use a type
you’ve defined deep in the hierarchy might have trouble finding out that type
exists. They might also be annoyed at having to enter <code>use  my_crate::some_module::another_module::UsefulType;</code> rather than <code>use  my_crate::UsefulType;</code>.</p>
<p>在第 7 章中，我们介绍了如何使用 <code>pub</code> 关键字使项变为公共的，以及如何使用 <code>use</code> 关键字将项引入作用域。然而，你在开发包时觉得合理的结构对你的用户来说可能并不方便。你可能希望将结构体组织在一个包含多层的层次结构中，但想要使用你在层次结构深处定义的类型的用户可能会难以发现该类型的存在。他们也可能对必须输入 <code>use my_crate::some_module::another_module::UsefulType;</code> 而不是 <code>use my_crate::UsefulType;</code> 感到烦恼。</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
from your private structure by using <code>pub use</code>. <em>Re-exporting</em> takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.</p>
<p>好消息是，如果这种结构<em>不</em>方便其他人在另一个库中使用，你不必重新安排你的内部组织：相反，你可以使用 <code>pub use</code> 重新导出项，以创建一个与你的私有结构不同的公共结构。<em>重新导出</em>（Re-exporting）将一个公共项从一个位置取出，使其在另一个位置也变为公共的，就好像它是在那个位置定义的一样。</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library are two modules: a <code>kinds</code> module containing two enums
named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a
function named <code>mix</code>, as shown in Listing 14-3.</p>
<p>例如，假设我们创建了一个名为 <code>art</code> 的库来模拟艺术概念。在这个库中有两个模块：一个 <code>kinds</code> 模块，包含两个枚举 <code>PrimaryColor</code> 和 <code>SecondaryColor</code>；一个 <code>utils</code> 模块，包含一个名为 <code>mix</code> 的函数，如清单 14-3 所示。</p>
<figure class="listing" id="listing-14-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-3">Listing 14-3</a>: An <code>art</code> library with items organized into <code>kinds</code> and <code>utils</code> modules 一个将项组织到 <code>kinds</code> 和 <code>utils</code> 模块的 <code>art</code> 库</figcaption>
</figure>
<p>Figure 14-3 shows what the front page of the documentation for this crate
generated by <code>cargo doc</code> would look like.</p>
<p>图 14-3 展示了由 <code>cargo doc</code> 生成的这个包的文档首页的样子。</p>
<img alt="" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: Front page of the documentation for <code>art</code>
that lists the <code>kinds</code> and <code>utils</code> modules. <code>art</code> 包的文档首页，列出了 <code>kinds</code> 和 <code>utils</code> 模块</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren’t listed on the
front page, nor is the <code>mix</code> function. We have to click <code>kinds</code> and <code>utils</code> to
see them.</p>
<p>请注意，<code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型没有列在首页上，<code>mix</code> 函数也没有。我们必须点击 <code>kinds</code> 和 <code>utils</code> 才能看到它们。</p>
<p>Another crate that depends on this library would need <code>use</code> statements that
bring the items from <code>art</code> into scope, specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
<code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate.</p>
<p>另一个依赖于这个库的包需要使用 <code>use</code> 语句将 <code>art</code> 中的项引入作用域，指定当前定义的模块结构。清单 14-4 展示了一个使用 <code>art</code> 包中的 <code>PrimaryColor</code> 和 <code>mix</code> 项的包示例。</p>
<figure class="listing" id="listing-14-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-4">Listing 14-4</a>: A crate using the <code>art</code> crate’s items with its internal structure exported 一个使用 <code>art</code> 包项（其内部结构已被导出）的包</figcaption>
</figure>
<p>The author of the code in Listing 14-4, which uses the <code>art</code> crate, had to
figure out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the
<code>utils</code> module. The module structure of the <code>art</code> crate is more relevant to
developers working on the <code>art</code> crate than to those using it. The internal
structure doesn’t contain any useful information for someone trying to
understand how to use the <code>art</code> crate, but rather causes confusion because
developers who use it have to figure out where to look, and must specify the
module names in the <code>use</code> statements.</p>
<p>清单 14-4 中使用 <code>art</code> 包的代码作者必须弄清楚 <code>PrimaryColor</code> 在 <code>kinds</code> 模块中，而 <code>mix</code> 在 <code>utils</code> 模块中。<code>art</code> 包的模块结构对开发 <code>art</code> 包的程序员更相关，而对使用它的人来说则不然。内部结构不包含任何对试图理解如何使用 <code>art</code> 包的人有用的信息，反而会引起混淆，因为使用它的开发者必须弄清楚去哪里找，并且必须在 <code>use</code> 语句中指定模块名称。</p>
<p>To remove the internal organization from the public API, we can modify the
<code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-5.</p>
<p>为了从公共 API 中移除内部组织，我们可以修改清单 14-3 中的 <code>art</code> 包代码，添加 <code>pub use</code> 语句在顶层重新导出这些项，如清单 14-5 所示。</p>
<figure class="listing" id="listing-14-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-5">Listing 14-5</a>: Adding <code>pub use</code> statements to re-export items 添加 <code>pub use</code> 语句重新导出项</figcaption>
</figure>
<p>The API documentation that <code>cargo doc</code> generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
<code>PrimaryColor</code> and <code>SecondaryColor</code> types and the <code>mix</code> function easier to find.</p>
<p>现在 <code>cargo doc</code> 为此包生成的 API 文档将在首页列出并链接重新导出的项，如图 14-4 所示，使得 <code>PrimaryColor</code> 和 <code>SecondaryColor</code> 类型以及 <code>mix</code> 函数更容易找到。</p>
<img alt="" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figure 14-4: The front page of the documentation for <code>art</code>
that lists the re-exports. <code>art</code> 包的文档首页，列出了重新导出的项</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6.</p>
<p><code>art</code> 包的用户仍然可以像清单 14-4 所示那样使用清单 14-3 的内部结构，或者他们可以使用清单 14-5 中更方便的结构，如清单 14-6 所示。</p>
<figure class="listing" id="listing-14-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
<figcaption><a href="ch14-02-publishing-to-crates-io.html#listing-14-6">Listing 14-6</a>: A program using the re-exported items from the <code>art</code> crate 一个使用 <code>art</code> 包重新导出项的程序</figcaption>
</figure>
<p>In cases where there are many nested modules, re-exporting the types at the top
level with <code>pub use</code> can make a significant difference in the experience of
people who use the crate. Another common use of <code>pub use</code> is to re-export
definitions of a dependency in the current crate to make that crate’s
definitions part of your crate’s public API.</p>
<p>在存在许多嵌套模块的情况下，使用 <code>pub use</code> 在顶层重新导出类型可以显著改善使用你包的人的体验。<code>pub use</code> 的另一个常见用途是在当前包中重新导出依赖项的定义，使该依赖项的定义成为你包公共 API 的一部分。</p>
<p>Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing <code>pub  use</code> gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.</p>
<p>创建一个有用的公共 API 结构更像是一门艺术而非科学，你可以通过迭代找到最适合用户的 API。选择 <code>pub use</code> 使你在内部如何组织包方面具有灵活性，并将内部结构与呈现给用户的结构解耦。查看一些你已安装包的代码，看看它们的内部结构是否与公共 API 不同。</p>
<h3 id="setting-up-a-cratesio-account-设置-cratesio-账户"><a class="header" href="#setting-up-a-cratesio-account-设置-cratesio-账户">Setting Up a Crates.io Account 设置 Crates.io 账户</a></h3>
<p>Before you can publish any crates, you need to create an account on
<a href="https://crates.io/">crates.io</a> and get an API token. To do so,
visit the home page at <a href="https://crates.io/">crates.io</a> and log
in via a GitHub account. (The GitHub account is currently a requirement, but
the site might support other ways of creating an account in the future.) Once
you’re logged in, visit your account settings at
<a href="https://crates.io/me/">https://crates.io/me/</a> and retrieve your
API key. Then run the <code>cargo login</code> command and paste your API key when prompted, like this:</p>
<p>在发布任何包之前，你需要在 <a href="https://crates.io/">crates.io</a> 上创建一个账户并获取一个 API 令牌。为此，访问 <a href="https://crates.io/">crates.io</a> 主页并通过 GitHub 账户登录。（目前 GitHub 账户是必需的，但将来该网站可能会支持其他创建账户的方式。）登录后，访问你的账户设置页面 <a href="https://crates.io/me/">https://crates.io/me/</a> 并获取你的 API 密钥。然后运行 <code>cargo login</code> 命令，并在提示时粘贴你的 API 密钥，如下所示：</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials.toml</em>. Note that this token is a <em>secret</em>: do not share
it with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on <a href="https://crates.io/">crates.io</a>.</p>
<p>此命令会将你的 API 令牌告知 Cargo，并将其本地存储在 <em>~/.cargo/credentials.toml</em> 中。请注意，此令牌是<em>机密</em>：不要与其他人共享。如果因任何原因将其共享给任何人，你应该撤销它并在 <a href="https://crates.io/">crates.io</a> 上生成一个新令牌。</p>
<h3 id="adding-metadata-to-a-new-crate-向新包添加元数据"><a class="header" href="#adding-metadata-to-a-new-crate-向新包添加元数据">Adding Metadata to a New Crate 向新包添加元数据</a></h3>
<p>Let’s say you have a crate you want to publish. Before publishing, you’ll need
to add some metadata in the <code>[package]</code> section of the crate’s <em>Cargo.toml</em>
file.</p>
<p>假设你有一个想要发布的包。在发布之前，你需要在包的 <em>Cargo.toml</em> 文件的 <code>[package]</code> 部分添加一些元数据。</p>
<p>Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
<a href="https://crates.io/">crates.io</a> are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use. If the name has been used, you will need to find another name and
edit the <code>name</code> field in the <em>Cargo.toml</em> file under the <code>[package]</code> section to
use the new name for publishing, like so:</p>
<p>你的包需要一个唯一的名称。在本地处理包时，你可以随意命名包。然而，<a href="https://crates.io/">crates.io</a> 上的包名是按先到先得的原则分配的。一旦一个包名被占用，其他人就无法发布同名的包。在尝试发布包之前，请搜索你想要使用的名称。如果该名称已被使用，你将需要找到另一个名称，并编辑 <em>Cargo.toml</em> 文件中 <code>[package]</code> 部分下的 <code>name</code> 字段以使用新名称进行发布，如下所示：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Even if you’ve chosen a unique name, when you run <code>cargo publish</code> to publish
the crate at this point, you’ll get a warning and then an error:</p>
<p>即使你选择了一个唯一的名称，此时运行 <code>cargo publish</code> 发布包时，你也会收到一个警告，然后是一个错误：</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
</code></pre>
<p>This results in an error because you’re missing some crucial information: a
description and license are required so people will know what your crate does
and under what terms they can use it. In <em>Cargo.toml</em>, add a description that’s
just a sentence or two, because it will appear with your crate in search
results. For the <code>license</code> field, you need to give a <em>license identifier value</em>.
The Linux Foundation’s Software Package Data Exchange (SPDX) lists the
identifiers you can use for this value. For example, to specify that you’ve
licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<p>出现错误是因为你缺少一些关键信息：描述和许可证是必需的，以便人们知道你的包是做什么的以及在什么条款下可以使用它。在 <em>Cargo.toml</em> 中，添加一个只需一两句话的描述，因为它将出现在搜索结果中你的包旁边。对于 <code>license</code> 字段，你需要提供一个<em>许可证标识符值</em>。Linux 基金会的 Software Package Data Exchange (SPDX) 列出了你可以用于此值的标识符。例如，要指定你使用 MIT 许可证授权你的包，添加 <code>MIT</code> 标识符：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use <code>license-file</code> to specify the name of that file instead of using the
<code>license</code> key.</p>
<p>如果你想使用 SPDX 中未列出的许可证，你需要将该许可证的文本放在一个文件中，将该文件包含在你的项目中，然后使用 <code>license-file</code> 指定该文件的名称，而不是使用 <code>license</code> 键。</p>
<p>Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of <code>MIT OR Apache-2.0</code>. This practice
demonstrates that you can also specify multiple license identifiers separated
by <code>OR</code> to have multiple licenses for your project.</p>
<p>哪种许可证适合你的项目超出了本书的范围。许多 Rust 社区成员通过与 Rust 相同的方式对他们的项目进行授权，即使用 <code>MIT OR Apache-2.0</code> 双重许可证。这种做法表明你也可以通过用 <code>OR</code> 分隔多个许可证标识符来为你的项目指定多个许可证。</p>
<p>With a unique name, the version, your description, and a license added, the
<em>Cargo.toml</em> file for a project that is ready to publish might look like this:</p>
<p>添加了唯一的名称、版本、描述和许可证后，一个准备好发布的项目的 <em>Cargo.toml</em> 文件可能如下所示：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure that others can discover and use your crate
more easily.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo 的文档</a>描述了你可以指定的其他元数据，以确保其他人可以更容易地发现和使用你的包。</p>
<h3 id="publishing-to-cratesio-发布到-cratesio"><a class="header" href="#publishing-to-cratesio-发布到-cratesio">Publishing to Crates.io 发布到 Crates.io</a></h3>
<p>Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
<a href="https://crates.io/">crates.io</a> for others to use.</p>
<p>现在你已经创建了账户、保存了 API 令牌、为包选择了名称并指定了所需的元数据，你准备好发布了！发布一个包会将特定版本上传到 <a href="https://crates.io/">crates.io</a> 供他人使用。</p>
<p>Be careful, because a publish is <em>permanent</em>. The version can never be
overwritten, and the code cannot be deleted except in certain circumstances.
One major goal of Crates.io is to act as a permanent archive of code so that
builds of all projects that depend on crates from
<a href="https://crates.io/">crates.io</a> will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.</p>
<p>请小心，因为发布是<em>永久性</em>的。版本永远不能被覆盖，代码也不能被删除，除非在特定情况下。Crates.io 的一个主要目标是充当代码的永久存档，以便所有依赖来自 <a href="https://crates.io/">crates.io</a> 的包的项目的构建都能继续工作。允许删除版本会使实现该目标变得不可能。但是，你可以发布的包版本数量没有限制。</p>
<p>Run the <code>cargo publish</code> command again. It should succeed now:</p>
<p>再次运行 <code>cargo publish</code> 命令。现在它应该成功了：</p>
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
    Packaged 6 files, 1.2KiB (895.0B compressed)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
    Uploaded guessing_game v0.1.0 to registry `crates-io`
note: waiting for `guessing_game v0.1.0` to be available at registry
`crates-io`.
You may press ctrl-c to skip waiting; the crate should be available shortly.
   Published guessing_game v0.1.0 at registry `crates-io`
</code></pre>
<p>Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.</p>
<p>恭喜！你现在已经与 Rust 社区分享了你的代码，任何人都可以轻松地将你的包添加为他们项目的依赖项。</p>
<h3 id="publishing-a-new-version-of-an-existing-crate-发布现有包的新版本"><a class="header" href="#publishing-a-new-version-of-an-existing-crate-发布现有包的新版本">Publishing a New Version of an Existing Crate 发布现有包的新版本</a></h3>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the Semantic Versioning rules to decide what an
appropriate next version number is, based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<p>当你对包进行了更改并准备发布新版本时，你可以更改 <em>Cargo.toml</em> 文件中指定的 <code>version</code> 值并重新发布。使用语义版本控制规则（Semantic Versioning rules），根据你所做更改的类型决定合适的下一个版本号。然后运行 <code>cargo publish</code> 上传新版本。</p>
<h3 id="deprecating-versions-from-cratesio-with-cargo-yank-使用-cargo-yank-从-cratesio-弃用版本"><a class="header" href="#deprecating-versions-from-cratesio-with-cargo-yank-使用-cargo-yank-从-cratesio-弃用版本">Deprecating Versions from Crates.io with <code>cargo yank</code> 使用 <code>cargo yank</code> 从 Crates.io 弃用版本</a></h3>
<p>Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports yanking a crate version.</p>
<p>虽然你不能删除包的先前版本，但你可以阻止任何未来的项目将它们添加为新的依赖项。这在包的某个版本因某种原因损坏时很有用。在这种情况下，Cargo 支持撤回（yank）一个包版本。</p>
<p><em>Yanking</em> a version prevents new projects from depending on that version while
allowing all existing projects that depend on it to continue. Essentially, a
yank means that all projects with a <em>Cargo.lock</em> will not break, and any future
<em>Cargo.lock</em> files generated will not use the yanked version.</p>
<p><em>撤回</em>一个版本会阻止新项目依赖该版本，同时允许所有已依赖它的现有项目继续使用。本质上，撤回意味着所有拥有 <em>Cargo.lock</em> 的项目都不会损坏，并且将来生成的任何 <em>Cargo.lock</em> 文件都不会使用被撤回的版本。</p>
<p>To yank a version of a crate, in the directory of the crate that you’ve
previously published, run <code>cargo yank</code> and specify which version you want to
yank. For example, if we’ve published a crate named <code>guessing_game</code> version
1.0.1 and we want to yank it, in the project directory for <code>guessing_game</code> we’d
run:</p>
<p>要撤回一个包的版本，在你之前发布的包所在的目录中运行 <code>cargo yank</code> 并指定你想要撤回的版本。例如，如果我们发布了一个名为 <code>guessing_game</code> 的版本 1.0.1 的包，并且我们想撤回它，那么在 <code>guessing_game</code> 的项目目录中我们会运行：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>By adding <code>--undo</code> to the command, you can also undo a yank and allow projects
to start depending on a version again:</p>
<p>通过在命令中添加 <code>--undo</code>，你也可以撤销撤回操作，并允许项目再次依赖某个版本：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>A yank <em>does not</em> delete any code. It cannot, for example, delete accidentally
uploaded secrets. If that happens, you must reset those secrets immediately.</p>
<p>撤回<em>不会</em>删除任何代码。例如，它不能删除意外上传的密钥。如果发生这种情况，你必须立即重置这些密钥。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspaces-cargo-工作空间"><a class="header" href="#cargo-workspaces-cargo-工作空间">Cargo Workspaces Cargo 工作空间</a></h2>
<p>In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split your package further into
multiple library crates. Cargo offers a feature called <em>workspaces</em> that can
help manage multiple related packages that are developed in tandem.</p>
<p>在第 12 章中，我们构建了一个包含二进制包和库包的包。随着项目的发展，你可能会发现库包变得越来越大，并且你希望进一步将包拆分成多个库包。Cargo 提供了一个名为<em>工作空间</em>的功能，可以帮助管理协同开发的多个相关包。</p>
<h3 id="creating-a-workspace-创建工作空间"><a class="header" href="#creating-a-workspace-创建工作空间">Creating a Workspace 创建工作空间</a></h3>
<p>A <em>workspace</em> is a set of packages that share the same <em>Cargo.lock</em> and output
directory. Let’s make a project using a workspace—we’ll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace, so we’ll just show one common way. We’ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an <code>add_one</code> function and the other library an <code>add_two</code> function.
These three crates will be part of the same workspace. We’ll start by creating
a new directory for the workspace:</p>
<p><span class="highlight">[note]一个工作空间是一组共享同一个 <code>Cargo.lock</code> 和输出目录的包。</span>让我们使用工作空间创建一个项目——我们将使用简单的代码，以便专注于工作空间的结构。构建工作空间有多种方式，因此我们只展示一种常见的方式。我们将有一个包含一个二进制包和两个库包的工作空间。提供主要功能的二进制包将依赖于这两个库。一个库将提供一个 <code>add_one</code> 函数，另一个库提供一个 <code>add_two</code> 函数。这三个包将是同一个工作空间的一部分。我们将首先为工作空间创建一个新目录：</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Next, in the <em>add</em> directory, we create the <em>Cargo.toml</em> file that will
configure the entire workspace. This file won’t have a <code>[package]</code> section.
Instead, it will start with a <code>[workspace]</code> section that will allow us to add
members to the workspace. We also make a point to use the latest and greatest
version of Cargo’s resolver algorithm in our workspace by setting the
<code>resolver</code> value to <code>"3"</code>.</p>
<p>接下来，在 <em>add</em> 目录中，我们创建 <em>Cargo.toml</em> 文件来配置整个工作空间。这个文件不会有 <code>[package]</code> 部分。相反，它将<span class="highlight">[note]以一个 <code>[workspace]</code> 部分开始，允许我们向工作空间添加成员</span>。我们还特意通过将 <code>resolver</code> 值设置为 <code>"3"</code> 来在工作空间中使用最新最好的 Cargo 解析器算法。</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
</code></pre>
<p>Next, we’ll create the <code>adder</code> binary crate by running <code>cargo new</code> within the
<em>add</em> directory:</p>
<p>接下来，我们将在 <em>add</em> 目录内运行 <code>cargo new</code> 来创建 <code>adder</code> 二进制包：</p>
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
</code></pre>
<p>Running <code>cargo new</code> inside a workspace also automatically adds the newly created
package to the <code>members</code> key in the <code>[workspace]</code> definition in the workspace
<em>Cargo.toml</em>, like this:</p>
<p>在工作空间内部运行 <code>cargo new</code> 也会自动将新创建的包添加到工作空间 <em>Cargo.toml</em> 中 <code>[workspace]</code> 定义的 <code>members</code> 键中，如下所示：</p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder"]
</code></pre>
<p>At this point, we can build the workspace by running <code>cargo build</code>. The files
in your <em>add</em> directory should look like this:</p>
<p>此时，我们可以通过运行 <code>cargo build</code> 来构建工作空间。你 <em>add</em> 目录中的文件应该如下所示：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>The workspace has one <em>target</em> directory at the top level that the compiled
artifacts will be placed into; the <code>adder</code> package doesn’t have its own
<em>target</em> directory. Even if we were to run <code>cargo build</code> from inside the
<em>adder</em> directory, the compiled artifacts would still end up in <em>add/target</em>
rather than <em>add/adder/target</em>. Cargo structures the <em>target</em> directory in a
workspace like this because the crates in a workspace are meant to depend on
each other. If each crate had its own <em>target</em> directory, each crate would have
to recompile each of the other crates in the workspace to place the artifacts
in its own <em>target</em> directory. By sharing one <em>target</em> directory, the crates
can avoid unnecessary rebuilding.</p>
<p>工作空间在顶层有一个 <em>target</em> 目录，编译后的工件将放在这里；<code>adder</code> 包没有它自己的 <em>target</em> 目录。即使我们从 <em>adder</em> 目录内部运行 <code>cargo build</code>，编译后的工件仍然会放在 <em>add/target</em> 中，而不是 <em>add/adder/target</em> 中。Cargo 这样构建工作空间的 <em>target</em> 目录是因为工作空间中的包旨在相互依赖。如果每个包都有自己的 <em>target</em> 目录，那么每个包为了将工件放在它自己的 <em>target</em> 目录中，就必须重新编译工作空间中的其他包。通过共享一个 <em>target</em> 目录，包可以避免不必要的重新构建。</p>
<h3 id="creating-the-second-package-in-the-workspace-在工作空间中创建第二个包"><a class="header" href="#creating-the-second-package-in-the-workspace-在工作空间中创建第二个包">Creating the Second Package in the Workspace 在工作空间中创建第二个包</a></h3>
<p>Next, let’s create another member package in the workspace and call it
<code>add_one</code>. Generate a new library crate named <code>add_one</code>:</p>
<p>接下来，让我们在工作空间中创建另一个成员包，并将其命名为 <code>add_one</code>。生成一个名为 <code>add_one</code> 的新库包：</p>
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
</code></pre>
<p>The top-level <em>Cargo.toml</em> will now include the <em>add_one</em> path in the <code>members</code>
list:</p>
<p>顶层的 <em>Cargo.toml</em> 现在将在 <code>members</code> 列表中包含 <em>add_one</em> 路径：</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder", "add_one"]
</code></pre>
<p>Your <em>add</em> directory should now have these directories and files:</p>
<p>你的 <em>add</em> 目录现在应该包含这些目录和文件：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>In the <em>add_one/src/lib.rs</em> file, let’s add an <code>add_one</code> function:</p>
<p>在 <em>add_one/src/lib.rs</em> 文件中，让我们添加一个 <code>add_one</code> 函数：</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Now we can have the <code>adder</code> package with our binary depend on the <code>add_one</code>
package that has our library. First, we’ll need to add a path dependency on
<code>add_one</code> to <em>adder/Cargo.toml</em>.</p>
<p>现在我们可以让我们带二进制文件的 <code>adder</code> 包依赖于拥有我们库的 <code>add_one</code> 包。首先，我们需要在 <em>adder/Cargo.toml</em> 中<span class="highlight">[note]添加一个对 <code>add_one</code> 的路径依赖</span>。</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo doesn’t assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships.</p>
<p>Cargo 不假设工作空间中的包会相互依赖，因此我们需要显式指定依赖关系。</p>
<p>Next, let’s use the <code>add_one</code> function (from the <code>add_one</code> crate) in the
<code>adder</code> crate. Open the <em>adder/src/main.rs</em> file and change the <code>main</code>
function to call the <code>add_one</code> function, as in Listing 14-7.</p>
<p>接下来，让我们在 <code>adder</code> 包中使用 <code>add_one</code> 函数（来自 <code>add_one</code> 包）。打开 <em>adder/src/main.rs</em> 文件并将 <code>main</code> 函数改为调用 <code>add_one</code> 函数，如清单 14-7 所示。</p>
<figure class="listing" id="listing-14-7">
<span class="file-name">Filename: adder/src/main.rs</span>
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}</code></pre>
<figcaption><a href="ch14-03-cargo-workspaces.html#listing-14-7">Listing 14-7</a>: Using the <code>add_one</code> library crate from the <code>adder</code> crate 在 <code>adder</code> 包中使用 <code>add_one</code> 库包</figcaption>
</figure>
<p>Let’s build the workspace by running <code>cargo build</code> in the top-level <em>add</em>
directory!</p>
<p>让我们在顶层的 <em>add</em> 目录中运行 <code>cargo build</code> 来构建工作空间！</p>
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>To run the binary crate from the <em>add</em> directory, we can specify which
package in the workspace we want to run by using the <code>-p</code> argument and the
package name with <code>cargo run</code>:</p>
<p>要从 <em>add</em> 目录运行二进制包，我们可以<span class="highlight">[note]使用 <code>cargo run</code> 命令的 <code>-p</code> 参数并指定我们想要运行的包的名称</span>：</p>
<pre><code class="language-console">$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>This runs the code in <em>adder/src/main.rs</em>, which depends on the <code>add_one</code> crate.</p>
<p>这会运行 <em>adder/src/main.rs</em> 中的代码，该代码依赖于 <code>add_one</code> 包。</p>
<h4 id="depending-on-an-external-package-in-a-workspace-在工作空间中依赖外部包"><a class="header" href="#depending-on-an-external-package-in-a-workspace-在工作空间中依赖外部包">Depending on an External Package in a Workspace 在工作空间中依赖外部包</a></h4>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level,
rather than having a <em>Cargo.lock</em> in each crate’s directory. This ensures that
all crates are using the same version of all dependencies. If we add the <code>rand</code>
package to the <em>adder/Cargo.toml</em> and <em>add_one/Cargo.toml</em> files, Cargo will
resolve both of those to one version of <code>rand</code> and record that in the one
<em>Cargo.lock</em>. Making all crates in the workspace use the same dependencies
means the crates will always be compatible with each other. Let’s add the
<code>rand</code> crate to the <code>[dependencies]</code> section in the <em>add_one/Cargo.toml</em> file
so we can use the <code>rand</code> crate in the <code>add_one</code> crate:</p>
<p>请注意，工作空间只在顶层有一个 <em>Cargo.lock</em> 文件，而不是在每个包的目录中都有一个。这确保了所有包都使用相同版本的所有依赖项。如果我们将 <code>rand</code> 包添加到 <em>adder/Cargo.toml</em> 和 <em>add_one/Cargo.toml</em> 文件中，Cargo 会将它们解析为同一个版本的 <code>rand</code> 并记录在唯一的 <em>Cargo.lock</em> 中。让工作空间中的所有包使用相同的依赖项意味着包之间始终是兼容的。让我们将 <code>rand</code> 包添加到 <em>add_one/Cargo.toml</em> 文件的 <code>[dependencies]</code> 部分，以便我们可以在 <code>add_one</code> 包中使用 <code>rand</code> 包：</p>
<p><span class="filename">Filename: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>We can now add <code>use rand;</code> to the <em>add_one/src/lib.rs</em> file, and building the
whole workspace by running <code>cargo build</code> in the <em>add</em> directory will bring in
and compile the <code>rand</code> crate. We will get one warning because we aren’t
referring to the <code>rand</code> we brought into scope:</p>
<p>我们现在可以在 <em>add_one/src/lib.rs</em> 文件中添加 <code>use rand;</code>，然后在 <em>add</em> 目录中运行 <code>cargo build</code> 来构建整个工作空间将会引入并编译 <code>rand</code> 包。我们会收到一个警告，因为我们没有引用我们引入作用域的 <code>rand</code>：</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s
</code></pre>
<p>The top-level <em>Cargo.lock</em> now contains information about the dependency of
<code>add_one</code> on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
<code>rand</code> to their <em>Cargo.toml</em> files as well. For example, if we add <code>use rand;</code>
to the <em>adder/src/main.rs</em> file for the <code>adder</code> package, we’ll get an error:</p>
<p>顶层的 <em>Cargo.lock</em> 现在包含了 <code>add_one</code> 依赖 <code>rand</code> 的信息。然而，尽管 <code>rand</code> 在工作空间中的某个地方被使用了，除非我们在其他包的 <em>Cargo.toml</em> 文件中添加 <code>rand</code>，否则我们不能在工作空间的其他包中使用它。例如，如果我们在 <code>adder</code> 包的 <em>adder/src/main.rs</em> 文件中添加 <code>use rand;</code>，我们会得到一个错误：</p>
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>To fix this, edit the <em>Cargo.toml</em> file for the <code>adder</code> package and indicate
that <code>rand</code> is a dependency for it as well. Building the <code>adder</code> package will
add <code>rand</code> to the list of dependencies for <code>adder</code> in <em>Cargo.lock</em>, but no
additional copies of <code>rand</code> will be downloaded. Cargo will ensure that every
crate in every package in the workspace using the <code>rand</code> package will use the
same version as long as they specify compatible versions of <code>rand</code>, saving us
space and ensuring that the crates in the workspace will be compatible with each
other.</p>
<p>要修复此问题，请编辑 <code>adder</code> 包的 <em>Cargo.toml</em> 文件，并指明 <code>rand</code> 也是它的依赖项。构建 <code>adder</code> 包会将 <code>rand</code> 添加到 <em>Cargo.lock</em> 中 <code>adder</code> 的依赖项列表中，但不会下载额外的 <code>rand</code> 副本。Cargo 将确保工作空间中每个使用 <code>rand</code> 包的包，只要它们指定了兼容的 <code>rand</code> 版本，就使用相同的版本，从而节省空间并确保工作空间中的包彼此兼容。</p>
<p>If crates in the workspace specify incompatible versions of the same dependency,
Cargo will resolve each of them, but will still try to resolve as few versions
as possible.</p>
<p>如果工作空间中的包指定了同一个依赖项的不兼容版本，Cargo 会分别解析它们，但仍会尝试解析尽可能少的版本。</p>
<h4 id="adding-a-test-to-a-workspace-向工作空间添加测试"><a class="header" href="#adding-a-test-to-a-workspace-向工作空间添加测试">Adding a Test to a Workspace 向工作空间添加测试</a></h4>
<p>For another enhancement, let’s add a test of the <code>add_one::add_one</code> function
within the <code>add_one</code> crate:</p>
<p>作为另一个增强功能，让我们在 <code>add_one</code> 包内部为 <code>add_one::add_one</code> 函数添加一个测试：</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Now run <code>cargo test</code> in the top-level <em>add</em> directory. Running <code>cargo test</code> in
a workspace structured like this one will run the tests for all the crates in
the workspace:</p>
<p>现在在顶层的 <em>add</em> 目录中运行 <code>cargo test</code>。在像这样结构化的工作空间中运行 <code>cargo test</code> 将运行工作空间中所有包的测试：</p>
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>The first section of the output shows that the <code>it_works</code> test in the <code>add_one</code>
crate passed. The next section shows that zero tests were found in the <code>adder</code>
crate, and then the last section shows zero documentation tests were found in
the <code>add_one</code> crate.</p>
<p>输出的第一部分显示 <code>add_one</code> 包中的 <code>it_works</code> 测试通过了。下一部分显示在 <code>adder</code> 包中未找到任何测试，然后最后一部分显示在 <code>add_one</code> 包中未找到任何文档测试。</p>
<p>We can also run tests for one particular crate in a workspace from the
top-level directory by using the <code>-p</code> flag and specifying the name of the crate
we want to test:</p>
<p>我们也可以使用 <code>cargo test</code> 的 <code>-p</code> 标志并指定我们想要测试的包的名称，从顶层目录运行工作空间中特定包的测试：</p>
<pre><code class="language-console">$ cargo test -p add_one
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add_one</code> crate and
didn’t run the <code>adder</code> crate tests.</p>
<p>此输出显示 <code>cargo test</code> 只运行了 <code>add_one</code> 包的测试，没有运行 <code>adder</code> 包的测试。</p>
<p>If you publish the crates in the workspace to
<a href="https://crates.io/">crates.io</a>, each crate in the workspace
will need to be published separately. Like <code>cargo test</code>, we can publish a
particular crate in our workspace by using the <code>-p</code> flag and specifying the
name of the crate we want to publish.</p>
<p>如果你将工作空间中的包发布到 <a href="https://crates.io/">crates.io</a>，工作空间中的每个包都需要单独发布。与 <code>cargo test</code> 类似，我们可以使用 <code>cargo publish</code> 的 <code>-p</code> 标志并指定我们想要发布的包的名称来发布工作空间中的特定包。</p>
<p>For additional practice, add an <code>add_two</code> crate to this workspace in a similar
way as the <code>add_one</code> crate!</p>
<p>作为额外的练习，以类似于 <code>add_one</code> 包的方式向此工作空间添加一个 <code>add_two</code> 包！</p>
<p>As your project grows, consider using a workspace: it enables you to work with
smaller, easier-to-understand components than one big blob of code. Furthermore,
keeping the crates in a workspace can make coordination between crates easier if
they are often changed at the same time.</p>
<p>随着项目的增长，考虑使用工作空间：它使你能够处理比一大块代码更小、更易于理解的组件。此外，如果包经常同时更改，将包保持在同一个工作空间可以使包之间的协调更容易。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-binaries-with-cargo-install-使用-cargo-install-安装二进制文件"><a class="header" href="#installing-binaries-with-cargo-install-使用-cargo-install-安装二进制文件">Installing Binaries with <code>cargo install</code> 使用 <code>cargo install</code> 安装二进制文件</a></h2>
<p>The <code>cargo install</code> command allows you to install and use binary crates
locally. This isn’t intended to replace system packages; it’s meant to be a
convenient way for Rust developers to install tools that others have shared on
<a href="https://crates.io/">crates.io</a>. Note that you can only install
packages that have binary targets. A <em>binary target</em> is the runnable program
that is created if the crate has a <em>src/main.rs</em> file or another file specified
as a binary, as opposed to a library target that isn’t runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the <em>README</em> file about whether a crate is a library, has a
binary target, or both.</p>
<p><code>cargo install</code> 命令允许你在本地安装和使用二进制包。这并不是要取代系统包；它的目的是为 Rust 开发人员提供一种便捷的方式来安装其他人分享在 <a href="https://crates.io/">crates.io</a> 上的工具。请注意，你只能安装具有二进制目标的包。<em>二进制目标</em>（binary target）是可运行的程序，如果包有 <em>src/main.rs</em> 文件或指定为二进制的其他文件，则会创建它，这与库目标（library target）不同，库目标本身不可运行，但适合包含在其他程序中。通常，包在 <em>README</em> 文件中包含有关它是库、具有二进制目标还是两者兼有的信息。</p>
<p>All binaries installed with <code>cargo install</code> are stored in the installation
root’s <em>bin</em> folder. If you installed Rust using <em>rustup.rs</em> and don’t have any
custom configurations, this directory will be <em>$HOME/.cargo/bin</em>. Ensure that
directory is in your <code>$PATH</code> to be able to run programs you’ve installed with
<code>cargo install</code>.</p>
<p>所有用 <code>cargo install</code> 安装的二进制文件都存储在安装根目录的 <em>bin</em> 文件夹中。如果你使用 <em>rustup.rs</em> 安装了 Rust 并且没有任何自定义配置，此目录将是 <em>$HOME/.cargo/bin</em>。确保该目录在你的 <code>$PATH</code> 环境变量中，以便能够运行你用 <code>cargo install</code> 安装的程序。</p>
<p>For example, in Chapter 12 we mentioned that there’s a Rust implementation of
the <code>grep</code> tool called <code>ripgrep</code> for searching files. To install <code>ripgrep</code>, we
can run the following:</p>
<p>例如，在第 12 章中我们提到有一个名为 <code>ripgrep</code> 的 Rust 实现的 <code>grep</code> 工具，用于搜索文件。要安装 <code>ripgrep</code>，我们可以运行以下命令：</p>
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v14.1.1
  Downloaded 1 crate (213.6 KB) in 0.40s
  Installing ripgrep v14.1.1
--snip--
   Compiling grep v0.3.2
    Finished `release` profile [optimized + debuginfo] target(s) in 6.73s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v14.1.1` (executable `rg`)
</code></pre>
<p>The second-to-last line of the output shows the location and the name of the
installed binary, which in the case of <code>ripgrep</code> is <code>rg</code>. As long as the
installation directory is in your <code>$PATH</code>, as mentioned previously, you can
then run <code>rg --help</code> and start using a faster, Rustier tool for searching files!</p>
<p>输出的倒数第二行显示了安装的二进制文件的位置和名称，对于 <code>ripgrep</code> 是 <code>rg</code>。只要安装目录在你的 <code>$PATH</code> 中（如前所述），你就可以运行 <code>rg --help</code> 并开始使用一个更快、更 Rust 化的文件搜索工具了！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extending-cargo-with-custom-commands-使用自定义命令扩展-cargo"><a class="header" href="#extending-cargo-with-custom-commands-使用自定义命令扩展-cargo">Extending Cargo with Custom Commands 使用自定义命令扩展 Cargo</a></h2>
<p>Cargo is designed so you can extend it with new subcommands without having to
modify it. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>, you can run
it as if it were a Cargo subcommand by running <code>cargo something</code>. Custom
commands like this are also listed when you run <code>cargo --list</code>. Being able to
use <code>cargo install</code> to install extensions and then run them just like the
built-in Cargo tools is a super-convenient benefit of Cargo’s design!</p>
<p>Cargo 的设计允许你通过新的子命令来扩展它，而无需修改它本身。如果在你的 <code>$PATH</code> 中有一个名为 <code>cargo-something</code> 的二进制文件，你可以通过运行 <code>cargo something</code> 来运行它，就好像它是 Cargo 的子命令一样。运行 <code>cargo --list</code> 时也会列出此类自定义命令。能够使用 <code>cargo install</code> 安装扩展，然后像运行内置的 Cargo 工具一样运行它们，是 Cargo 设计的一个极其便利的好处！</p>
<h2 id="summary-总结-13"><a class="header" href="#summary-总结-13">Summary 总结</a></h2>
<p>Sharing code with Cargo and <a href="https://crates.io/">crates.io</a> is
part of what makes the Rust ecosystem useful for many different tasks. Rust’s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Don’t be shy about
sharing code that’s useful to you on <a href="https://crates.io/">crates.io</a>; it’s likely that it will be useful to someone else as well!</p>
<p>使用 Cargo 和 <a href="https://crates.io/">crates.io</a> 共享代码是使 Rust 生态系统对许多不同任务都有用的原因之一。Rust 的标准库小而稳定，但包易于共享、使用和改进，其时间线与语言本身不同。不要犹豫将对你来说有用的代码分享到 <a href="https://crates.io/">crates.io</a>；很可能它对其他人也同样有用！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers-智能指针"><a class="header" href="#smart-pointers-智能指针">Smart Pointers 智能指针</a></h1>
<p>A <em>pointer</em> is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the <code>&amp;</code> symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data, and they have no overhead.</p>
<p><strong>指针</strong>是一个通用概念，指代内存中包含地址的变量。该地址指向或“引用”其他数据。Rust 中最常见的指针类型是引用，你在第 4 章已学习过。引用通过 <code>&amp;</code> 符号表示，并借用其指向的值。它们除了引用数据外没有任何特殊功能，也没有额外开销。</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that act like a
pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. Rust has a variety of smart pointers defined in the
standard library that provide functionality beyond that provided by references.
To explore the general concept, we’ll look at a couple of different examples of
smart pointers, including a <em>reference counting</em> smart pointer type. This
pointer enables you to allow data to have multiple owners by keeping track of
the number of owners and, when no owners remain, cleaning up the data.</p>
<p>另一方面，<strong>智能指针</strong>是类似指针的数据结构，但拥有额外的元数据和功能。智能指针的概念并非 Rust 独有：它起源于 C++ 并存在于其他语言中。Rust 标准库中定义了多种智能指针，提供了超出引用范畴的功能。为探索这一通用概念，我们将分析几个不同的智能指针示例，包括<strong>引用计数</strong>智能指针类型。该指针通过记录所有者数量实现数据多所有权机制，当所有者清零时自动清理数据。</p>
<p>Rust, with its concept of ownership and borrowing, has an additional difference
between references and smart pointers: while references only borrow data, in
many cases smart pointers <em>own</em> the data they point to.</p>
<p>Rust 凭借其所有权和借用概念，在引用与智能指针之间还存在另一关键差异：引用仅借用数据，而智能指针通常<strong>拥有</strong>其指向的数据。</p>
<p>Smart pointers are usually implemented using structs. Unlike an ordinary
struct, smart pointers implement the <code>Deref</code> and <code>Drop</code> traits. The <code>Deref</code>
trait allows an instance of the smart pointer struct to behave like a reference
so you can write your code to work with either references or smart pointers.
The <code>Drop</code> trait allows you to customize the code that’s run when an instance
of the smart pointer goes out of scope. In this chapter, we’ll discuss both of
these traits and demonstrate why they’re important to smart pointers.</p>
<p>智能指针通常通过结构体实现。不同于普通结构体，<span class="highlight">[note]智能指针实现了 <code>Deref</code> 和 <code>Drop</code> 特征</span>。<code>Deref</code> 特征允许智能指针结构体实例表现得像引用，从而编写同时兼容引用和智能指针的代码。<code>Drop</code> 特征允许自定义智能指针实例离开作用域时执行的代码。本章我们将探讨这两个特征及其对智能指针的重要性。</p>
<p>Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:</p>
<p>鉴于智能指针模式是 Rust 中常用的通用设计模式，本章不会覆盖所有现有智能指针。许多库提供自定义智能指针，你甚至可以编写自己的实现。我们将重点介绍标准库中最常见的智能指针：</p>
<ul>
<li><code>Box&lt;T&gt;</code>, for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces
the borrowing rules at runtime instead of compile time</li>
<li><code>Box&lt;T&gt;</code>，用于在堆上分配值</li>
<li><code>Rc&lt;T&gt;</code>，支持多重所有权的引用计数类型</li>
<li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问，该类型在运行时而非编译时强制执行借用规则</li>
</ul>
<p>In addition, we’ll cover the <em>interior mutability</em> pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
reference cycles: how they can leak memory and how to prevent them.</p>
<p>此外，我们将探讨<strong>内部可变性</strong>模式（允许不可变类型暴露修改内部值的 API），以及引用循环问题：它们如何导致内存泄漏及如何预防。</p>
<p>Let’s dive in!</p>
<p>让我们开始吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-boxt-to-point-to-data-on-the-heap-使用-boxt-指向堆数据"><a class="header" href="#using-boxt-to-point-to-data-on-the-heap-使用-boxt-指向堆数据">Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap 使用 <code>Box&lt;T&gt;</code> 指向堆数据</a></h2>
<p>The most straightforward smart pointer is a box, whose type is written
<code>Box&lt;T&gt;</code>. <em>Boxes</em> allow you to store data on the heap rather than the stack.
What remains on the stack is the pointer to the heap data. Refer to Chapter 4
to review the difference between the stack and the heap.</p>
<p>最直接的智能指针是 box，其类型写作 <code>Box&lt;T&gt;</code>。<span class="highlight">[note]<strong>Box</strong> 允许你将数据存储在堆而非栈上。</span>栈中保留的是指向堆数据的指针。栈与堆的区别详见第 4 章。</p>
<p>Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:</p>
<p>Box 除了将数据存储在堆上而非栈外，没有性能开销。但它们也没有太多额外功能。你通常会在以下场景使用它们：</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want
to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that
implements a particular trait rather than being of a specific type</li>
<li>当类型在编译时大小未知，但需在要求确切大小的上下文中使用该类型的值时</li>
<li>当需要转移大量数据的所有权但避免复制时</li>
<li>当只想拥有值并仅关心其实现特定特征而非具体类型时</li>
</ul>
<p>We’ll demonstrate the first situation in “Enabling Recursive Types with
Boxes”. In the second
case, transferring ownership of a large amount of data can take a long time
because the data is copied around on the stack. To improve performance in this
situation, we can store the large amount of data on the heap in a box. Then,
only the small amount of pointer data is copied around on the stack, while the
data it references stays in one place on the heap. The third case is known as a
<em>trait object</em>, and “Using Trait Objects That Allow for Values of Different
Types,” in Chapter 18 is devoted to that topic.
So what you learn here you’ll apply again in that section!</p>
<p>我们将在“通过 Box 启用递归类型”中演示第一种情况。在第二种情况下，转移大量数据所有权可能因栈上数据复制而耗时。为提升性能，可将大量数据存储在堆上的 box 中。这样仅需在栈上复制少量指针数据，其引用的数据则稳定驻留堆中。第三种情况称为<strong>特征对象</strong>，第 18 章的“使用允许不同值类型的特征对象”将专门讨论此主题。因此你在此学到的知识将在该部分再次应用！</p>
<h3 id="using-boxt-to-store-data-on-the-heap-使用-boxt-在堆上存储数据"><a class="header" href="#using-boxt-to-store-data-on-the-heap-使用-boxt-在堆上存储数据">Using <code>Box&lt;T&gt;</code> to Store Data on the Heap 使用 <code>Box&lt;T&gt;</code> 在堆上存储数据</a></h3>
<p>Before we discuss the heap storage use case for <code>Box&lt;T&gt;</code>, we’ll cover the
syntax and how to interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>在讨论 <code>Box&lt;T&gt;</code> 的堆存储用例前，我们先了解其语法及如何与存储在 <code>Box&lt;T&gt;</code> 中的值交互。</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap.</p>
<p>代码清单 15-1 展示了使用 box 在堆上存储 <code>i32</code> 值的方法。</p>
<figure class="listing" id="listing-15-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
<figcaption><a href="ch15-01-box.html#listing-15-1">Listing 15-1</a>: Storing an <code>i32</code> value on the heap using a box 使用 box 在堆上存储 <code>i32</code> 值</figcaption>
</figure>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the
value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in
this case, we can access the data in the box similarly to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The
deallocation happens both for the box (stored on the stack) and the data it
points to (stored on the heap).</p>
<p>我们定义变量 <code>b</code> 为指向堆上值 <code>5</code> 的 <code>Box</code>。该程序将打印 <code>b = 5</code>；此时访问 box 中数据的方式与数据在栈上时类似。与任何拥有所有权的值一样，当 box 离开作用域时（如 <code>b</code> 在 <code>main</code> 结尾处），它将被释放。释放同时作用于 box（存储在栈中）及其指向的数据（存储在堆中）。</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single <code>i32</code> on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to define if we didn’t have boxes.</p>
<p>将单个值存入堆实用性有限，因此很少单独这样使用 box。在多数情况下，将如 <code>i32</code> 的默认栈存储值保留在栈上更合适。下面我们通过 box 实现无法直接定义的递归类型。</p>
<h3 id="enabling-recursive-types-with-boxes-通过-box-启用递归类型"><a class="header" href="#enabling-recursive-types-with-boxes-通过-box-启用递归类型">Enabling Recursive Types with Boxes 通过 Box 启用递归类型</a></h3>
<p>A value of a <em>recursive type</em> can have another value of the same type as part of
itself. Recursive types pose an issue because Rust needs to know at compile time
how much space a type takes up. However, the nesting of values of recursive
types could theoretically continue infinitely, so Rust can’t know how much space
the value needs. Because boxes have a known size, we can enable recursive types
by inserting a box in the recursive type definition.</p>
<p><strong>递归类型</strong>的值可将同类型值作为自身组成部分。递归类型会引发问题，因为 Rust 需在编译时确定类型大小。但递归类型的值嵌套理论上可无限延续，导致 Rust 无法确定所需空间大小。由于 box 具有已知大小，我们可在递归类型定义中插入 box 来启用递归类型。</p>
<p>As an example of a recursive type, let’s explore the <em>cons list</em>. This is a data
type commonly found in functional programming languages. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.</p>
<p>以<strong>cons 列表</strong>为例，这是一种函数式编程语言常见的数据类型。我们定义的 cons 列表类型结构简单（递归除外），因此该示例中的概念适用于任何涉及递归类型的复杂场景。</p>
<h4 id="more-information-about-the-cons-list-关于-cons-列表的更多信息"><a class="header" href="#more-information-about-the-cons-list-关于-cons-列表的更多信息">More Information About the Cons List 关于 Cons 列表的更多信息</a></h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects, is made up of nested pairs, and is the Lisp version of a
linked list. Its name comes from the <code>cons</code> function (short for <em>construct
function</em>) in Lisp that constructs a new pair from its two arguments. By
calling <code>cons</code> on a pair consisting of a value and another pair, we can
construct cons lists made up of recursive pairs.</p>
<p><strong>Cons 列表</strong>源自 Lisp 编程语言及其方言，由嵌套对组成，是 Lisp 版的链表。其名源于 Lisp 的 <code>cons</code> 函数（<em>construct function</em> 的缩写），该函数从两个参数构造新对。通过在由值和对组成的对上调用 <code>cons</code>，可构造由递归对组成的 cons 列表。</p>
<p>For example, here’s a pseudocode representation of a cons list containing the
list <code>1, 2, 3</code> with each pair in parentheses:</p>
<p>例如，以下伪代码表示包含列表 <code>1, 2, 3</code> 的 cons 列表，每对用括号表示：</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called <code>Nil</code>
without a next item. A cons list is produced by recursively calling the <code>cons</code>
function. The canonical name to denote the base case of the recursion is <code>Nil</code>.
Note that this is not the same as the “null” or “nil” concept discussed in
Chapter 6, which is an invalid or absent value.</p>
<p>cons 列表中每项包含两个元素：当前项的值和下一项。列表末项仅含值 <code>Nil</code>（无下一项）。cons 列表通过递归调用 <code>cons</code> 函数生成。递归基础情形用 <code>Nil</code> 表示。注意这与第 6 章讨论的“null”或“nil”概念（表示无效或缺失值）不同。</p>
<p>The cons list isn’t a commonly used data structure in Rust. Most of the time
when you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use.
Other, more complex recursive data types <em>are</em> useful in various situations,
but by starting with the cons list in this chapter, we can explore how boxes
let us define a recursive data type without much distraction.</p>
<p>Cons 列表在 Rust 中并不常用。多数情况下 <code>Vec&lt;T&gt;</code> 是更佳选择。但其他更复杂的递归数据类型在某些场景中非常有用。本章通过 cons 列表可清晰展示 box 如何实现递归数据类型定义。</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate.</p>
<p>代码清单 15-2 包含 cons 列表的枚举定义。注意此代码尚不能编译，因为 <code>List</code> 类型大小未知，我们将演示此问题。</p>
<figure class="listing" id="listing-15-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="ch15-01-box.html#listing-15-2">Listing 15-2</a>: The first attempt at defining an enum to represent a cons list data structure of <code>i32</code> values 定义枚举表示 <code>i32</code> 值 cons 列表数据结构的首次尝试</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: We’re implementing a cons list that holds only <code>i32</code> values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.</p>
<p>注意：本例为简化仅实现存储 <code>i32</code> 值的 cons 列表。如第 10 章所述，可通过泛型实现存储任意类型值的 cons 列表。</p>
</section>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in
Listing 15-3.</p>
<p>使用 <code>List</code> 类型存储列表 <code>1, 2, 3</code> 的代码如代码清单 15-3 所示。</p>
<figure class="listing" id="listing-15-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<figcaption><a href="ch15-01-box.html#listing-15-3">Listing 15-3</a>: Using the <code>List</code> enum to store the list <code>1, 2, 3</code> 使用 <code>List</code> 枚举存储列表 <code>1, 2, 3</code></figcaption>
</figure>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>第一个 <code>Cons</code> 值持有 <code>1</code> 和另一个 <code>List</code> 值。该 <code>List</code> 值又是持有 <code>2</code> 和另一个 <code>List</code> 的 <code>Cons</code> 值。此 <code>List</code> 值再是持有 <code>3</code> 和 <code>List</code> 值的 <code>Cons</code>，最终以非递归变体 <code>Nil</code> 结束列表。</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4.</p>
<p>若尝试编译代码清单 15-3，将得到如代码清单 15-4 所示的错误。</p>
<figure class="listing" id="listing-15-4">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<figcaption><a href="ch15-01-box.html#listing-15-4">Listing 15-4</a>: The error we get when attempting to define a recursive enum 尝试定义递归枚举时的错误提示</figcaption>
</figure>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error. First we’ll look at how
Rust decides how much space it needs to store a value of a non-recursive type.</p>
<p>错误显示该类型“具有无限大小”。原因是我们定义的 <code>List</code> 包含递归变体：直接持有自身类型的值。因此 Rust 无法确定存储 <code>List</code> 值所需空间。下面分析错误根源。首先观察 Rust 如何确定非递归类型的大小。</p>
<h4 id="computing-the-size-of-a-non-recursive-type-计算非递归类型的大小"><a class="header" href="#computing-the-size-of-a-non-recursive-type-计算非递归类型的大小">Computing the Size of a Non-Recursive Type 计算非递归类型的大小</a></h4>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<p>回顾第 6 章讨论枚举定义时的代码清单 6-2 中的 <code>Message</code> 枚举：</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>为确定分配 <code>Message</code> 值所需空间，Rust 遍历各变体以找出空间需求最大者。Rust 发现 <code>Message::Quit</code> 无需空间，<code>Message::Move</code> 需存储两个 <code>i32</code> 值的空间，依此类推。因仅使用一个变体，<code>Message</code> 值所需最大空间即其最大变体的空间需求。</p>
<p>Contrast this with what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<p>这与 Rust 尝试确定如代码清单 15-2 中递归类型 <code>List</code> 枚举大小的过程形成对比。编译器从持有 <code>i32</code> 类型值和 <code>List</code> 类型值的 <code>Cons</code> 变体开始分析。因此 <code>Cons</code> 所需空间等于 <code>i32</code> 大小加上 <code>List</code> 大小。为计算 <code>List</code> 类型所需内存，编译器再次检查变体（从 <code>Cons</code> 开始）。<code>Cons</code> 变体持有 <code>i32</code> 类型值和 <code>List</code> 类型值，该过程无限循环，如图 15-1 所示。</p>
<img alt="" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants 由无限 <code>Cons</code> 变体组成的无限 <code>List</code></span></p>
<h4 id="using-boxt-to-get-a-recursive-type-with-a-known-size-使用-boxt-获取已知大小的递归类型"><a class="header" href="#using-boxt-to-get-a-recursive-type-with-a-known-size-使用-boxt-获取已知大小的递归类型">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size 使用 <code>Box&lt;T&gt;</code> 获取已知大小的递归类型</a></h4>
<p>Because Rust can’t figure out how much space to allocate for recursively
defined types, the compiler gives an error with this helpful suggestion:</p>
<p>因 Rust 无法确定递归定义类型的分配空间，编译器给出包含实用建议的错误提示：</p>
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In this suggestion, <em>indirection</em> means that instead of storing a value
directly, we should change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>此建议中，<strong>间接性</strong>指我们应改变数据结构，通过存储指向值的指针而非直接存储值本身。</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists holding other lists, but
this implementation is now more like placing the items next to one another
rather than inside one another.</p>
<p>由于 <code>Box&lt;T&gt;</code> 是指针，Rust 始终知晓其所需空间：指针大小不随指向数据量变化。这意味着可将 <code>Box&lt;T&gt;</code> 放入 <code>Cons</code> 变体替代直接存储另一个 <code>List</code> 值。<code>Box&lt;T&gt;</code> 将指向位于堆（而非 <code>Cons</code> 变体内）的下一个 <code>List</code> 值。概念上我们仍有由列表嵌套构成的列表，但此实现方式更近似于元素并置而非相互嵌套。</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile.</p>
<p>我们将代码清单 15-2 的 <code>List</code> 枚举定义及代码清单 15-3 中的 <code>List</code> 用法修改为代码清单 15-5 的形式，即可成功编译。</p>
<figure class="listing" id="listing-15-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<figcaption><a href="ch15-01-box.html#listing-15-5">Listing 15-5</a>: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in order to have a known size 使用 <code>Box&lt;T&gt;</code> 以确定大小的 <code>List</code> 定义</figcaption>
</figure>
<p>The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the
box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space
on the stack than the <code>Cons</code> variant. We now know that any <code>List</code> value will
take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a
box, we’ve broken the infinite, recursive chain, so the compiler can figure out
the size it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code>
variant looks like now.</p>
<p><code>Cons</code> 变体需要 <code>i32</code> 大小加上 box 指针数据的空间。<code>Nil</code> 变体不存储值，故栈上空间需求小于 <code>Cons</code> 变体。现在可知任何 <code>List</code> 值将占用 <code>i32</code> 大小加上 box 指针数据的空间。通过使用 box，我们打破了无限递归链，编译器得以确定存储 <code>List</code> 值所需大小。图 15-2 展示了当前 <code>Cons</code> 变体的形态。</p>
<img alt="" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized
because <code>Cons</code> holds a <code>Box</code> 非无限大小的 <code>List</code>（因 <code>Cons</code> 持有 <code>Box</code>）</span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have the performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 18.</p>
<p>Box 仅提供间接性和堆分配功能，不具备其他智能指针类型的特殊能力（后续将介绍）。它们也没有这些特殊能力带来的性能开销，因此在仅需间接性的场景（如 cons 列表）中非常实用。第 18 章将介绍更多 box 应用场景。</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. These two traits will be
even more important to the functionality provided by the other smart pointer
types we’ll discuss in the rest of this chapter. Let’s explore these two traits
in more detail.</p>
<p><code>Box&lt;T&gt;</code> 类型因实现 <code>Deref</code> 特征而成为智能指针，该特征允许 <code>Box&lt;T&gt;</code> 值被视作引用。当 <code>Box&lt;T&gt;</code> 值离开作用域时，得益于 <code>Drop</code> 特征实现，其所指的堆数据也会被清理。这两个特征对本章将讨论的其他智能指针功能更为重要。下面我们将深入探讨这两个特征。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="treating-smart-pointers-like-regular-references-with-deref-通过-deref-将智能指针视作常规引用"><a class="header" href="#treating-smart-pointers-like-regular-references-with-deref-通过-deref-将智能指针视作常规引用">Treating Smart Pointers Like Regular References with <code>Deref</code> 通过 <code>Deref</code> 将智能指针视作常规引用</a></h2>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the
<em>dereference operator</em> <code>*</code> (not to be confused with the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.</p>
<p><span class="highlight">[note]实现 <code>Deref</code> 特征可自定义解引用运算符</span> <code>*</code>（区别于乘法或通配符运算符）的行为。通过实现 <code>Deref</code> 使智能指针能像常规引用一样使用，可编写操作引用的代码并使其同时兼容智能指针。</p>
<p>Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for
smart pointers to work in ways similar to references. Then we’ll look at
Rust’s <em>deref coercion</em> feature and how it lets us work with either references
or smart pointers.</p>
<p>首先观察解引用运算符如何与常规引用协作。随后尝试定义行为类似 <code>Box&lt;T&gt;</code> 的自定义类型，探究解引用运算符为何不能像引用一样工作。通过实现 <code>Deref</code> 特征，可使智能指针以类似引用的方式工作。接着探讨 Rust 的<strong>解引用强制转换</strong>特性及其如何实现引用与智能指针的通用编程。</p>
<h3 id="following-the-reference-to-the-value-通过引用追踪值"><a class="header" href="#following-the-reference-to-the-value-通过引用追踪值">Following the Reference to the Value 通过引用追踪值</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the value.</p>
<p>常规引用是一种指针，可将其视为指向存储在其他位置值的箭头。代码清单 15-6 创建了指向 <code>i32</code> 值的引用，并通过解引用运算符追踪引用至值。</p>
<figure class="listing" id="listing-15-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-6">Listing 15-6</a>: Using the dereference operator to follow a reference to an <code>i32</code> value 使用解引用运算符追踪指向 <code>i32</code> 值的引用</figcaption>
</figure>
<p>The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>) so the compiler can compare
the actual value. Once we dereference <code>y</code>, we have access to the integer value
<code>y</code> is pointing to that we can compare with <code>5</code>.</p>
<p>变量 <code>x</code> 持有 <code>i32</code> 值 <code>5</code>。设 <code>y</code> 为指向 <code>x</code> 的引用。可断言 <code>x</code> 等于 <code>5</code>。但若要对 <code>y</code> 的值断言，需使用 <code>*y</code> 追踪引用至其指向的值（即<strong>解引用</strong>），编译器才能比较实际值。解引用 <code>y</code> 后，即可访问 <code>y</code> 指向的整数值并与 <code>5</code> 比较。</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<p>若尝试写 <code>assert_eq!(5, y);</code> 替代，将得到编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.</p>
<p><span class="highlight">[note]比较数字和数字引用因类型不同被禁止</span>。必须使用解引用运算符追踪引用至其指向的值。</p>
<h3 id="using-boxt-like-a-reference-像引用一样使用-boxt"><a class="header" href="#using-boxt-like-a-reference-像引用一样使用-boxt">Using <code>Box&lt;T&gt;</code> Like a Reference 像引用一样使用 <code>Box&lt;T&gt;</code></a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7
functions in the same way as the dereference operator used on the reference in
Listing 15-6.</p>
<p>我们可重写代码清单 15-6，用 <code>Box&lt;T&gt;</code> 替代引用。代码清单 15-7 中对 <code>Box&lt;T&gt;</code> 使用的解引用运算符与代码清单 15-6 中引用的用法功能相同。</p>
<figure class="listing" id="listing-15-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-7">Listing 15-7</a>: Using the dereference operator on a <code>Box&lt;i32&gt;</code> 在 <code>Box&lt;i32&gt;</code> 上使用解引用运算符</figcaption>
</figure>
<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to a copied value of <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<p>代码清单 15-7 与 15-6 的主要区别在于，此处设 <code>y</code> 为指向 <code>x</code> 值副本的 box 实例，而非指向 <code>x</code> 值的引用。在最后的断言中，我们可像 <code>y</code> 为引用时一样使用解引用运算符追踪 box 的指针。接下来，我们将通过自定义 box 类型探究 <code>Box&lt;T&gt;</code> 的特殊之处。</p>
<h3 id="defining-our-own-smart-pointer-自定义智能指针"><a class="header" href="#defining-our-own-smart-pointer-自定义智能指针">Defining Our Own Smart Pointer 自定义智能指针</a></h3>
<p>Let’s build a wrapper type similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointer types behave differently from
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>我们构建一个与标准库提供的 <code>Box&lt;T&gt;</code> 类型类似的封装类型，体验智能指针类型与引用的默认行为差异。随后学习如何添加解引用运算符支持。</p>
<section class="note" aria-role="note">
<p>Note: There’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to
build and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap.
We are focusing this example on <code>Deref</code>, so where the data is actually stored
is less important than the pointer-like behavior.</p>
<p>注意：我们将构建的 <code>MyBox&lt;T&gt;</code> 类型与真正的 <code>Box&lt;T&gt;</code> 存在重大差异：我们的版本不将数据存储在堆上。本例聚焦于 <code>Deref</code>，因此数据实际存储位置不如类指针行为重要。</p>
</section>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<p><code>Box&lt;T&gt;</code> 类型本质上是含单个元素的元组结构体，故代码清单 15-8 以相同方式定义 <code>MyBox&lt;T&gt;</code> 类型。同时定义匹配 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函数。</p>
<figure class="listing" id="listing-15-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-8">Listing 15-8</a>: Defining a <code>MyBox&lt;T&gt;</code> type 定义 <code>MyBox&lt;T&gt;</code> 类型</figcaption>
</figure>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code> because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>定义名为 <code>MyBox</code> 的结构体并声明泛型参数 <code>T</code>，以使类型能容纳任意类型的值。<code>MyBox</code> 类型是含单个 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数接收一个 <code>T</code> 类型参数，返回持有传入值的 <code>MyBox</code> 实例。</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>.</p>
<p>尝试将代码清单 15-7 的 <code>main</code> 函数加入代码清单 15-8，并修改为使用刚定义的 <code>MyBox&lt;T&gt;</code> 类型替代 <code>Box&lt;T&gt;</code>。代码清单 15-9 无法编译，因为 Rust 不知如何解引用 <code>MyBox</code>。</p>
<figure class="listing" id="listing-15-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-9">Listing 15-9</a>: Attempting to use <code>MyBox&lt;T&gt;</code> in the same way we used references and <code>Box&lt;T&gt;</code> 尝试以使用引用和 <code>Box&lt;T&gt;</code> 的相同方式使用 <code>MyBox&lt;T&gt;</code></figcaption>
</figure>
<p>Here’s the resultant compilation error:</p>
<p>编译错误如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<p><code>MyBox&lt;T&gt;</code> 类型因未实现解引用能力而无法解引用。为实现 <code>*</code> 运算符的解引用功能，需实现 <code>Deref</code> 特征。</p>
<h3 id="implementing-the-deref-trait-实现-deref-特征"><a class="header" href="#implementing-the-deref-trait-实现-deref-特征">Implementing the <code>Deref</code> Trait 实现 <code>Deref</code> 特征</a></h3>
<p>As discussed in “Implementing a Trait on a Type” in
Chapter 10, to implement a trait we need to provide implementations for the
trait’s required methods. The <code>Deref</code> trait, provided by the standard library,
requires us to implement one method named <code>deref</code> that borrows <code>self</code> and
returns a reference to the inner data. Listing 15-10 contains an implementation
of <code>Deref</code> to add to the definition of <code>MyBox&lt;T&gt;</code>.</p>
<p>如第 10 章<a href="ch15-02-deref.html#implementing-a-trait-on-a-type">“为类型实现特征”</a>所述，实现特征需提供特征必需方法的实现。标准库提供的 <code>Deref</code> 特征要求实现名为 <code>deref</code> 的方法：该方法借用 <code>self</code> 并返回内部数据的引用。代码清单 15-10 展示了添加到 <code>MyBox&lt;T&gt;</code> 定义的 <code>Deref</code> 实现。</p>
<figure class="listing" id="listing-15-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-10">Listing 15-10</a>: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code> 在 <code>MyBox&lt;T&gt;</code> 上实现 <code>Deref</code></figcaption>
</figure>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code>
trait to use. Associated types are a slightly different way of declaring a
generic parameter, but you don’t need to worry about them for now; we’ll cover
them in more detail in Chapter 20.</p>
<p><code>type Target = T;</code> 语法为 <code>Deref</code> 特征定义关联类型。关联类型是声明泛型参数的稍异方式，此处无需深究；第 20 章将详细讨论。</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator; recall from
“Using Tuple Structs Without Named Fields to Create Different
Types” in Chapter 5 that <code>.0</code> accesses the first
value in a tuple struct. The <code>main</code> function in Listing 15-9 that calls <code>*</code> on
the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>
<p><code>deref</code> 方法体填入 <code>&amp;self.0</code> 使其返回需通过 <code>*</code> 运算符访问值的引用；回顾第 5 章“使用无名字段元组结构体创建不同类型”，<code>.0</code> 访问元组结构体的首元素。现在代码清单 15-9 中调用 <code>MyBox&lt;T&gt;</code> 值 <code>*</code> 的 <code>main</code> 函数可编译，断言通过！</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get an <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>若无 <code>Deref</code> 特征，编译器仅能解引用 <code>&amp;</code> 引用。<code>deref</code> 方法赋予编译器能力：对任何实现 <code>Deref</code> 类型的值调用 <code>deref</code> 方法，获取其知晓如何解引用的 <code>&amp;</code> 引用。</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<p>在代码清单 15-9 中<span class="highlight">[note]输入 <code>*y</code> 时，Rust 底层实际执行：</span></p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so we don’t have to think about whether or not we need to
call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>Rust 将 <code>*</code> 运算符替换为 <code>deref</code> 方法调用及普通解引用，因此我们无需考虑是否需调用 <code>deref</code> 方法。此 Rust 特性让我们编写的代码无论使用常规引用还是实现 <code>Deref</code> 的类型均表现一致。</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the
plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary,
has to do with the ownership system. If the <code>deref</code> method returned the value
directly instead of a reference to the value, the value would be moved out of
<code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in
this case or in most cases where we use the dereference operator.</p>
<p><span class="highlight">[note]<code>deref</code> 方法返回值的引用，且 <code>*(y.deref())</code> 外层的普通解引用仍必要的原因与所有权系统相关。若 <code>deref</code> 方法直接返回值而非其引用，值将从 <code>self</code> 移出。</span>在此场景（及多数使用解引用运算符的场景）中，我们无意获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<p><span class="highlight">[note]注意 <code>*</code> 运算符仅被替换为一次 <code>deref</code> 方法调用及一次 <code>*</code> 运算符调用。因 <code>*</code> 运算符替换不会无限递归</span>，最终我们得到与代码清单 15-9 中 <code>assert_eq!</code> 的 <code>5</code> 匹配的 <code>i32</code> 类型数据。</p>
<h3 id="implicit-deref-coercions-with-functions-and-methods-函数和方法的隐式解引用强制转换"><a class="header" href="#implicit-deref-coercions-with-functions-and-methods-函数和方法的隐式解引用强制转换">Implicit Deref Coercions with Functions and Methods 函数和方法的隐式解引用强制转换</a></h3>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code>
trait into a reference to another type. For example, deref coercion can convert
<code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it
returns <code>&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to
functions and methods, and works only on types that implement the <code>Deref</code>
trait. It happens automatically when we pass a reference to a particular type’s
value as an argument to a function or method that doesn’t match the parameter
type in the function or method definition. A sequence of calls to the <code>deref</code>
method converts the type we provided into the type the parameter needs.</p>
<p><strong>解引用强制转换</strong>将实现了 <code>Deref</code> 特征的类型的引用转换为另一种类型的引用。例如，<span class="highlight">[note]解引用强制转换可将 <code>&amp;String</code> 转为 <code>&amp;str</code>，因 <code>String</code> 实现了返回 <code>&amp;str</code> 的 <code>Deref</code> 特征。</span>解引用强制转换是 Rust 为函数和方法参数提供的便利机制，且仅适用于实现 <code>Deref</code> 特征的类型。<span class="highlight">[note]当我们将特定类型值的引用传递给与函数或方法定义中形参类型不匹配的实参时，该转换自动发生。一系列 <code>deref</code> 方法调用将我们提供的类型转换为形参所需类型。</span></p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>Rust 引入解引用强制转换后，编写函数和方法调用时无需大量显式添加 <code>&amp;</code> 和 <code>*</code> 引用及解引用。该特性还让我们编写的代码可同时兼容引用和智能指针。</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter.</p>
<p>为观察解引用强制转换的实际效果，我们使用代码清单 15-8 定义的 <code>MyBox&lt;T&gt;</code> 类型及代码清单 15-10 添加的 <code>Deref</code> 实现。代码清单 15-11 展示了含字符串切片形参的函数定义。</p>
<figure class="listing" id="listing-15-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-11">Listing 15-11</a>: A <code>hello</code> function that has the parameter <code>name</code> of type <code>&amp;str</code> 含 <code>&amp;str</code> 类型形参 <code>name</code> 的 <code>hello</code> 函数</figcaption>
</figure>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello("Rust");</code>, for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12.</p>
<p>我们可用字符串切片调用 <code>hello</code> 函数，如 <code>hello("Rust");</code>。解引用强制转换使得用 <code>MyBox&lt;String&gt;</code> 类型值的引用调用 <code>hello</code> 成为可能，如代码清单 15-12 所示。</p>
<figure class="listing" id="listing-15-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-12">Listing 15-12</a>: Calling <code>hello</code> with a reference to a <code>MyBox&lt;String&gt;</code> value, which works because of deref coercion 通过解引用强制转换实现对 <code>MyBox&lt;String&gt;</code> 值引用调用 <code>hello</code></figcaption>
</figure>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, and this is in the API documentation
for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>此处我们以 <code>&amp;m</code> 为参数调用 <code>hello</code> 函数，这是指向 <code>MyBox&lt;String&gt;</code> 值的引用。因我们在代码清单 15-10 中为 <code>MyBox&lt;T&gt;</code> 实现了 <code>Deref</code> 特征，Rust 可通过调用 <code>deref</code> 将 <code>&amp;MyBox&lt;String&gt;</code> 转为 <code>&amp;String</code>。标准库为 <code>String</code> 提供了返回字符串切片的 <code>Deref</code> 实现（见 API 文档）。Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 转为 <code>&amp;str</code>，从而匹配 <code>hello</code> 函数的定义。</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p>若 Rust 未实现解引用强制转换，则需编写代码清单 15-13 的代码（替代代码清单 15-12）以实现对 <code>&amp;MyBox&lt;String&gt;</code> 类型值的 <code>hello</code> 调用。</p>
<figure class="listing" id="listing-15-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
<figcaption><a href="ch15-02-deref.html#listing-15-13">Listing 15-13</a>: The code we would have to write if Rust didn’t have deref coercion 若 Rust 无解引用强制转换需编写的代码</figcaption>
</figure>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. This code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。随后 <code>&amp;</code> 和 <code>[..]</code> 获取整个 <code>String</code> 的字符串切片以匹配 <code>hello</code> 的签名。无解引用强制转换的代码因涉及符号而更难读写理解。解引用强制转换让 Rust 自动处理这些转换。</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<p>当为相关类型定义 <code>Deref</code> 特征后，Rust 会分析类型并视需要多次调用 <code>Deref::deref</code> 以获取匹配形参类型的引用。<code>Deref::deref</code> 的插入次数在编译时解析，因此利用解引用强制转换无运行时开销！</p>
<h3 id="how-deref-coercion-interacts-with-mutability-解引用强制转换如何与可变性交互"><a class="header" href="#how-deref-coercion-interacts-with-mutability-解引用强制转换如何与可变性交互">How Deref Coercion Interacts with Mutability 解引用强制转换如何与可变性交互</a></h3>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on
immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>
operator on mutable references.</p>
<p>类似于使用 <code>Deref</code> 特征覆盖不可变引用的 <code>*</code> 运算符，<span class="highlight">[note]可用 <code>DerefMut</code> 特征覆盖可变引用的 <code>*</code> 运算符</span>。</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<p><span class="highlight">[note]Rust 在以下三种情况中执行解引用强制转换：</span></p>
<ol>
<li>
<p>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></p>
</li>
<li>
<p>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></p>
</li>
<li>
<p>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;T</code> 到 <code>&amp;U</code></p>
</li>
<li>
<p>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code></p>
</li>
<li>
<p>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;U</code></p>
</li>
</ol>
<p>The first two cases are the same except that the second implements mutability.
The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to
some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The second case states that the
same deref coercion happens for mutable references.</p>
<p>前两种情况除可变性外相同。第一种表明若存在 <code>&amp;T</code> 且 <code>T</code> 实现了到某类型 <code>U</code> 的 <code>Deref</code>，则可透明获得 <code>&amp;U</code>。第二种表明相同解引用强制转换适用于可变引用。</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules don’t guarantee that. Therefore, Rust can’t make the
assumption that converting an immutable reference to a mutable reference is
possible.</p>
<p>第三种情况更微妙：Rust 也会将可变引用强制转换为不可变引用。但反之则<strong>不成立</strong>：不可变引用永远不会强制转换为可变引用。根据借用规则，若持有可变引用，该引用必须是数据的唯一引用（否则程序无法编译）。<span class="highlight">[note]将可变引用转为不可变引用永不违反借用规则。</span>而将不可变引用转为可变引用则要求初始不可变引用是该数据的唯一不可变引用，但借用规则无法保证此点。因此 Rust 无法假设不可变引用到可变引用的转换成立。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-code-on-cleanup-with-the-drop-trait-使用-drop-trait-在清理时运行代码"><a class="header" href="#running-code-on-cleanup-with-the-drop-trait-使用-drop-trait-在清理时运行代码">Running Code on Cleanup with the <code>Drop</code> Trait 使用 <code>Drop</code> Trait 在清理时运行代码</a></h2>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the <code>Drop</code> trait on any type, and that code can
be used to release resources like files or network connections.</p>
<p>智能指针模式中第二个重要的 trait 是 <code>Drop</code>，它允许你自定义值即将离开作用域时发生的行为。你可以为任何类型提供 <code>Drop</code> trait 的实现，这些代码可用于释放文件或网络连接等资源。</p>
<p>We’re introducing <code>Drop</code> in the context of smart pointers because the
functionality of the <code>Drop</code> trait is almost always used when implementing a
smart pointer. For example, when a <code>Box&lt;T&gt;</code> is dropped it will deallocate the
space on the heap that the box points to.</p>
<p>我们在智能指针的上下文中介绍 <code>Drop</code>，因为在实现智能指针时几乎总是会用到 <code>Drop</code> trait 的功能。例如，当 <code>Box&lt;T&gt;</code> 被丢弃时，它会释放该 box 所指向的堆上空间。</p>
<p>In some languages, for some types, the programmer must call code to free memory
or resources every time they finish using an instance of those types. Examples
include file handles, sockets, and locks. If they forget, the system might
become overloaded and crash. In Rust, you can specify that a particular bit of
code be run whenever a value goes out of scope, and the compiler will insert
this code automatically. As a result, you don’t need to be careful about
placing cleanup code everywhere in a program that an instance of a particular
type is finished with—you still won’t leak resources!</p>
<p>在某些语言中，对于某些类型，程序员每次使用完这些类型的实例后都必须调用代码来释放内存或资源。例如文件句柄、套接字和锁。如果他们忘记了，系统可能会过载并崩溃。在 Rust 中，你可以指定每当值离开作用域时运行特定代码，编译器会自动插入此代码。因此，你无需小心地在程序中使用完特定类型实例的每个地方放置清理代码——你仍然不会泄漏资源！</p>
<p>You specify the code to run when a value goes out of scope by implementing the
<code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named
<code>drop</code> that takes a mutable reference to <code>self</code>. To see when Rust calls <code>drop</code>,
let’s implement <code>drop</code> with <code>println!</code> statements for now.</p>
<p>通过实现 <code>Drop</code> trait 来指定值离开作用域时要运行的代码。<code>Drop</code> trait 要求你实现一个名为 <code>drop</code> 的方法，该方法接受一个对 <code>self</code> 的可变引用。为了观察 Rust 何时调用 <code>drop</code>，我们暂时用 <code>println!</code> 语句来实现 <code>drop</code>。</p>
<p>Listing 15-14 shows a <code>CustomSmartPointer</code> struct whose only custom
functionality is that it will print <code>Dropping CustomSmartPointer!</code> when the
instance goes out of scope, to show when Rust runs the <code>drop</code> method.</p>
<p>代码清单 15-14 展示了一个 <code>CustomSmartPointer</code> 结构体，其唯一自定义功能是当实例离开作用域时会打印 <code>Dropping CustomSmartPointer!</code>，以展示 Rust 何时运行 <code>drop</code> 方法。</p>
<figure class="listing" id="listing-15-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre></pre>
<figcaption><a href="ch15-03-drop.html#listing-15-14">Listing 15-14</a>: A <code>CustomSmartPointer</code> struct that implements the <code>Drop</code> trait where we would put our cleanup code 实现了 <code>Drop</code> trait 的 <code>CustomSmartPointer</code> 结构体，我们将在此处放入清理代码</figcaption>
</figure>
<p>The <code>Drop</code> trait is included in the prelude, so we don’t need to bring it into
scope. We implement the <code>Drop</code> trait on <code>CustomSmartPointer</code> and provide an
implementation for the <code>drop</code> method that calls <code>println!</code>. The body of the
<code>drop</code> method is where you would place any logic that you wanted to run when an
instance of your type goes out of scope. We’re printing some text here to
demonstrate visually when Rust will call <code>drop</code>.</p>
<p><code>Drop</code> trait 已包含在预导入中，因此我们无需手动引入作用域。我们在 <code>CustomSmartPointer</code> 上实现 <code>Drop</code> trait，并为 <code>drop</code> 方法提供一个调用 <code>println!</code> 的实现。<code>drop</code> 方法的主体是你希望在该类型实例离开作用域时运行的任何逻辑。我们在此处打印文本，以便直观地展示 Rust 何时调用 <code>drop</code>。</p>
<p>In <code>main</code>, we create two instances of <code>CustomSmartPointer</code> and then print
<code>CustomSmartPointers created</code>. At the end of <code>main</code>, our instances of
<code>CustomSmartPointer</code> will go out of scope, and Rust will call the code we put
in the <code>drop</code> method, printing our final message. Note that we didn’t need to
call the <code>drop</code> method explicitly.</p>
<p>在 <code>main</code> 中，我们创建两个 <code>CustomSmartPointer</code> 实例，然后打印 <code>CustomSmartPointers created</code>。在 <code>main</code> 结束时，我们的 <code>CustomSmartPointer</code> 实例将离开作用域，Rust 将调用我们放入 <code>drop</code> 方法的代码，打印最终消息。注意，我们不需要显式调用 <code>drop</code> 方法。</p>
<p>When we run this program, we’ll see the following output:</p>
<p>运行此程序时，我们将看到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatically called <code>drop</code> for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so <code>d</code> was dropped before <code>c</code>. This example’s purpose is to
give you a visual guide to how the <code>drop</code> method works; usually you would
specify the cleanup code that your type needs to run rather than a print
message.</p>
<p>当实例离开作用域时，Rust 自动为我们调用了 <code>drop</code>，执行了我们指定的代码。变量以与创建顺序相反的顺序被丢弃，因此 <code>d</code> 在 <code>c</code> 之前被丢弃。此示例旨在直观展示 <code>drop</code> 方法的工作原理；通常你会指定类型需要运行的清理代码，而不是打印消息。</p>
<p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code>
functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the
<code>Drop</code> trait is that it’s taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the <code>drop</code> method that
releases the lock so that other code in the same scope can acquire the lock.
Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead,
you have to call the <code>std::mem::drop</code> function provided by the standard library
if you want to force a value to be dropped before the end of its scope.</p>
<p>不幸的是，禁用自动 <code>drop</code> 功能并不简单。通常不需要禁用 <code>drop</code>；<code>Drop</code> trait 的核心意义就在于它会自动处理。然而，偶尔你可能希望提前清理值。例如使用管理锁的智能指针时：你可能希望强制调用释放锁的 <code>drop</code> 方法，以便同一作用域中的其他代码可以获取锁。<span class="highlight">[note]Rust 不允许你手动调用 <code>Drop</code> trait 的 <code>drop</code> 方法；相反，如果你想在作用域结束前强制丢弃值，必须调用标准库提供的 <code>std::mem::drop</code> 函数。</span></p>
<p>If we try to call the <code>Drop</code> trait’s <code>drop</code> method manually by modifying the
<code>main</code> function from Listing 15-14, as shown in Listing 15-15, we’ll get a
compiler error.</p>
<p>如果我们尝试通过修改代码清单 15-14 中的 <code>main</code> 函数来手动调用 <code>Drop</code> trait 的 <code>drop</code> 方法，如代码清单 15-15 所示，我们将得到编译器错误。</p>
<figure class="listing" id="listing-15-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre>
<figcaption><a href="ch15-03-drop.html#listing-15-15">Listing 15-15</a>: Attempting to call the <code>drop</code> method from the <code>Drop</code> trait manually to clean up early 尝试手动调用 <code>Drop</code> trait 的 <code>drop</code> 方法以提前清理</figcaption>
</figure>
<p>When we try to compile this code, we’ll get this error:</p>
<p>尝试编译此代码时，我们将得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>This error message states that we’re not allowed to explicitly call <code>drop</code>. The
error message uses the term <em>destructor</em>, which is the general programming term
for a function that cleans up an instance. A <em>destructor</em> is analogous to a
<em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one
particular destructor.</p>
<p>此错误消息指出不允许显式调用 <code>drop</code>。错误消息使用了术语<strong>析构函数</strong>（destructor），这是清理实例的通用编程术语。<strong>析构函数</strong>类似于创建实例的<strong>构造函数</strong>。Rust 中的 <code>drop</code> 函数就是一种特定的析构函数。</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still
automatically call <code>drop</code> on the value at the end of <code>main</code>. This would cause a
<em>double free</em> error because Rust would be trying to clean up the same value
twice.</p>
<p><span class="highlight">[note]Rust 不允许显式调用 <code>drop</code>，因为它仍会在 <code>main</code> 结束时自动对该值调用 <code>drop</code>。这将导致<strong>双重释放</strong>错误，因为 Rust 会尝试清理同一个值两次。</span></p>
<p>We can’t disable the automatic insertion of <code>drop</code> when a value goes out of
scope, and we can’t call the <code>drop</code> method explicitly. So, if we need to force
a value to be cleaned up early, we use the <code>std::mem::drop</code> function.</p>
<p>当值离开作用域时，我们无法禁用自动插入的 <code>drop</code>，也无法显式调用 <code>drop</code> 方法。因此，如果需要<span class="highlight">[note]强制提前清理值，我们使用 <code>std::mem::drop</code> 函数</span>。</p>
<p>The <code>std::mem::drop</code> function is different from the <code>drop</code> method in the <code>Drop</code>
trait. We call it by passing as an argument the value we want to force-drop.
The function is in the prelude, so we can modify <code>main</code> in Listing 15-15 to
call the <code>drop</code> function, as shown in Listing 15-16.</p>
<p><code>std::mem::drop</code> 函数与 <code>Drop</code> trait 中的 <code>drop</code> 方法不同。我们通过将要强制丢弃的值作为参数传递来调用它。<span class="highlight">[note]此函数位于预导入中</span>，因此我们可以修改代码清单 15-15 中的 <code>main</code> 来调用 <code>drop</code> 函数，如代码清单 15-16 所示。</p>
<figure class="listing" id="listing-15-16">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre></pre>
<figcaption><a href="ch15-03-drop.html#listing-15-16">Listing 15-16</a>: Calling <code>std::mem::drop</code> to explicitly drop a value before it goes out of scope 调用 <code>std::mem::drop</code> 在值离开作用域前显式丢弃它</figcaption>
</figure>
<p>Running this code will print the following:</p>
<p>运行此代码将打印以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>The text <code>Dropping CustomSmartPointer with data `some data`!</code> is printed
between the <code>CustomSmartPointer created.</code> and <code>CustomSmartPointer dropped  before the end of main.</code> text, showing that the <code>drop</code> method code is called to
drop <code>c</code> at that point.</p>
<p>文本 <code>Dropping CustomSmartPointer with data `some data`!</code> 在 <code>CustomSmartPointer created.</code> 和 <code>CustomSmartPointer dropped before the end of main.</code> 文本之间打印，表明此时调用了 <code>drop</code> 方法丢弃了 <code>c</code>。</p>
<p>You can use code specified in a <code>Drop</code> trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the <code>Drop</code> trait and Rust’s ownership system, you
don’t have to remember to clean up because Rust does it automatically.</p>
<p>你可以通过多种方式使用 <code>Drop</code> trait 实现中指定的代码，使清理工作便捷且安全：例如，你可以用它创建自己的内存分配器！借助 <code>Drop</code> trait 和 Rust 的所有权系统，你无需记住清理工作，因为 Rust 会自动处理。</p>
<p>You also don’t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that <code>drop</code> gets called only once when
the value is no longer being used.</p>
<p>你也不必担心意外清理仍在使用的值所导致的问题：确保引用始终有效的所有权系统也确保仅在值不再使用时调用 <code>drop</code> 一次。</p>
<p>Now that we’ve examined <code>Box&lt;T&gt;</code> and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.</p>
<p>现在我们已经研究了 <code>Box&lt;T&gt;</code> 和智能指针的一些特性，接下来看看标准库中定义的其他几种智能指针。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-the-reference-counted-smart-pointer-rct引用计数智能指针"><a class="header" href="#rct-the-reference-counted-smart-pointer-rct引用计数智能指针"><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer <code>Rc&lt;T&gt;</code>，引用计数智能指针</a></h2>
<p>In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it and so has no owners.</p>
<p>在大多数情况下，所有权是明确的：你确切知道哪个变量拥有给定值。然而，有时单个值可能有多个所有者。例如在图数据结构中，多条边可能指向同一个节点，从概念上讲，该节点由指向它的所有边共同拥有。节点不应被清理，除非没有任何边指向它，即没有所有者。</p>
<p>You have to enable multiple ownership explicitly by using the Rust type
<code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type
keeps track of the number of references to a value to determine whether or not
the value is still in use. If there are zero references to a value, the value
can be cleaned up without any references becoming invalid.</p>
<p>你必须<span class="highlight">[note]使用 Rust 类型 <code>Rc&lt;T&gt;</code> 显式启用多重所有权，它是<strong>引用计数</strong>（reference counting）的缩写。</span><code>Rc&lt;T&gt;</code> 类型跟踪对值的引用数量，以确定该值是否仍在使用中。如果对值的引用为零，则可以在不使任何引用无效的情况下清理该值。</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
an uproar from the remaining TV watchers!</p>
<p>想象 <code>Rc&lt;T&gt;</code> 是家庭房间中的电视。当一个人进来看电视时，他们会打开它。其他人可以进入房间看电视。当最后一个人离开房间时，他们会关闭电视，因为它不再被使用。如果有人在其他人还在看电视时关闭电视，其他观看者会表示不满！</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.</p>
<p>当我们在堆上分配数据供程序的多个部分读取，并且无法在编译时确定哪部分最后使用数据时，我们会使用 <code>Rc&lt;T&gt;</code> 类型。如果知道哪部分最后完成，我们可以直接将该部分作为数据的所有者，并在编译时强制执行常规所有权规则。</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.</p>
<p>注意 <code>Rc&lt;T&gt;</code> 仅适用于单线程场景。在第 16 章讨论并发时，我们将介绍如何在多线程程序中进行引用计数。</p>
<h3 id="using-rct-to-share-data-使用-rct-共享数据"><a class="header" href="#using-rct-to-share-data-使用-rct-共享数据">Using <code>Rc&lt;T&gt;</code> to Share Data 使用 <code>Rc&lt;T&gt;</code> 共享数据</a></h3>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3.</p>
<p>让我们回到代码清单 15-5 中的 cons 列表示例。回想一下，我们使用 <code>Box&lt;T&gt;</code> 定义了它。这次，我们将创建两个列表，它们共同拥有第三个列表的所有权。从概念上讲，这类似于图 15-3。</p>
<img alt="" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code> 两个列表 <code>b</code> 和 <code>c</code> 共享对第三个列表 <code>a</code> 的所有权</span></p>
<p>We’ll create list <code>a</code> that contains <code>5</code> and then <code>10</code>. Then we’ll make two more
lists: <code>b</code> that starts with <code>3</code> and <code>c</code> that starts with <code>4</code>. Both <code>b</code> and <code>c</code>
lists will then continue on to the first <code>a</code> list containing <code>5</code> and <code>10</code>. In
other words, both lists will share the first list containing <code>5</code> and <code>10</code>.</p>
<p>我们将创建一个包含 <code>5</code> 和 <code>10</code> 的列表 <code>a</code>。然后创建另外两个列表：以 <code>3</code> 开头的 <code>b</code> 和以 <code>4</code> 开头的 <code>c</code>。然后 <code>b</code> 和 <code>c</code> 列表都将延续到包含 <code>5</code> 和 <code>10</code> 的第一个 <code>a</code> 列表。换句话说，两个列表将共享包含 <code>5</code> 和 <code>10</code> 的第一个列表。</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17.</p>
<p>尝试使用带 <code>Box&lt;T&gt;</code> 的 <code>List</code> 定义实现此场景是行不通的，如代码清单 15-17 所示。</p>
<figure class="listing" id="listing-15-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<figcaption><a href="ch15-04-rc.html#listing-15-17">Listing 15-17</a>: Demonstrating that we’re not allowed to have two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list 演示不允许两个使用 <code>Box&lt;T&gt;</code> 的列表尝试共享对第三个列表的所有权</figcaption>
</figure>
<p>When we compile this code, we get this error:</p>
<p>编译此代码时，我们得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p><code>Cons</code> 变体拥有它们持有的数据，因此当我们创建 <code>b</code> 列表时，<code>a</code> 被移动到 <code>b</code> 中，<code>b</code> 拥有 <code>a</code>。然后，当我们在创建 <code>c</code> 时尝试再次使用 <code>a</code>，这是不允许的，因为 <code>a</code> 已被移动。</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. This is the case for the elements and lists
in Listing 15-17, but not in every scenario.</p>
<p>我们可以将 <code>Cons</code> 的定义更改为持有引用，但这样就必须指定生命周期参数。通过指定生命周期参数，我们要求列表中的每个元素至少与整个列表一样长。这在代码清单 15-17 的元素和列表中成立，但并非所有场景都如此。</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby
increasing the number of references from one to two and letting <code>a</code> and <code>b</code>
share ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when
creating <code>c</code>, increasing the number of references from two to three. Every time
we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it.</p>
<p>相反，我们将 <code>List</code> 的定义更改为使用 <code>Rc&lt;T&gt;</code> 替代 <code>Box&lt;T&gt;</code>，如代码清单 15-18 所示。每个 <code>Cons</code> 变体现将持有一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。创建 <code>b</code> 时，我们不取得 <code>a</code> 的所有权，而是克隆 <code>a</code> 持有的 <code>Rc&lt;List&gt;</code>，从而将引用计数从 1 增加到 2，让 <code>a</code> 和 <code>b</code> 共享该 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也克隆 <code>a</code>，将引用计数从 2 增加到 3。<span class="highlight">[note]每次调用 <code>Rc::clone</code> 时，<code>Rc&lt;List&gt;</code> 内部数据的引用计数会增加</span>，除非引用计数为零，否则数据不会被清理。</p>
<figure class="listing" id="listing-15-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<figcaption><a href="ch15-04-rc.html#listing-15-18">Listing 15-18</a>: A definition of <code>List</code> that uses <code>Rc&lt;T&gt;</code> 使用 <code>Rc&lt;T&gt;</code> 的 <code>List</code> 定义</figcaption>
</figure>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding <code>5</code> and <code>10</code> and store it
in a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then, when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>我们需要添加 <code>use</code> 语句将 <code>Rc&lt;T&gt;</code> 引入作用域，因为它不在预导入中。在 <code>main</code> 中，我们创建包含 <code>5</code> 和 <code>10</code> 的列表，并将其存储在 <code>a</code> 中的新 <code>Rc&lt;List&gt;</code> 中。然后，创建 <code>b</code> 和 <code>c</code> 时，我们调用 <code>Rc::clone</code> 函数并将 <code>a</code> 中的 <code>Rc&lt;List&gt;</code> 引用作为参数传递。</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<p><span class="highlight">[note]我们本可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，但 Rust 的惯例是在这种情况下使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的实现不像大多数类型的 <code>clone</code> 实现那样深度复制所有数据。</span>调用 <code>Rc::clone</code> 仅增加引用计数，这不需要太多时间。数据的深度复制可能非常耗时。通过使用 <code>Rc::clone</code> 进行引用计数，我们可以直观区分深度复制的克隆和增加引用计数的克隆。在代码中查找性能问题时，我们只需考虑深度复制的克隆，而忽略对 <code>Rc::clone</code> 的调用。</p>
<h3 id="cloning-an-rct-increases-the-reference-count-克隆-rct-会增加引用计数"><a class="header" href="#cloning-an-rct-increases-the-reference-count-克隆-rct-会增加引用计数">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count 克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</a></h3>
<p>Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>让我们修改代码清单 15-18 中的工作示例，以便在创建和丢弃对 <code>a</code> 中 <code>Rc&lt;List&gt;</code> 的引用时观察引用计数的变化。</p>
<p>In Listing 15-19, we’ll change <code>main</code> so it has an inner scope around list <code>c</code>;
then we can see how the reference count changes when <code>c</code> goes out of scope.</p>
<p>在代码清单 15-19 中，我们将修改 <code>main</code>，使其包含围绕列表 <code>c</code> 的内部作用域；这样我们可以看到当 <code>c</code> 离开作用域时引用计数如何变化。</p>
<figure class="listing" id="listing-15-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>// --snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<figcaption><a href="ch15-04-rc.html#listing-15-19">Listing 15-19</a>: Printing the reference count 打印引用计数</figcaption>
</figure>
<p>At each point in the program where the reference count changes, we print the
reference count, which we get by calling the <code>Rc::strong_count</code> function. This
function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code> type
also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in “Preventing
Reference Cycles Using <code>Weak&lt;T&gt;</code>”.</p>
<p>在引用计数发生变化的程序每个位置，我们打印<span class="highlight">[note]通过调用 <code>Rc::strong_count</code> 函数获得的引用计数。此函数名为 <code>strong_count</code> 而不是 <code>count</code>，因为 <code>Rc&lt;T&gt;</code> 类型还有一个 <code>weak_count</code></span>；我们将在“使用 <code>Weak&lt;T&gt;</code> 防止引用循环”中看到 <code>weak_count</code> 的用途。</p>
<p>This code prints the following:</p>
<p>此代码打印以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1; then
each time we call <code>clone</code>, the count goes up by 1. When <code>c</code> goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call <code>Rc::clone</code> to increase the reference
count: the implementation of the <code>Drop</code> trait decreases the reference count
automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>我们可以看到 <code>a</code> 中的 <code>Rc&lt;List&gt;</code> 初始引用计数为 1；然后每次调用 <code>clone</code>，计数增加 1。当 <code>c</code> 离开作用域时，计数减少 1。我们无需像调用 <code>Rc::clone</code> 增加引用计数那样调用函数来减少引用计数：<code>Drop</code> trait 的实现会在 <code>Rc&lt;T&gt;</code> 值离开作用域时自动减少引用计数。</p>
<p>What we can’t see in this example is that when <code>b</code> and then <code>a</code> go out of scope
at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up
completely. Using <code>Rc&lt;T&gt;</code> allows a single value to have multiple owners, and
the count ensures that the value remains valid as long as any of the owners
still exist.</p>
<p>在此示例中看不到的是，当 <code>b</code> 和 <code>a</code> 在 <code>main</code> 结束时离开作用域，计数变为 0，<code>Rc&lt;List&gt;</code> 被完全清理。使用 <code>Rc&lt;T&gt;</code> 允许单个值拥有多个所有者，计数确保只要任何所有者仍然存在，该值就保持有效。</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple
parts of your program for reading only. If <code>Rc&lt;T&gt;</code> allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code>
type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this
immutability restriction.</p>
<p>通过不可变引用，<code>Rc&lt;T&gt;</code> 允许你在程序的多个部分之间共享数据仅供读取。如果 <code>Rc&lt;T&gt;</code> 也允许你拥有多个可变引用，你可能会违反第 4 章讨论的借用规则之一：对同一位置的多个可变借用可能导致数据竞争和不一致。但能够改变数据非常有用！在下一节中，我们将讨论内部可变性模式以及可以与 <code>Rc&lt;T&gt;</code> 结合使用的 <code>RefCell&lt;T&gt;</code> 类型来处理这种不可变性限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-and-the-interior-mutability-pattern-refcellt-和内部可变性模式"><a class="header" href="#refcellt-and-the-interior-mutability-pattern-refcellt-和内部可变性模式"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern <code>RefCell&lt;T&gt;</code> 和内部可变性模式</a></h2>
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. Unsafe code indicates to the compiler that we’re
checking the rules manually instead of relying on the compiler to check them
for us; we will discuss unsafe code more in Chapter 20.</p>
<p><strong>内部可变性</strong>（Interior mutability）是 Rust 中的一种设计模式，允许你在存在对该数据的不可变引用时改变数据；通常，借用规则不允许此操作。为了改变数据，该模式在数据结构内部使用 <code>unsafe</code> 代码来规避 Rust 管理可变性和借用的常规规则。不安全代码向编译器表明我们正在手动检查规则，而不是依赖编译器为我们检查；我们将在第 20 章更详细地讨论不安全代码。</p>
<p>We can use types that use the interior mutability pattern only when we can
ensure that the borrowing rules will be followed at runtime, even though the
compiler can’t guarantee that. The <code>unsafe</code> code involved is then wrapped in a
safe API, and the outer type is still immutable.</p>
<p>仅当我们能确保在运行时遵循借用规则时，才可以使用采用内部可变性模式的类型，即使编译器无法保证这一点。所涉及的 <code>unsafe</code> 代码随后被包装在安全的 API 中，外部类型仍然是不可变的。</p>
<p>Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<p>让我们通过遵循内部可变性模式的 <code>RefCell&lt;T&gt;</code> 类型来探索这一概念。</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcellt-使用-refcellt-在运行时强制执行借用规则"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt-使用-refcellt-在运行时强制执行借用规则">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code> 使用 <code>RefCell&lt;T&gt;</code> 在运行时强制执行借用规则</a></h3>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
it holds. So what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?
Recall the borrowing rules you learned in Chapter 4:</p>
<p>与 <code>Rc&lt;T&gt;</code> 不同，<code>RefCell&lt;T&gt;</code> 类型对其持有的数据表示单一所有权。那么 <code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 等类型有何不同？回顾第 4 章学到的借用规则：</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference or any number
of immutable references (but not both).</li>
<li>References must always be valid.</li>
<li>在任何给定时间，你可以拥有<strong>一个</strong>可变引用或任意数量的不可变引用（但不能同时拥有两者）。</li>
<li>引用必须始终有效。</li>
</ul>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you’ll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>
<p>对于引用和 <code>Box&lt;T&gt;</code>，借用规则的不变性在编译时强制执行。<span class="highlight">[note]对于 <code>RefCell&lt;T&gt;</code>，这些不变性在<strong>运行时</strong>强制执行。使用引用时，如果违反这些规则，将得到编译器错误。使用 <code>RefCell&lt;T&gt;</code> 时，如果违反这些规则，程序将恐慌退出。</span></p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.</p>
<p>在编译时检查借用规则的优势在于，错误会在开发过程中更早被发现，并且对运行时性能没有影响，因为所有分析都是预先完成的。因此，在大多数情况下，在编译时检查借用规则是最佳选择，这也是 Rust 的默认行为。</p>
<p>The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, where they would’ve been
disallowed by the compile-time checks. Static analysis, like the Rust compiler,
is inherently conservative. Some properties of code are impossible to detect by
analyzing the code: the most famous example is the Halting Problem, which is
beyond the scope of this book but is an interesting topic to research.</p>
<p>在运行时检查借用规则的优势在于，某些内存安全的场景因此被允许，而这些场景在编译时检查中是被禁止的。静态分析（如 Rust 编译器）本质上是保守的。代码的某些属性无法通过分析代码来检测：最著名的例子是停机问题，这超出了本书的范围，但值得研究。</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust the guarantees Rust makes. However, if Rust rejects a
correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.</p>
<p>因为某些分析是不可能的，如果 Rust 编译器无法确定代码符合所有权规则，它可能会拒绝正确的程序；从这种意义上说，它是保守的。如果 Rust 接受了不正确的程序，用户将无法信任 Rust 提供的保证。然而，如果 Rust 拒绝了正确的程序，程序员会感到不便，但不会发生灾难性后果。当你确信代码遵循借用规则但编译器无法理解和保证时，<code>RefCell&lt;T&gt;</code> 类型非常有用。</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in Chapter 16.</p>
<p><span class="highlight">[note]与 <code>Rc&lt;T&gt;</code> 类似，<code>RefCell&lt;T&gt;</code> 仅用于单线程场景</span>，如果尝试在多线程上下文中使用，将给出编译时错误。我们将在第 16 章讨论如何在多线程程序中获得 <code>RefCell&lt;T&gt;</code> 的功能。</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<p>以下是选择 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的原因总结：</p>
<ul>
<li>
<p><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>
have single owners.</p>
</li>
<li>
<p><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>
allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows
immutable or mutable borrows checked at runtime.</p>
</li>
<li>
<p>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can
mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is
immutable.</p>
</li>
<li>
<p><span class="highlight">[note]<code>Rc&lt;T&gt;</code> 支持相同数据的多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 具有单一所有者。</span></p>
</li>
<li>
<p><span class="highlight">[note]<code>Box&lt;T&gt;</code> 允许在编译时检查的不可变或可变借用；<code>Rc&lt;T&gt;</code> 仅允许在编译时检查的不可变借用；<code>RefCell&lt;T&gt;</code> 允许在运行时检查的不可变或可变借用。</span></p>
</li>
<li>
<p><span class="highlight">[note]因为 <code>RefCell&lt;T&gt;</code> 允许在运行时检查的可变借用，即使 <code>RefCell&lt;T&gt;</code> 是不可变的，你仍然可以改变其内部的值。</span></p>
</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em>
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.</p>
<p>改变不可变值内部的值就是<strong>内部可变性</strong>模式。让我们看一个内部可变性有用的场景，并探讨它是如何实现的。</p>
<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value-内部可变性对不可变值的可变借用"><a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value-内部可变性对不可变值的可变借用">Interior Mutability: A Mutable Borrow to an Immutable Value 内部可变性：对不可变值的可变借用</a></h3>
<p>A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:</p>
<p>借用规则的一个结果是，当你拥有一个不可变值时，无法可变地借用它。例如，此代码无法编译：</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>If you tried to compile this code, you’d get the following error:</p>
<p>如果尝试编译此代码，将得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is
one way to get the ability to have interior mutability, but <code>RefCell&lt;T&gt;</code>
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of
a compiler error.</p>
<p>然而，在某些情况下，值在其方法中改变自身但对其他代码显示为不可变是有用的。值方法之外的代码无法改变该值。使用 <code>RefCell&lt;T&gt;</code> 是获得内部可变性能力的一种方式，但 <code>RefCell&lt;T&gt;</code> 并未完全绕过借用规则：编译器中的借用检查器允许这种内部可变性，而借用规则在运行时检查。如果违反规则，你将得到 <code>panic!</code> 而不是编译器错误。</p>
<p>Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate
an immutable value and see why that is useful.</p>
<p>让我们通过一个实际示例来使用 <code>RefCell&lt;T&gt;</code> 改变不可变值，并了解其用途。</p>
<h4 id="a-use-case-for-interior-mutability-mock-objects-内部可变性的用例模拟对象"><a class="header" href="#a-use-case-for-interior-mutability-mock-objects-内部可变性的用例模拟对象">A Use Case for Interior Mutability: Mock Objects 内部可变性的用例：模拟对象</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type,
in order to observe particular behavior and assert that it’s implemented
correctly. This placeholder type is called a <em>test double</em>. Think of it in the
sense of a stunt double in filmmaking, where a person steps in and substitutes
for an actor to do a particularly tricky scene. Test doubles stand in for other
types when we’re running tests. <em>Mock objects</em> are specific types of test
doubles that record what happens during a test so you can assert that the
correct actions took place.</p>
<p>在测试期间，程序员有时会用一种类型替代另一种类型，以观察特定行为并断言其正确实现。这种占位类型称为<strong>测试替身</strong>（test double）。可以类比电影中的特技替身，一个人介入并替代演员完成特别棘手的场景。测试替身在我们运行测试时代表其他类型。<strong>模拟对象</strong>（Mock objects）是特定类型的测试替身，记录测试期间发生的情况，以便断言执行了正确的操作。</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.</p>
<p>Rust 没有其他语言意义上的对象，标准库中也没有像某些语言那样内置模拟对象功能。但是，你绝对可以创建一个结构体来达到与模拟对象相同的目的。</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>这是我们将测试的场景：创建一个库，用于跟踪值相对于最大值的状态，并根据当前值接近最大值的程度发送消息。例如，此库可用于跟踪用户允许的 API 调用次数配额。</p>
<p>Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an email,
send a text message, or do something else. The library doesn’t need to know that
detail. All it needs is something that implements a trait we’ll provide called
<code>Messenger</code>. Listing 15-20 shows the library code.</p>
<p>我们的库仅提供跟踪值接近最大值的程度以及在何时发送何种消息的功能。使用我们库的应用程序需要提供发送消息的机制：应用程序可以将消息放入应用程序、发送电子邮件、发送短信或其他操作。库不需要知道这些细节。它只需要实现我们将提供的名为 <code>Messenger</code> 的 trait 的内容。代码清单 15-20 显示了库代码。</p>
<figure class="listing" id="listing-15-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<figcaption><a href="ch15-05-interior-mutability.html#listing-15-20">Listing 15-20</a>: A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels 一个用于跟踪值接近最大值的程度并在值达到特定级别时发出警告的库</figcaption>
</figure>
<p>One important part of this code is that the <code>Messenger</code> trait has one method
called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the
message. This trait is the interface our mock object needs to implement so that
the mock can be used in the same way a real object is. The other important part
is that we want to test the behavior of the <code>set_value</code> method on the
<code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter, but
<code>set_value</code> doesn’t return anything for us to make assertions on. We want to be
able to say that if we create a <code>LimitTracker</code> with something that implements
the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass different
numbers for <code>value</code> the messenger is told to send the appropriate messages.</p>
<p>这段代码的一个重要部分是 <code>Messenger</code> trait 有一个名为 <code>send</code> 的方法，该方法接受对 <code>self</code> 的不可变引用和消息文本。这个 trait 是我们的模拟对象需要实现的接口，以便模拟对象可以像真实对象一样使用。另一个重要部分是我们希望测试 <code>LimitTracker</code> 上的 <code>set_value</code> 方法的行为。我们可以改变传递给 <code>value</code> 参数的内容，但 <code>set_value</code> 不返回任何内容供我们断言。我们希望能够断言：如果我们创建一个使用实现 <code>Messenger</code> trait 的对象的 <code>LimitTracker</code> 和一个特定的 <code>max</code> 值，当我们为 <code>value</code> 传递不同的数字时，模拟对象被告知发送了适当的消息。</p>
<p>We need a mock object that, instead of sending an email or text message when we
call <code>send</code>, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a <code>LimitTracker</code> that uses the
mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it.</p>
<p>我们需要一个模拟对象，在调用 <code>send</code> 时不发送电子邮件或短信，而仅跟踪它被告知要发送的消息。我们可以创建模拟对象的新实例，创建使用该模拟对象的 <code>LimitTracker</code>，调用 <code>LimitTracker</code> 的 <code>set_value</code> 方法，然后检查模拟对象是否包含我们期望的消息。代码清单 15-21 展示了实现模拟对象的尝试，但借用检查器不允许。</p>
<figure class="listing" id="listing-15-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<figcaption><a href="ch15-05-interior-mutability.html#listing-15-21">Listing 15-21</a>: An attempt to implement a <code>MockMessenger</code> that isn’t allowed by the borrow checker 尝试实现 <code>MockMessenger</code>，但借用检查器不允许</figcaption>
</figure>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>
field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told
to send. We also define an associated function <code>new</code> to make it convenient to
create new <code>MockMessenger</code> values that start with an empty list of messages. We
then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a
<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we
take the message passed in as a parameter and store it in the <code>MockMessenger</code>
list of <code>sent_messages</code>.</p>
<p>这段测试代码定义了一个 <code>MockMessenger</code> 结构体，其中包含一个 <code>String</code> 值的 <code>Vec</code> 字段 <code>sent_messages</code>，用于跟踪它被告知要发送的消息。我们还定义了一个关联函数 <code>new</code>，以便于创建以空消息列表开头的新 <code>MockMessenger</code> 值。然后我们为 <code>MockMessenger</code> 实现 <code>Messenger</code> trait，以便可以将 <code>MockMessenger</code> 提供给 <code>LimitTracker</code>。在 <code>send</code> 方法的定义中，我们将传入的消息作为参数并存储在 <code>MockMessenger</code> 的 <code>sent_messages</code> 列表中。</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set
<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First we
create a new <code>MockMessenger</code>, which will start with an empty list of messages.
Then we create a new <code>LimitTracker</code> and give it a reference to the new
<code>MockMessenger</code> and a <code>max</code> value of <code>100</code>. We call the <code>set_value</code> method on
the <code>LimitTracker</code> with a value of <code>80</code>, which is more than 75 percent of 100.
Then we assert that the list of messages that the <code>MockMessenger</code> is keeping
track of should now have one message in it.</p>
<p>在测试中，我们测试当 <code>LimitTracker</code> 被告知将 <code>value</code> 设置为超过 <code>max</code> 值 75% 的值时会发生什么。首先创建一个新的 <code>MockMessenger</code>，它将从空消息列表开始。然后创建一个新的 <code>LimitTracker</code>，并为其提供对新 <code>MockMessenger</code> 的引用和 <code>max</code> 值 <code>100</code>。我们使用值 <code>80</code> 调用 <code>LimitTracker</code> 的 <code>set_value</code> 方法，该值超过 100 的 75%。然后我们断言 <code>MockMessenger</code> 正在跟踪的消息列表现在应该包含一条消息。</p>
<p>However, there’s one problem with this test, as shown here:</p>
<p>然而，这个测试有一个问题，如下所示：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages because the
<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the
suggestion from the error text to use <code>&amp;mut self</code> in both the <code>impl</code> method and
the trait definition. We do not want to change the <code>Messenger</code> trait solely for
the sake of testing. Instead, we need to find a way to make our test code work
correctly with our existing design.</p>
<p>我们无法修改 <code>MockMessenger</code> 来跟踪消息，因为 <code>send</code> 方法接受对 <code>self</code> 的不可变引用。我们也不能按照错误文本的建议在 <code>impl</code> 方法和 trait 定义中都使用 <code>&amp;mut self</code>。我们不想仅仅为了测试而更改 <code>Messenger</code> trait。相反，我们需要找到一种方法使测试代码在现有设计下正常工作。</p>
<p>This is a situation in which interior mutability can help! We’ll store the
<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> method will be
able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22
shows what that looks like.</p>
<p>这就是内部可变性可以提供帮助的情况！我们将 <code>sent_messages</code> 存储在 <code>RefCell&lt;T&gt;</code> 中，然后 <code>send</code> 方法将能够修改 <code>sent_messages</code> 以存储我们看到的消息。代码清单 15-22 展示了具体实现。</p>
<figure class="listing" id="listing-15-22">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<figcaption><a href="ch15-05-interior-mutability.html#listing-15-22">Listing 15-22</a>: Using <code>RefCell&lt;T&gt;</code> to mutate an inner value while the outer value is considered immutable 使用 <code>RefCell&lt;T&gt;</code> 在外部值被视为不可变时改变内部值</figcaption>
</figure>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of
<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
instance around the empty vector.</p>
<p><code>sent_messages</code> 字段现在的类型是 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 而不是 <code>Vec&lt;String&gt;</code>。在 <code>new</code> 函数中，我们创建一个围绕空向量的新 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 实例。</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an
immutable borrow of <code>self</code>, which matches the trait definition. We call
<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a
mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the
vector. Then we can call <code>push</code> on the mutable reference to the vector to keep
track of the messages sent during the test.</p>
<p>对于 <code>send</code> 方法的实现，第一个参数仍然是对 <code>self</code> 的不可变引用，这与 trait 定义一致。我们在 <code>self.sent_messages</code> 中的 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 上<span class="highlight">[note]调用 <code>borrow_mut</code>，以获取对 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 内部值的可变引用，即向量。然后我们可以对向量的可变引用调用 <code>push</code> 来跟踪测试期间发送的消息。</span></p>
<p>The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an
immutable reference to the vector.</p>
<p>我们必须做的最后一个更改是在断言中：为了查看内部向量中有多少项，我们在 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 上<span class="highlight">[note]调用 <code>borrow</code> 以获取对向量的不可变引用。</span></p>
<p>Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>
<p>现在你已了解如何使用 <code>RefCell&lt;T&gt;</code>，让我们深入探讨它的工作原理！</p>
<h4 id="keeping-track-of-borrows-at-runtime-with-refcellt-使用-refcellt-在运行时跟踪借用"><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt-使用-refcellt-在运行时跟踪借用">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code> 使用 <code>RefCell&lt;T&gt;</code> 在运行时跟踪借用</a></h4>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>
syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>
methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The
<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>
returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we
can treat them like regular references.</p>
<p>创建不可变和可变引用时，我们分别使用 <code>&amp;</code> 和 <code>&amp;mut</code> 语法。对于 <code>RefCell&lt;T&gt;</code>，我们使用 <code>borrow</code> 和 <code>borrow_mut</code> 方法，它们是属于 <code>RefCell&lt;T&gt;</code> 的安全 API 的一部分。<span class="highlight">[note]<code>borrow</code> 方法返回智能指针类型 <code>Ref&lt;T&gt;</code>，而 <code>borrow_mut</code> 返回智能指针类型 <code>RefMut&lt;T&gt;</code>。两种类型都实现了 <code>Deref</code>，因此我们可以像常规引用一样对待它们。</span></p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>
increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>
value goes out of scope, the count of immutable borrows goes down by 1. Just
like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable
borrows or one mutable borrow at any point in time.</p>
<p><span class="highlight">[note]<code>RefCell&lt;T&gt;</code> 跟踪当前有多少 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针处于活动状态。每次调用 <code>borrow</code> 时，<code>RefCell&lt;T&gt;</code> 会增加其不可变借用活动计数。当 <code>Ref&lt;T&gt;</code> 值离开作用域时，不可变借用计数减少 1。</span>就像编译时借用规则一样，<code>RefCell&lt;T&gt;</code> 允许我们在任何时候拥有多个不可变借用或一个可变借用。</p>
<p>If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at
runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this
at runtime.</p>
<p>如果我们试图违反这些规则，不会像使用引用那样得到编译器错误，<code>RefCell&lt;T&gt;</code> 的实现将在运行时恐慌。代码清单 15-23 展示了代码清单 15-22 中 <code>send</code> 实现的修改版本。我们故意尝试为同一作用域创建两个活动的可变借用，以说明 <code>RefCell&lt;T&gt;</code> 在运行时阻止我们这样做。</p>
<figure class="listing" id="listing-15-23">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch15-05-interior-mutability.html#listing-15-23">Listing 15-23</a>: Creating two mutable references in the same scope to see that <code>RefCell&lt;T&gt;</code> will panic 在同一作用域中创建两个可变引用以观察 <code>RefCell&lt;T&gt;</code> 将恐慌</figcaption>
</figure>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned
from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the
variable <code>two_borrow</code>. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:</p>
<p>我们为 <code>borrow_mut</code> 返回的 <code>RefMut&lt;T&gt;</code> 智能指针创建变量 <code>one_borrow</code>。然后以相同方式在变量 <code>two_borrow</code> 中创建另一个可变借用。这导致在同一作用域中存在两个可变引用，这是不允许的。当我们运行库的测试时，代码清单 15-23 中的代码将编译而不会出现任何错误，但测试会失败：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed:  BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing
rules at runtime.</p>
<p>注意代码因消息 <code>already borrowed: BorrowMutError</code> 而恐慌。这就是 <code>RefCell&lt;T&gt;</code> 在运行时处理违反借用规则的方式。</p>
<p>Choosing to catch borrowing errors at runtime rather than compile time, as
we’ve done here, means you’d potentially be finding mistakes in your code later
in the development process: possibly not until your code was deployed to
production. Also, your code would incur a small runtime performance penalty as
a result of keeping track of the borrows at runtime rather than compile time.
However, using <code>RefCell&lt;T&gt;</code> makes it possible to write a mock object that can
modify itself to keep track of the messages it has seen while you’re using it
in a context where only immutable values are allowed. You can use <code>RefCell&lt;T&gt;</code>
despite its trade-offs to get more functionality than regular references
provide.</p>
<p>选择在运行时捕获借用错误而不是编译时（如此处所做），意味着你可能在开发过程后期才发现代码中的错误：甚至可能直到代码部署到生产环境。此外，由于在运行时而不是编译时跟踪借用，你的代码<span class="highlight">[note]会遭受轻微的性能损失</span>。然而，使用 <code>RefCell&lt;T&gt;</code> 可以在仅允许不可变值的上下文中编写可以修改自身以跟踪所见消息的模拟对象。尽管存在这些权衡，你仍然可以使用 <code>RefCell&lt;T&gt;</code> 来获得比常规引用提供的更多功能。</p>
<h3 id="allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt-通过-rct-和-refcellt-允许多个所有者持有可变数据"><a class="header" href="#allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt-通过-rct-和-refcellt-允许多个所有者持有可变数据">Allowing Multiple Owners of Mutable Data with <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> 通过 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 允许多个所有者持有可变数据</a></h3>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that
<code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can
get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<p><span class="highlight">[note]使用 <code>RefCell&lt;T&gt;</code> 的常见方式是与 <code>Rc&lt;T&gt;</code> 结合。</span>回想一下，<code>Rc&lt;T&gt;</code> 让你拥有某些数据的多个所有者，但它仅提供对该数据的不可变访问。如果你有一个持有 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code>，你可以获得一个可以拥有多个所有者<strong>并且</strong>可以改变的值！</p>
<p>For example, recall the cons list example in Listing 15-18 where we used <code>Rc&lt;T&gt;</code>
to allow multiple lists to share ownership of another list. Because <code>Rc&lt;T&gt;</code>
holds only immutable values, we can’t change any of the values in the list once
we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> for its ability to change the
values in the lists. Listing 15-24 shows that by using a <code>RefCell&lt;T&gt;</code> in the
<code>Cons</code> definition, we can modify the value stored in all the lists.</p>
<p>例如，回顾代码清单 15-18 中的 cons 列表示例，我们使用 <code>Rc&lt;T&gt;</code> 允许多个列表共享另一个列表的所有权。因为 <code>Rc&lt;T&gt;</code> 仅持有不可变值，一旦创建列表，我们就无法更改其中的任何值。让我们添加 <code>RefCell&lt;T&gt;</code> 以改变列表中的值。代码清单 15-24 显示，通过在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code>，我们可以修改所有列表中的值。</p>
<figure class="listing" id="listing-15-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
<figcaption><a href="ch15-05-interior-mutability.html#listing-15-24">Listing 15-24</a>: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a <code>List</code> that we can mutate 使用 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 创建可变的 <code>List</code></figcaption>
</figure>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a
variable named <code>value</code> so we can access it directly later. Then we create a
<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone
<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather
than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from
<code>value</code>.</p>
<p>我们创建一个 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 实例并将其存储在名为 <code>value</code> 的变量中，以便稍后直接访问。然后我们在 <code>a</code> 中创建一个 <code>List</code>，其 <code>Cons</code> 变体持有 <code>value</code>。我们需要克隆 <code>value</code>，以便 <code>a</code> 和 <code>value</code> 都拥有内部值 <code>5</code> 的所有权，而不是将所有权从 <code>value</code> 转移给 <code>a</code> 或让 <code>a</code> 从 <code>value</code> 借用。</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so that when we create lists <code>b</code> and <code>c</code>,
they can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>我们将列表 <code>a</code> 包装在 <code>Rc&lt;T&gt;</code> 中，这样在创建列表 <code>b</code> 和 <code>c</code> 时，它们都可以引用 <code>a</code>，正如我们在代码清单 15-18 中所做的那样。</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we want to add 10 to the
value in <code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the
automatic dereferencing feature we discussed in “Where’s the <code>-&gt;</code>
Operator?”) in Chapter 5 to dereference
the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code> method returns a
<code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator on it and change
the inner value.</p>
<p>创建 <code>a</code>、<code>b</code> 和 <code>c</code> 中的列表后，我们希望将 <code>value</code> 中的值增加 10。我们通过对 <code>value</code> 调用 <code>borrow_mut</code> 来实现这一点，该函数使用第 5 章“<code>-&gt;</code> 运算符在哪？”中讨论的自动解引用功能，将 <code>Rc&lt;T&gt;</code> 解引用为内部的 <code>RefCell&lt;T&gt;</code> 值。<code>borrow_mut</code> 方法返回一个 <code>RefMut&lt;T&gt;</code> 智能指针，我们在其上使用解引用运算符来更改内部值。</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified
value of <code>15</code> rather than <code>5</code>:</p>
<p>当我们打印 <code>a</code>、<code>b</code> 和 <code>c</code> 时，可以看到它们都具有修改后的值 <code>15</code> 而不是 <code>5</code>：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly
immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures. Note that <code>RefCell&lt;T&gt;</code> does not work for multithreaded code!
<code>Mutex&lt;T&gt;</code> is the thread-safe version of <code>RefCell&lt;T&gt;</code>, and we’ll discuss
<code>Mutex&lt;T&gt;</code> in Chapter 16.</p>
<p>这种技术相当巧妙！通过使用 <code>RefCell&lt;T&gt;</code>，我们获得了一个表面上不可变的 <code>List</code> 值。但我们可以使用 <code>RefCell&lt;T&gt;</code> 上的方法来访问其内部可变性，以便在需要时修改数据。借用规则的运行时检查保护我们免受数据竞争，有时为了数据结构的这种灵活性而牺牲一点速度是值得的。注意 <code>RefCell&lt;T&gt;</code> 不适用于多线程代码！<code>Mutex&lt;T&gt;</code> 是 <code>RefCell&lt;T&gt;</code> 的线程安全版本，我们将在第 16 章讨论 <code>Mutex&lt;T&gt;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reference-cycles-can-leak-memory-引用循环会导致内存泄漏"><a class="header" href="#reference-cycles-can-leak-memory-引用循环会导致内存泄漏">Reference Cycles Can Leak Memory 引用循环会导致内存泄漏</a></h2>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).
Preventing memory leaks entirely is not one of Rust’s guarantees, meaning
memory leaks are memory safe in Rust. We can see that Rust allows memory leaks
by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where
items refer to each other in a cycle. This creates memory leaks because the
reference count of each item in the cycle will never reach 0, and the values
will never be dropped.</p>
<p>Rust 的内存安全保证使得意外创建永远不会清理的内存（称为<strong>内存泄漏</strong>）变得困难，但并非不可能。完全防止内存泄漏不是 Rust 的保证之一，这意味着在 Rust 中内存泄漏是内存安全的。通过使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 可以看到 Rust 允许内存泄漏：有可能创建项目相互引用的循环。这会导致内存泄漏，因为循环中每个项目的引用计数永远不会达到 0，值永远不会被丢弃。</p>
<h3 id="creating-a-reference-cycle-创建引用循环"><a class="header" href="#creating-a-reference-cycle-创建引用循环">Creating a Reference Cycle 创建引用循环</a></h3>
<p>Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing
15-25.</p>
<p>让我们看看引用循环是如何发生的以及如何防止它，从代码清单 15-25 中的 <code>List</code> 枚举定义和 <code>tail</code> 方法开始。</p>
<figure class="listing" id="listing-15-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<figcaption><a href="ch15-06-reference-cycles.html#listing-15-25">Listing 15-25</a>: A cons list definition that holds a <code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to 一个持有 <code>RefCell&lt;T&gt;</code> 的 cons 列表定义，以便我们可以修改 <code>Cons</code> 变体引用的内容</figcaption>
</figure>
<p>We’re using another variation of the <code>List</code> definition from Listing 15-5. The
second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that
instead of having the ability to modify the <code>i32</code> value as we did in Listing
15-24, we want to modify the <code>List</code> value a <code>Cons</code> variant is pointing to.
We’re also adding a <code>tail</code> method to make it convenient for us to access the
second item if we have a <code>Cons</code> variant.</p>
<p>我们使用代码清单 15-5 中 <code>List</code> 定义的另一种变体。<code>Cons</code> 变体中的第二个元素现在是 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>，这意味着我们不是像代码清单 15-24 中那样能够修改 <code>i32</code> 值，而是希望修改 <code>Cons</code> 变体指向的 <code>List</code> 值。我们还添加了一个 <code>tail</code> 方法，以便在拥有 <code>Cons</code> 变体时方便地访问第二个项目。</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in
Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to
the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a
reference cycle. There are <code>println!</code> statements along the way to show what the
reference counts are at various points in this process.</p>
<p>在代码清单 15-26 中，我们添加了一个使用代码清单 15-25 中定义的 <code>main</code> 函数。此代码在 <code>a</code> 中创建一个列表，在 <code>b</code> 中创建一个指向 <code>a</code> 中列表的列表。然后它将 <code>a</code> 中的列表修改为指向 <code>b</code>，从而创建一个引用循环。沿途有 <code>println!</code> 语句显示在此过程中各个点的引用计数。</p>
<figure class="listing" id="listing-15-26">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack.
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<figcaption><a href="ch15-06-reference-cycles.html#listing-15-26">Listing 15-26</a>: Creating a reference cycle of two <code>List</code> values pointing to each other 创建两个相互指向的 <code>List</code> 值的引用循环</figcaption>
</figure>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>
with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance holding
another <code>List</code> value in the variable <code>b</code> that contains the value <code>10</code> and points
to the list in <code>a</code>.</p>
<p>我们在变量 <code>a</code> 中创建一个 <code>Rc&lt;List&gt;</code> 实例，其中包含初始列表 <code>5, Nil</code>。然后我们在变量 <code>b</code> 中创建另一个 <code>Rc&lt;List&gt;</code> 实例，其中包含值 <code>10</code> 并指向 <code>a</code> 中的列表。</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do
that by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>
in <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code>
method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code>
that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>我们将 <code>a</code> 修改为指向 <code>b</code> 而不是 <code>Nil</code>，从而创建一个循环。我们使用 <code>tail</code> 方法获取 <code>a</code> 中 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 的引用，并将其放入变量 <code>link</code> 中。然后我们在 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 上使用 <code>borrow_mut</code> 方法，将内部值从持有 <code>Nil</code> 值的 <code>Rc&lt;List&gt;</code> 更改为 <code>b</code> 中的 <code>Rc&lt;List&gt;</code>。</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the
moment, we’ll get this output:</p>
<p>当我们运行此代码时，暂时注释掉最后一个 <code>println!</code>，我们将得到以下输出：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> is 2 after
we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust drops the
variable <code>b</code>, which decreases the reference count of the <code>b</code> <code>Rc&lt;List&gt;</code> instance
from 2 to 1. The memory that <code>Rc&lt;List&gt;</code> has on the heap won’t be dropped at
this point because its reference count is 1, not 0. Then Rust drops <code>a</code>, which
decreases the reference count of the <code>a</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1 as
well. This instance’s memory can’t be dropped either, because the other
<code>Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will
remain uncollected forever. To visualize this reference cycle, we’ve created the
diagram in Figure 15-4.</p>
<p>在我们将 <code>a</code> 中的列表更改为指向 <code>b</code> 之后，<code>a</code> 和 <code>b</code> 中的 <code>Rc&lt;List&gt;</code> 实例的引用计数为 2。在 <code>main</code> 结束时，Rust 丢弃变量 <code>b</code>，这将 <code>b</code> 的 <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减少到 1。此时 <code>Rc&lt;List&gt;</code> 在堆上的内存不会被丢弃，因为其引用计数是 1 而不是 0。然后 Rust 丢弃 <code>a</code>，这又将 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减少到 1。这个实例的内存也不能被丢弃，因为另一个 <code>Rc&lt;List&gt;</code> 实例仍然引用它。分配给列表的内存将永远未被回收。为了可视化这个引用循环，我们创建了图 15-4 中的图表。</p>
<img alt="" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other 列表 <code>a</code> 和 <code>b</code> 相互指向的引用循环</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to print
this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it
overflows the stack.</p>
<p>如果取消注释最后一个 <code>println!</code> 并运行程序，Rust 将尝试打印这个循环，<code>a</code> 指向 <code>b</code>，<code>b</code> 指向 <code>a</code>，依此类推，直到堆栈溢出。</p>
<p>Compared to a real-world program, the consequences of creating a reference cycle
in this example aren’t very dire: right after we create the reference cycle,
the program ends. However, if a more complex program allocated lots of memory
in a cycle and held onto it for a long time, the program would use more memory
than it needed and might overwhelm the system, causing it to run out of
available memory.</p>
<p>与真实世界的程序相比，在此示例中创建引用循环的后果并不十分严重：在创建引用循环后，程序立即结束。但是，如果更复杂的程序在循环中分配了大量内存并长时间持有，程序将使用比所需更多的内存，并可能压垮系统，导致可用内存耗尽。</p>
<p>Creating reference cycles is not easily done, but it’s not impossible either.
If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.</p>
<p>创建引用循环并不容易，但也不是不可能的。<span class="highlight">[note]如果你有包含 <code>Rc&lt;T&gt;</code> 值的 <code>RefCell&lt;T&gt;</code> 值，或具有内部可变性和引用计数的类型的类似嵌套组合，则必须确保不会创建循环</span>；你不能依赖 Rust 来捕获它们。创建引用循环将是程序中的逻辑错误，你应该使用自动化测试、代码审查和其他软件开发实践来最小化其发生。</p>
<p>Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.</p>
<p>避免引用循环的另一种解决方案是重组数据结构，使得某些引用表示所有权而另一些引用不表示。因此，你可以拥有由所有权关系和非所有权关系组成的循环，并且只有所有权关系影响值是否可以被丢弃。在代码清单 15-25 中，我们总是希望 <code>Cons</code> 变体拥有其列表，因此重组数据结构是不可能的。让我们看一个由父节点和子节点组成的图的示例，以了解非所有权关系何时是防止引用循环的适当方式。</p>
<h3 id="preventing-reference-cycles-using-weakt-使用-weakt-防止引用循环"><a class="header" href="#preventing-reference-cycles-using-weakt-使用-weakt-防止引用循环">Preventing Reference Cycles Using <code>Weak&lt;T&gt;</code> 使用 <code>Weak&lt;T&gt;</code> 防止引用循环</a></h3>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code>
of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned up if its
<code>strong_count</code> is 0. You can also create a weak reference to the value within
an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the
<code>Rc&lt;T&gt;</code>. <em>Strong references</em> are how you can share ownership of an <code>Rc&lt;T&gt;</code>
instance. <em>Weak references</em> don’t express an ownership relationship, and their
count doesn’t affect when an <code>Rc&lt;T&gt;</code> instance is cleaned up. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.</p>
<p>到目前为止，我们已经证明调用 <code>Rc::clone</code> 会增加 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code>，并且只有当 <code>strong_count</code> 为 0 时才会清理 <code>Rc&lt;T&gt;</code> 实例。你也可以<span class="highlight">[note]通过调用 <code>Rc::downgrade</code> 并传递对 <code>Rc&lt;T&gt;</code> 的引用来创建对 <code>Rc&lt;T&gt;</code> 实例内值的弱引用。</span><strong>强引用</strong>是共享 <code>Rc&lt;T&gt;</code> 实例所有权的方式。<strong>弱引用</strong>不表示所有权关系，它们的计数不会影响 <code>Rc&lt;T&gt;</code> 实例何时被清理。它们不会导致引用循环，因为一旦所涉及值的强引用计数为 0，任何涉及弱引用的循环都会被打破。</p>
<p>When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>.
Instead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling
<code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses
<code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to
<code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the
<code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>当你调用 <code>Rc::downgrade</code> 时，你会<span class="highlight">[note]得到一个 <code>Weak&lt;T&gt;</code> 类型的智能指针</span>。调用 <code>Rc::downgrade</code> 不会将 <code>Rc&lt;T&gt;</code> 实例中的 <code>strong_count</code> 增加 1，而是将 <code>weak_count</code> 增加 1。<code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来跟踪存在多少 <code>Weak&lt;T&gt;</code> 引用，类似于 <code>strong_count</code>。不同之处在于，<code>weak_count</code> 不需要为 0 才能使 <code>Rc&lt;T&gt;</code> 实例被清理。</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to you must make sure the
value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>
if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>,
Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and
there won’t be an invalid pointer.</p>
<p>因为 <code>Weak&lt;T&gt;</code> 引用的值可能已被丢弃，要对 <code>Weak&lt;T&gt;</code> 指向的值执行任何操作，你必须确保该值仍然存在。通过在 <code>Weak&lt;T&gt;</code> 实例上<span class="highlight">[note]调用 <code>upgrade</code> 方法</span>来实现这一点，该方法将返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。如果 <code>Rc&lt;T&gt;</code> 值尚未被丢弃，你将得到 <code>Some</code> 结果；如果 <code>Rc&lt;T&gt;</code> 值已被丢弃，则得到 <code>None</code> 结果。因为 <code>upgrade</code> 返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，Rust 将确保处理 <code>Some</code> 和 <code>None</code> 情况，并且不会出现无效指针。</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items <em>and</em>
their parent items.</p>
<p>例如，我们将创建一个树结构，其项目知道它们的子项目<strong>和</strong>它们的父项目，而不是使用仅知道下一个项目的列表。</p>
<h4 id="creating-a-tree-data-structure-a-node-with-child-nodes-创建树数据结构具有子节点的-node"><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes-创建树数据结构具有子节点的-node">Creating a Tree Data Structure: A <code>Node</code> with Child Nodes 创建树数据结构：具有子节点的 <code>Node</code></a></h4>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its children <code>Node</code> values:</p>
<p>首先，我们将构建一个节点知道其子节点的树。我们将创建一个名为 <code>Node</code> 的结构体，它持有自己的 <code>i32</code> 值以及对其子 <code>Node</code> 值的引用：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so we can access each <code>Node</code> in the tree directly. To do this, we
define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>我们希望 <code>Node</code> 拥有其子节点，并且我们希望与变量共享该所有权，以便我们可以直接访问树中的每个 <code>Node</code>。为此，我们将 <code>Vec&lt;T&gt;</code> 项定义为 <code>Rc&lt;Node&gt;</code> 类型。我们还希望修改哪些节点是另一个节点的子节点，因此我们在 <code>children</code> 中使用 <code>RefCell&lt;T&gt;</code> 包装 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>。</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value <code>3</code> and no children, and another instance named <code>branch</code>
with the value <code>5</code> and <code>leaf</code> as one of its children, as shown in Listing 15-27.</p>
<p>接下来，我们将使用结构体定义创建一个名为 <code>leaf</code> 的 <code>Node</code> 实例，其值为 <code>3</code> 且无子节点，以及另一个名为 <code>branch</code> 的实例，其值为 <code>5</code> 且 <code>leaf</code> 作为其子节点之一，如代码清单 15-27 所示。</p>
<figure class="listing" id="listing-15-27">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<figcaption><a href="ch15-06-reference-cycles.html#listing-15-27">Listing 15-27</a>: Creating a <code>leaf</code> node with no children and a <code>branch</code> node with <code>leaf</code> as one of its children 创建没有子节点的 <code>leaf</code> 节点和有 <code>leaf</code> 作为子节点之一的 <code>branch</code> 节点</figcaption>
</figure>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<p>我们克隆 <code>leaf</code> 中的 <code>Rc&lt;Node&gt;</code> 并将其存储在 <code>branch</code> 中，这意味着 <code>leaf</code> 中的 <code>Node</code> 现在有两个所有者：<code>leaf</code> 和 <code>branch</code>。我们可以通过 <code>branch.children</code> 从 <code>branch</code> 访问 <code>leaf</code>，但无法从 <code>leaf</code> 访问 <code>branch</code>。原因是 <code>leaf</code> 没有对 <code>branch</code> 的引用，也不知道它们是相关的。我们希望 <code>leaf</code> 知道 <code>branch</code> 是其父节点。接下来我们将实现这一点。</p>
<h4 id="adding-a-reference-from-a-child-to-its-parent-添加从子节点到父节点的引用"><a class="header" href="#adding-a-reference-from-a-child-to-its-parent-添加从子节点到父节点的引用">Adding a Reference from a Child to Its Parent 添加从子节点到父节点的引用</a></h4>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>为了使子节点知道其父节点，我们需要向 <code>Node</code> 结构体定义添加 <code>parent</code> 字段。问题在于决定 <code>parent</code> 的类型。我们知道它不能包含 <code>Rc&lt;T&gt;</code>，因为这将创建引用循环，<code>leaf.parent</code> 指向 <code>branch</code>，<code>branch.children</code> 指向 <code>leaf</code>，这将导致它们的 <code>strong_count</code> 值永远不为 0。</p>
<p>Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>换一种方式思考关系，父节点应拥有其子节点：如果父节点被丢弃，其子节点也应被丢弃。然而，子节点不应拥有其父节点：如果我们丢弃子节点，父节点应该仍然存在。这是弱引用的用例！</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p>因此，我们不使用 <code>Rc&lt;T&gt;</code>，而是让 <code>parent</code> 的类型使用 <code>Weak&lt;T&gt;</code>，具体来说是 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>。现在我们的 <code>Node</code> 结构体定义如下：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>.</p>
<p>节点将能够引用其父节点，但不拥有其父节点。在代码清单 15-28 中，我们更新 <code>main</code> 以使用此新定义，以便 <code>leaf</code> 节点将有一种方式引用其父节点 <code>branch</code>。</p>
<figure class="listing" id="listing-15-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<figcaption><a href="ch15-06-reference-cycles.html#listing-15-28">Listing 15-28</a>: A <code>leaf</code> node with a weak reference to its parent node, <code>branch</code> <code>leaf</code> 节点具有指向其父节点 <code>branch</code> 的弱引用</figcaption>
</figure>
<p>Creating the <code>leaf</code> node looks similar to Listing 15-27 with the exception of
the <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new,
empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>创建 <code>leaf</code> 节点类似于代码清单 15-27，除了 <code>parent</code> 字段：<code>leaf</code> 开始时没有父节点，因此我们创建一个新的空 <code>Weak&lt;Node&gt;</code> 引用实例。</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<p>此时，当我们尝试使用 <code>upgrade</code> 方法获取 <code>leaf</code> 的父节点的引用时，会得到 <code>None</code> 值。我们在第一个 <code>println!</code> 语句的输出中看到这一点：</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field because <code>branch</code> doesn’t have a parent node.
We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the
<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>
reference to its parent. We use the <code>borrow_mut</code> method on the
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the
<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from
the <code>Rc&lt;Node&gt;</code> in <code>branch</code>.</p>
<p>创建 <code>branch</code> 节点时，它在其 <code>parent</code> 字段中也有一个新的 <code>Weak&lt;Node&gt;</code> 引用，因为 <code>branch</code> 没有父节点。我们仍然有 <code>leaf</code> 作为 <code>branch</code> 的子节点之一。一旦我们在 <code>branch</code> 中有了 <code>Node</code> 实例，我们就可以修改 <code>leaf</code> 以赋予它一个指向其父节点的 <code>Weak&lt;Node&gt;</code> 引用。我们在 <code>leaf</code> 的 <code>parent</code> 字段中的 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 上使用 <code>borrow_mut</code> 方法，然后使用 <code>Rc::downgrade</code> 函数从 <code>branch</code> 中的 <code>Rc&lt;Node&gt;</code> 创建指向 <code>branch</code> 的 <code>Weak&lt;Node&gt;</code> 引用。</p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<p>当我们再次打印 <code>leaf</code> 的父节点时，这次我们将得到一个包含 <code>branch</code> 的 <code>Some</code> 变体：现在 <code>leaf</code> 可以访问其父节点！当我们打印 <code>leaf</code> 时，也避免了最终导致堆栈溢出的循环，如代码清单 15-26 中所示；<code>Weak&lt;Node&gt;</code> 引用被打印为 <code>(Weak)</code>：</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<p>没有无限输出表明此代码没有创建引用循环。我们还可以通过查看调用 <code>Rc::strong_count</code> 和 <code>Rc::weak_count</code> 获得的值来确认这一点。</p>
<h4 id="visualizing-changes-to-strong_count-and-weak_count-可视化-strong_count-和-weak_count-的变化"><a class="header" href="#visualizing-changes-to-strong_count-and-weak_count-可视化-strong_count-和-weak_count-的变化">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code> 可视化 <code>strong_count</code> 和 <code>weak_count</code> 的变化</a></h4>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29.</p>
<p>让我们通过创建一个新的内部作用域并将 <code>branch</code> 的创建移入该作用域来观察 <code>Rc&lt;Node&gt;</code> 实例的 <code>strong_count</code> 和 <code>weak_count</code> 值的变化。这样做，我们可以看到当 <code>branch</code> 被创建然后在其离开作用域时被丢弃时会发生什么。修改如代码清单 15-29 所示。</p>
<figure class="listing" id="listing-15-29">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<figcaption><a href="ch15-06-reference-cycles.html#listing-15-29">Listing 15-29</a>: Creating <code>branch</code> in an inner scope and examining strong and weak reference counts 在内部作用域中创建 <code>branch</code> 并检查强引用和弱引用计数</figcaption>
</figure>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2 because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak
count of 0.</p>
<p>创建 <code>leaf</code> 后，其 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0。在内部作用域中，我们创建 <code>branch</code> 并将其与 <code>leaf</code> 关联，此时打印计数时，<code>branch</code> 中的 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 1（因为 <code>leaf.parent</code> 指向 <code>branch</code> 的 <code>Weak&lt;Node&gt;</code>）。当我们打印 <code>leaf</code> 的计数时，会看到其强引用计数为 2，因为 <code>branch</code> 现在在 <code>branch.children</code> 中存储了 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 的克隆，但弱引用计数仍为 0。</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>当内部作用域结束时，<code>branch</code> 离开作用域，<code>Rc&lt;Node&gt;</code> 的强引用计数减少到 0，因此其 <code>Node</code> 被丢弃。来自 <code>leaf.parent</code> 的弱引用计数 1 不会影响 <code>Node</code> 是否被丢弃，因此我们不会发生任何内存泄漏！</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0 because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>如果我们在作用域结束后尝试访问 <code>leaf</code> 的父节点，将再次得到 <code>None</code>。在程序结束时，<code>leaf</code> 中的 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0，因为变量 <code>leaf</code> 现在又是 <code>Rc&lt;Node&gt;</code> 的唯一引用。</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<p>所有管理计数和值丢弃的逻辑都内置于 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 及其 <code>Drop</code> trait 的实现中。通过在 <code>Node</code> 的定义中指定从子节点到其父节点的关系应为 <code>Weak&lt;T&gt;</code> 引用，你能够让父节点指向子节点，反之亦然，而不会创建引用循环和内存泄漏。</p>
<h2 id="summary-总结-14"><a class="header" href="#summary-总结-14">Summary 总结</a></h2>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so
that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>本章介绍了如何使用智能指针做出不同于 Rust 默认使用常规引用所做的保证和权衡。<code>Box&lt;T&gt;</code> 类型具有已知大小并指向堆上分配的数据。<code>Rc&lt;T&gt;</code> 类型跟踪堆上数据的引用数量，以便数据可以拥有多个所有者。<code>RefCell&lt;T&gt;</code> 类型及其内部可变性为我们提供了一种类型，当我们需要不可变类型但需要更改该类型的内部值时可以使用它；它还在运行时而不是编译时强制执行借用规则。</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>还讨论了 <code>Deref</code> 和 <code>Drop</code> trait，它们实现了智能指针的许多功能。我们探讨了可能导致内存泄漏的引用循环，以及如何使用 <code>Weak&lt;T&gt;</code> 来防止它们。</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out “The Rustonomicon” for more useful
information.</p>
<p>如果本章激发了你的兴趣，并且你想实现自己的智能指针，请查阅《Rustonomicon》以获取更多有用信息。</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
<p>接下来，我们将讨论 Rust 中的并发性。你甚至还会学到一些新的智能指针。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency-无畏并发"><a class="header" href="#fearless-concurrency-无畏并发">Fearless Concurrency 无畏并发</a></h1>
<p>Handling concurrent programming safely and efficiently is another of Rust’s
major goals. <em>Concurrent programming</em>, in which different parts of a program
execute independently, and <em>parallel programming</em>, in which different parts of
a program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone. Rust hopes to
change that.</p>
<p>安全高效地处理并发编程是 Rust 的另一个主要目标。随着越来越多计算机利用多核处理器的优势，<strong>并发编程</strong>（程序不同部分独立执行）和<strong>并行编程</strong>（程序不同部分同时执行）正变得日益重要。历史上，这类编程一直困难重重且容易出错。Rust 希望能改变这一现状。</p>
<p>Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety <em>and</em> concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust <em>fearless
concurrency</em>. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.</p>
<p>最初，Rust 团队认为确保内存安全和防止并发问题是两个独立的挑战，需用不同方法解决。但随着时间推移，团队发现所有权系统和类型系统正是帮助管理内存安全<strong>与</strong>并发问题的强大工具！通过利用所有权和类型检查，许多并发错误在 Rust 中变成了编译时错误而非运行时错误。因此，错误的代码将拒绝编译并显示问题解释，而非让你耗费大量时间尝试复现运行时并发 bug 出现的精确场景。这样，你可以在开发过程中修复代码，而非等到代码发布到生产环境后才处理。我们将 Rust 的这一特性称为<strong>无畏并发</strong>。无畏并发让你能编写无潜在隐患的代码，并易于重构而不引入新错误。</p>
<section class="note" aria-role="note">
<p>Note: For simplicity’s sake, we’ll refer to many of the problems as
<em>concurrent</em> rather than being more precise by saying <em>concurrent and/or
parallel</em>. For this chapter, please mentally substitute <em>concurrent and/or
parallel</em> whenever we use <em>concurrent</em>. In the next chapter, where the
distinction matters more, we’ll be more specific.</p>
<p>注意：为简化起见，我们将许多问题称为<strong>并发</strong>而非更精确的<strong>并发和/或并行</strong>。本章中，请在心里将我们使用的<strong>并发</strong>替换为<strong>并发和/或并行</strong>。下一章在区分更关键时，我们会更具体。</p>
</section>
<p>Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.</p>
<p>许多语言对其处理并发问题的解决方案持有教条态度。例如，Erlang 在消息传递并发方面功能优雅，但在线程间共享状态的方式却晦涩难懂。对高级语言而言，仅支持部分解决方案是合理策略，因为高级语言承诺通过放弃部分控制权获得抽象能力。但低级语言应能在任何情况下提供最佳性能的解决方案，且对硬件的抽象更少。因此，Rust 提供多种工具来根据你的场景和需求灵活建模问题。</p>
<p>Here are the topics we’ll cover in this chapter:</p>
<p>本章将涵盖以下主题：</p>
<ul>
<li>
<p>How to create threads to run multiple pieces of code at the same time</p>
</li>
<li>
<p><em>Message-passing</em> concurrency, where channels send messages between threads</p>
</li>
<li>
<p><em>Shared-state</em> concurrency, where multiple threads have access to some piece
of data</p>
</li>
<li>
<p>The <code>Sync</code> and <code>Send</code> traits, which extend Rust’s concurrency guarantees to
user-defined types as well as types provided by the standard library</p>
</li>
<li>
<p>如何创建线程同时运行多段代码</p>
</li>
<li>
<p><strong>消息传递</strong>并发：通过通道在线程间传递消息</p>
</li>
<li>
<p><strong>共享状态</strong>并发：多个线程访问同一数据</p>
</li>
<li>
<p><code>Sync</code> 和 <code>Send</code> 特征：将 Rust 的并发保证扩展到用户自定义类型及标准库类型</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-threads-to-run-code-simultaneously-使用线程同时运行代码"><a class="header" href="#using-threads-to-run-code-simultaneously-使用线程同时运行代码">Using Threads to Run Code Simultaneously 使用线程同时运行代码</a></h2>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system will manage multiple processes at once.
Within a program, you can also have independent parts that run simultaneously.
The features that run these independent parts are called <em>threads</em>. For
example, a web server could have multiple threads so that it can respond to
more than one request at the same time.</p>
<p>在当今多数操作系统中，执行程序的代码运行于<strong>进程</strong>内，操作系统会同时管理多个进程。程序内部也可有独立部分同时运行，运行这些独立部分的特性称为<strong>线程</strong>。例如，Web 服务器可使用多线程同时响应多个请求。</p>
<p>Splitting the computation in your program into multiple threads to run multiple
tasks at the same time can improve performance, but it also adds complexity.
Because threads can run simultaneously, there’s no inherent guarantee about the
order in which parts of your code on different threads will run. This can lead
to problems, such as:</p>
<p>将程序计算拆分到多个线程以同时执行多任务可提升性能，但也增加复杂性。由于线程可能同时运行，无法保证不同线程上代码的执行顺序。这会导致以下问题：</p>
<ul>
<li>
<p>Race conditions, in which threads are accessing data or resources in an
inconsistent order</p>
</li>
<li>
<p>Deadlocks, in which two threads are waiting for each other, preventing both
threads from continuing</p>
</li>
<li>
<p>Bugs that only happen in certain situations and are hard to reproduce and fix
reliably</p>
</li>
<li>
<p><strong>竞态条件</strong>：线程以不一致顺序访问数据或资源</p>
</li>
<li>
<p><strong>死锁</strong>：两个线程相互等待导致都无法继续</p>
</li>
<li>
<p>仅特定场景出现的 Bug：难以可靠复现和修复</p>
</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Rust 试图减轻使用线程的负面影响，但多线程编程仍需谨慎思考，且代码结构需不同于单线程程序。</p>
<p>Programming languages implement threads in a few different ways, and many
operating systems provide an API the programming language can call for creating
new threads. The Rust standard library uses a <em>1:1</em> model of thread
implementation, whereby a program uses one operating system thread per one
language thread. There are crates that implement other models of threading that
make different trade-offs to the 1:1 model. (Rust’s async system, which we will
see in the next chapter, provides another approach to concurrency as well.)</p>
<p>编程语言以几种不同方式实现线程，许多操作系统提供创建新线程的 API。Rust 标准库采用 <strong>1:1</strong> 线程模型，即每个语言线程对应一个操作系统线程。也有 crate 实现其他线程模型，权衡不同于 1:1 模型（Rust 的异步系统是另一种并发方案，将在下一章介绍）。</p>
<h3 id="creating-a-new-thread-with-spawn-使用-spawn-创建新线程"><a class="header" href="#creating-a-new-thread-with-spawn-使用-spawn-创建新线程">Creating a New Thread with <code>spawn</code> 使用 <code>spawn</code> 创建新线程</a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread.</p>
<p><span class="highlight">[note]创建新线程需调用 <code>thread::spawn</code> 函数并传递闭包</span>（第 13 章讨论过闭包），闭包包含要在新线程中运行的代码。示例 16-1 在主线程和新线程中分别打印文本。</p>
<figure class="listing" id="listing-16-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<figcaption><a href="ch16-01-threads.html#listing-16-1">Listing 16-1</a>: Creating a new thread to print one thing while the main thread prints something else 创建新线程，主线程和新线程同时打印内容</figcaption>
</figure>
<p>Note that when the main thread of a Rust program completes, all spawned threads
are shut down, whether or not they have finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<p>注意：当 Rust 程序的主线程结束时，所有派生线程无论是否完成都会被关闭。程序输出可能略有不同，但类似如下：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is <code>9</code>, it only got to <code>5</code>
before the main thread shut down.</p>
<p><span class="highlight">[note]<code>thread::sleep</code> 调用强制线程短暂暂停执行</span>，允许其他线程运行。线程可能轮流执行，但不保证：这取决于操作系统调度策略。此运行中主线程先打印，尽管派生线程的打印语句在代码中更靠前。虽然我们让派生线程打印到 <code>i</code> 为 <code>9</code>，但主线程关闭时它只打印到 <code>5</code>。</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<p>若运行此代码仅见主线程输出或无交替输出，尝试增大范围值以增加操作系统切换线程的机会。</p>
<h3 id="waiting-for-all-threads-to-finish-using-join-handles-使用-join-句柄等待所有线程完成"><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles-使用-join-句柄等待所有线程完成">Waiting for All Threads to Finish Using <code>join</code> Handles 使用 <code>join</code> 句柄等待所有线程完成</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but because there is no guarantee on
the order in which threads run, we also can’t guarantee that the spawned thread
will get to run at all!</p>
<p>示例 16-1 的代码不仅常因主线程结束而提前终止派生线程，且因线程执行顺序无保证，甚至无法确保派生线程能运行！</p>
<p>We can fix the problem of the spawned thread not running or of it ending
prematurely by saving the return value of <code>thread::spawn</code> in a variable. The
return type of <code>thread::spawn</code> is <code>JoinHandle&lt;T&gt;</code>. A <code>JoinHandle&lt;T&gt;</code> is an
owned value that, when we call the <code>join</code> method on it, will wait for its
thread to finish. Listing 16-2 shows how to use the <code>JoinHandle&lt;T&gt;</code> of the
thread we created in Listing 16-1 and how to call <code>join</code> to make sure the
spawned thread finishes before <code>main</code> exits.</p>
<p>通过将 <code>thread::spawn</code> 返回值存入变量可解决派生线程未运行或提前结束的问题。<span class="highlight">[note]<code>thread::spawn</code> 返回 <code>JoinHandle&lt;T&gt;</code> 类型。<code>JoinHandle&lt;T&gt;</code> 是一个拥有值，对其调用 <code>join</code> 方法会等待其线程结束。</span>示例 16-2 展示如何使用示例 16-1 中线程的 <code>JoinHandle&lt;T&gt;</code> 并调用 <code>join</code> 确保派生线程在 <code>main</code> 退出前完成。</p>
<figure class="listing" id="listing-16-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<figcaption><a href="ch16-01-threads.html#listing-16-2">Listing 16-2</a>: Saving a <code>JoinHandle&lt;T&gt;</code> from <code>thread::spawn</code> to guarantee the thread is run to completion 保存 <code>thread::spawn</code> 的 <code>JoinHandle&lt;T&gt;</code> 确保线程运行完成</figcaption>
</figure>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<p>对句柄调用 <code>join</code> 会阻塞当前线程，直到句柄代表的线程终止。<strong>阻塞</strong>线程意味着阻止其执行工作或退出。因将 <code>join</code> 调用置于主线程 <code>for</code> 循环后，运行示例 16-2 应产生类似输出：</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>两线程继续交替执行，但主线程因 <code>handle.join()</code> 调用而等待，直到派生线程结束后才退出。</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p>但若将 <code>handle.join()</code> 移到 <code>main</code> 的 <code>for</code> 循环之前，如下所示：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</figure>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<p>主线程将等待派生线程完成后再运行其 <code>for</code> 循环，因此输出不再交替，如下所示：</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<p>细微之处（如 <code>join</code> 的调用位置）会影响线程是否同时运行。</p>
<h3 id="using-move-closures-with-threads-在线程中使用-move-闭包"><a class="header" href="#using-move-closures-with-threads-在线程中使用-move-闭包">Using <code>move</code> Closures with Threads 在线程中使用 <code>move</code> 闭包</a></h3>
<p>We’ll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code>
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In “Capturing References or Moving Ownership” in Chapter 13, we discussed <code>move</code> in the context of closures. Now we’ll
concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>传递给 <code>thread::spawn</code> 的闭包常需使用 <code>move</code> 关键字，因为闭包会获取其使用环境值的所有权，从而将所有权从一个线程转移到另一个线程。第 13 章“捕获引用或移动所有权”中讨论过闭包的 <code>move</code>。现在我们将更关注 <code>move</code> 与 <code>thread::spawn</code> 的交互。</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t work yet, as you’ll see in a moment.</p>
<p>注意示例 16-1 中传递给 <code>thread::spawn</code> 的闭包无参数：派生线程未使用主线程中的任何数据。<span class="highlight">[note]要在派生线程中使用主线程数据，其闭包必须捕获所需值。</span>示例 16-3 尝试在主线程创建向量并在派生线程使用，但目前无法工作，稍后会看到原因。</p>
<figure class="listing" id="listing-16-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
<figcaption><a href="ch16-01-threads.html#listing-16-3">Listing 16-3</a>: Attempting to use a vector created by the main thread in another thread 尝试在主线程创建的向量在另一线程中使用</figcaption>
</figure>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<p>闭包使用 <code>v</code>，因此会捕获 <code>v</code> 并使其成为闭包环境的一部分。因 <code>thread::spawn</code> 在新线程运行闭包，应能在新线程内访问 <code>v</code>。但编译此示例会报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know whether the
reference to <code>v</code> will always be valid.</p>
<p>Rust <strong>推断</strong>如何捕获 <code>v</code>，因 <code>println!</code> 只需 <code>v</code> 的引用，闭包尝试借用 <code>v</code>。但存在问题：Rust 无法判断派生线程运行多久，故不知 <code>v</code> 的引用是否始终有效。</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid.</p>
<p>示例 16-4 展示了更可能导致 <code>v</code> 引用无效的场景。</p>
<figure class="listing" id="listing-16-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<figcaption><a href="ch16-01-threads.html#listing-16-4">Listing 16-4</a>: A thread with a closure that attempts to capture a reference to <code>v</code> from a main thread that drops <code>v</code> 线程闭包尝试捕获主线程 <code>v</code> 的引用，但主线程丢弃了 <code>v</code></figcaption>
</figure>
<p>If Rust allowed us to run this code, there’s a possibility that the spawned
thread would be immediately put in the background without running at all. The
spawned thread has a reference to <code>v</code> inside, but the main thread immediately
drops <code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>若 Rust 允许此代码运行，派生线程可能被立即置于后台而不运行。派生线程内含 <code>v</code> 的引用，但主线程立即用 <code>drop</code> 函数（第 15 章讨论过）丢弃 <code>v</code>。当派生线程开始执行时，<code>v</code> 已无效，其引用也无效。糟糕！</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<p>要修复示例 16-3 的编译错误，可使用错误提示建议：</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend.</p>
<p>在闭包前添加 <code>move</code> 关键字，强制闭包获取其使用值的所有权，而非让 Rust 推断借用值。示例 16-5 对示例 16-3 的修改可正常编译运行。</p>
<figure class="listing" id="listing-16-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
<figcaption><a href="ch16-01-threads.html#listing-16-5">Listing 16-5</a>: Using the <code>move</code> keyword to force a closure to take ownership of the values it uses 使用 <code>move</code> 关键字强制闭包获取所使用值的所有权</figcaption>
</figure>
<p>We might be tempted to try the same thing to fix the code in Listing 16-4 where
the main thread called <code>drop</code> by using a <code>move</code> closure. However, this fix will
not work because what Listing 16-4 is trying to do is disallowed for a
different reason. If we added <code>move</code> to the closure, we would move <code>v</code> into the
closure’s environment, and we could no longer call <code>drop</code> on it in the main
thread. We would get this compiler error instead:</p>
<p>我们可能想用相同方法修复示例 16-4（主线程调用 <code>drop</code>），但此修复无效，因为示例 16-4 的问题另有原因。若对闭包添加 <code>move</code>，会将 <code>v</code> 移入闭包环境，主线程无法再对其调用 <code>drop</code>。会得到以下编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing to Rust that the main thread won’t use <code>v</code> anymore.
If we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>Rust 的所有权规则再次拯救了我们！示例 16-3 的错误是因 Rust 保守地仅为线程借用 <code>v</code>，意味着主线程理论上可能使派生线程的引用失效。通过告知 Rust 将 <code>v</code> 所有权移至派生线程，我们向 Rust 保证主线程不再使用 <code>v</code>。若同样修改示例 16-4，则会在主线程使用 <code>v</code> 时违反所有权规则。<code>move</code> 关键字覆盖了 Rust 借用默认保守性，但不允许违反所有权规则。</p>
<p>Now that we’ve covered what threads are and the methods supplied by the thread
API, let’s look at some situations in which we can use threads.</p>
<p>现在介绍了线程及线程 API 的方法，来看一些使用线程的场景。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-message-passing-to-transfer-data-between-threads-使用消息传递在线程间传输数据"><a class="header" href="#using-message-passing-to-transfer-data-between-threads-使用消息传递在线程间传输数据">Using Message Passing to Transfer Data Between Threads 使用消息传递在线程间传输数据</a></h2>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message
passing</em>, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from <a href="https://golang.org/doc/effective_go.html#concurrency">the Go language documentation</a>:
“Do not communicate by sharing memory; instead, share memory by communicating.”</p>
<p>确保安全并发日益流行的方法是<strong>消息传递</strong>，线程或参与者通过相互发送包含数据的消息通信。以下是 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 语言文档</a> 的口号精髓：“不要通过共享内存来通信；相反，通过通信来共享内存。”</p>
<p>To accomplish message-sending concurrency, Rust’s standard library provides an
implementation of channels. A <em>channel</em> is a general programming concept by
which data is sent from one thread to another.</p>
<p>为实现消息发送并发，Rust 标准库提供了通道实现。<strong>通道</strong>是通用编程概念，数据通过其从一个线程发送到另一个线程。</p>
<p>You can imagine a channel in programming as being like a directional channel of
water, such as a stream or a river. If you put something like a rubber duck
into a river, it will travel downstream to the end of the waterway.</p>
<p>可将编程中的通道想象为单向水道（如溪流或河流）。若将橡皮鸭放入河流，它会顺流而下到水道终点。</p>
<p>A channel has two halves: a transmitter and a receiver. The transmitter half is
the upstream location where you put the rubber duck into the river, and the
receiver half is where the rubber duck ends up downstream. One part of your
code calls methods on the transmitter with the data you want to send, and
another part checks the receiving end for arriving messages. A channel is said
to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
<p>通道有两端：发送端和接收端。发送端是上游（放入橡皮鸭处），接收端是下游（橡皮鸭终点）。代码一部分调用发送端方法发送数据，另一部分检查接收端到达的消息。若发送端或接收端被丢弃，则称通道<strong>关闭</strong>。</p>
<p>Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels for any threads that need to communicate with each other, such as
a chat system or a system where many threads perform parts of a calculation and
send the parts to one thread that aggregates the results.</p>
<p>我们将编写一个程序：一个线程生成值并通过通道发送，另一个线程接收值并打印。使用通道发送简单值以演示特性。熟悉此技术后，可将通道用于任何需相互通信的线程（如聊天系统或多线程执行部分计算并将结果发送到聚合线程的系统）。</p>
<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.</p>
<p>首先在示例 16-6 <span class="highlight">[note]创建通道</span>但不操作。注意此代码尚不能编译，因 Rust 无法推断通道要发送的值类型。</p>
<figure class="listing" id="listing-16-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-6">Listing 16-6</a>: Creating a channel and assigning the two halves to <code>tx</code> and <code>rx</code> 创建通道并将两端赋值给 <code>tx</code> 和 <code>rx</code></figcaption>
</figure>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for
<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library
implements channels means a channel can have multiple <em>sending</em> ends that
produce values but only one <em>receiving</em> end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.</p>
<p>用 <code>mpsc::channel</code> 函数创建新通道；<code>mpsc</code> 表示<strong>多生产者，单消费者</strong>。简言之，Rust 标准库的通道实现允许多个<strong>发送端</strong>产生值，但仅一个<strong>接收端</strong>消费值。想象多条溪流汇入大河：任何溪流发送的内容都会在终点汇入同一条河。现在从单生产者开始，待此例运行后再添加多生产者。</p>
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the
sending end—the transmitter—and the second element of which is the receiving
end—the receiver. The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in
many fields for <em>transmitter</em> and <em>receiver</em>, respectively, so we name our
variables as such to indicate each end. We’re using a <code>let</code> statement with a
pattern that destructures the tuples; we’ll discuss the use of patterns in
<code>let</code> statements and destructuring in Chapter 19. For now, know that using a
<code>let</code> statement in this way is a convenient approach to extract the pieces of
the tuple returned by <code>mpsc::channel</code>.</p>
<p><code>mpsc::channel</code> 返回元组，第一元素是发送端（发送器），第二元素是接收端（接收器）。<span class="highlight">[note]传统上 <code>tx</code> 和 <code>rx</code> 分别缩写表示<strong>发送器</strong>和<strong>接收器</strong></span>，因此如此命名变量以区分两端。这里使用 <code>let</code> 语句和模式解构元组（第 19 章讨论）；目前只需知此方式可方便提取 <code>mpsc::channel</code> 返回元组的各部分。</p>
<p>Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.</p>
<p>将发送端移入派生线程并发送字符串，使派生线程与主线程通信，如示例 16-7 所示。这如同将橡皮鸭放入上游或线程间发送聊天消息。</p>
<figure class="listing" id="listing-16-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-7">Listing 16-7</a>: Moving <code>tx</code> to a spawned thread and sending <code>"hi"</code> 移动 <code>tx</code> 到派生线程并发送 <code>"hi"</code></figcaption>
</figure>
<p>Again, we’re using <code>thread::spawn</code> to create a new thread and then using <code>move</code>
to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code>. The spawned
thread needs to own the transmitter to be able to send messages through the
channel.</p>
<p>再次使用 <code>thread::spawn</code> 创建新线程并用 <code>move</code> 将 <code>tx</code> 移入闭包，使派生线程拥有 <code>tx</code>。派生线程需拥有发送器才能通过通道发送消息。</p>
<p>The transmitter has a <code>send</code> method that takes the value we want to send. The
<code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiver has already
been dropped and there’s nowhere to send a value, the send operation will
return an error. In this example, we’re calling <code>unwrap</code> to panic in case of an
error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.</p>
<p><span class="highlight">[note]发送器有 <code>send</code> 方法，接收要发送的值。<code>send</code> 返回 <code>Result&lt;T, E&gt;</code> 类型，因此若接收端已被丢弃且无处发送值，发送操作将返回错误。</span>本例中调用 <code>unwrap</code> 在错误时 panic。实际应用中应正确处理：回顾第 9 章的错误处理策略。</p>
<p><span class="highlight">[note]注：<code>send</code>不因无接收动作而阻塞。</span></p>
<p>In Listing 16-8, we’ll get the value from the receiver in the main thread. This
is like retrieving the rubber duck from the water at the end of the river or
receiving a chat message.</p>
<p>在示例 16-8，主线程从接收端获取值。这如同从终点取出橡皮鸭或接收聊天消息。</p>
<figure class="listing" id="listing-16-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-8">Listing 16-8</a>: Receiving the value <code>"hi"</code> in the main thread and printing it 在主线程接收值 <code>"hi"</code> 并打印</figcaption>
</figure>
<p>The receiver has two useful methods: <code>recv</code> and <code>try_recv</code>. We’re using <code>recv</code>,
short for <em>receive</em>, which will block the main thread’s execution and wait
until a value is sent down the channel. Once a value is sent, <code>recv</code> will
return it in a <code>Result&lt;T, E&gt;</code>. When the transmitter closes, <code>recv</code> will return
an error to signal that no more values will be coming.</p>
<p><span class="highlight">[note]接收端有两个实用方法：<code>recv</code> 和 <code>try_recv</code>。这里用 <code>recv</code>（receive 缩写）会阻塞主线程直到通道发送值。值发送后，<code>recv</code> 返回 <code>Result&lt;T, E&gt;</code>。发送器关闭时，<code>recv</code> 返回错误表示不再有值。</span></p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&lt;T, E&gt;</code>
immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code>
value if there aren’t any messages this time. Using <code>try_recv</code> is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls <code>try_recv</code> every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.</p>
<p><span class="highlight">[note]<code>try_recv</code> 方法不阻塞</span>，而是立即返回 <code>Result&lt;T, E&gt;</code>：若有消息则为包含消息的 <code>Ok</code>，若无则为 <code>Err</code>。若线程需在等待消息时执行其他工作，<code>try_recv</code> 很有用：可编写循环定期调用 <code>try_recv</code>，处理消息（若有），否则执行其他工作直到下次检查。</p>
<p>We’ve used <code>recv</code> in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.</p>
<p>此例为简化使用 <code>recv</code>；主线程除等待消息外无其他工作，因此阻塞主线程合适。</p>
<p>When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:</p>
<p>运行示例 16-8 的代码，主线程打印值：</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<p>完美！</p>
<h3 id="channels-and-ownership-transference-通道与所有权转移"><a class="header" href="#channels-and-ownership-transference-通道与所有权转移">Channels and Ownership Transference 通道与所有权转移</a></h3>
<p>The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a <code>val</code> value in the spawned thread <em>after</em> we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed.</p>
<p>所有权规则在消息传递中至关重要，因其助你编写安全的并发代码。在 Rust 程序中全面考虑所有权可防止并发错误。我们通过实验展示通道和所有权如何协同防止问题：尝试在发送值后于派生线程中使用 <code>val</code> 值。尝试编译示例 16-9 的代码以解其不被允许的原因。</p>
<figure class="listing" id="listing-16-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-9">Listing 16-9</a>: Attempting to use <code>val</code> after we’ve sent it down the channel 尝试在值发送后使用 <code>val</code></figcaption>
</figure>
<p>Here, we try to print <code>val</code> after we’ve sent it down the channel via <code>tx.send</code>.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:</p>
<p>此处尝试在通过 <code>tx.send</code> 发送后打印 <code>val</code>。允许此操作是坏主意：因值发送到另一线程后，该线程可能在我们重用前修改或丢弃它。另一线程的修改可能导致数据不一致或不存在而产生错误或意外结果。但 Rust 在编译示例 16-9 时会报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Our concurrency mistake has caused a compile-time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<p>并发错误导致了编译时错误。<code>send</code> 函数获取参数的所有权，值移动时接收端获取所有权。这防止我们意外重用发送后的值；所有权系统确保一切正常。</p>
<h3 id="sending-multiple-values-and-seeing-the-receiver-waiting-发送多值并观察接收端等待"><a class="header" href="#sending-multiple-values-and-seeing-the-receiver-waiting-发送多值并观察接收端等待">Sending Multiple Values and Seeing the Receiver Waiting 发送多值并观察接收端等待</a></h3>
<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel.</p>
<p>示例 16-8 的代码可编译运行，但未清晰展示两线程通过通道通信。</p>
<p>In Listing 16-10 we’ve made some modifications that will prove the code in
Listing 16-8 is running concurrently: the spawned thread will now send multiple
messages and pause for a second between each message.</p>
<p>示例 16-10 的修改将证明示例 16-8 并发运行：派生线程现在发送多条消息，每条间隔一秒。</p>
<figure class="listing" id="listing-16-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-10">Listing 16-10</a>: Sending multiple messages and pausing between each one 发送多条消息，每条间隔一秒</figcaption>
</figure>
<p>This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
one second.</p>
<p>派生线程现有一个字符串向量要发送到主线程。我们逐个发送，每条间隔一秒（通过 <code>thread::sleep</code> 和 <code>Duration</code> 值实现）。</p>
<p>In the main thread, we’re not calling the <code>recv</code> function explicitly anymore:
instead, we’re treating <code>rx</code> as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.</p>
<p>主线程不再显式调用 <code>recv</code>：而是<span class="highlight">[note]将 <code>rx</code> 视为迭代器。对每个接收值打印。通道关闭时迭代结束。</span></p>
<p>When running the code in Listing 16-10, you should see the following output
with a one-second pause in between each line:</p>
<p>运行示例 16-10 的代码，应在每行输出间看到一秒停顿：</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don’t have any code that pauses or delays in the <code>for</code> loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.</p>
<p>因主线程的 <code>for</code> 循环无暂停或延迟代码，可知主线程在等待派生线程发送值。</p>
<h3 id="creating-multiple-producers-by-cloning-the-transmitter-克隆发送端以创建多生产者"><a class="header" href="#creating-multiple-producers-by-cloning-the-transmitter-克隆发送端以创建多生产者">Creating Multiple Producers by Cloning the Transmitter 克隆发送端以创建多生产者</a></h3>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple producer,
single consumer</em>. Let’s put <code>mpsc</code> to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitter, as shown in Listing 16-11.</p>
<p>前文提到 <code>mpsc</code> 表示<strong>多生产者，单消费者</strong>。现使用 <code>mpsc</code> 扩展示例 16-10 的代码，创建多线程向同一接收端发送值。如示例 16-11 所示，通过克隆发送端实现。</p>
<figure class="listing" id="listing-16-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
<figcaption><a href="ch16-02-message-passing.html#listing-16-11">Listing 16-11</a>: Sending multiple messages from multiple producers 从多生产者发送多条消息</figcaption>
</figure>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
transmitter. This will give us a new transmitter we can pass to the first
spawned thread. We pass the original transmitter to a second spawned thread.
This gives us two threads, each sending different messages to the one receiver.</p>
<p>此次在创建第一个派生线程前，<span class="highlight">[note]对发送端调用 <code>clone</code></span>。这提供新发送端传递给第一个派生线程。原始发送端传递给第二个派生线程。这产生两个线程，各自向同一接收端发送不同消息。</p>
<p>When you run the code, your output should look something like this:</p>
<p>运行代码，输出类似如下：</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order, depending on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
<code>thread::sleep</code>, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.</p>
<p>值顺序可能因系统而异。这正是并发有趣且困难之处。若用 <code>thread::sleep</code> 在不同线程设置不同值，每次运行将更不确定且输出不同。</p>
<p>Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.</p>
<p>了解通道工作原理后，再看另一种并发方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shared-state-concurrency-共享状态并发"><a class="header" href="#shared-state-concurrency-共享状态并发">Shared-State Concurrency 共享状态并发</a></h2>
<p>Message passing is a fine way to handle concurrency, but it’s not the only way.
Another method would be for multiple threads to access the same shared data.
Consider this part of the slogan from the Go language documentation again: “Do
not communicate by sharing memory.”</p>
<p>消息传递是处理并发的良方，但非唯一方法。另一种方法是多线程访问同一共享数据。再思考 Go 文档的口号：“不要通过共享内存来通信。”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts caution not to use memory sharing?</p>
<p>共享内存通信是何种形式？为何消息传递倡导者警告勿用共享内存？</p>
<p>In a way, channels in any programming language are similar to single ownership
because once you transfer a value down a channel, you should no longer use that
value. Shared-memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.</p>
<p>某种程度上，任何语言的通道都类似单一所有权，因值传输后不应再使用。共享内存并发类似多所有权：多线程可同时访问同一内存位置。如第 15 章所述，智能指针使多所有权成为可能，但管理不同所有者会增加复杂性。Rust 的类型系统和所有权规则极大助力此管理的正确性。以互斥锁为例，这是共享内存的常见并发原语。</p>
<h3 id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time-使用互斥锁确保线程独占访问数据"><a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time-使用互斥锁确保线程独占访问数据">Using Mutexes to Allow Access to Data from One Thread at a Time 使用互斥锁确保线程独占访问数据</a></h3>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s lock. The <em>lock</em> is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p><strong>互斥锁</strong>（Mutex）是“相互排斥”的缩写，因其一次仅允许一个线程访问数据。要访问互斥锁数据，线程需先请求获取锁来发出访问信号。<strong>锁</strong>是互斥锁的数据结构，跟踪当前谁独占访问数据。因此，互斥锁通过锁定系统<strong>守护</strong>其数据。</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<p>互斥锁因难用而闻名，因需记住两条规则：</p>
<ol>
<li>
<p>You must attempt to acquire the lock before using the data.</p>
</li>
<li>
<p>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</p>
</li>
<li>
<p>使用数据前必须尝试获取锁</p>
</li>
<li>
<p>使用完互斥锁守护的数据后必须解锁，以便其他线程获取锁</p>
</li>
</ol>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!</p>
<p>互斥锁的现实隐喻：会议小组讨论仅有一个麦克风。发言前需请求使用麦克风。获得后发言时长不限，结束后传递给下一位请求发言者。若发言后未传递麦克风，其他人将无法发言。共享麦克风管理出错将导致讨论混乱！</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.</p>
<p>互斥锁管理可能极其复杂，因此许多人热衷通道。但得益于 Rust 的类型系统和所有权规则，锁定和解锁不会出错。</p>
<h4 id="the-api-of-mutext-mutext-的-api"><a class="header" href="#the-api-of-mutext-mutext-的-api">The API of <code>Mutex&lt;T&gt;</code> <code>Mutex&lt;T&gt;</code> 的 API</a></h4>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12.</p>
<p>以单线程上下文使用互斥锁为例，如示例 16-12。</p>
<figure class="listing" id="listing-16-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
<figcaption><a href="ch16-03-shared-state.html#listing-16-12">Listing 16-12</a>: Exploring the API of <code>Mutex&lt;T&gt;</code> in a single-threaded context for simplicity 在单线程中探索 <code>Mutex&lt;T&gt;</code> API</figcaption>
</figure>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>与许多类型相同，我们用<span class="highlight">[note]关联函数 <code>new</code> 创建 <code>Mutex&lt;T&gt;</code>。要访问互斥锁内部数据，需用 <code>lock</code> 方法获取锁。此调用阻塞当前线程直到轮到我们持有锁。</span></p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p><span class="highlight">[note]若持有锁的线程 panic，<code>lock</code> 调用会失败。</span>此时无人能获取锁，故选择 <code>unwrap</code> 让此线程 panic。</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>. The type of <code>m</code> is
<code>Mutex&lt;i32&gt;</code>, not <code>i32</code>, so we <em>must</em> call <code>lock</code> to be able to use the <code>i32</code>
value. We can’t forget; the type system won’t let us access the inner <code>i32</code>
otherwise.</p>
<p><span class="highlight">[note]获取锁后，可将返回值（此处为 <code>num</code>）视为内部数据的可变引用。</span>类型系统确保使用数据前先获取锁。<code>m</code> 类型为 <code>Mutex&lt;i32&gt;</code> 而非 <code>i32</code>，故<strong>必须</strong>调用 <code>lock</code> 才能使用 <code>i32</code> 值。类型系统防止我们以其他方式访问内部 <code>i32</code>。</p>
<p>The call to <code>lock</code> returns a type called <code>MutexGuard</code>, wrapped in a
<code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> type
implements <code>Deref</code> to point at our inner data; the type also has a <code>Drop</code>
implementation that releases the lock automatically when a <code>MutexGuard</code> goes
out of scope, which happens at the end of the inner scope. As a result, we
don’t risk forgetting to release the lock and blocking the mutex from being
used by other threads because the lock release happens automatically.</p>
<p><span class="highlight">[note]<code>lock</code> 调用返回名为 <code>MutexGuard</code> 的类型，包装在 <code>LockResult</code> 中（通过 <code>unwrap</code> 处理）。<code>MutexGuard</code> 实现 <code>Deref</code> 指向内部数据；其还有 <code>Drop</code> 实现，在 <code>MutexGuard</code> 离开作用域时自动释放锁。</span>因此，我们不会忘记释放锁导致互斥锁被其他线程阻塞。</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to <code>6</code>.</p>
<p>释放锁后，可打印互斥锁值，可见内部 <code>i32</code> 成功改为 <code>6</code>。</p>
<h4 id="sharing-a-mutext-between-multiple-threads-多线程间共享-mutext"><a class="header" href="#sharing-a-mutext-between-multiple-threads-多线程间共享-mutext">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads 多线程间共享 <code>Mutex&lt;T&gt;</code></a></h4>
<p>Now let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>. We’ll
spin up 10 threads and have them each increment a counter value by 1, so the
counter goes from 0 to 10. The example in Listing 16-13 will have a compiler
error, and we’ll use that error to learn more about using <code>Mutex&lt;T&gt;</code> and how
Rust helps us use it correctly.</p>
<p>现尝试用 <code>Mutex&lt;T&gt;</code> 在线程间共享值。启动 10 个线程，每个将计数器值增加 1，使计数器从 0 到 10。示例 16-13 将产生编译错误，我们将借此学习 <code>Mutex&lt;T&gt;</code> 的使用及 Rust 如何助其正确使用。</p>
<figure class="listing" id="listing-16-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="ch16-03-shared-state.html#listing-16-13">Listing 16-13</a>: Ten threads, each incrementing a counter guarded by a <code>Mutex&lt;T&gt;</code> 十个线程，每个递增 <code>Mutex&lt;T&gt;</code> 守护的计数器</figcaption>
</figure>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we did
in Listing 16-12. Next, we create 10 threads by iterating over a range of
numbers. We use <code>thread::spawn</code> and give all the threads the same closure: one
that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by
calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>创建 <code>counter</code> 变量持有 <code>Mutex&lt;T&gt;</code> 内的 <code>i32</code>（同示例 16-12）。接着通过数字范围迭代创建 10 个线程。使用 <code>thread::spawn</code> 并传递相同闭包：移动 <code>counter</code> 到线程，调用 <code>lock</code> 方法获取 <code>Mutex&lt;T&gt;</code> 的锁，然后将互斥锁值加 1。线程运行完闭包后，<code>num</code> 离开作用域并释放锁，其他线程可获取。</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call <code>join</code> on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.</p>
<p>主线程收集所有连接句柄。然后同示例 16-2，在每个句柄调用 <code>join</code> 确保所有线程完成。此时主线程获取锁并打印结果。</p>
<p>We hinted that this example wouldn’t compile. Now let’s find out why!</p>
<p>此例无法编译。现在找出原因！</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>The error message states that the <code>counter</code> value was moved in the previous
iteration of the loop. Rust is telling us that we can’t move the ownership of
lock <code>counter</code> into multiple threads. Let’s fix the compiler error with the
multiple-ownership method we discussed in Chapter 15.</p>
<p>错误信息表明 <code>counter</code> 值在上次循环迭代中被移动。Rust 提示无法将锁 <code>counter</code> 的所有权移入多个线程。用第 15 章的多所有权方法修复此错误。</p>
<h4 id="multiple-ownership-with-multiple-threads-多线程的多所有权"><a class="header" href="#multiple-ownership-with-multiple-threads-多线程的多所有权">Multiple Ownership with Multiple Threads 多线程的多所有权</a></h4>
<p>In Chapter 15, we gave a value to multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread.</p>
<p>第 15 章用智能指针 <code>Rc&lt;T&gt;</code> 创建引用计数值实现多所有权。现尝试相同方法，如示例 16-14 所示。</p>
<figure class="listing" id="listing-16-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
<figcaption><a href="ch16-03-shared-state.html#listing-16-14">Listing 16-14</a>: Attempting to use <code>Rc&lt;T&gt;</code> to allow multiple threads to own the <code>Mutex&lt;T&gt;</code> 尝试用 <code>Rc&lt;T&gt;</code> 允许多线程拥有 <code>Mutex&lt;T&gt;</code></figcaption>
</figure>
<p>Once again, we compile and get… different errors! The compiler is teaching us a
lot.</p>
<p>再次编译后…出现不同错误！编译器教会我们许多。</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:728:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Wow, that error message is very wordy! Here’s the important part to focus on:
<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The compiler is
also telling us the reason why: <code>the trait `Send` is not implemented for  `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. We’ll talk about <code>Send</code> in the next section: it’s one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.</p>
<p>重点在于：<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。编译器也给出原因：<code>the trait `Send` is not implemented for  `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>。下节讨论 <code>Send</code>：它是确保类型用于并发场景的特征之一。</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type that is exactly like <code>Rc&lt;T&gt;</code>, but that makes
changes to the reference count in a thread-safe way.</p>
<p>不幸的是，<span class="highlight">[note]<code>Rc&lt;T&gt;</code> 不能安全跨线程共享。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，<code>clone</code> 调用增加计数，<code>drop</code> 调用减少计数。但未使用任何并发原语确保计数更改不被其他线程中断。</span>这可能导致计数错误（进而导致内存泄漏或值提前丢弃）。我们需要类似 <code>Rc&lt;T&gt;</code> 但线程安全更改引用计数的类型。</p>
<h4 id="atomic-reference-counting-with-arct-原子引用计数-arct"><a class="header" href="#atomic-reference-counting-with-arct-原子引用计数-arct">Atomic Reference Counting with <code>Arc&lt;T&gt;</code> 原子引用计数 <code>Arc&lt;T&gt;</code></a></h4>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically
reference-counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <code>std::sync::atomic</code> for more
details. At this point, you just need to know that atomics work like primitive
types but are safe to share across threads.</p>
<p>幸运的是，<span class="highlight">[note]<code>Arc&lt;T&gt;</code> 正是类似 <code>Rc&lt;T&gt;</code> 但线程安全的类型。<strong>a</strong> 代表<strong>原子性</strong>（atomic），即<strong>原子引用计数</strong>类型。</span>原子是另一种并发原语（此处不赘述），详见标准库文档 <a href="https://doc.rust-lang.org/std/sync/atomic/"><code>std::sync::atomic</code></a>。目前只需知原子类型类似原始类型但可安全跨线程共享。</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>你可能好奇为何所有原始类型非原子，以及标准库类型为何不默认用 <code>Arc&lt;T&gt;</code>。原因是<span class="highlight">[note]线程安全需性能代价，仅当真正需要时才应支付</span>。若仅在单线程操作值，不强制原子保证可使代码更快。</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run.</p>
<p>回到示例：<code>Arc&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> API 相同，故修改 <code>use</code> 行、<code>new</code> 和 <code>clone</code> 调用即可。示例 16-15 最终可编译运行。</p>
<figure class="listing" id="listing-16-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
<figcaption><a href="ch16-03-shared-state.html#listing-16-15">Listing 16-15</a>: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code> to be able to share ownership across multiple threads 使用 <code>Arc&lt;T&gt;</code> 包装 <code>Mutex&lt;T&gt;</code> 以跨线程共享所有权</figcaption>
</figure>
<p>This code will print the following:</p>
<p>代码将打印：</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<p>成功了！从 0 计数到 10 可能不惊人，但教会我们许多 <code>Mutex&lt;T&gt;</code> 和线程安全知识。你也可用此程序结构执行比递增计数器更复杂的操作。使用此策略，可将计算拆分为独立部分，分配到不同线程，然后用 <code>Mutex&lt;T&gt;</code> 让每个线程更新其部分的最终结果。</p>
<p>Note that if you are doing simple numerical operations, there are types simpler
than <code>Mutex&lt;T&gt;</code> types provided by the <code>std::sync::atomic</code> module of the
standard library. These types provide safe, concurrent,
atomic access to primitive types. We chose to use <code>Mutex&lt;T&gt;</code> with a primitive
type for this example so we could concentrate on how <code>Mutex&lt;T&gt;</code> works.</p>
<p>注意：<span class="highlight">[note]若进行简单数值操作，标准库的 <code>std::sync::atomic</code> 模块提供比 <code>Mutex&lt;T&gt;</code> 更简单的类型。</span>这些类型提供对原始类型的安全并发原子访问。此例选择对原始类型用 <code>Mutex&lt;T&gt;</code> 是为专注于 <code>Mutex&lt;T&gt;</code> 工作原理。</p>
<h3 id="similarities-between-refcelltrct-and-mutextarct-refcelltrct-与-mutextarct-的相似性"><a class="header" href="#similarities-between-refcelltrct-and-mutextarct-refcelltrct-与-mutextarct-的相似性">Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 的相似性</a></h3>
<p>You might have noticed that <code>counter</code> is immutable but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in
Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code>
to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>你可能注意到 <code>counter</code> 不可变但能获取内部值的可变引用；这意味着 <code>Mutex&lt;T&gt;</code> 提供<strong>内部可变性</strong>（同 <code>Cell</code> 系列）。类似第 15 章用 <code>RefCell&lt;T&gt;</code> 在 <code>Rc&lt;T&gt;</code> 内部可变内容，我们用 <code>Mutex&lt;T&gt;</code> 在 <code>Arc&lt;T&gt;</code> 内部可变内容。</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall from Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>另需注意：使用 <code>Mutex&lt;T&gt;</code> 时，Rust 无法防止所有逻辑错误。回顾第 15 章，<span class="highlight">[note]使用 <code>Rc&lt;T&gt;</code> 有创建引用循环的风险（两个 <code>Rc&lt;T&gt;</code> 相互引用导致内存泄漏）。类似地，<code>Mutex&lt;T&gt;</code> 有创建<strong>死锁</strong>的风险。</span>死锁发生在操作需锁两个资源，而两线程各持有一个锁时，导致彼此永久等待。若对死锁感兴趣，可尝试用 Rust 编写死锁程序，研究任意语言的互斥锁死锁缓解策略并在 Rust 中实现。<code>Mutex&lt;T&gt;</code> 和 <code>MutexGuard</code> 的标准库 API 文档提供了有用信息。</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
<p>最后讨论 <code>Send</code> 和 <code>Sync</code> 特征及其在自定义类型中的应用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extensible-concurrency-with-the-send-and-sync-traits-通过-send-和-sync-特征扩展并发"><a class="header" href="#extensible-concurrency-with-the-send-and-sync-traits-通过-send-和-sync-特征扩展并发">Extensible Concurrency with the <code>Send</code> and <code>Sync</code> Traits 通过 <code>Send</code> 和 <code>Sync</code> 特征扩展并发</a></h2>
<p>Interestingly, almost every concurrency feature we’ve talked about so far in
this chapter has been part of the standard library, not the language. Your
options for handling concurrency are not limited to the language or the
standard library; you can write your own concurrency features or use those
written by others.</p>
<p>有趣的是，本章讨论的多数并发特性属于标准库而非语言本身。处理并发的选择不限于语言或标准库；可编写自己的并发特性或使用他人编写的。</p>
<p>However, among the key concurrency concepts that are embedded in the language
rather than the standard library are the <code>std::marker</code> traits <code>Send</code> and <code>Sync</code>.</p>
<p>但<span class="highlight">[note]语言本身（而非标准库）的关键并发概念是 <code>std::marker</code> 特征 <code>Send</code> 和 <code>Sync</code>。</span></p>
<h3 id="allowing-transference-of-ownership-between-threads-with-send-用-send-允许所有权在线程间转移"><a class="header" href="#allowing-transference-of-ownership-between-threads-with-send-用-send-允许所有权在线程间转移">Allowing Transference of Ownership Between Threads with <code>Send</code> 用 <code>Send</code> 允许所有权在线程间转移</a></h3>
<p>The <code>Send</code> marker trait indicates that ownership of values of the type
implementing <code>Send</code> can be transferred between threads. Almost every Rust type
implements <code>Send</code>, but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this
cannot implement <code>Send</code> because if you cloned an <code>Rc&lt;T&gt;</code> value and tried to
transfer ownership of the clone to another thread, both threads might update
the reference count at the same time. For this reason, <code>Rc&lt;T&gt;</code> is implemented
for use in single-threaded situations where you don’t want to pay the
thread-safe performance penalty.</p>
<p><span class="highlight">[note]<code>Send</code> 标记特征表示实现 <code>Send</code> 的类型值可跨线程转移所有权。几乎所有 Rust 类型都实现 <code>Send</code>，但例外包括 <code>Rc&lt;T&gt;</code></span>：若克隆 <code>Rc&lt;T&gt;</code> 值并尝试将克隆所有权转移到另一线程，两线程可能同时更新引用计数。因此 <code>Rc&lt;T&gt;</code> 仅用于单线程场景（避免线程安全性能代价）。</p>
<p>Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait `Send` is not implemented  for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. When we switched to <code>Arc&lt;T&gt;</code>, which does implement
<code>Send</code>, the code compiled.</p>
<p>因此，Rust 的类型系统和特征边界确保不会意外不安全地跨线程发送 <code>Rc&lt;T&gt;</code> 值。尝试在示例 16-14 中操作时，出现错误 <code>the trait `Send` is not implemented  for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>。改用实现 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 后，代码成功编译。</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we’ll discuss in Chapter 20.</p>
<p><span class="highlight">[note]完全由 <code>Send</code> 类型组成的类型自动标记为 <code>Send</code>。除原始指针（第 20 章讨论）外，几乎所有原始类型都是 <code>Send</code>。</span></p>
<h3 id="allowing-access-from-multiple-threads-with-sync-用-sync-允许多线程访问"><a class="header" href="#allowing-access-from-multiple-threads-with-sync-用-sync-允许多线程访问">Allowing Access from Multiple Threads with <code>Sync</code> 用 <code>Sync</code> 允许多线程访问</a></h3>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code>
implements <code>Sync</code> if <code>&amp;T</code> (an immutable reference to <code>T</code>) implements <code>Send</code>,
meaning the reference can be sent safely to another thread. Similar to <code>Send</code>,
primitive types all implement <code>Sync</code>, and types composed entirely of types that
implement <code>Sync</code> also implement <code>Sync</code>.</p>
<p><span class="highlight">[note]<code>Sync</code> 标记特征表示实现 <code>Sync</code> 的类型可安全地被多线程引用。换言之，若 <code>&amp;T</code>（<code>T</code> 的不可变引用）实现 <code>Send</code>（即引用可安全发送到另一线程），则类型 <code>T</code> 实现 <code>Sync</code>。与 <code>Send</code> 类似，原始类型都实现 <code>Sync</code>，完全由 <code>Sync</code> 类型组成的类型也实现 <code>Sync</code>。</span></p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> also doesn’t implement <code>Sync</code> for the same reasons
that it doesn’t implement <code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about
in Chapter 15) and the family of related <code>Cell&lt;T&gt;</code> types don’t implement
<code>Sync</code>. The implementation of borrow checking that <code>RefCell&lt;T&gt;</code> does at runtime
is not thread-safe. The smart pointer <code>Mutex&lt;T&gt;</code> implements <code>Sync</code> and can be
used to share access with multiple threads, as you saw in “Sharing a
<code>Mutex&lt;T&gt;</code> Between Multiple
Threads”.</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 同样因 <code>Send</code> 的相同原因不实现 <code>Sync</code>。<code>RefCell&lt;T&gt;</code> 类型（第 15 章讨论）及相关 <code>Cell&lt;T&gt;</code> 类型不实现 <code>Sync</code>。<code>RefCell&lt;T&gt;</code> 的运行时借用检查非线程安全。智能指针 <code>Mutex&lt;T&gt;</code> 实现 <code>Sync</code> 且可共享访问多线程（如“多线程间共享 <code>Mutex&lt;T&gt;</code>”所示）。</p>
<h3 id="implementing-send-and-sync-manually-is-unsafe-手动实现-send-和-sync-不安全"><a class="header" href="#implementing-send-and-sync-manually-is-unsafe-手动实现-send-和-sync-不安全">Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe 手动实现 <code>Send</code> 和 <code>Sync</code> 不安全</a></h3>
<p>Because types composed entirely of other types that implement the <code>Send</code> and
<code>Sync</code> traits also automatically implement <code>Send</code> and <code>Sync</code>, we don’t have to
implement those traits manually. As marker traits, they don’t even have any
methods to implement. They’re just useful for enforcing invariants related to
concurrency.</p>
<p>因完全由实现 <code>Send</code> 和 <code>Sync</code> 特征的类型组成的类型自动实现这些特征，故无需手动实现。作为标记特征，它们甚至无需实现方法。它们仅用于强制并发相关的不变性。</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 20; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees. “The
Rustonomicon” has more information about these guarantees and how to
uphold them.</p>
<p>手动实现这些特征涉及不安全 Rust 代码（第 20 章讨论）。目前需知：构建非由 <code>Send</code> 和 <code>Sync</code> 部分组成的并发新类型需谨慎思考以保证安全。《<a href="https://doc.rust-lang.org/nomicon/">Rust 秘典</a>》有更多关于这些保证及如何维护的信息。</p>
<h2 id="summary-总结-15"><a class="header" href="#summary-总结-15">Summary 总结</a></h2>
<p>This isn’t the last you’ll see of concurrency in this book: the next chapter
focuses on async programming, and the project in Chapter 21 will use the
concepts in this chapter in a more realistic situation than the smaller
examples discussed here.</p>
<p>本书后续章节仍涉及并发：下一章聚焦异步编程，第 21 章项目将在比小示例更真实的场景使用本章概念。</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>如前所述，Rust 处理并发的方式极少属于语言本身，故许多并发方案以 crate 形式实现。这些 crate 比标准库发展更快，因此务必在线搜索当前多线程场景的最新 crate。</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Rust 标准库为并发场景提供通道消息传递和智能指针类型（如 <code>Mutex&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>）。类型系统和借用检查器确保使用这些方案的代码不会出现数据竞争或无效引用。一旦代码编译通过，可确信其能无忧运行于多线程。并发编程不再可怕：无畏地前进，让你的程序并发吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals-of-asynchronous-programming-async-await-futures-and-streams-异步编程基础"><a class="header" href="#fundamentals-of-asynchronous-programming-async-await-futures-and-streams-异步编程基础">Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams 异步编程基础</a></h1>
<p>Many operations we ask the computer to do can take a while to finish. It would
be nice if we could do something else while we are waiting for those
long-running processes to complete. Modern computers offer two techniques for
working on more than one operation at a time: parallelism and concurrency. Once
we start writing programs that involve parallel or concurrent operations,
though, we quickly encounter new challenges inherent to <em>asynchronous
programming</em>, where operations may not finish sequentially in the order they
were started. This chapter builds on Chapter 16’s use of threads for parallelism
and concurrency by introducing an alternative approach to asynchronous
programming: Rust’s Futures, Streams, the <code>async</code> and <code>await</code> syntax that
supports them, and the tools for managing and coordinating between asynchronous
operations.</p>
<p>我们要求计算机执行的许多操作可能需要一段时间才能完成。如果在等待这些长时间运行的过程完成时能做其他事情就好了。现代计算机提供了两种同时处理多个操作的技术：<strong>并行</strong>和<strong>并发</strong>。然而，一旦我们开始编写涉及并行或并发操作的程序，很快就会遇到<strong>异步编程</strong>固有的新挑战——操作可能不会按照启动顺序依次完成。本章在第16章使用线程实现并行与并发的基础上，介绍另一种异步编程方法：Rust 的 Future、Stream、支持它们的 <code>async</code> 和 <code>await</code> 语法，以及管理和协调异步操作的工具。</p>
<p>Let’s consider an example. Say you’re exporting a video you’ve created of a
family celebration, an operation that could take anywhere from minutes to hours.
The video export will use as much CPU and GPU power as it can. If you had only
one CPU core and your operating system didn’t pause that export until it
completed—that is, if it executed the export <em>synchronously</em>—you couldn’t do
anything else on your computer while that task was running. That would be a
pretty frustrating experience. Fortunately, your computer’s operating system
can, and does, invisibly interrupt the export often enough to let you get other
work done simultaneously.</p>
<p>考虑一个例子。假设你正在导出家庭庆祝活动的视频，该操作可能需要几分钟到几小时。视频导出会尽可能占用 CPU 和 GPU 资源。如果只有一个 CPU 核心，且操作系统在导出完成前不暂停（即<strong>同步</strong>执行导出），那么任务运行时你将无法在计算机上执行其他操作。这种体验相当令人沮丧。幸运的是，计算机操作系统能够（且确实）频繁地透明中断导出，让你同时完成其他工作。</p>
<p>Now say you’re downloading a video shared by someone else, which can also take a
while but does not take up as much CPU time. In this case, the CPU has to wait
for data to arrive from the network. While you can start reading the data once
it starts to arrive, it might take some time for all of it to show up. Even once
the data is all present, if the video is quite large, it could take at least a
second or two to load it all. That might not sound like much, but it’s a very
long time for a modern processor, which can perform billions of operations every
second. Again, your operating system will invisibly interrupt your program to
allow the CPU to perform other work while waiting for the network call to
finish.</p>
<p>再假设你正在下载他人分享的视频，这也需要时间但占用较少 CPU 时间。此时 CPU 需等待网络数据传输。虽然数据开始到达后即可读取，但全部数据到达可能需要时间。即使数据全部到位，若视频很大，加载也可能耗时一两秒。这对现代处理器来说很长（每秒可执行数十亿次操作）。同样，操作系统会透明中断程序，让 CPU 在等待网络调用完成时执行其他工作。</p>
<p>The video export is an example of a <em>CPU-bound</em> or <em>compute-bound</em> operation.
It’s limited by the computer’s potential data processing speed within the CPU or
GPU, and how much of that speed it can dedicate to the operation. The video
download is an example of an <em>IO-bound</em> operation, because it’s limited by the
speed of the computer’s <em>input and output</em>; it can only go as fast as the data
can be sent across the network.</p>
<p>视频导出是 <strong>CPU 密集型</strong>（或<strong>计算密集型</strong>）操作的例子，其性能受限于 CPU/GPU 的数据处理能力及分配给该操作的资源。视频下载则是 <strong>I/O 密集型</strong>操作的例子，因为它受限于计算机的<strong>输入/输出速度</strong>，只能以网络传输数据的速度进行。</p>
<p>In both of these examples, the operating system’s invisible interrupts provide a
form of concurrency. That concurrency happens only at the level of the entire
program, though: the operating system interrupts one program to let other
programs get work done. In many cases, because we understand our programs at a
much more granular level than the operating system does, we can spot
opportunities for concurrency that the operating system can’t see.</p>
<p>这两个例子中，操作系统的透明中断提供了并发性。但这种并发仅在程序级别发生：操作系统中断一个程序以让其他程序工作。通常，由于我们比操作系统更细致地理解程序，能发现操作系统无法察觉的并发机会。</p>
<p>For example, if we’re building a tool to manage file downloads, we should be
able to write our program so that starting one download won’t lock up the UI,
and users should be able to start multiple downloads at the same time. Many
operating system APIs for interacting with the network are <em>blocking</em>, though;
that is, they block the program’s progress until the data they’re processing is
completely ready.</p>
<p>例如，构建文件下载管理工具时，程序应支持启动下载时不锁定 UI，且用户应能同时启动多个下载。但许多与网络交互的操作系统 API 是<strong>阻塞的</strong>——即它们会阻塞程序进度，直到处理的数据完全就绪。</p>
<section class="note" aria-role="note">
<p>Note: This is how <em>most</em> function calls work, if you think about it. However,
the term <em>blocking</em> is usually reserved for function calls that interact with
files, the network, or other resources on the computer, because those are the
cases where an individual program would benefit from the operation being
<em>non</em>-blocking.</p>
<p>注意：细想之下，<strong>大多数</strong>函数调用都是如此。但术语<strong>阻塞</strong>通常专用于与文件、网络或其他计算机资源交互的函数调用，因为这些情况下单个程序会受益于<strong>非阻塞</strong>操作。</p>
</section>
<p>We could avoid blocking our main thread by spawning a dedicated thread to
download each file. However, the overhead of those threads would eventually
become a problem. It would be preferable if the call didn’t block in the first
place. It would also be better if we could write in the same direct style we use
in blocking code, similar to this:</p>
<p>可通过为每个文件下载生成专用线程来避免阻塞主线程。但线程开销最终会成为问题。理想情况下，调用本身应是非阻塞的，且能以类似阻塞代码的直接风格编写：</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>That is exactly what Rust’s <em>async</em> (short for <em>asynchronous</em>) abstraction gives
us. In this chapter, you’ll learn all about async as we cover the following
topics:</p>
<p>这正是 Rust 的<strong>异步</strong>（async）抽象提供的功能。本章将涵盖以下主题：</p>
<ul>
<li>
<p>How to use Rust’s <code>async</code> and <code>await</code> syntax</p>
</li>
<li>
<p>How to use the async model to solve some of the same challenges we looked at
in Chapter 16</p>
</li>
<li>
<p>How multithreading and async provide complementary solutions, that you can
combine in many cases</p>
</li>
<li>
<p>如何使用 Rust 的 <code>async</code> 和 <code>await</code> 语法</p>
</li>
<li>
<p>如何用异步模型解决第16章中的相同挑战</p>
</li>
<li>
<p>多线程与异步如何提供互补解决方案，并可在许多情况下结合使用</p>
</li>
</ul>
<p>Before we see how async works in practice, though, we need to take a short
detour to discuss the differences between parallelism and concurrency.</p>
<p>在实践异步之前，需简要讨论并行与并发的区别。</p>
<h3 id="parallelism-and-concurrency-并行与并发"><a class="header" href="#parallelism-and-concurrency-并行与并发">Parallelism and Concurrency 并行与并发</a></h3>
<p>We’ve treated parallelism and concurrency as mostly interchangeable so far. Now
we need to distinguish between them more precisely, because the differences will
show up as we start working.</p>
<p>此前我们几乎将并行与并发视为同义词。现在需要更精确区分，因为差异会在实际工作中显现。</p>
<p>Consider the different ways a team could split up work on a software project.
You could assign a single member multiple tasks, assign each member one task, or
use a mix of the two approaches.</p>
<p>考虑团队分工的不同方式：可分配单人多任务、每人单任务或混合模式。个人在任务完成前处理多个不同任务是<strong>并发</strong>。例如你在计算机上检出两个项目，当对一个项目感到厌倦或卡住时切换到另一个。作为个体，你无法同时推进两项任务，但可通过切换进行多任务处理（见图17-1）。</p>
<p>When an individual works on several different tasks before any of them is
complete, this is <em>concurrency</em>. Maybe you have two different projects checked
out on your computer, and when you get bored or stuck on one project, you switch
to the other. You’re just one person, so you can’t make progress on both tasks
at the exact same time, but you can multi-task, making progress on one at a time
by switching between them (see Figure 17-1).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="" />
<figcaption>Figure 17-1: A concurrent workflow, switching between Task A and Task B 在任务A和B之间切换的并发工作流</figcaption>
</figure>
<p>When the team splits up a group of tasks by having each member take one task and
work on it alone, this is <em>parallelism</em>. Each person on the team can make
progress at the exact same time (see Figure 17-2).</p>
<p>团队通过每人独立处理单一任务来分配工作是<strong>并行</strong>。团队成员可同时推进工作（见图17-2）。</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="" />
<figcaption>Figure 17-2: A parallel workflow, where work happens on Task A and Task B independently 任务A和B独立执行的并行工作流</figcaption>
</figure>
<p>In both of these workflows, you might have to coordinate between different
tasks. Maybe you <em>thought</em> the task assigned to one person was totally
independent from everyone else’s work, but it actually requires another person
on the team to finish their task first. Some of the work could be done in
parallel, but some of it was actually <em>serial</em>: it could only happen in a
series, one task after the other, as in Figure 17-3.</p>
<p>这两种工作流均需任务间协调。可能你以为分配给某人的任务完全独立，实则需等待他人完成任务。部分工作可并行，但部分实际是<strong>串行</strong>的——只能按顺序依次执行（见图17-3）。</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="" />
<figcaption>Figure 17-3: A partially parallel workflow, where work happens on Task A and Task B independently until Task A3 is blocked on the results of Task B3. 部分并行的工作流，任务A和B独立执行，直到任务A3被任务B3的结果阻塞</figcaption>
</figure>
<p>Likewise, you might realize that one of your own tasks depends on another of
your tasks. Now your concurrent work has also become serial.</p>
<p>同理，你可能发现自己的某个任务依赖于另一任务，此时并发工作也变为串行。</p>
<p>Parallelism and concurrency can intersect with each other, too. If you learn
that a colleague is stuck until you finish one of your tasks, you’ll probably
focus all your efforts on that task to “unblock” your colleague. You and your
coworker are no longer able to work in parallel, and you’re also no longer able
to work concurrently on your own tasks.</p>
<p>并行与并发也会交织。若得知同事因等待你的某项任务而受阻，你可能会全力完成该任务以“解锁“同事。此时你与同事无法并行工作，你自身也无法并发处理任务。</p>
<p>The same basic dynamics come into play with software and hardware. On a machine
with a single CPU core, the CPU can perform only one operation at a time, but it
can still work concurrently. Using tools such as threads, processes, and async,
the computer can pause one activity and switch to others before eventually
cycling back to that first activity again. On a machine with multiple CPU cores,
it can also do work in parallel. One core can be performing one task while
another core performs a completely unrelated one, and those operations actually
happen at the same time.</p>
<p>软件和硬件遵循相同原理。单核机器上，CPU 一次只能执行一个操作，但仍可并发工作。通过线程、进程和异步等工具，计算机可暂停活动并切换到其他任务，最终再切回。多核机器上还能并行工作——一个核心执行任务时，另一核心可执行完全不相关的任务，这些操作真正同时发生。</p>
<p>When working with async in Rust, we’re always dealing with concurrency.
Depending on the hardware, the operating system, and the async runtime we are
using (more on async runtimes shortly), that concurrency may also use parallelism
under the hood.</p>
<p>在 Rust 中使用异步时，我们始终处理并发。根据硬件、操作系统和使用的异步运行时（稍后详述），这种并发在底层也可能利用并行性。</p>
<p>Now, let’s dive into how async programming in Rust actually works.</p>
<p>现在深入探讨 Rust 异步编程的实际工作原理。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="futures-and-the-async-syntax-future-与异步语法"><a class="header" href="#futures-and-the-async-syntax-future-与异步语法">Futures and the Async Syntax Future 与异步语法</a></h2>
<p>The key elements of asynchronous programming in Rust are <em>futures</em> and Rust’s
<code>async</code> and <code>await</code> keywords.</p>
<p>Rust 异步编程的核心要素是 <strong>Future</strong> 及 <code>async</code>/<code>await</code> 关键字。</p>
<p>A <em>future</em> is a value that may not be ready now but will become ready at some
point in the future. (This same concept shows up in many languages, sometimes
under other names such as <em>task</em> or <em>promise</em>.) Rust provides a <code>Future</code> trait
as a building block so that different async operations can be implemented with
different data structures but with a common interface. In Rust, futures are
types that implement the <code>Future</code> trait. Each future holds its own information
about the progress that has been made and what “ready” means.</p>
<p><strong>Future</strong> 是可能尚未就绪但将在未来某时刻就绪的值（其他语言中可能称为<strong>任务</strong>或<strong>承诺</strong>）。<span class="highlight">[note]Rust 提供 <code>Future</code> trait 作为基础构建块</span>，使不同异步操作可通过不同数据结构实现统一接口。在 Rust 中，Future 是实现 <code>Future</code> trait 的类型。<span class="highlight">[note]每个 Future 持有自身进展信息及“就绪“的含义</span>。</p>
<p>You can apply the <code>async</code> keyword to blocks and functions to specify that they
can be interrupted and resumed. Within an async block or async function, you can
use the <code>await</code> keyword to <em>await a future</em> (that is, wait for it to become
ready). Any point where you await a future within an async block or function is
a potential spot for that async block or function to pause and resume. The
process of checking with a future to see if its value is available yet is called
<em>polling</em>.</p>
<p><span class="highlight">[note]<code>async</code> 关键字可应用于代码块和函数，表示它们可被中断和恢复。在异步块或函数内，可用 <code>await</code> 关键字<strong>等待 Future</strong>（即等待其就绪）。异步块/函数内任何等待 Future 的点都是潜在的暂停/恢复点。检查 Future 值是否就绪的过程称为<strong>轮询</strong>。</span></p>
<p>Some other languages, such as C# and JavaScript, also use <code>async</code> and <code>await</code>
keywords for async programming. If you’re familiar with those languages, you may
notice some significant differences in how Rust does things, including how it
handles the syntax. That’s for good reason, as we’ll see!</p>
<p>C# 和 JavaScript 等语言也用 <code>async</code>/<code>await</code> 处理异步编程。若熟悉这些语言，可能会注意到 Rust 的显著差异（包括语法处理方式）。这是有意为之，我们稍后会看到！</p>
<p>When writing async Rust, we use the <code>async</code> and <code>await</code> keywords most of the
time. Rust compiles them into equivalent code using the <code>Future</code> trait, much as
it compiles <code>for</code> loops into equivalent code using the <code>Iterator</code> trait. Because
Rust provides the <code>Future</code> trait, though, you can also implement it for your own
data types when you need to. Many of the functions we’ll see throughout this
chapter return types with their own implementations of <code>Future</code>. We’ll return to
the definition of the trait at the end of the chapter and dig into more of how
it works, but this is enough detail to keep us moving forward.</p>
<p>编写异步 Rust 时，我们主要<span class="highlight">[note]使用 <code>async</code>/<code>await</code>。Rust 将其编译为基于 <code>Future</code> trait 的等效代码</span>，类似将 <code>for</code> 循环编译为基于 <code>Iterator</code> trait 的代码。由于 Rust 提供了 <code>Future</code> trait，你也可在需要时为自定义类型实现它。本章多数函数返回实现 <code>Future</code> 的自定义类型。我们将在章末回顾该 trait 定义并深入其工作原理，目前这些细节已足够推进。</p>
<p>This may all feel a bit abstract, so let’s write our first async program: a
little web scraper. We’ll pass in two URLs from the command line, fetch both of
them concurrently, and return the result of whichever one finishes first. This
example will have a fair bit of new syntax, but don’t worry—we’ll explain
everything you need to know as we go.</p>
<p>这些概念可能较抽象，因此我们编写第一个异步程序：简易网页抓取工具。通过命令行传入两个 URL，并发获取两者，并返回先完成的结果。此例会有新语法，但请放心——我们将逐步解释。</p>
<h2 id="our-first-async-program-首个异步程序"><a class="header" href="#our-first-async-program-首个异步程序">Our First Async Program 首个异步程序</a></h2>
<p>To keep the focus of this chapter on learning async rather than juggling parts
of the ecosystem, we’ve created the <code>trpl</code> crate (<code>trpl</code> is short for “The Rust
Programming Language”). It re-exports all the types, traits, and functions
you’ll need, primarily from the <code>futures</code> and
<code>tokio</code> crates. The <code>futures</code> crate is an official home
for Rust experimentation for async code, and it’s actually where the <code>Future</code>
trait was originally designed. Tokio is the most widely used async runtime in
Rust today, especially for web applications. There are other great runtimes out
there, and they may be more suitable for your purposes. We use the <code>tokio</code> crate
under the hood for <code>trpl</code> because it’s well tested and widely used.</p>
<p>为聚焦异步学习而非生态库细节，我们创建了 <code>trpl</code> crate（“The Rust Programming Language“缩写）。它重新导出了所需类型、trait 和函数（主要来自 <code>futures</code> 和 <code>tokio</code> crate）。<span class="highlight">[note]<code>futures</code> crate 是 Rust 异步代码的官方实验基地</span>，<code>Future</code> trait 最初在此设计。Tokio 是当前 Rust 最广泛使用的异步运行时（尤其适用于 Web 应用）。还有其他优秀运行时可能更适合你的需求。我们底层使用 <code>tokio</code> 是因为它经过充分测试且应用广泛。</p>
<p>In some cases, <code>trpl</code> also renames or wraps the original APIs to keep you
focused on the details relevant to this chapter. If you want to understand what
the crate does, we encourage you to check out its source
code. You’ll be able to see what crate each
re-export comes from, and we’ve left extensive comments explaining what the
crate does.</p>
<p>有时 <code>trpl</code> 会重命名或包装原始 API 以聚焦本章相关细节。若想了解该 crate 的功能，建议查看其<a href="https://github.com/rust-lang/book/tree/main/packages/trpl">源代码</a>。你可查看每个重导出项的来源，且我们留有详细注释说明功能。</p>
<p>Create a new binary project named <code>hello-async</code> and add the <code>trpl</code> crate as a
dependency:</p>
<p>创建名为 <code>hello-async</code> 的二进制项目并添加 <code>trpl</code> 依赖：</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Now we can use the various pieces provided by <code>trpl</code> to write our first async
program. We’ll build a little command line tool that fetches two web pages,
pulls the <code>&lt;title&gt;</code> element from each, and prints out the title of whichever
page finishes that whole process first.</p>
<p>现在可用 <code>trpl</code> 提供的组件编写首个异步程序。我们将构建命令行工具：获取两个网页，提取各自的 <code>&lt;title&gt;</code> 元素，并打印先完成整个过程的页面标题。</p>
<h3 id="defining-the-page_title-function-定义-page_title-函数"><a class="header" href="#defining-the-page_title-function-定义-page_title-函数">Defining the page_title Function 定义 page_title 函数</a></h3>
<p>Let’s start by writing a function that takes one page URL as a parameter, makes
a request to it, and returns the text of the title element (see Listing 17-1).</p>
<p>首先编写函数：接收页面 URL 参数，发起请求，返回标题元素文本（见示例17-1）。</p>
<figure class="listing" id="listing-17-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre></pre>
<figcaption><a href="ch17-01-futures-and-syntax.html#listing-17-1">Listing 17-1</a>: Defining an async function to get the title element from an HTML page 定义异步函数从HTML页面获取标题元素</figcaption>
</figure>
<p>First, we define a function named <code>page_title</code> and mark it with the <code>async</code>
keyword. Then we use the <code>trpl::get</code> function to fetch whatever URL is passed in
and add the <code>await</code> keyword to await the response. To get the text of the
response, we call its <code>text</code> method, and once again await it with the <code>await</code>
keyword. Both of these steps are asynchronous. For the <code>get</code> function, we have
to wait for the server to send back the first part of its response, which will
include HTTP headers, cookies, and so on, and can be delivered separately from
the response body. Especially if the body is very large, it can take some time
for it all to arrive. Because we have to wait for the <em>entirety</em> of the response
to arrive, the <code>text</code> method is also async.</p>
<p>首先用 <code>async</code> 关键字定义 <code>page_title</code> 函数。然后用 <code>trpl::get</code> 获取传入的 URL，并用 <code>await</code> 等待响应。为获取响应文本，调用其 <code>text</code> 方法并再次用 <code>await</code> 等待。这两步都是异步的：<code>get</code> 需等待服务器返回响应第一部分（含 HTTP 头、Cookie 等），可能与响应体分开发送；若响应体很大，完全到达可能耗时。因需等待<strong>整个</strong>响应到达，<code>text</code> 方法也是异步的。</p>
<p>We have to explicitly await both of these futures, because futures in Rust are
<em>lazy</em>: they don’t do anything until you ask them to with the <code>await</code> keyword.
(In fact, Rust will show a compiler warning if you don’t use a future.) This
might remind you of Chapter 13’s discussion of iterators in the section
Processing a Series of Items With Iterators.
Iterators do nothing unless you call their <code>next</code> method—whether directly or by
using <code>for</code> loops or methods such as <code>map</code> that use <code>next</code> under the hood.
Likewise, futures do nothing unless you explicitly ask them to. This laziness
allows Rust to avoid running async code until it’s actually needed.</p>
<p>必须显式等待这两个 Future，因为 Rust 的 Future 是<strong>惰性</strong>的：<span class="highlight">[note]除非用 <code>await</code> 显式请求，否则不执行任何操作</span>（实际上，未使用的 Future 会触发编译器警告）。这类似于第13章迭代器的处理方式：除非调用 <code>next</code> 方法（直接或通过 <code>for</code> 循环/<code>map</code> 等方法），否则迭代器不工作。同理，Future 除非显式请求否则不执行。这种惰性让 Rust 避免在真正需要前运行异步代码。</p>
<section class="note" aria-role="note">
<p>Note: This is different from the behavior we saw in the previous chapter when
using <code>thread::spawn</code> in Creating a New Thread with
spawn, where the closure we passed to another
thread started running immediately. It’s also different from how many other
languages approach async. But it’s important for Rust to be able to provide
its performance guarantees, just as it is with iterators.</p>
<p>注意：这与第16章使用 <code>thread::spawn</code> 的行为不同（线程闭包立即运行），也不同于许多其他语言的异步处理方式。但对 Rust 提供性能保证至关重要（与迭代器类似）。</p>
</section>
<p>Once we have <code>response_text</code>, we can parse it into an instance of the <code>Html</code>
type using <code>Html::parse</code>. Instead of a raw string, we now have a data type we
can use to work with the HTML as a richer data structure. In particular, we can
use the <code>select_first</code> method to find the first instance of a given CSS
selector. By passing the string <code>"title"</code>, we’ll get the first <code>&lt;title&gt;</code> element
in the document, if there is one. Because there may not be any matching element,
<code>select_first</code> returns an <code>Option&lt;ElementRef&gt;</code>. Finally, we use the
<code>Option::map</code> method, which lets us work with the item in the <code>Option</code> if it’s
present, and do nothing if it isn’t. (We could also use a <code>match</code> expression
here, but <code>map</code> is more idiomatic.) In the body of the function we supply to
<code>map</code>, we call <code>inner_html</code> on the <code>title</code> to get its content, which is
a <code>String</code>. When all is said and done, we have an <code>Option&lt;String&gt;</code>.</p>
<p>获得 <code>response_text</code> 后，用 <code>Html::parse</code> 解析为 <code>Html</code> 类型实例。现在有了可操作 HTML 的丰富数据结构。特别是可用 <code>select_first</code> 方法查找给定 CSS 选择器的首个实例。传入字符串 <code>"title"</code> 将获取文档中首个 <code>&lt;title&gt;</code> 元素（若存在）。因可能无匹配元素，<code>select_first</code> 返回 <code>Option&lt;ElementRef&gt;</code>。最后用 <code>Option::map</code> 处理 <code>Option</code> 中的元素（若存在），否则无操作（此处也可用 <code>match</code>，但 <code>map</code> 更符合习惯）。在传给 <code>map</code> 的函数中，对 <code>title</code> 调用 <code>inner_html</code> 获取其内容（即 <code>String</code>）。最终得到 <code>Option&lt;String&gt;</code>。</p>
<p>Notice that Rust’s <code>await</code> keyword goes <em>after</em> the expression you’re awaiting,
not before it. That is, it’s a <em>postfix</em> keyword. This may differ from what
you’re used to if you’ve used <code>async</code> in other languages, but in Rust it makes
chains of methods much nicer to work with. As a result, we can change the body
of <code>page_title</code> to chain the <code>trpl::get</code> and <code>text</code> function calls together
with <code>await</code> between them, as shown in Listing 17-2.</p>
<p>注意 Rust 的 <code>await</code> 关键字位于表达式<strong>之后</strong>而非之前，是<strong>后缀</strong>关键字。若熟悉其他语言的异步，这可能有别，但在 Rust 中它使方法链更清晰。因此可将 <code>page_title</code> 函数体改为链式调用 <code>trpl::get</code> 和 <code>text</code> 方法，中间用 <code>await</code> 连接（见示例17-2）。</p>
<figure class="listing" id="listing-17-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-01-futures-and-syntax.html#listing-17-2">Listing 17-2</a>: Chaining with the <code>await</code> keyword 使用 <code>await</code> 关键字进行链式调用</figcaption>
</figure>
<p>With that, we have successfully written our first async function! Before we add
some code in <code>main</code> to call it, let’s talk a little more about what we’ve
written and what it means.</p>
<p>至此我们成功编写了第一个异步函数！在 <code>main</code> 中添加调用代码前，再讨论已写内容及其含义。</p>
<p>When Rust sees a block marked with the <code>async</code> keyword, it compiles it into a
unique, anonymous data type that implements the <code>Future</code> trait. When Rust sees a
function marked with <code>async</code>, it compiles it into a non-async function whose
body is an async block. An async function’s return type is the type of the
anonymous data type the compiler creates for that async block.</p>
<p><span class="highlight">[note]Rust 遇到 <code>async</code> 标记的代码块时，会将其编译为实现 <code>Future</code> trait 的唯一匿名数据类型。遇到 <code>async</code> 标记的函数时，会将其编译为返回异步块的非异步函数。异步函数的返回类型是编译器为该异步块创建的匿名数据类型。</span></p>
<p>Thus, writing <code>async fn</code> is equivalent to writing a function that returns a
<em>future</em> of the return type. To the compiler, a function definition such as the
<code>async fn page_title</code> in Listing 17-1 is equivalent to a non-async function
defined like this:</p>
<p>因此，编写 <code>async fn</code> 等效于返回该返回类型的 <strong>Future</strong> 的函数。对编译器而言，示例17-1中的 <code>async fn page_title</code> 定义等效于如下非异步函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let’s walk through each part of the transformed version:</p>
<p>逐步解析转换版本：</p>
<ul>
<li>It uses the <code>impl Trait</code> syntax we discussed back in Chapter 10 in the
“Traits as Parameters” section.</li>
<li>使用第10章“将 trait 作为参数“所述的 <code>impl Trait</code> 语法</li>
<li>The returned trait is a <code>Future</code> with an associated type of <code>Output</code>. Notice
that the <code>Output</code> type is <code>Option&lt;String&gt;</code>, which is the same as the original
return type from the <code>async fn</code> version of <code>page_title</code>.</li>
<li>返回的 trait 是 <code>Future</code>，关联类型为 <code>Output</code>（注意 <code>Output</code> 类型是 <code>Option&lt;String&gt;</code>，与原 <code>async fn</code> 版本的返回类型相同）</li>
<li>All of the code called in the body of the original function is wrapped in an
<code>async move</code> block. Remember that blocks are expressions. This whole block is
the expression returned from the function.</li>
<li>原函数体内所有代码被包装在 <code>async move</code> 块中（块是表达式，整个块是函数的返回表达式）</li>
<li>This async block produces a value with the type <code>Option&lt;String&gt;</code>, as just
described. That value matches the <code>Output</code> type in the return type. This
is just like other blocks you have seen.</li>
<li>该异步块生成 <code>Option&lt;String&gt;</code> 类型的值，匹配返回类型中的 <code>Output</code></li>
<li>The new function body is an <code>async move</code> block because of how it uses the
<code>url</code> parameter. (We’ll talk much more about <code>async</code> versus <code>async move</code> later
in the chapter.)</li>
<li>新函数体是 <code>async move</code> 块，因其使用了 <code>url</code> 参数（本章稍后将详述 <code>async</code> 与 <code>async move</code>）</li>
</ul>
<p>Now we can call <code>page_title</code> in <code>main</code>.</p>
<p>现在可在 <code>main</code> 中调用 <code>page_title</code>。</p>
<h2 id="determining-a-single-pages-title-获取单个页面标题"><a class="header" href="#determining-a-single-pages-title-获取单个页面标题">Determining a Single Page’s Title 获取单个页面标题</a></h2>
<p>To start, we’ll just get the title for a single page. In Listing 17-3, we follow
the same pattern we used in Chapter 12 to get command line arguments in the
Accepting Command Line Arguments section. Then we
pass the first URL <code>page_title</code> and await the result. Because the value
produced by the future is an <code>Option&lt;String&gt;</code>, we use a <code>match</code> expression to
print different messages to account for whether the page had a <code>&lt;title&gt;</code>.</p>
<p>首先仅获取单个页面标题。示例17-3沿用第12章获取命令行参数的模式，将第一个 URL 传给 <code>page_title</code> 并等待结果。因 Future 产生 <code>Option&lt;String&gt;</code>，用 <code>match</code> 表达式根据页面是否有 <code>&lt;title&gt;</code> 打印不同信息。</p>
<figure class="listing" id="listing-17-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-01-futures-and-syntax.html#listing-17-3">Listing 17-3</a>: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument 从 <code>main</code> 调用 <code>page_title</code> 函数（用户提供参数）</figcaption>
</figure>
<p>Unfortunately, this code doesn’t compile. The only place we can use the <code>await</code>
keyword is in async functions or blocks, and Rust won’t let us mark the
special <code>main</code> function as <code>async</code>.</p>
<p>但此代码无法编译：<code>await</code> 关键字只能在异步函数或块中使用，而 Rust 不允许将特殊的 <code>main</code> 函数标记为 <code>async</code>。</p>
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>The reason <code>main</code> can’t be marked <code>async</code> is that async code needs a <em>runtime</em>:
a Rust crate that manages the details of executing asynchronous code. A
program’s <code>main</code> function can <em>initialize</em> a runtime, but it’s not a runtime
<em>itself</em>. (We’ll see more about why this is the case in a bit.) Every Rust
program that executes async code has at least one place where it sets up a
runtime and executes the futures.</p>
<p><code>main</code> 不能标记 <code>async</code> 的原因是异步代码需要<strong>运行时</strong>（管理异步代码执行细节的 Rust crate）。程序的 <code>main</code> 函数可<strong>初始化</strong>运行时，但其本身不是运行时（稍后详述原因）。每个执行异步代码的 Rust 程序至少有一个设置运行时并执行 Future 的位置。</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead,
there are many different async runtimes available, each of which makes different
tradeoffs suitable to the use case it targets. For example, a high-throughput
web server with many CPU cores and a large amount of RAM has very different
needs than a microcontroller with a single core, a small amount of RAM, and no
heap allocation ability. The crates that provide those runtimes also often
supply async versions of common functionality such as file or network I/O.</p>
<p>多数支持异步的语言捆绑运行时，但 Rust 没有。相反，有许多异步运行时可用，各自针对目标用例做出不同权衡。例如，具有多 CPU 核心和大内存的高吞吐量 Web 服务器，与单核、小内存且无堆分配能力的微控制器需求迥异。<span class="highlight">[note]提供这些运行时的 crate 通常也包含常见功能（如文件/网络 I/O）的异步版本。</span></p>
<p>Here, and throughout the rest of this chapter, we’ll use the <code>run</code> function from
the <code>trpl</code> crate, which takes a future as an argument and runs it to completion.
Behind the scenes, calling <code>run</code> sets up a runtime that’s used to run the future
passed in. Once the future completes, <code>run</code> returns whatever value the future
produced.</p>
<p>本章将使用 <code>trpl</code> crate 的 <code>run</code> 函数：接收 Future 参数并运行至完成。调用 <code>run</code> 会设置运行时以运行传入的 Future。Future 完成后，<code>run</code> 返回其产生的值。</p>
<p>We could pass the future returned by <code>page_title</code> directly to <code>run</code>, and once it
completed, we could match on the resulting <code>Option&lt;String&gt;</code>, as
we tried to do in Listing 17-3. However, for most of the examples in the chapter
(and most async code in the real world), we’ll be doing more than just one
async function call, so instead we’ll pass an <code>async</code> block and explicitly
await the result of the <code>page_title</code> call, as in Listing 17-4.</p>
<p>可将 <code>page_title</code> 返回的 Future 直接传给 <code>run</code>，完成后对结果 <code>Option&lt;String&gt;</code> 进行匹配（如示例17-3尝试）。但本章多数示例（及现实中的异步代码）不只有单个异步调用，因此我们将传递 <code>async</code> 块并显式等待 <code>page_title</code> 调用的结果（见示例17-4）。</p>
<figure class="listing" id="listing-17-4">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-01-futures-and-syntax.html#listing-17-4">Listing 17-4</a>: Awaiting an async block with <code>trpl::run</code> 用 <code>trpl::run</code> 等待异步块</figcaption>
</figure>
<p>When we run this code, we get the behavior we expected initially:</p>
<p>运行此代码将获得预期行为：</p>
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Phew—we finally have some working async code! But before we add the code to race
the two sites against each other, let’s briefly turn our attention back to how
futures work.</p>
<p>终于有了可工作的异步代码！但在添加竞速两个站点的代码前，先简要回顾 Future 的工作原理。</p>
<p>Each <em>await point</em>—that is, every place where the code uses the <code>await</code>
keyword—represents a place where control is handed back to the runtime. To
make that work, Rust needs to keep track of the state involved in the async
block so that the runtime can kick off some other work and then come back when
it’s ready to try advancing the first one again. This is an invisible state machine,
as if you’d written an enum like this to save the current state at each await
point:</p>
<p><span class="highlight">[note]每个<strong>等待点</strong>（即使用 <code>await</code> 关键字的位置）代表将控制权交回运行时的位置。</span>为此，Rust 需跟踪异步块涉及的状态，以便运行时暂停某活动并切换到其他活动，最终再切回推进第一个活动。这是<strong>隐形状态机</strong>，如同手动编写枚举保存每个等待点的当前状态：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>Writing the code to transition between each state by hand would be tedious and
error-prone, however, especially when you need to add more functionality and
more states to the code later. Fortunately, the Rust compiler creates and
manages the state machine data structures for async code automatically. The
normal borrowing and ownership rules around data structures all still apply, and
happily, the compiler also handles checking those for us and provides useful
error messages. We’ll work through a few of those later in the chapter.</p>
<p>手动编写状态间转换代码冗长易错（尤其需添加功能和状态时）。幸运的是，Rust 编译器自动为异步代码创建和管理状态机数据结构。围绕数据结构的常规借用和所有权规则仍适用，编译器也处理这些检查并提供有用错误信息（本章稍后将涉及）。</p>
<p>Ultimately, something has to execute this state machine, and that something is a
runtime. (This is why you may come across references to <em>executors</em>
when looking into runtimes: an executor is the part of a runtime responsible for
executing the async code.)</p>
<p>最终需有执行此状态机的实体，即<strong>运行时</strong>（因此研究运行时时可能遇到<strong>执行器</strong>的提法：执行器是运行时中负责执行异步代码的部分）。</p>
<p>Now you can see why the compiler stopped us from making <code>main</code> itself an async
function back in Listing 17-3. If <code>main</code> were an async function, something else
would need to manage the state machine for whatever future <code>main</code> returned, but
<code>main</code> is the starting point for the program! Instead, we called the <code>trpl::run</code>
function in <code>main</code> to set up a runtime and run the future returned by the
<code>async</code> block until it is done.</p>
<p>现在明白为何编译器在示例17-3中阻止我们将 <code>main</code> 设为异步函数：若 <code>main</code> 是异步函数，需有其他实体管理其返回的 Future 状态机，但 <code>main</code> 是程序的起点！我们在 <code>main</code> 中调用 <code>trpl::run</code> 来设置运行时并运行 <code>async</code> 块返回的 Future 直至完成。</p>
<section class="note" aria-role="note">
<p>Note: Some runtimes provide macros so you <em>can</em> write an async <code>main</code>
function. Those macros rewrite <code>async fn main() { ... }</code> to be a normal <code>fn  main</code>, which does the same thing we did by hand in Listing 17-4: call a
function that runs a future to completion the way <code>trpl::run</code> does.</p>
<p>注意：某些运行时提供宏支持编写异步 <code>main</code> 函数。这些宏将 <code>async fn main() { ... }</code> 重写为普通 <code>fn main</code>，其功能与示例17-4手动操作相同：调用运行 Future 至完成的函数（类似 <code>trpl::run</code>）。</p>
</section>
<p>Now let’s put these pieces together and see how we can write concurrent code.</p>
<p>现在整合这些部分，看看如何编写并发代码。</p>
<h3 id="racing-our-two-urls-against-each-other-竞速两个-url"><a class="header" href="#racing-our-two-urls-against-each-other-竞速两个-url">Racing Our Two URLs Against Each Other 竞速两个 URL</a></h3>
<p>In Listing 17-5, we call <code>page_title</code> with two different URLs passed in from the
command line and race them.</p>
<p>示例17-5用命令行传入的两个不同 URL 调用 <code>page_title</code> 并竞速它们。</p>
<figure class="listing" id="listing-17-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title was: '{title}'"),
            None =&gt; println!("It had no title."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption><a href="ch17-01-futures-and-syntax.html#listing-17-5">Listing 17-5</a>: </figcaption>
</figure>
<p>We begin by calling <code>page_title</code> for each of the user-supplied URLs. We save the
resulting futures as <code>title_fut_1</code> and <code>title_fut_2</code>. Remember, these don’t do
anything yet, because futures are lazy and we haven’t yet awaited them. Then we
pass the futures to <code>trpl::race</code>, which returns a value to indicate which of the
futures passed to it finishes first.</p>
<p>首先为每个用户提供的 URL 调用 <code>page_title</code>，将结果 Future 保存为 <code>title_fut_1</code> 和 <code>title_fut_2</code>。记住：这些调用尚未执行任何操作（因 Future 是惰性的且尚未等待）。然后将 Future 传给 <code>trpl::race</code>（返回指示哪个 Future 先完成的值）。</p>
<section class="note" aria-role="note">
<p>Note: Under the hood, <code>race</code> is built on a more general function, <code>select</code>,
which you will encounter more often in real-world Rust code. A <code>select</code>
function can do a lot of things that the <code>trpl::race</code> function can’t, but it
also has some additional complexity that we can skip over for now.</p>
<p>注意：底层 <code>race</code> <span class="highlight">[note]基于更通用的 <code>select</code> 函数构建</span>（实际 Rust 代码中更常见）。<code>select</code> 函数能完成 <code>trpl::race</code> 无法实现的许多功能，但也带来额外复杂性（目前可跳过）。</p>
<p><span class="highlight">[note]注：<code>use futures::future::select;</code></span></p>
</section>
<p>Either future can legitimately “win,” so it doesn’t make sense to return a
<code>Result</code>. Instead, <code>race</code> returns a type we haven’t seen before,
<code>trpl::Either</code>. The <code>Either</code> type is somewhat similar to a <code>Result</code> in that it
has two cases. Unlike <code>Result</code>, though, there is no notion of success or
failure baked into <code>Either</code>. Instead, it uses <code>Left</code> and <code>Right</code> to indicate
“one or the other”:</p>
<p>任一 Future 都可能“获胜“，因此返回 <code>Result</code> 不合理。<code>race</code> 返回新类型 <code>trpl::Either</code>。<code>Either</code> 类型类似于 <code>Result</code>（有两种情况），但不内建成功/失败概念，而是用 <code>Left</code> 和 <code>Right</code> 表示“二者之一“：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>race</code> function returns <code>Left</code> with the output from the first future
argument it finishes first, or <code>Right</code> with the output of the second future
argument if that one finishes first. This matches the order the arguments appear
in when calling the function: the first argument is to the left of the second
argument.</p>
<p><code>race</code> 函数返回 <code>Left</code>（含第一个参数的输出，若其先完成）或 <code>Right</code>（含第二个参数的输出，若其先完成）。这匹配参数顺序：第一个参数在左，第二个在右。</p>
<p>We also update <code>page_title</code> to return the same URL passed in. That way, if
the page that returns first does not have a <code>&lt;title&gt;</code> we can resolve, we can
still print a meaningful message. With that information available, we wrap up by
updating our <code>println!</code> output to indicate both which URL finished first and
what, if any, the <code>&lt;title&gt;</code> is for the web page at that URL.</p>
<p>我们还更新 <code>page_title</code> 以返回传入的 URL。这样即使先返回的页面无 <code>&lt;title&gt;</code>，仍能打印有意义的消息。利用这些信息更新 <code>println!</code> 输出，指示哪个 URL 先完成及其网页标题（若有）。</p>
<p>You have built a small working web scraper now! Pick a couple URLs and run the
command line tool. You may discover that some sites are consistently faster than
others, while in other cases the faster site varies from run to run. More
importantly, you’ve learned the basics of working with futures, so now we can
dig deeper into what we can do with async.</p>
<p>现在你已构建了简易网页抓取工具！选择几个 URL 运行命令行工具，可能会发现某些站点始终更快，而其他情况下较快的站点因运行而异。更重要的是，你已掌握使用 Future 的基础知识，现在可深入探索异步的更多功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="applying-concurrency-with-async-应用异步实现并发"><a class="header" href="#applying-concurrency-with-async-应用异步实现并发">Applying Concurrency with Async 应用异步实现并发</a></h2>
<p>In this section, we’ll apply async to some of the same concurrency challenges
we tackled with threads in chapter 16. Because we already talked about a lot of
the key ideas there, in this section we’ll focus on what’s different between
threads and futures.</p>
<p>本节将异步应用于第16章用线程解决的并发挑战。因已讨论许多关键思想，本节聚焦线程与 Future 的差异。</p>
<p>In many cases, the APIs for working with concurrency using async are very
similar to those for using threads. In other cases, they end up being quite
different. Even when the APIs <em>look</em> similar between threads and async, they
often have different behavior—and they nearly always have different performance
characteristics.</p>
<p>许多情况下，异步并发的 API 与线程非常相似，但有时差异显著。即使 API <strong>看似</strong>相似，它们的行为通常不同，且几乎总有不同的性能特征。</p>
<h3 id="creating-a-new-task-with-spawn_task-用-spawn_task-创建新任务"><a class="header" href="#creating-a-new-task-with-spawn_task-用-spawn_task-创建新任务">Creating a New Task with <code>spawn_task</code> 用 <code>spawn_task</code> 创建新任务</a></h3>
<p>The first operation we tackled in Creating a New Thread with
Spawn was counting up on two separate threads.
Let’s do the same using async. The <code>trpl</code> crate supplies a <code>spawn_task</code> function
that looks very similar to the <code>thread::spawn</code> API, and a <code>sleep</code> function
that is an async version of the <code>thread::sleep</code> API. We can use these together
to implement the counting example, as shown in Listing 17-6.</p>
<p>在“用 spawn 创建新线程“中，我们在两个独立线程上计数。现在用异步实现相同功能。<code>trpl</code> crate 提供与 <code>thread::spawn</code> API 非常相似的 <code>spawn_task</code> 函数，以及异步版的 <code>sleep</code> 函数。结合两者可实现计数示例（见示例17-6）。</p>
<p><span class="highlight">[note]注：<code>use tokio::task::spawn; use tokio::time::sleep;</code></span></p>
<figure class="listing" id="listing-17-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-6">Listing 17-6</a>: Creating a new task to print one thing while the main task prints something else 创建新任务：主任务打印内容时另一任务打印其他内容</figcaption>
</figure>
<p>As our starting point, we set up our <code>main</code> function with <code>trpl::run</code> so that
our top-level function can be async.</p>
<p>首先在 <code>main</code> 中设置 <code>trpl::run</code>，使顶层函数可为异步。</p>
<section class="note" aria-role="note">
<p>Note: From this point forward in the chapter, every example will include this
exact same wrapping code with <code>trpl::run</code> in <code>main</code>, so we’ll often skip it
just as we do with <code>main</code>. Don’t forget to include it in your code!</p>
<p>注意：本章后续示例均包含 <code>trpl::run</code> 的相同包装代码，因此常会省略（类似 <code>main</code>）。但你的代码中勿忘包含！</p>
</section>
<p>Then we write two loops within that block, each containing a <code>trpl::sleep</code> call,
which waits for half a second (500 milliseconds) before sending the next
message. We put one loop in the body of a <code>trpl::spawn_task</code> and the other in a
top-level <code>for</code> loop. We also add an <code>await</code> after the <code>sleep</code> calls.</p>
<p>然后在异步块内编写两个循环，每个循环含 <code>trpl::sleep</code> 调用（等待半秒后发送下条消息）。一个循环放在 <code>trpl::spawn_task</code> 体内，另一个放在顶层 <code>for</code> 循环中。还在 <code>sleep</code> 调用后添加 <code>await</code>。</p>
<p>This code behaves similarly to the thread-based implementation—including the
fact that you may see the messages appear in a different order in your own
terminal when you run it:</p>
<p>此代码行为类似于基于线程的实现（包括终端中消息顺序可能不同）：</p>
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>This version stops as soon as the <code>for</code> loop in the body of the main async block
finishes, because the task spawned by <code>spawn_task</code> is shut down when the <code>main</code>
function ends. If you want it to run all the way to the task’s completion, you
will need to use a join handle to wait for the first task to complete. With
threads, we used the <code>join</code> method to “block” until the thread was done running.
In Listing 17-7, we can use <code>await</code> to do the same thing, because the task
handle itself is a future. Its <code>Output</code> type is a <code>Result</code>, so we also unwrap it
after awaiting it.</p>
<p>主异步块中的 <code>for</code> 循环结束后立即停止（因 <code>spawn_task</code> 生成的任务在 <code>main</code> 结束时关闭）。若要让任务完全完成，需使用 join 句柄<span class="highlight">[note]等待第一个任务完成</span>。线程中我们用 <code>join</code> 方法“阻塞“至线程完成。在示例17-7中，因<span class="highlight">[note]任务句柄本身是 Future，可用 <code>await</code></span> 实现相同功能。其 <code>Output</code> 类型是 <code>Result</code>，因此在等待后解包它。</p>
<figure class="listing" id="listing-17-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-7">Listing 17-7</a>: Using <code>await</code> with a join handle to run a task to completion 对 join 句柄使用 <code>await</code> 使任务运行至完成</figcaption>
</figure>
<p>This updated version runs until <em>both</em> loops finish.</p>
<p>此更新版本将运行至<strong>两个</strong>循环均完成。</p>
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>So far, it looks like async and threads give us the same basic outcomes, just
with different syntax: using <code>await</code> instead of calling <code>join</code> on the join
handle, and awaiting the <code>sleep</code> calls.</p>
<p>目前看来，异步和线程提供了相同的基本结果（仅语法不同）：用 <code>await</code> 替代对 join 句柄调用 <code>join</code>，并等待 <code>sleep</code> 调用。</p>
<p>The bigger difference is that we didn’t need to spawn another operating system
thread to do this. In fact, we don’t even need to spawn a task here. Because
async blocks compile to anonymous futures, we can put each loop in an async
block and have the runtime run them both to completion using the <code>trpl::join</code>
function.</p>
<p>更大区别在于我们无需生成另一个操作系统线程。实际上甚至无需生成任务。因异步块编译为匿名 Future，可将每个循环放入异步块，并用 <code>trpl::join</code> 函数让运行时运行两者至完成。</p>
<p>In the section Waiting for All Threads to Finishing Using <code>join</code>
Handles, we showed how to use the <code>join</code> method on
the <code>JoinHandle</code> type returned when you call <code>std::thread::spawn</code>. The
<code>trpl::join</code> function is similar, but for futures. When you give it two futures,
it produces a single new future whose output is a tuple containing the output of
each future you passed in once they <em>both</em> complete. Thus, in Listing 17-8, we
use <code>trpl::join</code> to wait for both <code>fut1</code> and <code>fut2</code> to finish. We do <em>not</em> await
<code>fut1</code> and <code>fut2</code> but instead the new future produced by <code>trpl::join</code>. We ignore
the output, because it’s just a tuple containing two unit values.</p>
<p><span class="highlight">[note]注：<code>use futures::future::join</code></span></p>
<p>在“使用 join 句柄等待所有线程完成“中，我们展示了如何对 <code>std::thread::spawn</code> 返回的 <code>JoinHandle</code> 类型使用 <code>join</code> 方法。<code>trpl::join</code> 函数类似（但用于 Future）。<span class="highlight">[note]传入两个 Future 时，它生成新的 Future（其输出是包含两个 Future 输出的元组</span>，当它们<strong>均</strong>完成后）。因此在示例17-8中，用 <code>trpl::join</code> 等待 <code>fut1</code> 和 <code>fut2</code> 完成。我们<strong>不</strong>等待 <code>fut1</code> 和 <code>fut2</code>，而是等待 <code>trpl::join</code> 产生的新 Future。因输出仅为包含两个单元值的元组，故忽略它。</p>
<figure class="listing" id="listing-17-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-8">Listing 17-8</a>: Using <code>trpl::join</code> to await two anonymous futures 用 <code>trpl::join</code> 等待两个匿名 Future</figcaption>
</figure>
<p>When we run this, we see both futures run to completion:</p>
<p>运行后将看到两个 Future 均运行至完成：</p>
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>Now, you’ll see the exact same order every time, which is very different from
what we saw with threads. That is because the <code>trpl::join</code> function is <em>fair</em>,
meaning it checks each future equally often, alternating between them, and never
lets one race ahead if the other is ready. With threads, the operating system
decides which thread to check and how long to let it run. With async Rust, the
runtime decides which task to check. (In practice, the details get complicated
because an async runtime might use operating system threads under the hood as
part of how it manages concurrency, so guaranteeing fairness can be more work
for a runtime—but it’s still possible!) Runtimes don’t have to guarantee
fairness for any given operation, and they often offer different APIs to let you
choose whether or not you want fairness.</p>
<p>现在每次看到的顺序完全相同（与线程方式截然不同）。这是因为 <span class="highlight">[note]<code>trpl::join</code> 函数是<strong>公平的</strong>——它平等检查每个 Future，在它们之间交替</span>，且若另一个已就绪则不让一个超前。使用线程时，操作系统决定检查哪个线程及允许其运行多久。使用异步 Rust 时，运行时决定检查哪个任务（实践中，因异步运行时可能在底层使用操作系统线程管理并发，保证公平性可能需要更多工作，但仍有可能）。<span class="highlight">[note]运行时不必保证给定操作的公平性，且通常提供不同 API 供选择是否要求公平性。</span></p>
<p>Try some of these variations on awaiting the futures and see what they do:</p>
<p>尝试以下变体并观察行为：</p>
<ul>
<li>
<p>Remove the async block from around either or both of the loops.</p>
</li>
<li>
<p>Await each async block immediately after defining it.</p>
</li>
<li>
<p>Wrap only the first loop in an async block, and await the resulting future
after the body of second loop.</p>
</li>
<li>
<p>移除任一或两个循环的 async 块</p>
</li>
<li>
<p>定义后立即等待每个 async 块</p>
</li>
<li>
<p>仅将第一个循环包装在 async 块中，并在第二个循环体后等待生成的 Future</p>
</li>
</ul>
<p>For an extra challenge, see if you can figure out what the output will be in
each case <em>before</em> running the code!</p>
<p>进阶挑战：在运行代码前预测每种情况的输出！</p>
<h3 id="counting-up-on-two-tasks-using-message-passing-通过消息传递在两个任务上计数"><a class="header" href="#counting-up-on-two-tasks-using-message-passing-通过消息传递在两个任务上计数">Counting Up on Two Tasks Using Message Passing 通过消息传递在两个任务上计数</a></h3>
<p>Sharing data between futures will also be familiar: we’ll use message passing
again, but this time with async versions of the types and functions. We’ll take
a slightly different path than we did in Using Message Passing to Transfer Data
Between Threads to illustrate some of
the key differences between thread-based and futures-based concurrency. In
Listing 17-9, we’ll begin with just a single async block—<em>not</em> spawning a
separate task as we spawned a separate thread.</p>
<p>Future 间共享数据的方式也类似：再次使用消息传递，但这次用异步版本的类型和函数。我们将采取与“使用消息传递在线程间传输数据“略有不同的路径，以说明线程与 Future 并发的关键差异。在示例17-9中，我们仅从一个异步块开始（<strong>不</strong>生成单独任务）。</p>
<p><span class="highlight">[note]注：<code>use tokio::sync::mpsc::unbounded_channel;</code></span></p>
<figure class="listing" id="listing-17-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("received '{received}'");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-9">Listing 17-9</a>: Creating an async channel and assigning the two halves to <code>tx</code> and <code>rx</code> 创建异步通道并将两端分配给 <code>tx</code> 和 <code>rx</code></figcaption>
</figure>
<p>Here, we use <code>trpl::channel</code>, an async version of the multiple-producer,
single-consumer channel API we used with threads back in Chapter 16. The async
version of the API is only a little different from the thread-based version: it
uses a mutable rather than an immutable receiver <code>rx</code>, and its <code>recv</code> method
produces a future we need to await rather than producing the value directly. Now
we can send messages from the sender to the receiver. Notice that we don’t have
to spawn a separate thread or even a task; we merely need to await the <code>rx.recv</code>
call.</p>
<p>这里使用 <code>trpl::channel</code>（第16章所用多生产者单消费者通道 API 的异步版本）。异步 API 与线程版略有不同：<span class="highlight">[note]接收端 <code>rx</code> 需可变而非不可变，且其 <code>recv</code> 方法生成需等待的 Future</span>（而非直接生成值）。现在可通过发送端向接收端发送消息。注意：我们无需生成单独线程甚至任务，仅需等待 <code>rx.recv</code> 调用。</p>
<p>The synchronous <code>Receiver::recv</code> method in <code>std::mpsc::channel</code> blocks until
it receives a message. The <code>trpl::Receiver::recv</code> method does not, because it
is async. Instead of blocking, it hands control back to the runtime until either
a message is received or the send side of the channel closes. By contrast, we
don’t await the <code>send</code> call, because it doesn’t block. It doesn’t need to,
because the channel we’re sending it into is unbounded.</p>
<p>同步的 <code>std::mpsc::channel</code> 中的 <code>Receiver::recv</code> 方法阻塞直至收到消息。而 <code>trpl::Receiver::recv</code> 方法是异步的（不阻塞），它将控制权交还运行时（直到消息到达或通道发送端关闭）。相反，我们<span class="highlight">[note]不等待 <code>send</code> 调用（因其不阻塞）。这是因为它发送到的通道是无界的。</span></p>
<section class="note" aria-role="note">
<p>Note: Because all of this async code runs in an async block in a <code>trpl::run</code>
call, everything within it can avoid blocking. However, the code <em>outside</em> it
will block on the <code>run</code> function returning. That’s the whole point of the
<code>trpl::run</code> function: it lets you <em>choose</em> where to block on some set of async
code, and thus where to transition between sync and async code. In most async
runtimes, <code>run</code> is actually named <code>block_on</code> for exactly this reason.</p>
<p>注意：因所有异步代码在 <code>trpl::run</code> 调用的异步块中运行，其内部可避免阻塞。但<strong>外部</strong>代码将在 <code>run</code> 函数返回时阻塞。这正是 <code>trpl::run</code> 函数的意义：让你<strong>选择</strong>在何处阻塞一组异步代码，从而在同步与异步代码间过渡。多数异步运行时中，<code>run</code> 实际名为 <code>block_on</code>（原因即此）。</p>
</section>
<p>Notice two things about this example. First, the message will arrive right away.
Second, although we use a future here, there’s no concurrency yet. Everything
in the listing happens in sequence, just as it would if there were no futures
involved.</p>
<p>注意此例两点：消息立即到达；虽有 Future 但尚无并发性。该示例中的一切都是顺序发生的（如同未涉及 Future）。</p>
<p>Let’s address the first part by sending a series of messages and sleeping in
between them, as shown in Listing 17-10.</p>
<p>通过发送多条消息并在其间休眠来解决第一点（见示例17-10）。</p>
<figure class="listing" id="listing-17-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-10">Listing 17-10</a>: Sending and receiving multiple messages over the async channel and sleeping with an <code>await</code> between each message 通过异步通道发送/接收多条消息，每条消息间用 <code>await</code> 休眠</figcaption>
</figure>
<p>In addition to sending the messages, we need to receive them. In this case,
because we know how many messages are coming in, we could do that manually by
calling <code>rx.recv().await</code> four times. In the real world, though, we’ll generally
be waiting on some <em>unknown</em> number of messages, so we need to keep waiting
until we determine that there are no more messages.</p>
<p>除发送消息外，还需接收它们。已知消息数量时可手动调用 <code>rx.recv().await</code> 四次。但现实中通常等待<strong>未知</strong>数量的消息，因此需持续等待直至确认无更多消息。</p>
<p>In Listing 16-10, we used a <code>for</code> loop to process all the items received from a
synchronous channel. Rust doesn’t yet have a way to write a <code>for</code> loop over an
<em>asynchronous</em> series of items, however, so we need to use a loop we haven’t
seen before: the <code>while let</code> conditional loop. This is the loop version of the
<code>if let</code> construct we saw back in the section Concise Control Flow with <code>if  let</code> and <code>let else</code>. The loop will continue executing as
long as the pattern it specifies continues to match the value.</p>
<p>在示例16-10中，我们用 <code>for</code> 循环处理同步通道的所有接收项。但 Rust 尚无对<strong>异步</strong>序列项写 <code>for</code> 循环的方式，因此<span class="highlight">[note]需使用 <code>while let</code> 条件循环</span>（这是第6章“用 <code>if let</code> 和 <code>let else</code> 简洁控制流“中 <code>if let</code> 的循环版）。只要指定模式继续匹配值，循环就会持续执行。</p>
<p>The <code>rx.recv</code> call produces a future, which we await. The runtime will pause the
future until it is ready. Once a message arrives, the future will resolve to
<code>Some(message)</code> as many times as a message arrives. When the channel closes,
regardless of whether <em>any</em> messages have arrived, the future will instead
resolve to <code>None</code> to indicate that there are no more values and thus we should
stop polling—that is, stop awaiting.</p>
<p><code>rx.recv</code> 调用生成 Future（我们等待它）。运行时将暂停该 Future 直至其就绪。消息到达后，Future 将解析为 <code>Some(message)</code>（多次到达则多次解析）。通道关闭时（无论是否到达消息），Future 将解析为 <code>None</code>（表示无更多值且应停止轮询——即停止等待）。</p>
<p>The <code>while let</code> loop pulls all of this together. If the result of calling
<code>rx.recv().await</code> is <code>Some(message)</code>, we get access to the message and we can
use it in the loop body, just as we could with <code>if let</code>. If the result is
<code>None</code>, the loop ends. Every time the loop completes, it hits the await point
again, so the runtime pauses it again until another message arrives.</p>
<p><code>while let</code> 循环整合了这些：若 <code>rx.recv().await</code> 结果是 <code>Some(message)</code>，则在循环体内访问消息；若为 <code>None</code> 则循环结束。每次循环完成时，会再次到达等待点，因此运行时再次暂停它直到下条消息到达。</p>
<p>The code now successfully sends and receives all of the messages. Unfortunately,
there are still a couple of problems. For one thing, the messages do not arrive
at half-second intervals. They arrive all at once, 2 seconds (2,000
milliseconds) after we start the program. For another, this program never exits!
Instead, it waits forever for new messages. You will need to shut it down using
<span class="keystroke">ctrl-c</span>.</p>
<p>此代码成功发送并接收所有消息。但仍有几个问题：消息非半秒间隔到达（启动程序2秒后同时到达）；程序永不退出（永远等待新消息，需按 <span class="keystroke">ctrl-c</span> 关闭）。</p>
<p>Let’s start by examining why the messages come in all at once after the full
delay, rather than coming in with delays between each one. Within a given async
block, the order in which <code>await</code> keywords appear in the code is also the order
in which they’re executed when the program runs.</p>
<p>首先，我们来探究一下为什么消息会在整个延迟之后一次性全部收到，而不是在每个消息之间产生延迟。在给定的异步块中，代码中<code>await</code>关键字出现的顺序，也是它们在程序运行时执行的顺序。</p>
<p>There’s only one async block in Listing 17-10, so everything in it runs
linearly. There’s still no concurrency. All the <code>tx.send</code> calls happen,
interspersed with all of the <code>trpl::sleep</code> calls and their associated await
points. Only then does the <code>while let</code> loop get to go through any of the <code>await</code>
points on the <code>recv</code> calls.</p>
<p>在代码清单17-10中只有一个异步块，因此其中的所有内容都是线性运行的。这仍然没有并发性。所有的<code>tx.send</code>调用都会发生，其间夹杂着所有的<code>trpl::sleep</code>调用及其相关的等待点。只有在此之后，<code>while let</code>循环才能开始处理<code>recv</code>调用上的任何等待点。</p>
<p>To get the behavior we want, where the sleep delay happens between each message,
we need to put the <code>tx</code> and <code>rx</code> operations in their own async blocks, as shown
in Listing 17-11. Then the runtime can execute each of them separately using
<code>trpl::join</code>, just as in the counting example. Once again, we await the result
of calling <code>trpl::join</code>, not the individual futures. If we awaited the
individual futures in sequence, we would just end up back in a sequential
flow—exactly what we’re trying <em>not</em> to do.</p>
<p>为了实现我们期望的行为，即每个消息之间产生睡眠延迟，我们需要将<code>tx</code>和<code>rx</code>操作放入它们各自的异步块中，如代码清单17-11所示。这样，运行时就可以像在计数示例中一样，使用<code>trpl::join</code>分别执行它们。再次强调，我们等待的是调用<code>trpl::join</code>的结果，而不是各个Future本身。如果我们按顺序等待各个Future，最终只会回到顺序流程——而这正是我们<strong>试图避免</strong>的做法。</p>
<figure class="listing" id="listing-17-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-11">Listing 17-11</a>: Separating <code>send</code> and <code>recv</code> into their own <code>async</code> blocks and awaiting the futures for those blocks 将 <code>send</code> 和 <code>recv</code> 分离到各自的 <code>async</code> 块并等待这些块的 Future</figcaption>
</figure>
<p>With the updated code in Listing 17-11, the messages get printed at
500-millisecond intervals, rather than all in a rush after 2 seconds.</p>
<p>更新后（示例17-11）的消息以500毫秒间隔打印（而非2秒后集中到达）。</p>
<p>The program still never exits, though, because of the way the <code>while let</code> loop
interacts with <code>trpl::join</code>:</p>
<p>程序仍不退出（因 <code>while let</code> 循环与 <code>trpl::join</code> 的交互方式）：</p>
<ul>
<li>
<p>The future returned from <code>trpl::join</code> completes only once <em>both</em> futures
passed to it have completed.</p>
</li>
<li>
<p>The <code>tx</code> future completes once it finishes sleeping after sending the last
message in <code>vals</code>.</p>
</li>
<li>
<p>The <code>rx</code> future won’t complete until the <code>while let</code> loop ends.</p>
</li>
<li>
<p>The <code>while let</code> loop won’t end until awaiting <code>rx.recv</code> produces <code>None</code>.</p>
</li>
<li>
<p>Awaiting <code>rx.recv</code> will return <code>None</code> only once the other end of the channel
is closed.</p>
</li>
<li>
<p>The channel will close only if we call <code>rx.close</code> or when the sender side,
<code>tx</code>, is dropped.</p>
</li>
<li>
<p>We don’t call <code>rx.close</code> anywhere, and <code>tx</code> won’t be dropped until the
outermost async block passed to <code>trpl::run</code> ends.</p>
</li>
<li>
<p>The block can’t end because it is blocked on <code>trpl::join</code> completing, which
takes us back to the top of this list.</p>
</li>
<li>
<p><code>trpl::join</code> 返回的 Future 仅在传入的两个 Future <strong>均</strong>完成后完成</p>
</li>
<li>
<p><code>tx</code> Future 在 <code>vals</code> 中发送最后一条消息并休眠后完成</p>
</li>
<li>
<p><code>rx</code> Future 在 <code>while let</code> 循环结束前不会完成</p>
</li>
<li>
<p><code>while let</code> 循环仅在等待 <code>rx.recv</code> 产生 <code>None</code> 时结束</p>
</li>
<li>
<p>仅当通道另一端关闭时，等待 <code>rx.recv</code> 才会返回 <code>None</code></p>
</li>
<li>
<p><span class="highlight">[note]仅当调用 <code>rx.close</code> 或发送端 <code>tx</code> 被丢弃时通道才关闭</span></p>
</li>
<li>
<p>我们未调用 <code>rx.close</code>，且 <code>tx</code> 在最外层异步块结束前不会被丢弃</p>
</li>
<li>
<p>该块因阻塞在 <code>trpl::join</code> 完成上而无法结束（回到本列表开头）</p>
</li>
</ul>
<p>We could manually close <code>rx</code> by calling <code>rx.close</code> somewhere, but that doesn’t
make much sense. Stopping after handling some arbitrary number of messages would
make the program shut down, but we could miss messages. We need some other way
to make sure that <code>tx</code> gets dropped <em>before</em> the end of the function.</p>
<p>可手动调用 <code>rx.close</code> 关闭，但这不合理（处理任意数量消息后停止程序可能遗漏消息）。需要其他方式确保 <code>tx</code> 在函数结束<strong>前</strong>被丢弃。</p>
<p>Right now, the async block where we send the messages only borrows <code>tx</code> because
sending a message doesn’t require ownership, but if we could move <code>tx</code> into that
async block, it would be dropped once that block ends. In the Chapter 13 section
Capturing References or Moving Ownership, you
learned how to use the <code>move</code> keyword with closures, and, as discussed in the
Chapter 16 section Using <code>move</code> Closures with Threads, we often need to move data into closures when working with threads. The
same basic dynamics apply to async blocks, so the <code>move</code> keyword works with
async blocks just as it does with closures.</p>
<p>当前发送消息的异步块仅借用 <code>tx</code>（因发送消息不需所有权）。若能将 <code>tx</code> 移入该异步块，它将在块结束时被丢弃。第13章“捕获引用或移动所有权“中学习了对闭包使用 <code>move</code> 关键字（如第16章“对线程使用 <code>move</code> 闭包“所述，使用线程时经常需将数据移入闭包）。相同原理适用于异步块，因此 <code>move</code> 关键字对异步块的作用与闭包相同。</p>
<p>In Listing 17-12, we change the block used to send messages from <code>async</code> to
<code>async move</code>. When we run <em>this</em> version of the code, it shuts down gracefully
after the last message is sent and received.</p>
<p>在示例17-12中，将发送消息的块从 <code>async</code> 改为 <code>async move</code>。运行此版本代码时，最后一条消息发送和接收后将正常关闭。</p>
<figure class="listing" id="listing-17-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-12">Listing 17-12</a>: A  revision of the code from Listing 17-11 that correctly shuts down when complete 示例17-11的修正版（完成后正确关闭）</figcaption>
</figure>
<p>This async channel is also a multiple-producer channel, so we can call <code>clone</code>
on <code>tx</code> if we want to send messages from multiple futures, as shown in Listing
17-13.</p>
<p>此异步通道也是多生产者通道，因此若要从多个 Future 发送消息<span class="highlight">[note]可对 <code>tx</code> 调用 <code>clone</code></span>（见示例17-13）。</p>
<figure class="listing" id="listing-17-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-02-concurrency-with-async.html#listing-17-13">Listing 17-13</a>: Using multiple producers with async blocks 在异步块中使用多生产者</figcaption>
</figure>
<p>First, we clone <code>tx</code>, creating <code>tx1</code> outside the first async block. We move
<code>tx1</code> into that block just as we did before with <code>tx</code>. Then, later, we move the
original <code>tx</code> into a <em>new</em> async block, where we send more messages on a
slightly slower delay. We happen to put this new async block after the async
block for receiving messages, but it could go before it just as well. The key is
the order in which the futures are awaited, not in which they’re created.</p>
<p>首先在第一个异步块外克隆 <code>tx</code> 创建 <code>tx1</code>，并将 <code>tx1</code> 移入该块（如前处理 <code>tx</code>）。然后将原始的 <code>tx</code> 移入<strong>新</strong>异步块（以较慢延迟发送更多消息）。新异步块恰好在接收消息块之后，但其位置无关紧要（关键是 Future 的等待顺序而非创建顺序）。</p>
<p>Both of the async blocks for sending messages need to be <code>async move</code> blocks so
that both <code>tx</code> and <code>tx1</code> get dropped when those blocks finish. Otherwise, we’ll
end up back in the same infinite loop we started out in. Finally, we switch from
<code>trpl::join</code> to <code>trpl::join3</code> to handle the additional future.</p>
<p>两个发送消息的异步块需为 <code>async move</code> 块（以便 <code>tx</code> 和 <code>tx1</code> 在块结束时被丢弃），否则会陷入之前的无限循环。最后从 <code>trpl::join</code> 切换到 <code>trpl::join3</code> 以处理额外的 Future。</p>
<p><span class="highlight">[note]注：<code>use futures::future::join3;</code></span></p>
<p>Now we see all the messages from both sending futures, and because the sending
futures use slightly different delays after sending, the messages are also
received at those different intervals.</p>
<p>现在我们将看到来自两个发送 Future 的所有消息（因发送 Future 使用略有不同的发送后延迟，消息也以不同间隔接收）。</p>
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>This is a good start, but it limits us to just a handful of futures: two with
<code>join</code>, or three with <code>join3</code>. Let’s see how we might work with more futures.</p>
<p>这是良好的开端，但仅限于少量 Future（<code>join</code> 处理两个，<code>join3</code> 处理三个）。接下来探讨如何处理更多 Future。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="working-with-any-number-of-futures-处理任意数量的-future"><a class="header" href="#working-with-any-number-of-futures-处理任意数量的-future">Working with Any Number of Futures 处理任意数量的 Future</a></h2>
<p>When we switched from using two futures to three in the previous section, we
also had to switch from using <code>join</code> to using <code>join3</code>. It would be annoying to
have to call a different function every time we changed the number of futures we
wanted to join. Happily, we have a macro form of <code>join</code> to which we can pass an
arbitrary number of arguments. It also handles awaiting the futures itself.
Thus, we could rewrite the code from Listing 17-13 to use <code>join!</code> instead of
<code>join3</code>, as in Listing 17-14.</p>
<p>在上一节中，当我们将使用的 Future 数量从两个增加到三个时，我们也不得不从使用 <code>join</code> 切换到使用 <code>join3</code>。每次改变我们想要合并的 Future 数量时都必须调用不同的函数会很烦人。幸运的是，我们有一个<span class="highlight">[note]宏形式的 <code>join</code>，可以向它传递任意数量的参数。它还会自己处理对 Future 的等待</span>。因此，我们可以重写代码清单 17-13 中的代码，使用 <code>join!</code> 代替 <code>join3</code>，如代码清单 17-14 所示。</p>
<p><span class="highlight">[note]注：<code>use futures::join;</code></span></p>
<figure class="listing" id="listing-17-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-14">Listing 17-14</a>: Using <code>join!</code> to wait for multiple futures 使用 <code>join!</code> 等待多个 Future</figcaption>
</figure>
<p>This is definitely an improvement over swapping between <code>join</code> and
<code>join3</code> and <code>join4</code> and so on! However, even this macro form only works
when we know the number of futures ahead of time. In real-world Rust,
though, pushing futures into a collection and then waiting on some or
all the futures of them to complete is a common pattern.</p>
<p>这绝对比在 <code>join</code>、<code>join3</code>、<code>join4</code> 等之间切换要好得多！然而，即使这种宏形式也仅在我们事先知道 Future 数量时才有效。在现实世界的 Rust 中，将 Future 推入一个集合，然后等待其中部分或全部 Future 完成是一种常见模式。</p>
<p>To check all the futures in some collection, we’ll need to iterate over and
join on <em>all</em> of them. The <code>trpl::join_all</code> function accepts any type that
implements the <code>Iterator</code> trait, which you learned about back in The Iterator
Trait and the <code>next</code> Method Chapter 13, so
it seems like just the ticket. Let’s try putting our futures in a vector and
replacing <code>join!</code> with <code>join_all</code> as shown in Listing 17-15.</p>
<p>要检查某个集合中的所有 Future，我们需要对<em>所有</em>它们进行迭代并合并（join）。<code>trpl::join_all</code> 函数接受任何实现了 <code>Iterator</code> 特征的类型（你在第 13 章“Iterator 特征和 <code>next</code> 方法”中学习过），所以它看起来正合适。让我们尝试将我们的 Future 放入一个向量（vector）中，并用 <code>join_all</code> 替换 <code>join!</code>，如代码清单 17-15 所示。</p>
<p><span class="highlight">[note]注：<code>use futures::future::join_all;</code></span></p>
<figure class="listing" id="listing-17-15">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-15">Listing 17-15</a>: Storing anonymous futures in a vector and calling <code>join_all</code> 将匿名 Future 存储在向量中并调用 <code>join_all</code></figcaption>
</figure>
<p>Unfortunately, this code doesn’t compile. Instead, we get this error:</p>
<p>不幸的是，这段代码无法编译。相反，我们得到这个错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>This might be surprising. After all, none of the async blocks returns anything,
so each one produces a <code>Future&lt;Output = ()&gt;</code>. Remember that <code>Future</code> is a trait,
though, and that the compiler creates a unique enum for each async block. You
can’t put two different hand-written structs in a <code>Vec</code>, and the same rule
applies to the different enums generated by the compiler.</p>
<p>这可能令人惊讶。毕竟，没有一个异步块返回任何东西，所以每个都产生一个 <code>Future&lt;Output = ()&gt;</code>。但请记住，<code>Future</code> 是一个特征（trait），<span class="highlight">[note]编译器会为每个异步块创建一个唯一的枚举</span>。你不能将两个不同手写的结构体放入 <code>Vec</code> 中，同样的规则也适用于编译器生成的不同枚举。</p>
<p>To make this work, we need to use <em>trait objects</em>, just as we did in “Returning
Errors from the run function” in Chapter 12. (We’ll cover
trait objects in detail in Chapter 18.) Using trait objects lets us treat each
of the anonymous futures produced by these types as the same type, because all
of them implement the <code>Future</code> trait.</p>
<p>为了使这个工作，我们需要使用<em>特征对象</em>（trait objects），就像我们在第 12 章“从 run 函数返回错误”中所做的那样。（我们将在第 18 章详细讨论特征对象。）使用特征对象让我们可以将这些类型产生的每个匿名 Future 视为相同的类型，因为它们都实现了 <code>Future</code> 特征。</p>
<section class="note" aria-role="note">
<p>Note: In Using an Enum to Store Multiple Values in
Chapter 8, we discussed another way to include multiple types in a <code>Vec</code>:
using an enum to represent each type that can appear in the vector. We can’t
do that here, though. For one thing, we have no way to name the different
types, because they are anonymous. For another, the reason we reached for a
vector and <code>join_all</code> in the first place was to be able to work with a dynamic
collection of futures where we only care that they have the same output type.</p>
<p>注意：在第 8 章“使用枚举存储多个值”中，我们讨论了在 <code>Vec</code> 中包含多种类型的另一种方法：使用枚举（enum）来表示向量中可以出现的每种类型。然而，我们在这里不能这样做。一方面，我们无法命名这些不同的类型，因为它们是匿名的。另一方面，我们最初选择使用向量和 <code>join_all</code> 的原因，是为了能够处理一个动态的 Future 集合，而我们只关心它们具有相同的输出类型。</p>
</section>
<p>We start by wrapping each future in the <code>vec!</code> in a <code>Box::new</code>, as shown in
Listing 17-16.</p>
<p>我们首先在 <code>vec!</code> 中用 <code>Box::new</code> 包装每个 Future，如代码清单 17-16 所示。</p>
<figure class="listing" id="listing-17-16">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-16">Listing 17-16</a>: Using <code>Box::new</code> to align the types of the futures in a <code>Vec</code> 使用 <code>Box::new</code> 对齐 <code>Vec</code> 中 Future 的类型</figcaption>
</figure>
<p>Unfortunately, this code still doesn’t compile. In fact, we get the same basic
error we got before for both the second and third <code>Box::new</code> calls, as well as
new errors referring to the <code>Unpin</code> trait. We’ll come back to the <code>Unpin</code> errors
in a moment. First, let’s fix the type errors on the <code>Box::new</code> calls by
explicitly annotating the type of the <code>futures</code> variable (see Listing 17-17).</p>
<p>不幸的是，这段代码仍然无法编译。实际上，对于第二个和第三个 <code>Box::new</code> 调用，我们得到了与之前基本相同的错误，同时还出现了引用 <code>Unpin</code> 特征的新错误。我们稍后会回到 <code>Unpin</code> 错误。首先，让我们通过显式<span class="highlight">[note]注解 <code>futures</code> 变量的类型</span>来修复 <code>Box::new</code> 调用的类型错误（见代码清单 17-17）。</p>
<figure class="listing" id="listing-17-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-17">Listing 17-17</a>: Fixing the rest of the type mismatch errors by using an explicit type declaration 使用显式类型声明修复剩余的类型不匹配错误</figcaption>
</figure>
<p>This type declaration is a little involved, so let’s walk through it:</p>
<p>这个类型声明有点复杂，让我们逐步分析一下：</p>
<ol>
<li>
<p>The innermost type is the future itself. We note explicitly that the output
of the future is the unit type <code>()</code> by writing <code>Future&lt;Output = ()&gt;</code>.</p>
</li>
<li>
<p>Then we annotate the trait with <code>dyn</code> to mark it as dynamic.</p>
</li>
<li>
<p>The entire trait reference is wrapped in a <code>Box</code>.</p>
</li>
<li>
<p>Finally, we state explicitly that <code>futures</code> is a <code>Vec</code> containing these
items.</p>
</li>
<li>
<p>最内层的类型是 Future 本身。我们通过写 <code>Future&lt;Output = ()&gt;</code> 显式注解 Future 的输出是单元类型 <code>()</code>。</p>
</li>
<li>
<p>然后我们用 <code>dyn</code> 注解特征，将其标记为动态的（dynamic）。</p>
</li>
<li>
<p>整个特征引用被包装在一个 <code>Box</code> 中。</p>
</li>
<li>
<p>最后，我们显式声明 <code>futures</code> 是一个包含这些项的 <code>Vec</code>。</p>
</li>
</ol>
<p>That already made a big difference. Now when we run the compiler, we get only
the errors mentioning <code>Unpin</code>. Although there are three of them, their contents
are very similar.</p>
<p>这已经带来了很大的改变。现在当我们运行编译器时，我们只得到提及 <code>Unpin</code> 的错误。虽然有三个错误，但它们的内容非常相似。</p>
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
   --&gt; src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `async_await` (bin "async_await") due to 3 previous errors
</code></pre>
<p>That is a <em>lot</em> to digest, so let’s pull it apart. The first part of the message
tell us that the first async block (<code>src/main.rs:8:23: 20:10</code>) does not
implement the <code>Unpin</code> trait and suggests using <code>pin!</code> or <code>Box::pin</code> to resolve
it. Later in the chapter, we’ll dig into a few more details about <code>Pin</code> and
<code>Unpin</code>. For the moment, though, we can just follow the compiler’s advice to get
unstuck. In Listing 17-18, we start by importing <code>Pin</code> from <code>std::pin</code>. Next we
update the type annotation for <code>futures</code>, with a <code>Pin</code> wrapping each <code>Box</code>.
Finally, we use <code>Box::pin</code> to pin the futures themselves.</p>
<p>这有<em>很多</em>信息需要消化，所以让我们分解一下。消息的第一部分告诉我们第一个异步块（<code>src/main.rs:8:23: 20:10</code>）没有实现 <code>Unpin</code> 特征，并建议使用 <code>pin!</code> 或 <code>Box::pin</code> 来解决它。在本章后面，我们将更深入地探讨一些关于 <code>Pin</code> 和 <code>Unpin</code> 的细节。不过现在，我们可以直接遵循编译器的建议来解决问题。在代码清单 17-18 中，我们<span class="highlight">[note]首先从 <code>std::pin</code> 导入 <code>Pin</code>。接下来我们更新 <code>futures</code> 的类型注解，用 <code>Pin</code> 包装每个 <code>Box</code>。最后，我们使用 <code>Box::pin</code> 来固定（pin）Future 本身。</span></p>
<figure class="listing" id="listing-17-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::Pin;

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-18">Listing 17-18</a>: Using <code>Pin</code> and <code>Box::pin</code> to make the <code>Vec</code> type check 使用 <code>Pin</code> 和 <code>Box::pin</code> 使 <code>Vec</code> 通过类型检查</figcaption>
</figure>
<p>If we compile and run this, we finally get the output we hoped for:</p>
<p>如果我们编译并运行这个，我们终于得到了我们期望的输出：</p>
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>Phew!</p>
<p>呼！</p>
<p>There’s a bit more to explore here. For one thing, using <code>Pin&lt;Box&lt;T&gt;&gt;</code> adds a
small amount of overhead from putting these futures on the heap with <code>Box</code>—and
we’re only doing that to get the types to line up. We don’t actually <em>need</em> the
heap allocation, after all: these futures are local to this particular function.
As noted before, <code>Pin</code> is itself a wrapper type, so we can get the benefit of
having a single type in the <code>Vec</code>—the original reason we reached for
<code>Box</code>—without doing a heap allocation. We can use <code>Pin</code> directly with each
future, using the <code>std::pin::pin</code> macro.</p>
<p><span class="highlight">[note]这里还有更多可以探索的地方。首先，使用 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 会带来一点开销，这源于用 <code>Box</code> 把这些 future 对象放到堆上——而我们这么做仅仅是为了让类型能够匹配。毕竟，我们实际上<em>并不需要</em>堆分配：这些 Future 是特定于此函数的局部变量。如前所述，<code>Pin</code> 本身是一个包装类型，因此我们可以在 <code>Vec</code> 中拥有单一类型——这是我们最初选择 <code>Box</code> 的原因——而无需进行堆分配。我们可以使用 <code>std::pin::pin</code> 宏直接在每个 Future 上使用 <code>Pin</code>。</span></p>
<p>However, we must still be explicit about the type of the pinned reference;
otherwise, Rust will still not know to interpret these as dynamic trait objects,
which is what we need them to be in the <code>Vec</code>. We therefore add <code>pin</code> to our
list of imports from <code>std::pin</code>. Then we can <code>pin!</code> each future when we define
it and define <code>futures</code> as a <code>Vec</code> containing pinned mutable references to the
dynamic future type, as in Listing 17-19.</p>
<p><span class="highlight">[note]然而，我们仍然必须显式声明固定引用的类型；否则，Rust 仍然不会知道将这些解释为动态特征对象，而这正是我们在 <code>Vec</code> 中需要的。因此，我们将 <code>pin</code> 添加到从 <code>std::pin</code> 导入的列表中。然后我们可以在定义每个 Future 时使用 <code>pin!</code> 宏固定它，并将 <code>futures</code> 定义为一个包含固定可变引用（指向动态 Future 类型）的 <code>Vec</code>，如代码清单 17-19 所示。</span></p>
<figure class="listing" id="listing-17-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::{Pin, pin};

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-19">Listing 17-19</a>: Using <code>Pin</code> directly with the <code>pin!</code> macro to avoid unnecessary heap allocations 直接使用 <code>Pin</code> 和 <code>pin!</code> 宏避免不必要的堆分配</figcaption>
</figure>
<p>We got this far by ignoring the fact that we might have different <code>Output</code>
types. For example, in Listing 17-20, the anonymous future for <code>a</code> implements
<code>Future&lt;Output = u32&gt;</code>, the anonymous future for <code>b</code> implements <code>Future&lt;Output =  &amp;str&gt;</code>, and the anonymous future for <code>c</code> implements <code>Future&lt;Output = bool&gt;</code>.</p>
<p>我们通过忽略我们可能有不同的 <code>Output</code> 类型这一事实才走到这一步。例如，在代码清单 17-20 中，<code>a</code> 的匿名 Future 实现了 <code>Future&lt;Output = u32&gt;</code>，<code>b</code> 的匿名 Future 实现了 <code>Future&lt;Output = &amp;str&gt;</code>，而 <code>c</code> 的匿名 Future 实现了 <code>Future&lt;Output = bool&gt;</code>。</p>
<figure class="listing" id="listing-17-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-20">Listing 17-20</a>: Three futures with distinct types 三个具有不同类型的 Future</figcaption>
</figure>
<p>We can use <code>trpl::join!</code> to await them, because it allows us to pass in multiple
future types and produces a tuple of those types. We <em>cannot</em> use
<code>trpl::join_all</code>, because it requires all of the futures passed in to have the
same type. Remember, that error is what got us started on this adventure with
<code>Pin</code>!</p>
<p>我们可以使用 <code>trpl::join!</code> 来等待它们，因为它允许我们传入多种 Future 类型，并产生这些类型组成的元组。我们<em>不能</em>使用 <code>trpl::join_all</code>，因为它要求传入的所有 Future 具有相同的类型。记住，正是这个错误让我们开始了这段关于 <code>Pin</code> 的冒险！</p>
<p>This is a fundamental tradeoff: we can either deal with a dynamic number of
futures with <code>join_all</code>, as long as they all have the same type, or we can deal
with a set number of futures with the <code>join</code> functions or the <code>join!</code> macro,
even if they have different types. This is the same scenario we’d face when
working with any other types in Rust. Futures are not special, even though we
have some nice syntax for working with them, and that’s a good thing.</p>
<p>这是一个根本性的权衡：我们<span class="highlight">[note]可以使用 <code>join_all</code> 处理动态数量的 Future，只要它们都具有相同的类型；或者我们可以使用 <code>join</code> 系列函数或 <code>join!</code> 宏处理固定数量的 Future，即使它们具有不同的类型。</span>这与我们在 Rust 中处理任何其他类型时面临的情况相同。Future 并不特殊，尽管我们有一些很好的语法来处理它们，这是一件好事。</p>
<h3 id="racing-futures-future-竞速"><a class="header" href="#racing-futures-future-竞速">Racing Futures Future 竞速</a></h3>
<p>When we “join” futures with the <code>join</code> family of functions and macros, we
require <em>all</em> of them to finish before we move on. Sometimes, though, we only
need <em>some</em> future from a set to finish before we move on—kind of similar to
racing one future against another.</p>
<p>当我们使用 <code>join</code> 系列函数和宏“合并” Future 时，我们要求它们都完成才能继续。然而，有时我们只需要集合中的<em>某个</em> Future 完成就可以继续——有点像让一个 Future 与另一个 Future 赛跑（race）。</p>
<p>In Listing 17-21, we once again use <code>trpl::race</code> to run two futures, <code>slow</code> and
<code>fast</code>, against each other.</p>
<p>在代码清单 17-21 中，我们再次使用 <code>trpl::race</code> 来让两个 Future <code>slow</code> 和 <code>fast</code> 相互竞争。</p>
<figure class="listing" id="listing-17-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-21">Listing 17-21</a>: Using <code>race</code> to get the result of whichever future finishes first 使用 <code>race</code> 获取最先完成的 Future 的结果</figcaption>
</figure>
<p>Each future prints a message when it starts running, pauses for some amount of
time by calling and awaiting <code>sleep</code>, and then prints another message when it
finishes. Then we pass both <code>slow</code> and <code>fast</code> to <code>trpl::race</code> and wait for one
of them to finish. (The outcome here isn’t too surprising: <code>fast</code> wins.) Unlike
when we used <code>race</code> back in “Our First Async Program”, we just ignore the <code>Either</code> instance it returns here, because all of
the interesting behavior happens in the body of the async blocks.</p>
<p>每个 Future 在开始运行时打印一条消息，通过调用并等待 <code>sleep</code> 暂停一段时间，然后在完成时打印另一条消息。然后我们将 <code>slow</code> 和 <code>fast</code> 都传递给 <code>trpl::race</code> 并等待其中一个完成。（这里的结果并不太令人惊讶：<code>fast</code> 获胜。）与我们之前在“第一个异步程序”中使用 <code>race</code> 不同，这里我们只是忽略它返回的 <code>Either</code> 实例，因为所有有趣的行为都发生在异步块的主体中。</p>
<p>Notice that if you flip the order of the arguments to <code>race</code>, the order of the
“started” messages changes, even though the <code>fast</code> future always completes
first. That’s because the implementation of this particular <code>race</code> function is
not fair. It always runs the futures passed in as arguments in the order in
which they’re passed. Other implementations <em>are</em> fair and will randomly choose
which future to poll first. Regardless of whether the implementation of race
we’re using is fair, though, <em>one</em> of the futures will run up to the first
<code>await</code> in its body before another task can start.</p>
<p>请注意，如果你翻转传递给 <code>race</code> 的参数顺序，“started”消息的顺序也会改变，即使 <code>fast</code> Future 总是最先完成。这是因为<span class="highlight">[note]这个特定 <code>race</code> 函数的实现是不公平的。它总是按照参数传递的顺序运行 Future。其他实现是公平的，会随机选择首先轮询（poll）哪个 Future。</span>不过，无论我们使用的 race 实现是否公平，<em>总有一个</em> Future 会在其主体中运行到第一个 <code>await</code> 点，然后另一个任务才能开始。</p>
<p>Recall from Our First Async Program that at each
await point, Rust gives a runtime a chance to pause the task and switch to
another one if the future being awaited isn’t ready. The inverse is also true:
Rust <em>only</em> pauses async blocks and hands control back to a runtime at an await
point. Everything between await points is synchronous.</p>
<p>回想一下“第一个异步程序”，在每个 await 点，Rust 都会给运行时（runtime）一个机会来暂停当前任务，如果被等待的 Future 还没准备好，就切换到另一个任务。反之亦然：<span class="highlight">[note]Rust <em>只</em>在 await 点暂停异步块并将控制权交还给运行时</span>。await 点之间的所有代码都是同步执行的。</p>
<p>That means if you do a bunch of work in an async block without an await point,
that future will block any other futures from making progress. You may sometimes
hear this referred to as one future <em>starving</em> other futures. In some cases,
that may not be a big deal. However, if you are doing some kind of expensive
setup or long-running work, or if you have a future that will keep doing some
particular task indefinitely, you’ll need to think about when and where to hand
control back to the runtime.</p>
<p><span class="highlight">[note]这意味着如果你在一个异步块中做了一堆工作而没有 await 点，那么这个 Future 将阻塞其他 Future 的进展。</span>你有时可能会听到这被称为一个 Future <em>饿死</em>（starving）其他 Future。在某些情况下，这可能不是什么大问题。但是，如果你正在进行某种昂贵的设置或长时间运行的工作，或者如果你有一个 Future 将无限期地持续执行某个特定任务，你就需要考虑何时何地将控制权交还给运行时。</p>
<p>By the same token, if you have long-running blocking operations, async can be a
useful tool for providing ways for different parts of the program to relate to
each other.</p>
<p>同样地，如果你有长时间运行的阻塞操作，异步可以成为一个有用的工具，用于提供程序不同部分之间相互关联的方式。</p>
<p>But <em>how</em> would you hand control back to the runtime in those cases?</p>
<p>但是，在这些情况下，你<em>如何</em>将控制权交还给运行时呢？</p>
<h3 id="yielding-control-to-the-runtime-向运行时让出控制权"><a class="header" href="#yielding-control-to-the-runtime-向运行时让出控制权">Yielding Control to the Runtime 向运行时让出控制权</a></h3>
<p>Let’s simulate a long-running operation. Listing 17-22 introduces a <code>slow</code>
function.</p>
<p>让我们模拟一个长时间运行的操作。代码清单 17-22 引入了一个 <code>slow</code> 函数。</p>
<figure class="listing" id="listing-17-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-22">Listing 17-22</a>: Using <code>thread::sleep</code> to simulate slow operations 使用 <code>thread::sleep</code> 模拟慢操作</figcaption>
</figure>
<p>This code uses <code>std::thread::sleep</code> instead of <code>trpl::sleep</code> so that calling
<code>slow</code> will block the current thread for some number of milliseconds. We can use
<code>slow</code> to stand in for real-world operations that are both long-running and
blocking.</p>
<p>这段代码使用 <code>std::thread::sleep</code> 而不是 <code>trpl::sleep</code>，因此调用 <code>slow</code> 将在当前线程上阻塞指定的毫秒数。我们可以使用 <code>slow</code> 来代表现实世界中既长时间运行又阻塞的操作。</p>
<p>In Listing 17-23, we use <code>slow</code> to emulate doing this kind of CPU-bound work in
a pair of futures.</p>
<p>在代码清单 17-23 中，我们使用 <code>slow</code> 来模拟在一对 Future 中执行这种 CPU 密集型工作。</p>
<figure class="listing" id="listing-17-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-23">Listing 17-23</a>: Using <code>thread::sleep</code> to simulate slow operations 使用 <code>thread::sleep</code> 模拟慢操作</figcaption>
</figure>
<p>To begin, each future only hands control back to the runtime <em>after</em> carrying
out a bunch of slow operations. If you run this code, you will see this output:</p>
<p>开始时，每个 Future 只有在执行了一堆慢操作之后才会将控制权交还给运行时。如果你运行这段代码，你将看到这样的输出：</p>
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>As with our earlier example, <code>race</code> still finishes as soon as <code>a</code> is done.
There’s no interleaving between the two futures, though. The <code>a</code> future does all
of its work until the <code>trpl::sleep</code> call is awaited, then the <code>b</code> future does
all of its work until its own <code>trpl::sleep</code> call is awaited, and finally the <code>a</code>
future completes. To allow both futures to make progress between their slow
tasks, we need await points so we can hand control back to the runtime. That
means we need something we can await!</p>
<p>与我们之前的例子类似，<code>race</code> 仍然在 <code>a</code> 完成后立即结束。但是，两个 Future 之间没有交错执行。<code>a</code> Future 完成了它所有的工作，直到 <code>trpl::sleep</code> 调用被等待，然后 <code>b</code> Future 完成了它所有的工作，直到它自己的 <code>trpl::sleep</code> 调用被等待，最后 <code>a</code> Future 完成。为了允许两个 Future 在它们的慢任务之间交替取得进展，我们需要 await 点，以便我们可以将控制权交还给运行时。这意味着我们需要一些我们可以 await 的东西！</p>
<p>We can already see this kind of handoff happening in Listing 17-23: if we
removed the <code>trpl::sleep</code> at the end of the <code>a</code> future, it would complete
without the <code>b</code> future running <em>at all</em>. Let’s try using the <code>sleep</code> function as
a starting point for letting operations switch off making progress, as shown in
Listing 17-24.</p>
<p>我们已经在代码清单 17-23 中看到了这种控制权移交的发生：如果我们移除 <code>a</code> Future 末尾的 <code>trpl::sleep</code>，它将在 <code>b</code> Future <em>根本</em>没有运行的情况下完成。让我们尝试使用 <code>sleep</code> 函数作为起点，让操作交替取得进展，如代码清单 17-24 所示。</p>
<figure class="listing" id="listing-17-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-24">Listing 17-24</a>: Using <code>sleep</code> to let operations switch off making progress 使用 <code>sleep</code> 让操作交替取得进展</figcaption>
</figure>
<p>In Listing 17-24, we add <code>trpl::sleep</code> calls with await points between each call
to <code>slow</code>. Now the two futures’ work is interleaved:</p>
<p>在代码清单 17-24 中，我们在每次调用 <code>slow</code> 之间添加了带 await 点的 <code>trpl::sleep</code> 调用。现在两个 Future 的工作是交错进行的：</p>
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>The <code>a</code> future still runs for a bit before handing off control to <code>b</code>, because
it calls <code>slow</code> before ever calling <code>trpl::sleep</code>, but after that the futures
swap back and forth each time one of them hits an await point. In this case, we
have done that after every call to <code>slow</code>, but we could break up the work in
whatever way makes the most sense to us.</p>
<p><code>a</code> Future 在将控制权交给 <code>b</code> 之前仍然运行了一会儿，因为它先调用了 <code>slow</code> 然后才调用 <code>trpl::sleep</code>，但在此之后，每当其中一个 Future 遇到 await 点时，它们就会来回交换。在这种情况下，我们在每次调用 <code>slow</code> 之后都这样做了，但我们可以用对我们最有意义的方式来拆分工作。</p>
<p>We don’t really want to <em>sleep</em> here, though: we want to make progress as fast
as we can. We just need to hand back control to the runtime. We can do that
directly, using the <code>yield_now</code> function. In Listing 17-25, we replace all those
<code>sleep</code> calls with <code>yield_now</code>.</p>
<p>然而，我们在这里并不是真的想<em>休眠</em>（sleep）：我们想尽可能快地取得进展。我们只需要<span class="highlight">[note]将控制权交还给运行时。我们可以直接使用 <code>yield_now</code> 函数</span>来实现这一点。在代码清单 17-25 中，我们用 <code>yield_now</code> 替换所有那些 <code>sleep</code> 调用。</p>
<p><span class="highlight">[note]注：<code>use tokio::task::yield_now;</code></span></p>
<figure class="listing" id="listing-17-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-25">Listing 17-25</a>: Using <code>yield_now</code> to let operations switch off making progress 使用 <code>yield_now</code> 让操作交替取得进展</figcaption>
</figure>
<p>This code is both clearer about the actual intent and can be significantly
faster than using <code>sleep</code>, because timers such as the one used by <code>sleep</code> often
have limits on how granular they can be. The version of <code>sleep</code> we are using,
for example, will always sleep for at least a millisecond, even if we pass it a
<code>Duration</code> of one nanosecond. Again, modern computers are <em>fast</em>: they can do a
lot in one millisecond!</p>
<p>这段代码在表达实际意图上更清晰，并且可能比使用 <code>sleep</code> 快得多，因为像 <code>sleep</code> 使用的计时器通常有最小粒度的限制。例如，<span class="highlight">[note]我们使用的 <code>sleep</code> 版本，即使我们传递一纳秒的 <code>Duration</code>，也总是会至少休眠一毫秒。</span>再说一次，现代计算机<em>非常快</em>：它们在一毫秒内可以做很多事情！</p>
<p>You can see this for yourself by setting up a little benchmark, such as the one
in Listing 17-26. (This isn’t an especially rigorous way to do performance
testing, but it suffices to show the difference here.)</p>
<p>你可以通过设置一个小型基准测试自己看到这一点，例如代码清单 17-26 中的测试。（这不是进行性能测试的特别严谨的方法，但足以显示此处的差异。）</p>
<figure class="listing" id="listing-17-26">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-26">Listing 17-26</a>: Comparing the performance of <code>sleep</code> and <code>yield_now</code> 比较 <code>sleep</code> 和 <code>yield_now</code> 的性能</figcaption>
</figure>
<p>Here, we skip all the status printing, pass a one-nanosecond <code>Duration</code> to
<code>trpl::sleep</code>, and let each future run by itself, with no switching between the
futures. Then we run for 1,000 iterations and see how long the future using
<code>trpl::sleep</code> takes compared to the future using <code>trpl::yield_now</code>.</p>
<p>在这里，我们跳过所有状态打印，将一纳秒的 <code>Duration</code> 传递给 <code>trpl::sleep</code>，并让每个 Future 自己运行，没有 Future 之间的切换。然后我们运行 1000 次迭代，看看使用 <code>trpl::sleep</code> 的 Future 与使用 <code>trpl::yield_now</code> 的 Future 相比需要多长时间。</p>
<p>The version with <code>yield_now</code> is <em>way</em> faster!</p>
<p>使用 <code>yield_now</code> 的版本<em>快得多</em>！</p>
<p>This means that async can be useful even for compute-bound tasks, depending on
what else your program is doing, because it provides a useful tool for
structuring the relationships between different parts of the program. This is a
form of <em>cooperative multitasking</em>, where each future has the power to determine
when it hands over control via await points. Each future therefore also has the
responsibility to avoid blocking for too long. In some Rust-based embedded
operating systems, this is the <em>only</em> kind of multitasking!</p>
<p>这意味着异步对于计算密集型任务也可能有用，这取决于你的程序还在做什么，因为它为构建程序不同部分之间的关系提供了一个有用的工具。这是一种<em>协作式多任务处理</em>（cooperative multitasking），其中每个 Future 都有权通过 await 点决定何时交出控制权。因此，每个 Future 也有责任避免阻塞太久。在一些基于 Rust 的嵌入式操作系统中，这是<em>唯一</em>的多任务处理方式！</p>
<p>In real-world code, you won’t usually be alternating function calls with await
points on every single line, of course. While yielding control in this way is
relatively inexpensive, it’s not free. In many cases, trying to break up a
compute-bound task might make it significantly slower, so sometimes it’s better
for <em>overall</em> performance to let an operation block briefly. Always
measure to see what your code’s actual performance bottlenecks are. The
underlying dynamic is important to keep in mind, though, if you <em>are</em> seeing a
lot of work happening in serial that you expected to happen concurrently!</p>
<p>在真实世界的代码中，你通常不会在每一行都交替进行函数调用和 await 点。虽然以这种方式让出控制权相对便宜，但它并非免费。<span class="highlight">[note]在许多情况下，尝试拆分一个计算密集型任务可能会使其显著变慢，因此有时为了<em>整体</em>性能，让一个操作短暂阻塞会更好。</span>始终测量以查看代码的实际性能瓶颈是什么。但是，如果你<em>确实</em>看到大量你期望并发发生的工作在串行进行，那么了解底层的动态特性非常重要！</p>
<h3 id="building-our-own-async-abstractions-构建我们自己的异步抽象"><a class="header" href="#building-our-own-async-abstractions-构建我们自己的异步抽象">Building Our Own Async Abstractions 构建我们自己的异步抽象</a></h3>
<p>We can also compose futures together to create new patterns. For example, we can
build a <code>timeout</code> function with async building blocks we already have. When
we’re done, the result will be another building block we could use to create
still more async abstractions.</p>
<p>我们也可以将 Future 组合在一起创建新的模式。例如，我们可以使用已有的异步构建块来构建一个 <code>timeout</code> 函数。完成后，结果将是另一个构建块，我们可以用它来创建更多的异步抽象。</p>
<p>Listing 17-27 shows how we would expect this <code>timeout</code> to work with a slow
future.</p>
<p>代码清单 17-27 展示了我们期望这个 <code>timeout</code> 如何与一个慢 Future 一起工作。</p>
<figure class="listing" id="listing-17-27">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-27">Listing 17-27</a>: Using our imagined <code>timeout</code> to run a slow operation with a time limit 使用我们设想的 <code>timeout</code> 在时间限制内运行慢操作</figcaption>
</figure>
<p>Let’s implement this! To begin, let’s think about the API for <code>timeout</code>:</p>
<p>让我们来实现它！首先，让我们思考一下 <code>timeout</code> 的 API：</p>
<ul>
<li>
<p>It needs to be an async function itself so we can await it.</p>
</li>
<li>
<p>Its first parameter should be a future to run. We can make it generic to allow
it to work with any future.</p>
</li>
<li>
<p>Its second parameter will be the maximum time to wait. If we use a <code>Duration</code>,
that will make it easy to pass along to <code>trpl::sleep</code>.</p>
</li>
<li>
<p>It should return a <code>Result</code>. If the future completes successfully, the
<code>Result</code> will be <code>Ok</code> with the value produced by the future. If the timeout
elapses first, the <code>Result</code> will be <code>Err</code> with the duration that the timeout
waited for.</p>
</li>
<li>
<p>它本身需要是一个异步函数，以便我们可以 await 它。</p>
</li>
<li>
<p>它的第一个参数应该是一个要运行的 Future。我们可以将其设为泛型，以允许它与任何 Future 一起工作。</p>
</li>
<li>
<p>它的第二个参数将是最大等待时间。如果我们使用 <code>Duration</code>，这将使其易于传递给 <code>trpl::sleep</code>。</p>
</li>
<li>
<p>它应该返回一个 <code>Result</code>。如果 Future 成功完成，<code>Result</code> 将是 <code>Ok</code>，其值是该 Future 产生的值。如果超时首先发生，<code>Result</code> 将是 <code>Err</code>，其值是超时等待的时长。</p>
</li>
</ul>
<p>Listing 17-28 shows this declaration.</p>
<p>代码清单 17-28 显示了这个声明。</p>
<figure class="listing" id="listing-17-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-28">Listing 17-28</a>: Defining the signature of <code>timeout</code> 定义 <code>timeout</code> 的签名</figcaption>
</figure>
<p>That satisfies our goals for the types. Now let’s think about the <em>behavior</em> we
need: we want to race the future passed in against the duration. We can use
<code>trpl::sleep</code> to make a timer future from the duration, and use <code>trpl::race</code> to
run that timer with the future the caller passes in.</p>
<p>这满足了我们对类型的目标。现在让我们思考我们需要的行为：我们希望将传入的 Future 与给定的时长进行竞速（race）。我们可以使用 <code>trpl::sleep</code> 从该时长创建一个计时器 Future，并使用 <code>trpl::race</code> 来运行这个计时器和调用者传递的 Future。</p>
<p>We also know that <code>race</code> is not fair, polling arguments in the order in which
they are passed. Thus, we pass <code>future_to_try</code> to <code>race</code> first so it gets a
chance to complete even if <code>max_time</code> is a very short duration. If
<code>future_to_try</code> finishes first, <code>race</code> will return <code>Left</code> with the output from
<code>future_to_try</code>. If <code>timer</code> finishes first, <code>race</code> will return <code>Right</code> with the
timer’s output of <code>()</code>.</p>
<p>我们还知道 <code>race</code> 是不公平的，按照参数传递的顺序轮询它们。因此，我们首先将 <code>future_to_try</code> 传递给 <code>race</code>，这样即使 <code>max_time</code> 非常短，它也有机会完成。如果 <code>future_to_try</code> 先完成，<code>race</code> 将返回 <code>Left</code>，其值是 <code>future_to_try</code> 的输出。如果 <code>timer</code> 先完成，<code>race</code> 将返回 <code>Right</code>，其值是计时器的输出 <code>()</code>。</p>
<p>In Listing 17-29, we match on the result of awaiting <code>trpl::race</code>.</p>
<p>在代码清单 17-29 中，我们匹配等待 <code>trpl::race</code> 的结果。</p>
<figure class="listing" id="listing-17-29">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-03-more-futures.html#listing-17-29">Listing 17-29</a>: Defining <code>timeout</code> with <code>race</code> and <code>sleep</code> 用 <code>race</code> 和 <code>sleep</code> 定义 <code>timeout</code></figcaption>
</figure>
<p>If the <code>future_to_try</code> succeeds and we get a <code>Left(output)</code>, we return
<code>Ok(output)</code>. If the sleep timer elapses instead and we get a <code>Right(())</code>, we
ignore the <code>()</code> with <code>_</code> and return <code>Err(max_time)</code> instead.</p>
<p>如果 <code>future_to_try</code> 成功并且我们得到 <code>Left(output)</code>，我们就返回 <code>Ok(output)</code>。如果睡眠计时器先结束而我们得到 <code>Right(())</code>，我们用 <code>_</code> 忽略 <code>()</code>，然后返回 <code>Err(max_time)</code>。</p>
<p>With that, we have a working <code>timeout</code> built out of two other async helpers. If
we run our code, it will print the failure mode after the timeout:</p>
<p>就这样，我们有了一个由另外两个异步辅助函数构建的工作中的 <code>timeout</code>。如果我们运行我们的代码，它将在超时后打印失败模式：</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>Because futures compose with other futures, you can build really powerful tools
using smaller async building blocks. For example, you can use this same approach
to combine timeouts with retries, and in turn use those with operations such as
network calls (one of the examples from the beginning of the chapter).</p>
<p>因为 Future 可以与其他 Future 组合，你可以使用较小的异步构建块构建非常强大的工具。例如，你可以使用相同的方法将超时与重试结合起来，反过来又可以将这些用于网络调用等操作（本章开头提到的例子之一）。</p>
<p>In practice, you’ll usually work directly with <code>async</code> and <code>await</code>, and
secondarily with functions and macros such as <code>join</code>, <code>join_all</code>, <code>race</code>, and so
on. You’ll only need to reach for <code>pin</code> now and again to use futures with those
APIs.</p>
<p>在实践中，你通常会直接使用 <code>async</code> 和 <code>await</code>，其次使用像 <code>join</code>、<code>join_all</code>、<code>race</code> 等函数和宏。你只需要偶尔使用 <code>pin</code> 来配合这些 API 使用 Future。</p>
<p>We’ve now seen a number of ways to work with multiple futures at the same
time. Up next, we’ll look at how we can work with multiple futures in a
sequence over time with <em>streams</em>. Here are a couple more things you might want
to consider first, though:</p>
<p>我们现在已经看到了多种同时处理多个 Future 的方法。接下来，我们将看看如何使用<em>流</em>（streams）按时间顺序处理多个 Future。不过，这里还有几件事你可能想先考虑一下：</p>
<ul>
<li>We used a <code>Vec</code> with <code>join_all</code> to wait for all of the futures in some group
to finish. How could you use a <code>Vec</code> to process a group of futures in
sequence instead? What are the tradeoffs of doing that?</li>
<li>我们使用带有 <code>join_all</code> 的 <code>Vec</code> 来等待某个组中的所有 Future 完成。你如何使用 <code>Vec</code> 来<em>按顺序</em>处理一组 Future？这样做的权衡是什么？</li>
<li>Take a look at the <code>futures::stream::FuturesUnordered</code> type from the <code>futures</code>
crate. How would using it be different from using a <code>Vec</code>? (Don’t worry about
the fact that it’s from the <code>stream</code> part of the crate; it works just fine
with any collection of futures.)</li>
<li>看看 <code>futures</code> crate 中的 <code>futures::stream::FuturesUnordered</code> 类型。使用它与使用 <code>Vec</code> 有什么不同？（不用担心它来自 crate 的 <code>stream</code> 部分；它与任何 Future 集合一起工作得很好。）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="streams-futures-in-sequence-流按顺序处理的-future"><a class="header" href="#streams-futures-in-sequence-流按顺序处理的-future">Streams: Futures in Sequence 流：按顺序处理的 Future</a></h2>
<p>So far in this chapter, we’ve mostly stuck to individual futures. The one big
exception was the async channel we used. Recall how we used the receiver for our
async channel earlier in this chapter in the “Message
Passing” section. The async <code>recv</code> method
produces a sequence of items over time. This is an instance of a much more
general pattern known as a <em>stream</em>.</p>
<p>本章到目前为止，我们主要专注于单个 Future。一个重要的例外是使用过的异步通道。回顾本章在“消息传递“部分使用异步通道接收器的方式：异步 <code>recv</code> 方法会随时间产生一系列项。这是更通用模式——<strong>流（stream）</strong>——的一个实例。</p>
<p>We saw a sequence of items back in Chapter 13, when we looked at the <code>Iterator</code>
trait in The Iterator Trait and the <code>next</code> Method section, but there are two differences between iterators and the async
channel receiver. The first difference is time: iterators are synchronous, while
the channel receiver is asynchronous. The second is the API. When working
directly with <code>Iterator</code>, we call its synchronous <code>next</code> method. With the
<code>trpl::Receiver</code> stream in particular, we called an asynchronous <code>recv</code> method
instead. Otherwise, these APIs feel very similar, and that similarity
isn’t a coincidence. A stream is like an asynchronous form of iteration. Whereas
the <code>trpl::Receiver</code> specifically waits to receive messages, though, the
general-purpose stream API is much broader: it provides the next item the
way <code>Iterator</code> does, but asynchronously.</p>
<p>我们在第13章讨论<code>Iterator</code>特性时就见过项的序列，但迭代器与异步通道接收器有两点区别。第一点是时间性：迭代器是同步的，而通道接收器是异步的。第二点是 API：直接使用 <code>Iterator</code> 时，我们调用其同步的 <code>next</code> 方法；而对于 <code>trpl::Receiver</code> 流，我们调用的是异步的 <code>recv</code> 方法。除此之外，这些 API 非常相似，这种相似性并非偶然。流就像是异步版本的迭代。虽然 <code>trpl::Receiver</code> 专门用于等待接收消息，但通用流 API 更为广泛：它像 <code>Iterator</code> 一样提供下一项，但采用异步方式。</p>
<p>The similarity between iterators and streams in Rust means we can actually
create a stream from any iterator. As with an iterator, we can work with a
stream by calling its <code>next</code> method and then awaiting the output, as in Listing
17-30.</p>
<p>Rust 中迭代器与流的相似性意味着我们实际上可以从任何迭代器创建流。如迭代器一样，我们可以通过调用流的 <code>next</code> 方法并等待其输出来处理流，如代码清单 17-30 所示。</p>
<p><span class="highlight">[note]注：<code>use tokio_stream::iter;</code></span></p>
<figure class="listing" id="listing-17-30">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-30">Listing 17-30</a>: Creating a stream from an iterator and printing its values 从迭代器创建流并打印其值</figcaption>
</figure>
<p>We start with an array of numbers, which we convert to an iterator and then call
<code>map</code> on to double all the values. Then we convert the iterator into a stream
using the <code>trpl::stream_from_iter</code> function. Next, we loop over the items in the
stream as they arrive with the <code>while let</code> loop.</p>
<p>我们从一个数字数组开始，将其转换为迭代器，然后调用 <code>map</code> 将所有值加倍。接着使用 <code>trpl::stream_from_iter</code> 函数将迭代器转换为流。然后使用 <code>while let</code> 循环遍历流中到达的项。</p>
<p>Unfortunately, when we try to run the code, it doesn’t compile, but instead it
reports that there’s no <code>next</code> method available:</p>
<p>遗憾的是，尝试运行此代码时无法编译，而是报告找不到 <code>next</code> 方法：</p>
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async-await/target/debug/deps/async_await-575db3dd3197d257.long-type-14490787947592691573.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>As this output explains, the reason for the compiler error is that we need the
right trait in scope to be able to use the <code>next</code> method. Given our discussion
so far, you might reasonably expect that trait to be <code>Stream</code>, but it’s actually
<code>StreamExt</code>. Short for <em>extension</em>, <code>Ext</code> is a common pattern in the
Rust community for extending one trait with another.</p>
<p>如输出所示，编译器报错的原因是需要将正确的特性引入作用域才能使用 <code>next</code> 方法。根据目前的讨论，你可能合理预期该特性是 <code>Stream</code>，但实际上是 <code>StreamExt</code>。<code>Ext</code> 是“扩展“（extension）的缩写，在 Rust 社区中是扩展特性的常见模式。</p>
<p>We’ll explain the <code>Stream</code> and <code>StreamExt</code> traits in a bit more detail at the
end of the chapter, but for now all you need to know is that the <code>Stream</code> trait
defines a low-level interface that effectively combines the <code>Iterator</code> and
<code>Future</code> traits. <code>StreamExt</code> supplies a higher-level set of APIs on top of
<code>Stream</code>, including the <code>next</code> method as well as other utility methods similar
to those provided by the <code>Iterator</code> trait. <code>Stream</code> and <code>StreamExt</code> are not yet
part of Rust’s standard library, but most ecosystem crates use the same
definition.</p>
<p>本章末尾会更详细解释 <code>Stream</code> 和 <code>StreamExt</code> 特性，目前只需知道：<span class="highlight">[note]<code>Stream</code> 特性定义了一个底层接口，有效结合了 <code>Iterator</code> 和 <code>Future</code> 特性；<code>StreamExt</code> 在 <code>Stream</code> 之上提供了一套高级 API，包括 <code>next</code> 方法以及其他类似 <code>Iterator</code> 特性的实用方法。</span><code>Stream</code> 和 <code>StreamExt</code> 尚未成为 Rust 标准库的一部分，但大多数生态库使用相同的定义。</p>
<p>The fix to the compiler error is to add a <code>use</code> statement for <code>trpl::StreamExt</code>,
as in Listing 17-31.</p>
<p>修复编译错误的方法是添加 <code>use trpl::StreamExt;</code> 语句，如代码清单 17-31 所示。</p>
<p><span class="highlight">[note]注：<code>use tokio_stream::StreamExt;</code></span></p>
<figure class="listing" id="listing-17-31">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-31">Listing 17-31</a>: Successfully using an iterator as the basis for a stream 成功使用迭代器作为流的基础</figcaption>
</figure>
<p>With all those pieces put together, this code works the way we want! What’s
more, now that we have <code>StreamExt</code> in scope, we can use all of its utility
methods, just as with iterators. For example, in Listing 17-32, we use the
<code>filter</code> method to filter out everything but multiples of three and five.</p>
<p>所有部分组合后，代码按预期工作！更重要的是，现在 <code>StreamExt</code> 在作用域中，我们可以使用其所有实用方法，就像使用迭代器一样。例如，在代码清单 17-32 中，我们使用 <code>filter</code> 方法过滤掉非 3 或 5 的倍数。</p>
<figure class="listing" id="listing-17-32">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-32">Listing 17-32</a>: Filtering a stream with the <code>StreamExt::filter</code> method 使用 <code>StreamExt::filter</code> 方法过滤流</figcaption>
</figure>
<p>Of course, this isn’t very interesting, since we could do the same with normal
iterators and without any async at all. Let’s look at what
we can do that <em>is</em> unique to streams.</p>
<p>当然，这并不有趣，因为用普通迭代器无需异步也能实现。现在来看<strong>流独有的功能</strong>。</p>
<h3 id="composing-streams-组合流"><a class="header" href="#composing-streams-组合流">Composing Streams 组合流</a></h3>
<p>Many concepts are naturally represented as streams: items becoming available in
a queue, chunks of data being pulled incrementally from the filesystem when the
full data set is too large for the computer’s memory, or data arriving over the
network over time. Because streams are futures, we can use them with any other
kind of future and combine them in interesting ways. For example, we can batch
up events to avoid triggering too many network calls, set timeouts on sequences
of long-running operations, or throttle user interface events to avoid doing
needless work.</p>
<p>许多概念天然适合用流表示：队列中可用的项、当数据集过大无法载入内存时从文件系统分块增量拉取的数据，或随时间到达的网络数据。由于流就是 Future，我们可以将它们与其他 Future 结合使用，实现有趣组合。例如：批量处理事件以减少网络调用、为长操作序列设置超时、或节流用户界面事件以避免冗余工作。</p>
<p>Let’s start by building a little stream of messages as a stand-in for a stream
of data we might see from a WebSocket or another real-time communication
protocol, as shown in Listing 17-33.</p>
<p>首先构建一个消息流作为 WebSocket 或其他实时通信协议的替身，如代码清单 17-33 所示。</p>
<p><span class="highlight">[note]注：<code>tokio_stream::wrappers::UnboundedReceiverStream</code></span></p>
<figure class="listing" id="listing-17-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-33">Listing 17-33</a>: Using the <code>rx</code> receiver as a <code>ReceiverStream</code> 将接收器 <code>rx</code> 用作 <code>ReceiverStream</code></figcaption>
</figure>
<p>First, we create a function called <code>get_messages</code> that returns <code>impl Stream&lt;Item  = String&gt;</code>. For its implementation, we create an async channel, loop over the
first 10 letters of the English alphabet, and send them across the channel.</p>
<p>首先创建返回 <code>impl Stream&lt;Item = String&gt;</code> 的函数 <code>get_messages</code>。在实现中，创建异步通道，遍历英文字母表前 10 个字母并通过通道发送。</p>
<p>We also use a new type: <code>ReceiverStream</code>, which converts the <code>rx</code> receiver from
the <code>trpl::channel</code> into a <code>Stream</code> with a <code>next</code> method. Back in <code>main</code>, we use
a <code>while let</code> loop to print all the messages from the stream.</p>
<p>这里使用了<span class="highlight">[note]新类型 <code>ReceiverStream</code>，它将 <code>trpl::channel</code> 的 <code>rx</code> 接收器转换为带 <code>next</code> 方法的 <code>Stream</code>。</span>在 <code>main</code> 中，使用 <code>while let</code> 循环打印流中的所有消息。</p>
<p>When we run this code, we get exactly the results we would expect:</p>
<p>运行代码将得到预期结果：</p>
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>Again, we could do this with the regular <code>Receiver</code> API or even the regular
<code>Iterator</code> API, though, so let’s add a feature that requires streams: adding a
timeout that applies to every item in the stream, and a delay on the items we
emit, as shown in Listing 17-34.</p>
<p>虽然常规 <code>Receiver</code> API 或 <code>Iterator</code> API 也能实现此功能，现在添加流独有的特性：为流中每个项添加超时和延迟，如代码清单 17-34 所示。</p>
<figure class="listing" id="listing-17-34">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-34">Listing 17-34</a>: Using the <code>StreamExt::timeout</code> method to set a time limit on the items in a stream 使用 <code>StreamExt::timeout</code> 为流中的项设置时间限制</figcaption>
</figure>
<p>We start by adding a timeout to the stream with the <code>timeout</code> method, which
comes from the <code>StreamExt</code> trait. Then we update the body of the <code>while let</code>
loop, because the stream now returns a <code>Result</code>. The <code>Ok</code> variant indicates a
message arrived in time; the <code>Err</code> variant indicates that the timeout elapsed
before any message arrived. We <code>match</code> on that result and either print the
message when we receive it successfully or print a notice about the timeout.
Finally, notice that we pin the messages after applying the timeout to them,
because the timeout helper produces a stream that needs to be pinned to be
polled.</p>
<p>首先<span class="highlight">[note]使用 <code>StreamExt</code> 的 <code>timeout</code> 方法为流添加超时</span>。接着更新 <code>while let</code> 循环体，因为流现在返回 <code>Result</code>：<code>Ok</code> 变体表示消息及时到达；<code>Err</code> 变体表示超时后无消息到达。通过 <code>match</code> 处理结果：成功接收时打印消息，超时则打印通知。最后注意：<span class="highlight">[note]应用超时后需固定</span>（pin）消息，因为超时辅助器生成的流需要固定才能轮询（poll）。</p>
<p>However, because there are no delays between messages, this timeout does not
change the behavior of the program. Let’s add a variable delay to the messages
we send, as shown in Listing 17-35.</p>
<p>但由于消息间无延迟，超时不会改变程序行为。现在为发送的消息添加可变延迟，如代码清单 17-35 所示。</p>
<figure class="listing" id="listing-17-35">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-35">Listing 17-35</a>: Sending messages through <code>tx</code> with an async delay without making <code>get_messages</code> an async function 通过 <code>tx</code> 发送带异步延迟的消息（不将 <code>get_messages</code> 改为异步函数）</figcaption>
</figure>
<p>In <code>get_messages</code>, we use the <code>enumerate</code> iterator method with the <code>messages</code>
array so that we can get the index of each item we’re sending along with the
item itself. Then we apply a 100-millisecond delay to even-index items and a
300-millisecond delay to odd-index items to simulate the different delays we
might see from a stream of messages in the real world. Because our timeout is
for 200 milliseconds, this should affect half of the messages.</p>
<p>在 <code>get_messages</code> 中，对 <code>messages</code> 数组使用 <code>enumerate</code> 迭代器方法以获取索引。然后为偶数索引项添加 100 毫秒延迟，为奇数索引项添加 300 毫秒延迟，模拟真实消息流的差异延迟。由于超时为 200 毫秒，这将影响半数消息。</p>
<p>To sleep between messages in the <code>get_messages</code> function without blocking, we
need to use async. However, we can’t make <code>get_messages</code> itself into an async
function, because then we’d return a <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code>
instead of a <code>Stream&lt;Item = String&gt;&gt;</code>. The caller would have to await
<code>get_messages</code> itself to get access to the stream. But remember: everything in a
given future happens linearly; concurrency happens <em>between</em> futures. Awaiting
<code>get_messages</code> would require it to send all the messages, including the sleep
delay between each message, before returning the receiver stream. As a result,
the timeout would be useless. There would be no delays in the stream itself;
they would all happen before the stream was even available.</p>
<p>要在 <code>get_messages</code> 中非阻塞地睡眠，需使用异步。但<strong>不能</strong>将 <code>get_messages</code> 改为异步函数，否则将返回 <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> 而非 <code>Stream&lt;Item = String&gt;</code>。调用方需先等待 <code>get_messages</code> 才能获取流。注意：给定 Future 中的所有操作是线性的；并发发生在 Future <strong>之间</strong>。等待 <code>get_messages</code> 会要求其在返回接收器流前发送所有消息（含延迟），导致超时失效（流中无延迟）。</p>
<p>Instead, we leave <code>get_messages</code> as a regular function that returns a stream,
and we spawn a task to handle the async <code>sleep</code> calls.</p>
<p>因此，保持 <code>get_messages</code> 为返回流的常规函数，并生成任务处理异步 <code>sleep</code> 调用。</p>
<section class="note" aria-role="note">
<p>Note: Calling <code>spawn_task</code> in this way works because we already set up our
runtime; had we not, it would cause a panic. Other implementations choose
different tradeoffs: they might spawn a new runtime and avoid the panic but
end up with a bit of extra overhead, or they may simply not provide a
standalone way to spawn tasks without reference to a runtime. Make sure you
know what tradeoff your runtime has chosen and write your code accordingly!</p>
<p>注意：此方式调用 <code>spawn_task</code> 有效是因为已设置运行时；否则会 panic。其他实现可能选择不同权衡：生成新运行时（避免 panic 但增加开销），或不提供独立于运行时的任务生成方式。请根据所用运行时的设计编写代码！</p>
</section>
<p>Now our code has a much more interesting result. Between every other pair of
messages, a <code>Problem: Elapsed(())</code> error.</p>
<p>现在程序结果更有趣：在每对消息之间会出现 <code>Problem: Elapsed(())</code> 错误。</p>
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>The timeout doesn’t prevent the messages from arriving in the end. We still get
all of the original messages, because our channel is <em>unbounded</em>: it can hold as
many messages as we can fit in memory. If the message doesn’t arrive before the
timeout, our stream handler will account for that, but when it polls the stream
again, the message may now have arrived.</p>
<p>超时<strong>不会</strong>阻止消息最终到达。由于通道是<strong>无界</strong>的（可容纳任意多消息），所有原始消息仍会到达。若消息在超时前未到达，流处理器会处理该情况，但再次轮询流时消息可能已到达。</p>
<p>You can get different behavior if needed by using other kinds of channels or
other kinds of streams more generally. Let’s see one of those in practice by
combining a stream of time intervals with this stream of messages.</p>
<p>通过使用其他通道或流类型，可获得不同行为。现在通过将时间间隔流与消息流结合来实践这一点。</p>
<h3 id="merging-streams-合并流"><a class="header" href="#merging-streams-合并流">Merging Streams 合并流</a></h3>
<p>First, let’s create another stream, which will emit an item every millisecond if
we let it run directly. For simplicity, we can use the <code>sleep</code> function to send
a message on a delay and combine it with the same approach we used in
<code>get_messages</code> of creating a stream from a channel. The difference is that this
time, we’re going to send back the count of intervals that have elapsed, so the
return type will be <code>impl Stream&lt;Item = u32&gt;</code>, and we can call the function
<code>get_intervals</code> (see Listing 17-36).</p>
<p>首先创建另一个流：若直接运行，该流每毫秒发射一个项。简化为：使用 <code>sleep</code> 函数在延迟后发送消息，并采用与 <code>get_messages</code> 相同的通道流方法。区别在于：此次发送已过去的时间间隔计数，因此返回类型为 <code>impl Stream&lt;Item = u32&gt;</code>，函数命名为 <code>get_intervals</code>（见代码清单 17-36）。</p>
<figure class="listing" id="listing-17-36">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-36">Listing 17-36</a>: Creating a stream with a counter that will be emitted once every millisecond 创建每毫秒发射计数器的流</figcaption>
</figure>
<p>We start by defining a <code>count</code> in the task. (We could define it outside the
task, too, but it’s clearer to limit the scope of any given variable.) Then we
create an infinite loop. Each iteration of the loop asynchronously sleeps for
one millisecond, increments the count, and then sends it over the channel.
Because this is all wrapped in the task created by <code>spawn_task</code>, all of
it—including the infinite loop—will get cleaned up along with the runtime.</p>
<p>首先在任务中定义 <code>count</code>（也可定义在任务外，但限定变量作用域更清晰）。然后创建无限循环：每次迭代异步睡眠 1 毫秒，增加计数并通过通道发送。由于所有操作封装在 <code>spawn_task</code> 生成的任务中，包括无限循环在内的内容都会随运行时清理。</p>
<p>This kind of infinite loop, which ends only when the whole runtime gets torn
down, is fairly common in async Rust: many programs need to keep running
indefinitely. With async, this doesn’t block anything else, as long as there is
at least one await point in each iteration through the loop.</p>
<p>此类无限循环（仅在整个运行时关闭时结束）在异步 Rust 中很常见：许多程序需永久运行。只要有 await 点，异步就不会阻塞其他操作。</p>
<p>Now, back in our main function’s async block, we can attempt to merge the
<code>messages</code> and <code>intervals</code> streams, as shown in Listing 17-37.</p>
<p>现在回到主函数的异步块，尝试合并 <code>messages</code> 和 <code>intervals</code> 流（见代码清单 17-37）。</p>
<figure class="listing" id="listing-17-37">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);

        while let Some(result) = merged.next().await {
<span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-37">Listing 17-37</a>: Attempting to merge the <code>messages</code> and <code>intervals</code> streams 尝试合并 <code>messages</code> 和 <code>intervals</code> 流</figcaption>
</figure>
<p>We start by calling <code>get_intervals</code>. Then we merge the <code>messages</code> and
<code>intervals</code> streams with the <code>merge</code> method, which combines multiple streams
into one stream that produces items from any of the source streams as soon as
the items are available, without imposing any particular ordering. Finally, we
loop over that combined stream instead of over <code>messages</code>.</p>
<p>首先调用 <code>get_intervals</code>，然后<span class="highlight">[note]使用 <code>merge</code> 方法合并</span> <code>messages</code> 和 <code>intervals</code> 流。该方法将多个流合并为一个流，在源流项可用时立即生成（不强制特定顺序）。最后遍历合并后的流而非 <code>messages</code>。</p>
<p>At this point, neither <code>messages</code> nor <code>intervals</code> needs to be pinned or mutable,
because both will be combined into the single <code>merged</code> stream. However, this
call to <code>merge</code> doesn’t compile! (Neither does the <code>next</code> call in the <code>while  let</code> loop, but we’ll come back to that.) This is because the two streams have
different types. The <code>messages</code> stream has the type <code>Timeout&lt;impl Stream&lt;Item =  String&gt;&gt;</code>, where <code>Timeout</code> is the type that implements <code>Stream</code> for a <code>timeout</code>
call. The <code>intervals</code> stream has the type <code>impl Stream&lt;Item = u32&gt;</code>. To merge
these two streams, we need to transform one of them to match the other. We’ll
rework the intervals stream, because messages is already in the basic format we
want and has to handle timeout errors (see Listing 17-38).</p>
<p>此时，<code>messages</code> 和 <code>intervals</code> 都无需固定或可变，因为它们将合并到单个 <code>merged</code> 流中。但此 <code>merge</code> 调用无法编译！（<code>while let</code> 循环中的 <code>next</code> 调用也不能编译，稍后处理。）原因是两个流类型不同：<code>messages</code> 是 <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code>（<code>Timeout</code> 是实现 <code>timeout</code> 调用的流类型）；<code>intervals</code> 是 <code>impl Stream&lt;Item = u32&gt;</code>。要合并需转换其中一个流。我们将重构 <code>intervals</code> 流，因为 <code>messages</code> 已是所需格式且需处理超时错误（见代码清单 17-38）。</p>
<figure class="listing" id="listing-17-38">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);

        while let Some(result) = stream.next().await {
<span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-38">Listing 17-38</a>: Aligning the type of the the <code>intervals</code> stream with the type of the <code>messages</code> stream 对齐 <code>intervals</code> 流与 <code>messages</code> 流的类型</figcaption>
</figure>
<p>First, we can use the <code>map</code> helper method to transform the <code>intervals</code> into a
string. Second, we need to match the <code>Timeout</code> from <code>messages</code>. Because we don’t
actually <em>want</em> a timeout for <code>intervals</code>, though, we can just create a timeout
which is longer than the other durations we are using. Here, we create a
10-second timeout with <code>Duration::from_secs(10)</code>. Finally, we need to make
<code>stream</code> mutable, so that the <code>while let</code> loop’s <code>next</code> calls can iterate
through the stream, and pin it so that it’s safe to do so. That gets us <em>almost</em>
to where we need to be. Everything type checks. If you run this, though, there
will be two problems. First, it will never stop! You’ll need to stop it with
<span class="keystroke">ctrl-c</span>. Second, the messages from the English
alphabet will be buried in the midst of all the interval counter messages:</p>
<p>首先使用 <code>map</code> 方法将 <code>intervals</code> 转换为字符串。其次需匹配 <code>messages</code> 的 <code>Timeout</code>。由于我们<strong>不需要</strong> <code>intervals</code> 的超时，可创建比其他持续时间更长的超时（此处为 10 秒）。最后需将 <code>stream</code> 设为可变以便 <code>while let</code> 循环调用 <code>next</code>，并固定它以保证安全。这<strong>几乎</strong>达到要求：类型检查通过。但运行时会遇到两个问题：1) 永不停止（需按 <span class="keystroke">ctrl-c</span> 终止）；2) 字母消息淹没在间隔计数消息中：</p>
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>Listing 17-39 shows one way to solve these last two problems.</p>
<p>代码清单 17-39 展示最后两个问题的解决方案。</p>
<figure class="listing" id="listing-17-39">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-39">Listing 17-39</a>: Using <code>throttle</code> and <code>take</code> to manage the merged streams 使用 <code>throttle</code> 和 <code>take</code> 管理合并流</figcaption>
</figure>
<p>First, we use the <code>throttle</code> method on the <code>intervals</code> stream so that it doesn’t
overwhelm the <code>messages</code> stream. <em>Throttling</em> is a way of limiting the rate at
which a function will be called—or, in this case, how often the stream will be
polled. Once every 100 milliseconds should do, because that’s roughly how often
our messages arrive.</p>
<p>首先在 <code>intervals</code> 流上<span class="highlight">[note]使用 <code>throttle</code> 方法，避免其淹没</span> <code>messages</code> 流。<strong>节流</strong>（throttling）用于限制函数调用频率（此处限制流轮询频率）。设为每 100 毫秒一次（接近消息到达频率）。</p>
<p>To limit the number of items we will accept from a stream, we apply the <code>take</code>
method to the <code>merged</code> stream, because we want to limit the final output, not
just one stream or the other.</p>
<p><span class="highlight">[note]为限制流的总处理量，对 <code>merged</code> 流应用 <code>take</code> 方法</span>（需限制最终输出而非单个流）。</p>
<p>Now when we run the program, it stops after pulling 20 items from the stream,
and the intervals don’t overwhelm the messages. We also don’t get <code>Interval:  100</code> or <code>Interval: 200</code> or so on, but instead get <code>Interval: 1</code>, <code>Interval: 2</code>,
and so on—even though we have a source stream that <em>can</em> produce an event every
millisecond. That’s because the <code>throttle</code> call produces a new stream that wraps
the original stream so that the original stream gets polled only at the throttle
rate, not its own “native” rate. We don’t have a bunch of unhandled interval
messages we’re choosing to ignore. Instead, we never produce those interval
messages in the first place! This is the inherent “laziness” of Rust’s futures
at work again, allowing us to choose our performance characteristics.</p>
<p>现在程序在从流中拉取 20 项后停止，且间隔消息不再淹没字母消息。虽然源流每毫秒可生成事件，但我们得到的是 <code>Interval: 1</code>、<code>Interval: 2</code> 等（而非 <code>Interval: 100</code>）。这是因为 <code>throttle</code> 调用产生的新流包装了原始流，使原始流仅按节流速率为轮询，而非“原生“速率。我们并非忽略未处理的间隔消息，而是<strong>从不生成</strong>这些消息！这再次体现了 Rust Future 固有的“惰性“，允许我们选择性能特征。</p>
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>There’s one last thing we need to handle: errors! With both of these
channel-based streams, the <code>send</code> calls could fail when the other side of the
channel closes—and that’s just a matter of how the runtime executes the futures
that make up the stream. Up until now, we’ve ignored this possibility by calling
<code>unwrap</code>, but in a well-behaved app, we should explicitly handle the error, at
minimum by ending the loop so we don’t try to send any more messages. Listing
17-40 shows a simple error strategy: print the issue and then <code>break</code> from the
loops.</p>
<p>最后需处理错误！这两个<span class="highlight">[note]基于通道的流中，当通道另一端关闭时 <code>send</code> 调用可能失败</span>（这取决于运行时执行 Future 的方式）。此前我们通过 <code>unwrap</code> 忽略此可能性，但在健壮应用中应显式处理错误（至少终止循环以避免继续发送消息）。代码清单 17-40 展示简单错误策略：打印问题并 <code>break</code> 跳出循环。</p>
<figure class="listing" id="listing-17-40">
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="ch17-04-streams.html#listing-17-40">Listing 17-40</a>: Handling errors and shutting down the loops 处理错误并终止循环</figcaption>
</figure>
<p>As usual, the correct way to handle a message send error will vary; just make
sure you have a strategy.</p>
<p>通常，处理消息发送错误的方式因场景而异；关键是制定策略。</p>
<p>Now that we’ve seen a bunch of async in practice, let’s take a step back and dig
into a few of the details of how <code>Future</code>, <code>Stream</code>, and the other key traits
Rust uses to make async work.</p>
<p>实践大量异步操作后，现在深入探讨 <code>Future</code>、<code>Stream</code> 等 Rust 异步核心特性的细节。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-closer-look-at-the-traits-for-async-深入探索异步特性"><a class="header" href="#a-closer-look-at-the-traits-for-async-深入探索异步特性">A Closer Look at the Traits for Async 深入探索异步特性</a></h2>
<p>Throughout the chapter, we’ve used the <code>Future</code>, <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>, and
<code>StreamExt</code> traits in various ways. So far, though, we’ve avoided getting too
far into the details of how they work or how they fit together, which is fine
most of the time for your day-to-day Rust work. Sometimes, though, you’ll
encounter situations where you’ll need to understand a few more of these
details. In this section, we’ll dig in just enough to help in those scenarios,
still leaving the <em>really</em> deep dive for other documentation.</p>
<p>在本章中，我们以多种方式使用了 <code>Future</code>、<code>Pin</code>、<code>Unpin</code>、<code>Stream</code> 和 <code>StreamExt</code> 特征。但到目前为止，我们避免深入探讨它们的<span class="highlight">[note]工作原理</span>或如何协同工作，这对日常 Rust 工作通常已足够。然而，有时你会遇到需要理解更多细节的情况。本节将深入探讨这些细节以应对此类场景，更深入的内容则留给其他文档。</p>
<h3 id="the-future-trait-future-特征"><a class="header" href="#the-future-trait-future-特征">The <code>Future</code> Trait <code>Future</code> 特征</a></h3>
<p>Let’s start by taking a closer look at how the <code>Future</code> trait works. Here’s how
Rust defines it:</p>
<p>首先深入了解 <code>Future</code> 特征的工作原理。以下是 Rust 的定义方式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>That trait definition includes a bunch of new types and also some syntax we
haven’t seen before, so let’s walk through the definition piece by piece.</p>
<p>该特征定义包含多个新类型及未见的语法，因此我们将逐部分解析。</p>
<p>First, <code>Future</code>’s associated type <code>Output</code> says what the future resolves to.
This is analogous to the <code>Item</code> associated type for the <code>Iterator</code> trait.
Second, <code>Future</code> also has the <code>poll</code> method, which takes a special <code>Pin</code>
reference for its <code>self</code> parameter and a mutable reference to a <code>Context</code> type,
and returns a <code>Poll&lt;Self::Output&gt;</code>. We’ll talk more about <code>Pin</code> and
<code>Context</code> in a moment. For now, let’s focus on what the method returns,
the <code>Poll</code> type:</p>
<p>首先，<code>Future</code> 的关联类型 <code>Output</code> 表示 Future 的解析结果。这类似于 <code>Iterator</code> 特征的 <code>Item</code> 关联类型。其次，<code>Future</code> 还包含 <code>poll</code> 方法，它接收一个特殊的 <code>Pin</code> 引用作为 <code>self</code> 参数，以及一个 <code>Context</code> 类型的可变引用，并返回 <code>Poll&lt;Self::Output&gt;</code>。稍后将详细讨论 <code>Pin</code> 和 <code>Context</code>，现在先关注返回值 <code>Poll</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>Poll</code> type is similar to an <code>Option</code>. It has one variant that has a value,
<code>Ready(T)</code>, and one which does not, <code>Pending</code>. <code>Poll</code> means something quite
different from <code>Option</code>, though! The <code>Pending</code> variant indicates that the future
still has work to do, so the caller will need to check again later. The <code>Ready</code>
variant indicates that the future has finished its work and the <code>T</code> value is
available.</p>
<p><code>Poll</code> 类型类似于 <code>Option</code>：包含带值的 <code>Ready(T)</code> 变体和无值的 <code>Pending</code> 变体。但 <code>Poll</code> 的含义与 <code>Option</code> 截然不同！<code>Pending</code> 表示 Future 仍需工作，调用方需稍后重试；<code>Ready</code> 表示 Future 已完成工作，值 <code>T</code> 已就绪。</p>
<section class="note" aria-role="note">
<p>Note: With most futures, the caller should not call <code>poll</code> again after the
future has returned <code>Ready</code>. Many futures will panic if polled again after
becoming ready. Futures that are safe to poll again will say so explicitly in
their documentation. This is similar to how <code>Iterator::next</code> behaves.</p>
<p>注意：对多数 Future 而言，在返回 <code>Ready</code> 后不应再次调用 <code>poll</code>。若在就绪后轮询，许多 Future 会触发 panic。可安全重复轮询的 Future 会在文档中明确说明，类似于 <code>Iterator::next</code> 的行为。</p>
</section>
<p>When you see code that uses <code>await</code>, Rust compiles it under the hood to code
that calls <code>poll</code>. If you look back at Listing 17-4, where we printed out the
page title for a single URL once it resolved, Rust compiles it into something
kind of (although not exactly) like this:</p>
<p>当使用 <code>await</code> 时，Rust 在底层将其编译为调用 <code>poll</code> 的代码。回顾清单 17-4（单 URL 页面标题打印），Rust 会将其编译为类似以下代码（非完全一致）：</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p>What should we do when the future is still <code>Pending</code>? We need some way to try
again, and again, and again, until the future is finally ready. In other words,
we need a loop:</p>
<p>当 Future 仍为 <code>Pending</code> 时该如何处理？我们需要一种能反复重试直至就绪的机制，即循环：</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p>If Rust compiled it to exactly that code, though, every <code>await</code> would be
blocking—exactly the opposite of what we were going for! Instead, Rust makes
sure that the loop can hand off control to something that can pause work on this
future to work on other futures and then check this one again later. As we’ve
seen, that something is an async runtime, and this scheduling and coordination
work is one of its main jobs.</p>
<p>若 Rust 直接编译为此代码，每个 <code>await</code> 都会阻塞——这与我们的目标背道而驰！实际上，Rust 确保循环能将控制权转移给可暂停当前 Future 以处理其他 Future 的调度器，并在稍后重新检查。如我们所见，调度器就是异步运行时，其核心职责之一正是此类调度协调。</p>
<p>Earlier in the chapter, we described waiting on <code>rx.recv</code>. The <code>recv</code> call
returns a future, and awaiting the future polls it. We noted that a runtime will
pause the future until it’s ready with either <code>Some(message)</code> or <code>None</code> when the
channel closes. With our deeper understanding of the <code>Future</code> trait, and
specifically <code>Future::poll</code>, we can see how that works. The runtime knows the
future isn’t ready when it returns <code>Poll::Pending</code>. Conversely, the runtime
knows the future <em>is</em> ready and advances it when <code>poll</code> returns
<code>Poll::Ready(Some(message))</code> or <code>Poll::Ready(None)</code>.</p>
<p>本章前半部分描述的 <code>rx.recv</code> 等待：<code>recv</code> 返回 Future，而 <code>await</code> 会轮询该 Future。运行时会在通道关闭前暂停 Future，直到返回 <code>Some(message)</code> 或 <code>None</code>。通过对 <code>Future</code> 特征（尤其是 <code>poll</code>）的深入理解，可明确其机制：当返回 <code>Poll::Pending</code> 时，运行时知晓 Future 未就绪；反之当返回 <code>Poll::Ready(Some(message))</code> 或 <code>Poll::Ready(None)</code> 时，运行时知晓 Future 已就绪并推进其状态。</p>
<p>The exact details of how a runtime does that are beyond the scope of this book,
but the key is to see the basic mechanics of futures: a runtime <em>polls</em> each
future it is responsible for, putting the future back to sleep when it is not
yet ready.</p>
<p>运行时的具体实现超出本书范围，但关键在于理解 Future 的基本机制：运行时<strong>轮询</strong>其管理的每个 Future，在未就绪时使其休眠。</p>
<h3 id="the-pin-and-unpin-traits-pin-与-unpin-特征"><a class="header" href="#the-pin-and-unpin-traits-pin-与-unpin-特征">The <code>Pin</code> and <code>Unpin</code> Traits <code>Pin</code> 与 <code>Unpin</code> 特征</a></h3>
<p>When we introduced the idea of pinning in Listing 17-16, we ran into a very
gnarly error message. Here is the relevant part of it again:</p>
<p>在清单 17-16 引入固定（pinning）概念时，我们遇到了复杂错误信息。以下是其核心部分：</p>
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>This error message tells us not only that we need to pin the values but also why
pinning is required. The <code>trpl::join_all</code> function returns a struct called
<code>JoinAll</code>. That struct is generic over a type <code>F</code>, which is constrained to
implement the <code>Future</code> trait. Directly awaiting a future with <code>await</code> pins the
future implicitly. That’s why we don’t need to use <code>pin!</code> everywhere we want to
await futures.</p>
<p>此错误不仅提示需固定值，还解释了原因：<code>trpl::join_all</code> 返回的 <code>JoinAll</code> 结构体对类型 <code>F</code> 有泛型约束，要求其实现 <code>Future</code> 特征。直接通过 <code>await</code> 等待 Future 会隐式固定该 Future，因此无需在每个等待处显式使用 <code>pin!</code>。</p>
<p>However, we’re not directly awaiting a future here. Instead, we construct a new
future, <code>JoinAll</code>, by passing a collection of futures to the <code>join_all</code>
function. The signature for <code>join_all</code> requires that the types of the items in
the collection all implement the <code>Future</code> trait, and <code>Box&lt;T&gt;</code> implements
<code>Future</code> only if the <code>T</code> it wraps is a future that implements the <code>Unpin</code> trait.</p>
<p>但此处并非直接等待 Future，而是通过向 <code>join_all</code> 传递 Future 集合来构造新 Future <code>JoinAll</code>。<code>join_all</code> 的签名要求集合中所有项均实现 <code>Future</code> 特征，而 <code>Box&lt;T&gt;</code> 仅在包装的 <code>T</code> 实现 <code>Unpin</code> 特征时才实现 <code>Future</code>。</p>
<p>That’s a lot to absorb! To really understand it, let’s dive a little further
into how the <code>Future</code> trait actually works, in particular around <em>pinning</em>.</p>
<p>信息量巨大！为深入理解，需进一步探究 <code>Future</code> 特征的工作原理，尤其是<strong>固定</strong>机制。</p>
<p>Look again at the definition of the <code>Future</code> trait:</p>
<p>再次查看 <code>Future</code> 特征定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cx</code> parameter and its <code>Context</code> type are the key to how a runtime actually
knows when to check any given future while still being lazy. Again, the details
of how that works are beyond the scope of this chapter, and you generally only
need to think about this when writing a custom <code>Future</code> implementation. We’ll
focus instead on the type for <code>self</code>, as this is the first time we’ve seen a
method where <code>self</code> has a type annotation. A type annotation for <code>self</code> works
like type annotations for other function parameters, but with two key
differences:</p>
<p><code>cx</code> 参数及其 <code>Context</code> 类型是运行时实现惰性调度的关键。其细节超出本章范围，通常仅在自定义 <code>Future</code> 实现时需关注。我们将聚焦 <code>self</code> 的类型——这是首次在方法中看到带类型注解的 <code>self</code>。<code>self</code> 的类型注解与其他函数参数类似，但有两点关键区别：</p>
<ul>
<li>It tells Rust what type <code>self</code> must be for the method to be called.</li>
<li>它指定调用方法时 <code>self</code> 必须具备的类型</li>
<li>It can’t be just any type. It’s restricted to the type on which the method is
implemented, a reference or smart pointer to that type, or a <code>Pin</code> wrapping a
reference to that type.</li>
<li>它不能是任意类型，仅限于方法实现的类型、该类型的引用/智能指针，或包裹该类型引用的 <code>Pin</code></li>
</ul>
<p>We’ll see more on this syntax in Chapter 18. For now,
it’s enough to know that if we want to poll a future to check whether it is
<code>Pending</code> or <code>Ready(Output)</code>, we need a <code>Pin</code>-wrapped mutable reference to the
type.</p>
<p>第 18 章将详述此语法。目前只需知晓：轮询 Future 检查其状态（<code>Pending</code> 或 <code>Ready(Output)</code>）时，需要该类型的 <code>Pin</code> 包裹的可变引用。</p>
<p><code>Pin</code> is a wrapper for pointer-like types such as <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, and <code>Rc</code>.
(Technically, <code>Pin</code> works with types that implement the <code>Deref</code> or <code>DerefMut</code>
traits, but this is effectively equivalent to working only with pointers.) <code>Pin</code>
is not a pointer itself and doesn’t have any behavior of its own like <code>Rc</code> and
<code>Arc</code> do with reference counting; it’s purely a tool the compiler can use to
enforce constraints on pointer usage.</p>
<p><code>Pin</code> 是指针类类型（如 <code>&amp;</code>、<code>&amp;mut</code>、<code>Box</code>、<code>Rc</code>）的包装器（严格说，<code>Pin</code> 适用于实现 <code>Deref</code> 或 <code>DerefMut</code> 的类型，但效果等同于仅处理指针）。<code>Pin</code> 本身非指针，也不像 <code>Rc</code> 和 <code>Arc</code> 具备引用计数等行为；它纯粹是编译器用于强制执行指针约束的工具。</p>
<p>Recalling that <code>await</code> is implemented in terms of calls to <code>poll</code> starts to
explain the error message we saw earlier, but that was in terms of <code>Unpin</code>, not
<code>Pin</code>. So how exactly does <code>Pin</code> relate to <code>Unpin</code>, and why does <code>Future</code> need
<code>self</code> to be in a <code>Pin</code> type to call <code>poll</code>?</p>
<p>回顾 <code>await</code> 通过调用 <code>poll</code> 实现，可部分解释之前的错误，但错误涉及 <code>Unpin</code> 而非 <code>Pin</code>。那么 <code>Pin</code> 与 <code>Unpin</code> 究竟有何关联？为何 <code>Future</code> 调用 <code>poll</code> 时要求 <code>self</code> 为 <code>Pin</code> 类型？</p>
<p>Remember from earlier in this chapter a series of await points in a future get
compiled into a state machine, and the compiler makes sure that state machine
follows all of Rust’s normal rules around safety, including borrowing and
ownership. To make that work, Rust looks at what data is needed between one
await point and either the next await point or the end of the async block. It
then creates a corresponding variant in the compiled state machine. Each variant
gets the access it needs to the data that will be used in that section of the
source code, whether by taking ownership of that data or by getting a mutable or
immutable reference to it.</p>
<p>本章前文提到，Future 中的一系列等待点会被编译为状态机，编译器确保该状态机遵循 Rust 的安全规则（包括借用和所有权）。为此，Rust 分析从一个等待点到下一等待点（或 async 块结束）所需的数据，并在编译后的状态机中创建对应变体。每个变体通过获取所有权或可变/不可变引用来访问该代码段所需数据。</p>
<p>So far, so good: if we get anything wrong about the ownership or references in a
given async block, the borrow checker will tell us. When we want to move around
the future that corresponds to that block—like moving it into a <code>Vec</code> to pass to
<code>join_all</code>—things get trickier.</p>
<p>目前一切正常：若在 async 块中所有权或引用处理有误，借用检查器会报错。但当移动该块对应的 Future 时（如移入 <code>Vec</code> 以传递给 <code>join_all</code>），情况变得复杂。</p>
<p>When we move a future—whether by pushing it into a data structure to use as an
iterator with <code>join_all</code> or by returning it from a function—that actually means
moving the state machine Rust creates for us. And unlike most other types in
Rust, the futures Rust creates for async blocks can end up with references to
themselves in the fields of any given variant, as shown in the simplified illustration in Figure 17-4.</p>
<p>移动 Future（无论是将其推入数据结构供 <code>join_all</code> 迭代使用，还是从函数返回）实际是移动 Rust 生成的状态机。与多数 Rust 类型不同，async 块生成的 Future 可能在其任意变体字段中包含指向自身的引用，如图 17-4 的简化示意图所示。</p>
<figure>
<img alt="" src="img/trpl17-04.svg" class="center" />
<figcaption>Figure 17-4: A self-referential data type. 自引用数据类型</figcaption>
</figure>
<p>By default, though, any object that has a reference to itself is unsafe to move,
because references always point to the actual memory address of whatever they
refer to (see Figure 17-5). If you move the data structure itself, those
internal references will be left pointing to the old location. However, that
memory location is now invalid. For one thing, its value will not be updated
when you make changes to the data structure. For another—more important—thing,
the computer is now free to reuse that memory for other purposes! You could end
up reading completely unrelated data later.</p>
<p>默认情况下，包含自引用的对象移动是不安全的，因为引用总指向其目标的内存地址（见图 17-5）。若移动数据结构，内部引用将指向旧地址，而该地址现已失效：值更新不会反映移动，且计算机可重用该内存！最终可能读取到无关数据。</p>
<figure>
<img alt="" src="img/trpl17-05.svg" class="center" />
<figcaption>Figure 17-5: The unsafe result of moving a self-referential data type 移动自引用数据类型的不安全结果</figcaption>
</figure>
<p>Theoretically, the Rust compiler could try to update every reference to an
object whenever it gets moved, but that could add a lot of performance overhead,
especially if a whole web of references needs updating. If we could instead make
sure the data structure in question <em>doesn’t move in memory</em>, we wouldn’t have
to update any references. This is exactly what Rust’s borrow checker requires:
in safe code, it prevents you from moving any item with an active reference to
it.</p>
<p>理论上，Rust 编译器可在对象移动时更新所有引用，但这会带来性能开销（尤其当引用网络庞大时）。若确保数据结构<strong>内存位置固定</strong>，则无需更新引用。这正是 Rust 借用检查器的要求：在安全代码中，禁止移动存在活跃引用的项。</p>
<p><code>Pin</code> builds on that to give us the exact guarantee we need. When we <em>pin</em> a
value by wrapping a pointer to that value in <code>Pin</code>, it can no longer move. Thus,
if you have <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>, you actually pin the <code>SomeType</code> value, <em>not</em>
the <code>Box</code> pointer. Figure 17-6 illustrates this process.</p>
<p><code>Pin</code> 基于此提供所需保证：当通过 <code>Pin</code> 包裹指向值的指针来<strong>固定</strong>该值时，其位置将不可移动。因此，若持有 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>，实际固定的是 <code>SomeType</code> 值而非 <code>Box</code> 指针。图 17-6 展示了此过程。</p>
<figure>
<img alt="" src="img/trpl17-06.svg" class="center" />
<figcaption>Figure 17-6: Pinning a `Box` that points to a self-referential future type. 固定指向自引用 Future 的 `Box`</figcaption>
</figure>
<p>In fact, the <code>Box</code> pointer can still move around freely. Remember: we care about
making sure the data ultimately being referenced stays in place. If a pointer
moves around, <em>but the data it points to is in the same place</em>, as in Figure
17-7, there’s no potential problem. As an independent exercise, look at the docs
for the types as well as the <code>std::pin</code> module and try to work out how you’d do
this with a <code>Pin</code> wrapping a <code>Box</code>.) The key is that the self-referential type
itself cannot move, because it is still pinned.</p>
<p>实际上 <code>Box</code> 指针仍可自由移动（见图 17-7）。关键点在于确保被引用的数据位置固定。若指针移动但指向的数据未移动（作为独立练习，可查阅相关类型及 <code>std::pin</code> 文档），则无潜在问题。核心在于自引用类型本身不可移动，因其仍处于固定状态。</p>
<figure>
<img alt="" src="img/trpl17-07.svg" class="center" />
<figcaption>Figure 17-7: Moving a `Box` which points to a self-referential future type. 移动指向自引用 Future 的 `Box`</figcaption>
</figure>
<p>However, most types are perfectly safe to move around, even if they happen to be
behind a <code>Pin</code> wrapper. We only need to think about pinning when items have
internal references. Primitive values such as numbers and Booleans are safe
because they obviously don’t have any internal references. Neither do most types
you normally work with in Rust. You can move around a <code>Vec</code>, for example,
without worrying. Given only what we have seen so far, if you have a
<code>Pin&lt;Vec&lt;String&gt;&gt;</code>, you’d have to do everything via the safe but restrictive
APIs provided by <code>Pin</code>, even though a <code>Vec&lt;String&gt;</code> is always safe to move if
there are no other references to it. We need a way to tell the compiler that
it’s fine to move items around in cases like this—and that’s where <code>Unpin</code> comes
into play.</p>
<p>但多数类型可安全移动，即使被 <code>Pin</code> 包裹。仅当项存在内部引用时才需考虑固定。原始值（如数字、布尔值）显然安全，Rust 中多数常用类型（如 <code>Vec</code>）亦然。若持有 <code>Pin&lt;Vec&lt;String&gt;&gt;</code>，即使 <code>Vec&lt;String&gt;</code> 在无其他引用时可安全移动，也需通过 <code>Pin</code> 提供的安全但受限的 API 操作。我们需要一种方式告知编译器此类情况可安全移动——这正是 <code>Unpin</code> 的作用。</p>
<p><code>Unpin</code> is a marker trait, similar to the <code>Send</code> and <code>Sync</code> traits we saw in
Chapter 16, and thus has no functionality of its own. Marker traits exist only
to tell the compiler it’s safe to use the type implementing a given trait in a
particular context. <code>Unpin</code> informs the compiler that a given type does <em>not</em>
need to uphold any guarantees about whether the value in question can be safely
moved.</p>
<p><code>Unpin</code> 是标记特征（类似第 16 章的 <code>Send</code> 和 <code>Sync</code>），自身无功能。标记特征仅用于告知编译器可在特定上下文中安全使用实现该特征的类型。<code>Unpin</code> 向编译器声明：某类型<strong>无需</strong>保证其值可安全移动。</p>
<p>Just as with <code>Send</code> and <code>Sync</code>, the compiler implements <code>Unpin</code> automatically
for all types where it can prove it is safe. A special case, again similar to
<code>Send</code> and <code>Sync</code>, is where <code>Unpin</code> is <em>not</em> implemented for a type. The
notation for this is <code>impl !Unpin for <em>SomeType</em></code>, where
<code><em>SomeType</em></code> is the name of a type that <em>does</em> need to uphold
those guarantees to be safe whenever a pointer to that type is used in a <code>Pin</code>.</p>
<p>与 <code>Send</code> 和 <code>Sync</code> 类似，编译器会为可证明安全的所有类型自动实现 <code>Unpin</code>。特殊情况下，某类型可能<strong>未实现</strong> <code>Unpin</code>，记为 <code>impl !Unpin for <em>SomeType</em></code>，表示该类型需在 <code>Pin</code> 包裹的指针使用时满足安全保证。</p>
<p>In other words, there are two things to keep in mind about the relationship
between <code>Pin</code> and <code>Unpin</code>. First, <code>Unpin</code> is the “normal” case, and <code>!Unpin</code> is
the special case. Second, whether a type implements <code>Unpin</code> or <code>!Unpin</code> <em>only</em>
matters when you’re using a pinned pointer to that type like <code>Pin&lt;&amp;mut
<em>SomeType</em>&gt;</code>.</p>
<p>综上，关于 <code>Pin</code> 和 <code>Unpin</code> 需注意两点：</p>
<ol>
<li><code>Unpin</code> 是“常态”，<code>!Unpin</code> 是特例</li>
<li>仅当使用固定指针（如 <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>）时，类型是否实现 <code>Unpin</code> 才有意义</li>
</ol>
<p>To make that concrete, think about a <code>String</code>: it has a length and the Unicode
characters that make it up. We can wrap a <code>String</code> in <code>Pin</code>, as seen in Figure
17-8. However, <code>String</code> automatically implements <code>Unpin</code>, as do most other types
in Rust.</p>
<p>以 <code>String</code> 为例（见图 17-8）：其长度和字符数据可被 <code>Pin</code> 包裹，但 <code>String</code> 自动实现 <code>Unpin</code>（Rust 中多数类型如此）。</p>
<figure>
<img alt="" src="img/trpl17-08.svg" class="center" />
<figcaption>Figure 17-8: Pinning a `String`; the dotted line indicates that the `String` implements the `Unpin` trait, and thus is not pinned. 固定 `String`（虚线表示其实现 `Unpin` 特征，故未被固定）</figcaption>
</figure>
<p>As a result, we can do things that would be illegal if <code>String</code> implemented
<code>!Unpin</code> instead, such as replacing one string with another at the exact same
location in memory as in Figure 17-9. This doesn’t violate the <code>Pin</code> contract,
because <code>String</code> has no internal references that make it unsafe to move around!
That is precisely why it implements <code>Unpin</code> rather than <code>!Unpin</code>.</p>
<p>因此，若 <code>String</code> 实现 <code>!Unpin</code> 本应非法的操作（如在内存相同位置替换字符串，见图 17-9），在 <code>Unpin</code> 下是允许的。这不违反 <code>Pin</code> 约定，因为 <code>String</code> 无使其移动不安全的内部引用！这正是其实现 <code>Unpin</code> 而非 <code>!Unpin</code> 的原因。</p>
<figure>
<img alt="" src="img/trpl17-09.svg" class="center" />
<figcaption>Figure 17-9: Replacing the `String` with an entirely different `String` in memory. 在内存中完全替换 `String`</figcaption>
</figure>
<p>Now we know enough to understand the errors reported for that <code>join_all</code> call
from back in Listing 17-17. We originally tried to move the futures produced by
async blocks into a <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>, but as we’ve seen,
those futures may have internal references, so they don’t implement <code>Unpin</code>.
They need to be pinned, and then we can pass the <code>Pin</code> type into the <code>Vec</code>,
confident that the underlying data in the futures will <em>not</em> be moved.</p>
<p>现在可理解清单 17-17 中 <code>join_all</code> 调用的报错了：我们尝试将 async 块生成的 Future 移入 <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>，但这些 Future 可能有内部引用，故未实现 <code>Unpin</code>。它们需被固定后，才能将 <code>Pin</code> 类型传入 <code>Vec</code>，确保 Future 底层数据<strong>不会</strong>移动。</p>
<p><code>Pin</code> and <code>Unpin</code> are mostly important for building lower-level libraries, or
when you’re building a runtime itself, rather than for day-to-day Rust code.
When you see these traits in error messages, though, now you’ll have a better
idea of how to fix your code!</p>
<p><code>Pin</code> 和 <code>Unpin</code> 主要用于构建底层库或运行时本身，而非日常 Rust 编码。但当在错误信息中遇到这些特征时，你现在应能更好地修复代码！</p>
<section class="note" aria-role="note">
<p>Note: This combination of <code>Pin</code> and <code>Unpin</code> makes it possible to safely
implement a whole class of complex types in Rust that would otherwise prove
challenging because they’re self-referential. Types that require <code>Pin</code> show up
most commonly in async Rust today, but every once in a while, you might see
them in other contexts, too.</p>
<p>注意：<code>Pin</code> 与 <code>Unpin</code> 的组合使 Rust 能安全实现一类复杂类型（否则因自引用特性难以实现）。需 <code>Pin</code> 的类型最常见于异步 Rust，但偶尔也出现在其他场景。</p>
<p>The specifics of how <code>Pin</code> and <code>Unpin</code> work, and the rules they’re required
to uphold, are covered extensively in the API documentation for <code>std::pin</code>, so
if you’re interested in learning more, that’s a great place to start.</p>
<p><code>Pin</code> 和 <code>Unpin</code> 的具体工作原理及约束规则详见 <code>std::pin</code> 的 API 文档。</p>
<p>If you want to understand how things work under the hood in even more detail,
see Chapters 2 and 4 of <em>Asynchronous
Programming in Rust</em>.</p>
<p>若需更深入理解底层机制，请参阅《Rust 异步编程》第 2 章和第 4 章。</p>
</section>
<h3 id="the-stream-trait-stream-特征"><a class="header" href="#the-stream-trait-stream-特征">The <code>Stream</code> Trait <code>Stream</code> 特征</a></h3>
<p>Now that you have a deeper grasp on the <code>Future</code>, <code>Pin</code>, and <code>Unpin</code> traits, we
can turn our attention to the <code>Stream</code> trait. As you learned earlier in the
chapter, streams are similar to asynchronous iterators. Unlike <code>Iterator</code> and
<code>Future</code>, however, <code>Stream</code> has no definition in the standard library as of this
writing, but there <em>is</em> a very common definition from the <code>futures</code> crate used
throughout the ecosystem.</p>
<p>深入理解 <code>Future</code>、<code>Pin</code> 和 <code>Unpin</code> 后，我们将转向 <code>Stream</code> 特征。如本章前文所述，流（Stream）类似于异步迭代器。但不同于 <code>Iterator</code> 和 <code>Future</code>，截至本文写作时 <code>Stream</code> 在标准库中无定义，生态中普遍使用的是 <code>futures</code> crate 的定义。</p>
<p>Let’s review the definitions of the <code>Iterator</code> and <code>Future</code> traits before
looking at how a <code>Stream</code> trait might merge them together. From <code>Iterator</code>, we
have the idea of a sequence: its <code>next</code> method provides an <code>Option&lt;Self::Item&gt;</code>.
From <code>Future</code>, we have the idea of readiness over time: its <code>poll</code> method
provides a <code>Poll&lt;Self::Output&gt;</code>. To represent a sequence of items that become
ready over time, we define a <code>Stream</code> trait that puts those features together:</p>
<p>在探讨如何合并 <code>Stream</code> 特征前，先回顾 <code>Iterator</code> 和 <code>Future</code> 的定义。<code>Iterator</code> 体现序列性：其 <code>next</code> 方法返回 <code>Option&lt;Self::Item&gt;</code>。<code>Future</code> 体现随时间就绪性：其 <code>poll</code> 方法返回 <code>Poll&lt;Self::Output&gt;</code>。为表示随时间就绪的项序列，我们定义结合这两者的 <code>Stream</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Stream</code> trait defines an associated type called <code>Item</code> for the type of the
items produced by the stream. This is similar to <code>Iterator</code>, where there may be
zero to many items, and unlike <code>Future</code>, where there is always a single
<code>Output</code>, even if it’s the unit type <code>()</code>.</p>
<p><code>Stream</code> 特征定义关联类型 <code>Item</code> 表示流生成的项类型。这类似于 <code>Iterator</code>（可能生成零至多项），而有别于 <code>Future</code>（即使输出为单元类型 <code>()</code>，也总有单个 <code>Output</code>）。</p>
<p><code>Stream</code> also defines a method to get those items. We call it <code>poll_next</code>, to
make it clear that it polls in the same way <code>Future::poll</code> does and produces a
sequence of items in the same way <code>Iterator::next</code> does. Its return type
combines <code>Poll</code> with <code>Option</code>. The outer type is <code>Poll</code>, because it has to be
checked for readiness, just as a future does. The inner type is <code>Option</code>,
because it needs to signal whether there are more messages, just as an iterator
does.</p>
<p><code>Stream</code> 还定义了获取项的方法 <code>poll_next</code>，其命名明确体现类似 <code>Future::poll</code> 的轮询机制和类似 <code>Iterator::next</code> 的序列生成特性。返回类型结合了 <code>Poll</code> 和 <code>Option</code>：外层为 <code>Poll</code>（需检查就绪性，如 Future），内层为 <code>Option</code>（需表示是否有更多消息，如迭代器）。</p>
<p>Something very similar to this definition will likely end up as part of Rust’s
standard library. In the meantime, it’s part of the toolkit of most runtimes, so
you can rely on it, and everything we cover next should generally apply!</p>
<p>类似定义很可能纳入 Rust 标准库。目前它已是多数运行时的工具集组成部分，因此你可依赖它，且下文内容通常适用！</p>
<p>In the example we saw in the section on streaming, though, we didn’t use
<code>poll_next</code> <em>or</em> <code>Stream</code>, but instead used <code>next</code> and <code>StreamExt</code>. We <em>could</em>
work directly in terms of the <code>poll_next</code> API by hand-writing our own <code>Stream</code>
state machines, of course, just as we <em>could</em> work with futures directly via
their <code>poll</code> method. Using <code>await</code> is much nicer, though, and the <code>StreamExt</code>
trait supplies the <code>next</code> method so we can do just that:</p>
<p>但在本章流处理的示例中，我们未使用 <code>poll_next</code> 或 <code>Stream</code>，而是使用了 <code>next</code> 和 <code>StreamExt</code>。当然，我们也可直接通过 <code>poll_next</code> API 手动编写 <code>Stream</code> 状态机（如同通过 <code>poll</code> 方法直接操作 Future）。但使用 <code>await</code> 更优雅，而 <code>StreamExt</code> 特征提供的 <code>next</code> 方法使之成为可能：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre></pre>
<section class="note" aria-role="note">
<p>Note: The actual definition we used earlier in the chapter looks slightly
different than this, because it supports versions of Rust that did not yet
support using async functions in traits. As a result, it looks like this:</p>
<p>注意：本章早前使用的实际定义略有不同（因支持在特征中使用 async 函数的 Rust 版本较新）。其形式如下：</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>That <code>Next</code> type is a <code>struct</code> that implements <code>Future</code> and allows us to name
the lifetime of the reference to <code>self</code> with <code>Next&lt;'_, Self&gt;</code>, so that <code>await</code>
can work with this method.</p>
<p>此处的 <code>Next</code> 是实现了 <code>Future</code> 的结构体，通过 <code>Next&lt;'_, Self&gt;</code> 显式命名 <code>self</code> 引用的生命周期，使 <code>await</code> 可作用于该方法。</p>
</section>
<p>The <code>StreamExt</code> trait is also the home of all the interesting methods available
to use with streams. <code>StreamExt</code> is automatically implemented for every type
that implements <code>Stream</code>, but these traits are defined separately to enable the
community to iterate on convenience APIs without affecting the foundational
trait.</p>
<p><code>StreamExt</code> 特征也包含所有流操作的有用方法。该特征自动为所有实现 <code>Stream</code> 的类型提供实现，但与基础特征分离定义，以便社区迭代便利 API 而不影响核心。</p>
<p>In the version of <code>StreamExt</code> used in the <code>trpl</code> crate, the trait not only
defines the <code>next</code> method but also supplies a default implementation of <code>next</code>
that correctly handles the details of calling <code>Stream::poll_next</code>. This means
that even when you need to write your own streaming data type, you <em>only</em> have
to implement <code>Stream</code>, and then anyone who uses your data type can use
<code>StreamExt</code> and its methods with it automatically.</p>
<p>在 <code>trpl</code> crate 使用的 <code>StreamExt</code> 版本中，该特征不仅定义 <code>next</code> 方法，还提供正确处理 <code>Stream::poll_next</code> 细节的默认实现。这意味着即使需自定义流数据类型，也<strong>仅需</strong>实现 <code>Stream</code>，使用者即可自动使用 <code>StreamExt</code> 的方法。</p>
<p>That’s all we’re going to cover for the lower-level details on these traits. To
wrap up, let’s consider how futures (including streams), tasks, and threads all
fit together!</p>
<p>关于这些特征的底层细节到此结束。最后，我们探讨 Future（含流）、任务和线程如何协同工作！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="putting-it-all-together-futures-tasks-and-threads-整合future任务与线程"><a class="header" href="#putting-it-all-together-futures-tasks-and-threads-整合future任务与线程">Putting It All Together: Futures, Tasks, and Threads 整合：Future、任务与线程</a></h2>
<p>As we saw in Chapter 16, threads provide one approach to
concurrency. We’ve seen another approach in this chapter: using async with
futures and streams. If you‘re wondering when to choose method over the other,
the answer is: it depends! And in many cases, the choice isn’t threads <em>or</em>
async but rather threads <em>and</em> async.</p>
<p>如第 16 章所见，线程提供了一种并发途径。本章展示了另一种途径：使用 async 与 Future 及流。若你困惑如何选择，答案是：视情况而定！多数情况下，选择非线程<strong>或</strong>异步，而是线程<strong>与</strong>异步协同。</p>
<p>Many operating systems have supplied threading-based concurrency models for
decades now, and many programming languages support them as a result. However,
these models are not without their tradeoffs. On many operating systems, they
use a fair bit of memory for each thread, and they come with some overhead for
starting up and shutting down. Threads are also only an option when your
operating system and hardware support them. Unlike mainstream desktop and mobile
computers, some embedded systems don’t have an OS at all, so they also don’t
have threads.</p>
<p>许多操作系统提供基于线程的并发模型已数十年，多数编程语言因此支持它们。但这些模型存在代价：许多系统为每个线程分配较多内存，且启动/关闭有开销。此外，仅当操作系统和硬件支持时线程才可用（嵌入式系统等无 OS 环境不适用）。</p>
<p>The async model provides a different—and ultimately complementary—set of
tradeoffs. In the async model, concurrent operations don’t require their own
threads. Instead, they can run on tasks, as when we used <code>trpl::spawn_task</code> to
kick off work from a synchronous function in the streams section. A task is
similar to a thread, but instead of being managed by the operating system, it’s
managed by library-level code: the runtime.</p>
<p>异步模型提供了一套不同且互补的权衡方案。异步模型中，并发操作无需独占线程，而是运行在任务（task）上（如在流处理章节通过 <code>trpl::spawn_task</code> 从同步函数启动工作）。任务类似于线程，但非由操作系统管理，而是由库级代码（运行时）管理。</p>
<p>In the previous section, we saw that we could build a stream by using an async
channel and spawning an async task we could call from synchronous code. We can
do the exact same thing with a thread. In Listing 17-40, we used
<code>trpl::spawn_task</code> and <code>trpl::sleep</code>. In Listing 17-41, we replace those with
the <code>thread::spawn</code> and <code>thread::sleep</code> APIs from the standard library in the
<code>get_intervals</code> function.</p>
<p>上节中，我们使用异步通道构建流，并通过异步任务从同步代码调用。线程也可实现相同功能。清单 17-40 使用了 <code>trpl::spawn_task</code> 和 <code>trpl::sleep</code>，清单 17-41 则在 <code>get_intervals</code> 函数中替换为标准库的 <code>thread::spawn</code> 和 <code>thread::sleep</code> API。</p>
<figure class="listing" id="listing-17-41">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
</span><span class="boring">                eprintln!("Cannot send message '{message}': {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
<figcaption><a href="ch17-06-futures-tasks-threads.html#listing-17-41">Listing 17-41</a>: Using the <code>std::thread</code> APIs instead of the async <code>trpl</code> APIs for the <code>get_intervals</code> function 在 <code>get_intervals</code> 函数中使用 <code>std::thread</code> API 替代异步 <code>trpl</code> API</figcaption>
</figure>
<p>If you run this code, the output is identical to that of Listing 17-40. And
notice how little changes here from the perspective of the calling code. What’s
more, even though one of our functions spawned an async task on the runtime and
the other spawned an OS thread, the resulting streams were unaffected by the
differences.</p>
<p>运行此代码，输出与清单 17-40 完全相同。注意调用代码的改动极小！更重要的是，尽管一个函数在运行时生成异步任务，另一个生成 OS 线程，但产生的流不受差异影响。</p>
<p>Despite their similarities, these two approaches behave very differently,
although we might have a hard time measuring it in this very simple example. We
could spawn millions of async tasks on any modern personal computer. If we tried
to do that with threads, we would literally run out of memory!</p>
<p>尽管相似，这两种方式行为迥异（在此简单示例中难以测量）。现代个人计算机可生成数百万异步任务，但使用线程尝试此操作会耗尽内存！</p>
<p>However, there’s a reason these APIs are so similar. Threads act as a boundary
for sets of synchronous operations; concurrency is possible <em>between</em> threads.
Tasks act as a boundary for sets of <em>asynchronous</em> operations; concurrency is
possible both <em>between</em> and <em>within</em> tasks, because a task can switch between
futures in its body. Finally, futures are Rust’s most granular unit of
concurrency, and each future may represent a tree of other futures. The
runtime—specifically, its executor—manages tasks, and tasks manage futures. In
that regard, tasks are similar to lightweight, runtime-managed threads with
added capabilities that come from being managed by a runtime instead of by the
operating system.</p>
<p>但两种 API 相似存在原因：线程作为同步操作的边界，支持线程<strong>间</strong>并发；任务作为<strong>异步</strong>操作的边界，支持任务<strong>间</strong>与任务<strong>内</strong>并发（因任务可在其体内切换 Future）。最终，Future 是 Rust 最细粒度的并发单元，每个 Future 可表示其他 Future 的树形结构。运行时（具体指其执行器）管理任务，任务管理 Future。就此而言，任务类似于由运行时（而非操作系统）管理的轻量级线程，并具备额外能力。</p>
<p>This doesn’t mean that async tasks are always better than threads (or vice
versa). Concurrency with threads is in some ways a simpler programming model
than concurrency with <code>async</code>. That can be a strength or a weakness. Threads are
somewhat “fire and forget”; they have no native equivalent to a future, so they
simply run to completion without being interrupted except by the operating
system itself. That is, they have no built-in support for <em>intratask
concurrency</em> the way futures do. Threads in Rust also have no mechanisms for
cancellation—a subject we haven’t covered explicitly in this chapter but was
implied by the fact that whenever we ended a future, its state got cleaned up
correctly.</p>
<p>这不意味着异步任务总优于线程（或反之）。线程并发模型在某些方面比异步更简单，这可能是优势也可能是劣势。线程某种程度上是“即发即弃”；它们无原生等价于 Future 的机制，因此仅运行至完成（除非被操作系统中断）。即，它们无内置的<strong>任务内并发</strong>支持（如 Future）。Rust 线程也无取消机制（本章未明确涉及，但通过 Future 状态正确清理已隐含此能力）。</p>
<p>These limitations also make threads harder to compose than futures. It’s much
more difficult, for example, to use threads to build helpers such as the
<code>timeout</code> and <code>throttle</code> methods we built earlier in this chapter. The fact that
futures are richer data structures means they can be composed together more
naturally, as we have seen.</p>
<p>这些限制也使线程比 Future 更难组合。例如，使用线程构建类似本章早前的 <code>timeout</code> 和 <code>throttle</code> 方法更为困难。Future 作为更丰富的数据结构，可更自然地组合（如前所见）。</p>
<p>Tasks, then, give us <em>additional</em> control over futures, allowing us to choose
where and how to group them. And it turns out that threads and tasks often work
very well together, because tasks can (at least in some runtimes) be moved
around between threads. In fact, under the hood, the runtime we’ve been
using—including the <code>spawn_blocking</code> and <code>spawn_task</code> functions—is multithreaded
by default! Many runtimes use an approach called <em>work stealing</em> to
transparently move tasks around between threads, based on how the threads are
currently being utilized, to improve the system’s overall performance. That
approach actually requires threads <em>and</em> tasks, and therefore futures.</p>
<p>因此，任务赋予我们对 Future 的<strong>额外</strong>控制权，允许选择分组方式。事实证明，线程与任务常能出色协作，因为任务可（至少在某些运行时中）在线程间移动。实际上，我们使用的运行时（含 <code>spawn_blocking</code> 和 <code>spawn_task</code> 函数）默认是多线程的！许多运行时采用<strong>工作窃取</strong>（work stealing）策略，根据线程当前利用率在线程间透明迁移任务以提升整体性能。此策略实际需线程<strong>与</strong>任务（进而需 Future）协同工作。</p>
<p>When thinking about which method to use when, consider these rules of thumb:</p>
<p>选择方法时可参考以下经验法则：</p>
<ul>
<li>If the work is <em>very parallelizable</em>, such as processing a bunch of data where
each part can be processed separately, threads are a better choice.</li>
<li><span class="highlight">[note]高度可并行工作（如各部分可独立处理的数据处理）：线程更优</span></li>
<li>If the work is <em>very concurrent</em>, such as handling messages from a bunch of
different sources that may come in at different intervals or different rates,
async is a better choice.</li>
<li><span class="highlight">[note]高度并发工作（如处理不同间隔/速率的多源消息）：异步更优</span></li>
</ul>
<p>And if you need both parallelism and concurrency, you don’t have to choose
between threads and async. You can use them together freely, letting each one
play the part it’s best at. For example, Listing 17-42 shows a fairly common
example of this kind of mix in real-world Rust code.</p>
<p>若需并行与并发，无需在线程和异步间二选一。可自由组合两者，发挥各自优势。例如，清单 17-42 展示了真实 Rust 代码中此类混合的常见示例。</p>
<figure class="listing" id="listing-17-42">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate trpl; // for mdbook test
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
<figcaption><a href="ch17-06-futures-tasks-threads.html#listing-17-42">Listing 17-42</a>: Sending messages with blocking code in a thread and awaiting the messages in an async block 在线程中运行阻塞代码发送消息，在异步块中等待消息</figcaption>
</figure>
<p>We begin by creating an async channel, then spawn a thread that takes
ownership of the sender side of the channel. Within the thread, we send the
numbers 1 through 10, sleeping for a second between each. Finally, we run a
future created with an async block passed to <code>trpl::run</code> just as we have
throughout the chapter. In that future, we await those messages, just as in
the other message-passing examples we have seen.</p>
<p>我们创建异步通道，生成拥有通道发送端所有权的线程。线程内每秒发送数字 1 到 10。最后，通过传递给 <code>trpl::run</code> 的 async 块运行 Future（如全章所示），其中等待消息（类似其他消息传递示例）。</p>
<p>To return to the scenario we opened the chapter with, imagine running a set of
video encoding tasks using a dedicated thread (because video encoding is
compute-bound) but notifying the UI that those operations are done with an async
channel. There are countless examples of these kinds of combinations in
real-world use cases.</p>
<p>回到本章开篇场景：用专用线程运行视频编码任务（因编码是计算密集型），但通过异步通道通知 UI 操作完成。现实案例中有无数此类组合。</p>
<h2 id="summary-总结-16"><a class="header" href="#summary-总结-16">Summary 总结</a></h2>
<p>This isn’t the last you’ll see of concurrency in this book. The project in
Chapter 21 will apply these concepts in a more realistic situation
than the simpler examples discussed here and compare problem-solving with threading versus tasks more directly.</p>
<p>本书后续仍涉及并发。第 21 章的项目将在更真实场景应用这些概念，并更直接对比线程与任务的解题方式。</p>
<p>No matter which of these approaches you choose, Rust gives you the tools you need to write safe, fast, concurrent
code—whether for a high-throughput web server or an embedded operating system.</p>
<p>无论选择何种方式，Rust 都为你提供编写安全、快速、并发代码的工具——无论用于高吞吐 Web 服务器还是嵌入式操作系统。</p>
<p>Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object-oriented programming.</p>
<p>接下来，我们将探讨随着 Rust 程序规模增长，如何以惯用方式建模问题与构建解决方案，并讨论 Rust 惯用法与你可能熟悉的面向对象编程惯用法的关联。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-features-面向对象编程特性"><a class="header" href="#object-oriented-programming-features-面向对象编程特性">Object-Oriented Programming Features 面向对象编程特性</a></h1>
<p>Object-oriented programming (OOP) is a way of modeling programs. Objects as a
programmatic concept were introduced in the programming language Simula in the
1960s. Those objects influenced Alan Kay’s programming architecture in which
objects pass messages to each other. To describe this architecture, he coined
the term <em>object-oriented programming</em> in 1967. Many competing definitions
describe what OOP is, and by some of these definitions Rust is object oriented
but by others it is not. In this chapter, we’ll explore certain characteristics
that are commonly considered object oriented and how those characteristics
translate to idiomatic Rust. We’ll then show you how to implement an
object-oriented design pattern in Rust and discuss the trade-offs of doing so
versus implementing a solution using some of Rust’s strengths instead.</p>
<p>面向对象编程（OOP）是一种程序建模方式。对象作为编程概念于1960年代在Simula语言中被引入，这些对象影响了Alan Kay的编程架构——其中对象相互传递消息。为描述此架构，他在1967年创造了术语<strong>面向对象编程</strong>。关于OOP的定义存在许多争议，按某些定义Rust是面向对象的，而按另一些则不是。本章将探讨通常被视为面向对象的特性，以及这些特性如何转化为Rust的惯用实现。随后我们将展示如何在Rust中实现面向对象设计模式，并讨论与利用Rust自身优势实现方案的权衡。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="characteristics-of-object-oriented-languages-面向对象语言的特性"><a class="header" href="#characteristics-of-object-oriented-languages-面向对象语言的特性">Characteristics of Object-Oriented Languages 面向对象语言的特性</a></h2>
<p>There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let’s look at what each of those characteristics means and whether
Rust supports it.</p>
<p>编程界对于一门语言必须具备哪些特性才能被视为面向对象尚未达成共识。Rust 受到多种编程范式的影响，包括面向对象编程（OOP）；例如我们在第 13 章探讨了来自函数式编程的特性。可以说，面向对象语言具有某些共同特征：即对象、封装和继承。让我们逐一分析这些特性的含义以及 Rust 是否支持它们。</p>
<h3 id="objects-contain-data-and-behavior-对象包含数据和行为"><a class="header" href="#objects-contain-data-and-behavior-对象包含数据和行为">Objects Contain Data and Behavior 对象包含数据和行为</a></h3>
<p>The book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley,
1994), colloquially referred to as <em>The Gang of Four</em> book, is a catalog of
object-oriented design patterns. It defines OOP in this way:</p>
<p>Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 所著的《设计模式：可复用面向对象软件的基础》（Addison-Wesley, 1994），通常被称为《四人帮》（Gang of Four）著作，其中这样定义面向对象编程：</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <strong>object</strong> packages both
data and the procedures that operate on that data. The procedures are
typically called <strong>methods</strong> or <strong>operations</strong>.</p>
<p>面向对象程序由对象组成。<strong>对象</strong> 同时打包了数据及操作这些数据的流程。这些流程通常被称为 <strong>方法</strong> 或 <strong>操作</strong>。</p>
</blockquote>
<p>Using this definition, Rust is object oriented: structs and enums have data,
and <code>impl</code> blocks provide methods on structs and enums. Even though structs and
enums with methods aren’t <em>called</em> objects, they provide the same
functionality, according to the Gang of Four’s definition of objects.</p>
<p>根据此定义，Rust 是面向对象的：结构体（struct）和枚举（enum）拥有数据，而 <code>impl</code> 块为结构体和枚举提供了方法。尽管带方法的结构体和枚举不被称为对象，但根据四人帮的对象定义，它们提供了相同的功能。</p>
<h3 id="encapsulation-that-hides-implementation-details-隐藏实现细节的封装"><a class="header" href="#encapsulation-that-hides-implementation-details-隐藏实现细节的封装">Encapsulation That Hides Implementation Details 隐藏实现细节的封装</a></h3>
<p>Another aspect commonly associated with OOP is the idea of <em>encapsulation</em>,
which means that the implementation details of an object aren’t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn’t be able to reach into
the object’s internals and change data or behavior directly. This enables the
programmer to change and refactor an object’s internals without needing to
change the code that uses the object.</p>
<p>面向对象的另一个常见特性是 <strong>封装</strong>，这意味着使用对象的代码无法访问其实现细节。因此，与对象交互的唯一方式是通过其公共 API；使用对象的代码不应直接触及对象内部来修改数据或行为。这使得程序员能够在不影响使用该对象代码的前提下，修改和重构对象内部实现。</p>
<p>We discussed how to control encapsulation in Chapter 7: we can use the <code>pub</code>
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct <code>AveragedCollection</code> that has a field containing a vector
of <code>i32</code> values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn’t have to be computed on
demand whenever anyone needs it. In other words, <code>AveragedCollection</code> will
cache the calculated average for us. Listing 18-1 has the definition of the
<code>AveragedCollection</code> struct.</p>
<p>我们在第 7 章讨论了如何控制封装：使用 <code>pub</code> 关键字决定代码中哪些模块、类型、函数和方法应公开，其他内容默认私有。例如可定义包含 <code>i32</code> 值向量的结构体 <code>AveragedCollection</code>，该结构体还包含字段存储向量的平均值，避免每次需要时重复计算。换言之，<code>AveragedCollection</code> 会缓存计算结果（如代码清单 18-1 所示）。</p>
<figure class="listing" id="listing-18-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<figcaption><a href="ch18-01-what-is-oo.html#listing-18-1">Listing 18-1</a>: An <code>AveragedCollection</code> struct that maintains a list of integers and the average of the items in the collection 维护整数列表及平均值的<code>AveragedCollection</code>结构体</figcaption>
</figure>
<p>The struct is marked <code>pub</code> so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing <code>add</code>, <code>remove</code>, and <code>average</code> methods
on the struct, as shown in Listing 18-2.</p>
<p>结构体标记为 <code>pub</code> 可供外部使用，但其内部字段保持私有。这很关键，因为需确保列表增删值时同步更新平均值。通过在结构体上实现 <code>add</code>、<code>remove</code> 和 <code>average</code> 方法实现此功能（如代码清单 18-2）。</p>
<figure class="listing" id="listing-18-2">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<figcaption><a href="ch18-01-what-is-oo.html#listing-18-2">Listing 18-2</a>: Implementations of the public methods <code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code>. <code>AveragedCollection</code> 的公共方法 <code>add</code>、<code>remove</code> 和 <code>average</code> 实现</figcaption>
</figure>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only ways to access
or modify data in an instance of <code>AveragedCollection</code>. When an item is added to
<code>list</code> using the <code>add</code> method or removed using the <code>remove</code> method, the
implementations of each call the private <code>update_average</code> method that handles
updating the <code>average</code> field as well.</p>
<p>公共方法 <code>add</code>、<code>remove</code> 和 <code>average</code> 是访问或修改 <code>AveragedCollection</code> 实例的唯一途径。当通过 <code>add</code> 添加或 <code>remove</code> 删除列表项时，这些方法会调用私有的 <code>update_average</code> 方法更新 <code>average</code> 字段。</p>
<p>We leave the <code>list</code> and <code>average</code> fields private so there is no way for
external code to add or remove items to or from the <code>list</code> field directly;
otherwise, the <code>average</code> field might become out of sync when the <code>list</code>
changes. The <code>average</code> method returns the value in the <code>average</code> field,
allowing external code to read the <code>average</code> but not modify it.</p>
<p>通过保持 <code>list</code> 和 <code>average</code> 字段私有，外部代码无法直接修改 <code>list</code>，确保 <code>average</code> 始终与列表状态同步。<code>average</code> 方法仅返回字段值，允许外部读取但禁止修改。</p>
<p>Because we’ve encapsulated the implementation details of the struct
<code>AveragedCollection</code>, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a <code>HashSet&lt;i32&gt;</code> instead of a
<code>Vec&lt;i32&gt;</code> for the <code>list</code> field. As long as the signatures of the <code>add</code>,
<code>remove</code>, and <code>average</code> public methods stayed the same, code using
<code>AveragedCollection</code> wouldn’t need to change. If we made <code>list</code> public instead,
this wouldn’t necessarily be the case: <code>HashSet&lt;i32&gt;</code> and <code>Vec&lt;i32&gt;</code> have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying <code>list</code> directly.</p>
<p>由于封装了 <code>AveragedCollection</code> 的实现细节，未来可轻松调整内部数据结构（例如将 <code>list</code> 字段的 <code>Vec&lt;i32&gt;</code> 改为 <code>HashSet&lt;i32&gt;</code>）。只要 <code>add</code>、<code>remove</code> 和 <code>average</code> 的方法签名不变，使用 <code>AveragedCollection</code> 的代码就无需修改。若将 <code>list</code> 公开则无法保证这一点——<code>HashSet&lt;i32&gt;</code> 和 <code>Vec&lt;i32&gt;</code> 的增删方法不同，直接操作 <code>list</code> 会迫使外部代码修改。</p>
<p>If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use <code>pub</code> or not for
different parts of code enables encapsulation of implementation details.</p>
<p>若封装是面向对象语言的必要条件，则 Rust 满足此要求。通过 <code>pub</code> 选择性公开实现了实现细节的封装。</p>
<h3 id="inheritance-as-a-type-system-and-as-code-sharing-作为类型系统与代码共享的继承"><a class="header" href="#inheritance-as-a-type-system-and-as-code-sharing-作为类型系统与代码共享的继承">Inheritance as a Type System and as Code Sharing 作为类型系统与代码共享的继承</a></h3>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit elements from
another object’s definition, thus gaining the parent object’s data and behavior
without you having to define them again.</p>
<p><strong>继承</strong> 是一种机制，对象通过继承另一个对象的定义元素，无需重复定义即可获得父对象的数据和行为。</p>
<p>If a language must have inheritance to be object oriented, then Rust is not
such a language. There is no way to define a struct that inherits the parent
struct’s fields and method implementations without using a macro.</p>
<p>若面向对象语言必须支持继承，则 Rust 不符合标准。无法直接定义继承父结构体字段和方法实现的结构体（宏除外）。</p>
<p>However, if you’re used to having inheritance in your programming toolbox, you
can use other solutions in Rust, depending on your reason for reaching for
inheritance in the first place.</p>
<p>但对于习惯使用继承的开发人员，可根据需求选择 Rust 的其他解决方案。</p>
<p>You would choose inheritance for two main reasons. One is for reuse of code:
you can implement particular behavior for one type, and inheritance enables you
to reuse that implementation for a different type. You can do this in a limited
way in Rust code using default trait method implementations, which you saw in
Listing 10-14 when we added a default implementation of the <code>summarize</code> method
on the <code>Summary</code> trait. Any type implementing the <code>Summary</code> trait would have
the <code>summarize</code> method available on it without any further code. This is
similar to a parent class having an implementation of a method and an
inheriting child class also having the implementation of the method. We can
also override the default implementation of the <code>summarize</code> method when we
implement the <code>Summary</code> trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.</p>
<p>继承主要有两个目的：首先是 <strong>代码复用</strong>——为某类型实现特定行为后，继承可将其复用于其他类型。在 Rust 中可通过特质（trait）的默认方法实现有限地达成此目标（如代码清单 10-14 中为 <code>Summary</code> 特质添加的 <code>summarize</code> 默认实现）。任何实现 <code>Summary</code> 特质的类型都会自动获得 <code>summarize</code> 方法，这类似于父类方法被子类继承。实现 <code>Summary</code> 特质时也可覆盖默认方法，类似于子类重写父类方法。</p>
<p>The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called <em>polymorphism</em>, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.</p>
<p>第二个目的是 <strong>类型系统</strong>——允许子类型在父类型适用的场景中使用。这也称为 <strong>多态</strong>（polymorphism），即在运行时可替换具有某些共同特征的对象。</p>
<section class="note" aria-role="note">
<h3 id="polymorphism-多态性"><a class="header" href="#polymorphism-多态性">Polymorphism 多态性</a></h3>
<p>To many people, polymorphism is synonymous with inheritance. But it’s
actually a more general concept that refers to code that can work with data of
multiple types. For inheritance, those types are generally subclasses.</p>
<p>对许多人而言，多态等同于继承。但它实际是更广泛的概念，指能处理多种类型数据的代码。在继承中，这些类型通常是子类。</p>
<p>Rust instead uses generics to abstract over different possible types and
trait bounds to impose constraints on what those types must provide. This is
sometimes called <em>bounded parametric polymorphism</em>.</p>
<p>Rust 改用泛型（generics）抽象不同类型，并通过特质约束（trait bounds）限制类型需提供的功能。这种方式有时称为 <strong>有界参数化多态</strong>（bounded parametric polymorphism）。</p>
</section>
<p>Rust has chosen a different set of tradeoffs by not offering inheritance.
Inheritance is often at risk of sharing more code than necessary. Subclasses
shouldn’t always share all characteristics of their parent class but will do so
with inheritance. This can make a program’s design less flexible. It also
introduces the possibility of calling methods on subclasses that don’t make
sense or that cause errors because the methods don’t apply to the subclass. In
addition, some languages will only allow <em>single inheritance</em> (meaning a
subclass can only inherit from one class), further restricting the flexibility
of a program’s design.</p>
<p>Rust 通过舍弃继承选择了不同的权衡方案。继承机制往往导致过度共享代码——子类不应始终共享父类的全部特性，但继承会强制共享。这会降低程序设计的灵活性，并可能引发错误（对子类调用无意义的方法）。此外，某些语言仅支持 <strong>单继承</strong>（子类只能继承一个父类），进一步限制了程序设计的灵活性。</p>
<p>For these reasons, Rust takes the different approach of using trait objects
instead of inheritance to enable polymorphism. Let’s look at how trait objects
work.</p>
<p>因此 Rust 采用特质对象（trait object）而非继承来实现多态。接下来我们将探讨特质对象的工作机制。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-trait-objects-to-abstract-over-shared-behavior-使用-trait-对象抽象共享行为"><a class="header" href="#using-trait-objects-to-abstract-over-shared-behavior-使用-trait-对象抽象共享行为">Using Trait Objects to Abstract over Shared Behavior 使用 Trait 对象抽象共享行为</a></h2>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-9 where
we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.</p>
<p>在第 8 章中，我们提到向量的一个限制是只能存储单一类型的元素。我们在示例 8-9 中创建了一个变通方案，定义了包含不同成员的 <code>SpreadsheetCell</code> 枚举来存储整数、浮点数和文本。这意味着我们可以在每个单元格存储不同类型的数据，同时仍拥有表示整行单元格的向量。当可互换项是编译时已知的固定类型集合时，这是一个完美的解决方案。</p>
<p>However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we’ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a <code>draw</code> method on each one to draw it to the
screen—a common technique for GUI tools. We’ll create a library crate called
<code>gui</code> that contains the structure of a GUI library. This crate might include
some types for people to use, such as <code>Button</code> or <code>TextField</code>. In addition,
<code>gui</code> users will want to create their own types that can be drawn: for
instance, one programmer might add an <code>Image</code> and another might add a
<code>SelectBox</code>.</p>
<p>然而，有时我们希望库用户能够扩展特定场景下有效的类型集合。为展示实现方式，我们将创建一个图形用户界面（GUI）工具示例，该工具会遍历项目列表并对每个项目调用 <code>draw</code> 方法将其绘制到屏幕上——这是 GUI 工具的常用技术。我们将创建一个名为 <code>gui</code> 的库 crate，其中包含 GUI 库的结构。该 crate 可能包含供用户使用的类型，例如 <code>Button</code> 或 <code>TextField</code>。此外，<code>gui</code> 用户可能希望创建可绘制的自定义类型：例如，一位程序员可能添加 <code>Image</code>，另一位可能添加 <code>SelectBox</code>。</p>
<p>At the time of writing the library, we can’t know and define all the types
other programmers might want to create. But we do know that <code>gui</code> needs to keep
track of many values of different types, and it needs to call a <code>draw</code> method
on each of these differently typed values. It doesn’t need to know exactly what
will happen when we call the <code>draw</code> method, just that the value will have that
method available for us to call.</p>
<p>在编写库时，我们无法预知或定义其他程序员可能创建的所有类型。但我们知道 <code>gui</code> 需要追踪多种不同类型的值，并需要对每个不同类型的值调用 <code>draw</code> 方法。它无需确切知道调用 <code>draw</code> 方法时会发生什么，只需确保该值具有可供调用的此方法。</p>
<p>To do this in a language with inheritance, we might define a class named
<code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as
<code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus
inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define
their custom behavior, but the framework could treat all of the types as if
they were <code>Component</code> instances and call <code>draw</code> on them. But because Rust
doesn’t have inheritance, we need another way to structure the <code>gui</code> library to
allow users to create new types compatible with the library.</p>
<p>在支持继承的语言中，可以定义名为 <code>Component</code> 的类，其中包含 <code>draw</code> 方法。其他类（如 <code>Button</code>、<code>Image</code> 和 <code>SelectBox</code>）会继承 <code>Component</code> 并自动获得 <code>draw</code> 方法。它们可各自重写 <code>draw</code> 方法定义自定义行为，但框架可将所有类型视为 <code>Component</code> 实例调用其 <code>draw</code> 方法。由于 Rust 不支持继承，我们需要另一种方式构建 <code>gui</code> 库以允许用户创建与库兼容的新类型。</p>
<h3 id="defining-a-trait-for-common-behavior-为通用行为定义-trait"><a class="header" href="#defining-a-trait-for-common-behavior-为通用行为定义-trait">Defining a Trait for Common Behavior 为通用行为定义 Trait</a></h3>
<p>To implement the behavior we want <code>gui</code> to have, we’ll define a trait named
<code>Draw</code> that will have one method named <code>draw</code>. Then we can define a vector that
takes a trait object. A <em>trait object</em> points to both an instance of a type
implementing our specified trait and a table used to look up trait methods on
that type at runtime. We create a trait object by specifying some sort of
pointer, such as an <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, then the <code>dyn</code>
keyword, and then specifying the relevant trait. (We’ll talk about the reason
trait objects must use a pointer in “Dynamically Sized Types and the <code>Sized</code>
Trait” in Chapter 20.) We can use trait
objects in place of a generic or concrete type. Wherever we use a trait object,
Rust’s type system will ensure at compile time that any value used in that
context will implement the trait object’s trait. Consequently, we don’t need to
know all the possible types at compile time.</p>
<p>为实现 <code>gui</code> 所需的行为，我们将定义名为 <code>Draw</code> 的 trait，其中包含一个 <code>draw</code> 方法。随后可定义接收 trait 对象的向量。<strong>trait 对象</strong>同时指向实现了指定 trait 的类型实例，以及用于在运行时查找该类型 trait 方法的表。<span class="highlight">[note]创建 trait 对象时需指定某种指针（如 <code>&amp;</code> 引用或 <code>Box&lt;T&gt;</code> 智能指针）</span>，后接 <code>dyn</code> 关键字和相关 trait（第 20 章将探讨 trait 对象必须使用指针的原因）。我们可用 trait 对象替代泛型或具体类型。在 trait 对象使用处，Rust 的类型系统会在编译时确保该上下文中使用的任何值都实现了该 trait 对象的 trait。因此我们无需在编译时知晓所有可能的类型。</p>
<p>We’ve mentioned that, in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. Trait objects differ from objects in other
languages in that we can’t add data to a trait object. Trait objects aren’t as
generally useful as objects in other languages: their specific purpose is to
allow abstraction across common behavior.</p>
<p>前文提到，在 Rust 中我们避免称结构体和枚举为“对象“，以区别于其他语言的对象。结构体或枚举中，结构体字段的数据与 <code>impl</code> 块的行为是分离的；而其他语言中数据和行为组合成的单一概念常被称作对象。Trait 对象的独特之处在于无法向其添加数据，其通用性不如其他语言的对象：其特定目的是允许对通用行为进行抽象。</p>
<p>Listing 18-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>.</p>
<p>示例 18-3 展示了如何定义包含单个 <code>draw</code> 方法的 <code>Draw</code> trait。</p>
<figure class="listing" id="listing-18-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-3">Listing 18-3</a>: Definition of the <code>Draw</code> trait. <code>Draw</code> trait 的定义</figcaption>
</figure>
<p>This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 18-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside a
<code>Box</code> that implements the <code>Draw</code> trait.</p>
<p>此语法与第 10 章讨论的 trait 定义方式类似。接下来是新语法：示例 18-4 定义了包含名为 <code>components</code> 向量的 <code>Screen</code> 结构体。该向量的类型为 <code>Box&lt;dyn Draw&gt;</code>（即 trait 对象），代表实现了 <code>Draw</code> trait 的 <code>Box</code> 中的任何类型。</p>
<figure class="listing" id="listing-18-4">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-4">Listing 18-4</a>: Definition of the <code>Screen</code> struct with a <code>components</code> field holding a vector of trait objects that implement the <code>Draw</code> trait 包含 <code>components</code> 字段的 <code>Screen</code> 结构体定义，该字段持有实现 <code>Draw</code> trait 的 trait 对象向量</figcaption>
</figure>
<p>On the <code>Screen</code> struct, we’ll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 18-5.</p>
<p>在 <code>Screen</code> 结构体上，我们将定义名为 <code>run</code> 的方法，该方法会对其每个 <code>components</code> 调用 <code>draw</code> 方法，如示例 18-5 所示。</p>
<figure class="listing" id="listing-18-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-5">Listing 18-5</a>: A <code>run</code> method on <code>Screen</code> that calls the <code>draw</code> method on each component. <code>Screen</code> 上的 <code>run</code> 方法，对每个组件调用 <code>draw</code> 方法</figcaption>
</figure>
<p>This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can be substituted with
only one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the <code>Screen</code> struct using a generic type and a trait bound,
as in Listing 18-6.</p>
<p>这与使用带 trait 约束的泛型类型参数的结构体定义不同。泛型类型参数一次只能替换为一个具体类型，而 trait 对象允许在运行时用多个具体类型填充。例如，我们本可使用泛型和 trait 约束定义 <code>Screen</code> 结构体，如示例 18-6 所示。</p>
<figure class="listing" id="listing-18-6">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-6">Listing 18-6</a>: An alternate implementation of the <code>Screen</code> struct and its <code>run</code> method using generics and trait bounds 使用泛型和 trait 约束实现 <code>Screen</code> 结构体及其 <code>run</code> 方法的替代方案</figcaption>
</figure>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>这限制了 <code>Screen</code> 实例的组件列表必须全为 <code>Button</code> 类型或全为 <code>TextField</code> 类型。若只需同质集合，使用泛型和 trait 约束更可取，因为定义会在编译时单态化为具体类型。</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance
can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a
<code>Box&lt;TextField&gt;</code>. Let’s look at how this works, and then we’ll talk about the
runtime performance implications.</p>
<p>另一方面，使用 trait 对象的方法允许单个 <code>Screen</code> 实例持有包含 <code>Box&lt;Button&gt;</code> 和 <code>Box&lt;TextField&gt;</code> 的 <code>Vec&lt;T&gt;</code>。下面探讨其工作原理，随后讨论运行时性能影响。</p>
<h3 id="implementing-the-trait-实现-trait"><a class="header" href="#implementing-the-trait-实现-trait">Implementing the Trait 实现 Trait</a></h3>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’ll provide the
<code>Button</code> type. Again, actually implementing a GUI library is beyond the scope
of this book, so the <code>draw</code> method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a <code>Button</code> struct
might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 18-7.</p>
<p>现在我们将添加实现 <code>Draw</code> trait 的类型。以 <code>Button</code> 类型为例。重申：实际实现 GUI 库超出了本书范围，因此 <code>draw</code> 方法体不会有实际逻辑。设想的实现中，<code>Button</code> 结构体可能包含 <code>width</code>、<code>height</code> 和 <code>label</code> 字段，如示例 18-7 所示。</p>
<figure class="listing" id="listing-18-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-7">Listing 18-7</a>: A <code>Button</code> struct that implements the <code>Draw</code> trait 实现 <code>Draw</code> trait 的 <code>Button</code> 结构体</figcaption>
</figure>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the
fields on other components; for example, a <code>TextField</code> type might have those
same fields plus a <code>placeholder</code> field. Each of the types we want to draw on
the screen will implement the <code>Draw</code> trait but will use different code in the
<code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here
(without the actual GUI code, as mentioned). The <code>Button</code> type, for instance,
might have an additional <code>impl</code> block containing methods related to what
happens when a user clicks the button. These kinds of methods won’t apply to
types like <code>TextField</code>.</p>
<p><code>Button</code> 的 <code>width</code>、<code>height</code> 和 <code>label</code> 字段将不同于其他组件（如 <code>TextField</code> 可能有额外 <code>placeholder</code> 字段）。每种需绘制的类型都会实现 <code>Draw</code> trait，但会在 <code>draw</code> 方法中使用不同代码定义具体绘制方式（如前所述，此处不含实际 GUI 代码）。例如 <code>Button</code> 可能有额外的 <code>impl</code> 块包含与点击相关的方法，这类方法不适用于 <code>TextField</code> 等类型。</p>
<p>If someone using our library decides to implement a <code>SelectBox</code> struct that has
<code>width</code>, <code>height</code>, and <code>options</code> fields, they would implement the <code>Draw</code> trait
on the <code>SelectBox</code> type as well, as shown in Listing 18-8.</p>
<p>若库用户决定实现包含 <code>width</code>、<code>height</code> 和 <code>options</code> 字段的 <code>SelectBox</code> 结构体，他们也会在 <code>SelectBox</code> 上实现 <code>Draw</code> trait，如示例 18-8 所示。</p>
<figure class="listing" id="listing-18-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-8">Listing 18-8</a>: Another crate using <code>gui</code> and implementing the <code>Draw</code> trait on a <code>SelectBox</code> struct 另一个 crate 使用 <code>gui</code> 并在 <code>SelectBox</code> 结构体上实现 <code>Draw</code> trait</figcaption>
</figure>
<p>Our library’s user can now write their <code>main</code> function to create a <code>Screen</code>
instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code>
by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the
<code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 18-9 shows this implementation.</p>
<p>库用户现在可以编写 <code>main</code> 函数创建 <code>Screen</code> 实例。他们可将 <code>SelectBox</code> 和 <code>Button</code> 分别放入 <code>Box&lt;T&gt;</code> 包装为 trait 对象后添加到 <code>Screen</code> 实例。随后调用 <code>Screen</code> 实例的 <code>run</code> 方法，该方法将调用每个组件的 <code>draw</code> 方法。示例 18-9 展示了此实现。</p>
<figure class="listing" id="listing-18-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-9">Listing 18-9</a>: Using trait objects to store values of different types that implement the same trait 使用 trait 对象存储实现相同 trait 的不同类型值</figcaption>
</figure>
<p>When we wrote the library, we didn’t know that someone might add the
<code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the
new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which
means it implements the <code>draw</code> method.</p>
<p>编写库时我们无法预知用户会添加 <code>SelectBox</code> 类型，但 <code>Screen</code> 实现能操作并绘制该新类型，因为 <code>SelectBox</code> 实现了包含 <code>draw</code> 方法的 <code>Draw</code> trait。</p>
<p>This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept of <em>duck
typing</em> in dynamically typed languages: if it walks like a duck and quacks like
a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in
Listing 18-5, <code>run</code> doesn’t need to know what the concrete type of each
component is. It doesn’t check whether a component is an instance of a <code>Button</code>
or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By
specifying <code>Box&lt;dyn Draw&gt;</code> as the type of the values in the <code>components</code>
vector, we’ve defined <code>Screen</code> to need values that we can call the <code>draw</code>
method on.</p>
<p>这种只关注值响应的消息而非具体类型的概念，类似于动态类型语言中的<strong>鸭子类型</strong>：若它走路像鸭子、叫声像鸭子，那它就是鸭子！在示例 18-5 的 <code>Screen.run</code> 实现中，<code>run</code> 无需知道各组件的具体类型。它不检查组件是 <code>Button</code> 还是 <code>SelectBox</code> 实例，仅调用其 <code>draw</code> 方法。通过指定 <code>components</code> 向量的类型为 <code>Box&lt;dyn Draw&gt;</code>，我们定义了 <code>Screen</code> 需要可调用 <code>draw</code> 方法的值。</p>
<p>The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.</p>
<p>使用 trait 对象和 Rust 类型系统编写类鸭子类型代码的优势在于：无需在运行时检查值是否实现了特定方法，也不必担心值未实现方法时调用会出错。若值未实现 trait 对象所需的 trait，Rust 将拒绝编译代码。</p>
<p>For example, Listing 18-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component.</p>
<p>例如示例 18-10 展示了尝试用 <code>String</code> 作为组件创建 <code>Screen</code> 的情况。</p>
<figure class="listing" id="listing-18-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}</code></pre>
<figcaption><a href="ch18-02-trait-objects.html#listing-18-10">Listing 18-10</a>: Attempting to use a type that doesn’t implement the trait object’s trait 尝试使用未实现 trait 对象 trait 的类型</figcaption>
</figure>
<p>We’ll get this error because <code>String</code> doesn’t implement the <code>Draw</code> trait:</p>
<p>由于 <code>String</code> 未实现 <code>Draw</code> trait，我们将收到错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>This error lets us know that either we’re passing something to <code>Screen</code> that we
didn’t mean to pass and so should pass a different type, or we should implement
<code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<p>此错误表明：要么传递了非预期的类型（应传递其他类型），要么应在 <code>String</code> 上实现 <code>Draw</code> trait 以使 <code>Screen</code> 能调用其 <code>draw</code> 方法。</p>
<h3 id="trait-objects-perform-dynamic-dispatch-trait-对象执行动态分发"><a class="header" href="#trait-objects-perform-dynamic-dispatch-trait-对象执行动态分发">Trait Objects Perform Dynamic Dispatch Trait 对象执行动态分发</a></h3>
<p>Recall in “Performance of Code Using
Generics” in Chapter 10 our
discussion on the monomorphization process performed on generics by the
compiler: the compiler generates nongeneric implementations of functions and
methods for each concrete type that we use in place of a generic type
parameter. The code that results from monomorphization is doing <em>static
dispatch</em>, which is when the compiler knows what method you’re calling at
compile time. This is opposed to <em>dynamic dispatch</em>, which is when the compiler
can’t tell at compile time which method you’re calling. In dynamic dispatch
cases, the compiler emits code that at runtime will know which method to call.</p>
<p>回忆第 10 章中“使用泛型的代码性能“关于编译器对泛型执行的单态化过程：编译器会为每个替代泛型类型参数的具体类型生成非泛型的函数和方法实现。单态化生成的代码执行的是<strong>静态分发</strong>（编译器在编译时知晓所调用的方法）。与之相对的是<strong>动态分发</strong>（编译器无法在编译时确定所调用的方法）。动态分发时，编译器会生成在运行时确定调用方法的代码。</p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t
know all the types that might be used with the code that’s using trait objects,
so it doesn’t know which method implemented on which type to call. Instead, at
runtime, Rust uses the pointers inside the trait object to know which method to
call. This lookup incurs a runtime cost that doesn’t occur with static dispatch.
Dynamic dispatch also prevents the compiler from choosing to inline a method’s
code, which in turn prevents some optimizations, and Rust has some rules about
where you can and cannot use dynamic dispatch, called <em>dyn compatibility</em>. Those
rules are beyond the scope of this discussion, but you can read more about them
in the reference. However, we did get extra
flexibility in the code that we wrote in Listing 18-5 and were able to support
in Listing 18-9, so it’s a trade-off to consider.</p>
<p>使用 trait 对象时，Rust 必须采用动态分发。编译器无法预知使用 trait 对象的代码可能涉及的所有类型，故无法确定应调用哪个类型实现的哪个方法。作为替代，<span class="highlight">[note]Rust 在运行时利用 trait 对象内部的指针确定应调用的方法。此查找过程会产生静态分发不存在的运行时开销。动态分发还阻碍编译器内联方法代码，进而影响某些优化。</span>Rust 对动态分发的使用场景有特定规则（称为 <strong>dyn 兼容性规则</strong>），这超出了本书讨论范围，但可在 Rust 参考文档中查阅。不过，我们在示例 18-5 的代码中获得了额外的灵活性，并能支持示例 18-9 的场景，因此这是一种需要权衡的取舍。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementing-an-object-oriented-design-pattern-实现面向对象设计模式"><a class="header" href="#implementing-an-object-oriented-design-pattern-实现面向对象设计模式">Implementing an Object-Oriented Design Pattern 实现面向对象设计模式</a></h2>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the
pattern is that we define a set of states a value can have internally. The
states are represented by a set of <em>state objects</em>, and the value’s behavior
changes based on its state. We’re going to work through an example of a blog
post struct that has a field to hold its state, which will be a state object
from the set “draft,” “review,” or “published.”</p>
<p><strong>状态模式</strong>(<em>state pattern</em>)是一种面向对象设计模式。该模式的核心在于：我们定义值可能具有的一组内部状态。这些状态由一组<strong>状态对象</strong>(<em>state objects</em>)表示，值的行为随其状态而改变。我们将通过一个示例展示：定义一个博客文章结构体，其中包含一个存储状态的字段，该状态字段的值来自“草稿”、“审核中”或“已发布”状态集合中的某个状态对象。</p>
<p>The state objects share functionality: in Rust, of course, we use structs and
traits rather than objects and inheritance. Each state object is responsible
for its own behavior and for governing when it should change into another
state. The value that holds a state object knows nothing about the different
behavior of the states or when to transition between states.</p>
<p>状态对象共享功能：在 Rust 中，我们使用结构体(struct)和特征(trait)而非对象和继承。每个状态对象负责自身行为，并控制何时应转换为另一个状态。持有状态对象的值对状态间的不同行为及状态转换时机一无所知。</p>
<p>The advantage of using the state pattern is that, when the business
requirements of the program change, we won’t need to change the code of the
value holding the state or the code that uses the value. We’ll only need to
update the code inside one of the state objects to change its rules or perhaps
add more state objects.</p>
<p>使用状态模式的优势在于：当程序业务需求变更时，我们无需修改持有状态的值的代码或使用该值的代码。只需更新某个状态对象内部的代码来更改规则，或添加更多状态对象。</p>
<p>First we’re going to implement the state pattern in a more traditional
object-oriented way, then we’ll use an approach that’s a bit more natural in
Rust. Let’s dig in to incrementally implement a blog post workflow using the
state pattern.</p>
<p>首先，我们将以更传统的面向对象方式实现状态模式，随后采用一种更符合 Rust 风格的方式。让我们深入探讨如何用状态模式逐步实现博客文章工作流。</p>
<p>The final functionality will look like this:</p>
<p>最终功能如下：</p>
<ol>
<li>
<p>A blog post starts as an empty draft.</p>
</li>
<li>
<p>When the draft is done, a review of the post is requested.</p>
</li>
<li>
<p>When the post is approved, it gets published.</p>
</li>
<li>
<p>Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.</p>
</li>
<li>
<p>博客文章初始为空草稿。</p>
</li>
<li>
<p>草稿完成后，请求审核文章。</p>
</li>
<li>
<p>文章通过审核后发布。</p>
</li>
<li>
<p>仅已发布的博客文章返回可打印内容，因此未批准的文章不会被意外发布。</p>
</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.</p>
<p>其他对文章的更改尝试应无效。例如，若在请求审核前尝试批准草稿文章，文章应保持未发布的草稿状态。</p>
<h3 id="a-traditional-object-oriented-attempt-传统面向对象尝试"><a class="header" href="#a-traditional-object-oriented-attempt-传统面向对象尝试">A Traditional Object-oriented Attempt 传统面向对象尝试</a></h3>
<p>There are infinite ways to structure code to solve the same problem, each with
different trade-offs. This section’s implementation is more of a traditional
object-oriented style, which is possible to write in Rust, but doesn’t take
advantage of some of Rust’s strengths. Later, we’ll demonstrate a different
solution that still uses the object-oriented design pattern but is structured
in a way that might look less familiar to programmers with object-oriented
experience. We’ll compare the two solutions to experience the trade-offs of
designing Rust code differently than code in other languages.</p>
<p>解决同一问题的代码结构方式无穷无尽，各有取舍。本节实现更偏向传统面向对象风格，虽然能用 Rust 编写，但未充分利用 Rust 的某些优势。稍后我们将展示另一种仍使用面向对象设计模式但结构不同的解决方案，这可能让有面向对象经验的程序员感到陌生。通过比较两种方案，可体会 Rust 代码设计与其他语言的差异。</p>
<p>Listing 18-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named <code>blog</code>. This won’t compile yet
because we haven’t implemented the <code>blog</code> crate.</p>
<p>清单 18-11 展示了该工作流的代码形式：这是我们将在名为 <code>blog</code> 的库 crate 中实现的 API 用法示例。因尚未实现 <code>blog</code> crate，此代码暂无法编译。</p>
<figure class="listing" id="listing-18-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-11">Listing 18-11</a>: Code that demonstrates the desired behavior we want our <code>blog</code> crate to have 展示我们希望 <code>blog</code> crate 具备行为的代码示例</figcaption>
</figure>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>. We
want to allow text to be added to the blog post. If we try to get the post’s
content immediately, before approval, we shouldn’t get any text because the
post is still a draft. We’ve added <code>assert_eq!</code> in the code for demonstration
purposes. An excellent unit test for this would be to assert that a draft blog
post returns an empty string from the <code>content</code> method, but we’re not going to
write tests for this example.</p>
<p>我们希望允许用户通过 <code>Post::new</code> 创建新草稿文章。允许向文章添加文本。若在批准前立即获取文章内容，应无文本返回（因文章仍是草稿）。代码中添加了 <code>assert_eq!</code> 用于演示。对此的完美单元测试是：断言草稿文章从 <code>content</code> 方法返回空字符串，但本例不编写测试。</p>
<p>Next, we want to enable a request for a review of the post, and we want
<code>content</code> to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when <code>content</code> is called.</p>
<p>接下来，启用审核请求功能，在等待审核期间 <code>content</code> 应返回空字符串。当文章获批准后发布，即调用 <code>content</code> 时返回文章文本。</p>
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code>
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, review, or published. Changing from one state to another will be
managed internally within the <code>Post</code> type. The states change in response to the
methods called by our library’s users on the <code>Post</code> instance, but they don’t
have to manage the state changes directly. Also, users can’t make a mistake
with the states, such as publishing a post before it’s reviewed.</p>
<p>注意，我们仅与 crate 中的 <code>Post</code> 类型交互。该类型使用状态模式，持有表示文章可能状态（草稿、审核中或已发布）的三个状态对象之一的状态值。状态间的转换由 <code>Post</code> 类型内部管理。状态随用户对 <code>Post</code> 实例调用方法而改变，但用户无需直接管理状态变更。此外，用户不会误操作状态（例如在审核前发布文章）。</p>
<h4 id="defining-post-and-creating-a-new-instance-in-the-draft-state-定义-post-及在草稿状态下创建新实例"><a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state-定义-post-及在草稿状态下创建新实例">Defining <code>Post</code> and Creating a New Instance in the Draft State 定义 <code>Post</code> 及在草稿状态下创建新实例</a></h4>
<p>Let’s get started on the implementation of the library! We know we need a
public <code>Post</code> struct that holds some content, so we’ll start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code>, as shown in Listing 18-12. We’ll also make a private
<code>State</code> trait that will define the behavior that all state objects for a <code>Post</code>
must have.</p>
<p>开始库的实现！已知需一个公有 <code>Post</code> 结构体来存储内容，因此从结构体定义和关联的公有 <code>new</code> 函数开始（如清单 18-12 所示）。同时创建私有 <code>State</code> 特征，定义 <code>Post</code> 所有状态对象必须的行为。</p>
<p>Then <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code> inside an <code>Option&lt;T&gt;</code>
in a private field named <code>state</code> to hold the state object. You’ll see why the
<code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<p>接着 <code>Post</code> 在私有字段 <code>state</code> 中持有 <code>Box&lt;dyn State&gt;</code> 的特征对象，并封装在 <code>Option&lt;T&gt;</code> 中。稍后你会明白为何需要 <code>Option&lt;T&gt;</code>。</p>
<figure class="listing" id="listing-18-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-12">Listing 18-12</a>: Definition of a <code>Post</code> struct and a <code>new</code> function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code> struct 定义 <code>Post</code> 结构体、创建新 <code>Post</code> 实例的 <code>new</code> 函数、<code>State</code> 特征及 <code>Draft</code> 结构体</figcaption>
</figure>
<p>The <code>State</code> trait defines the behavior shared by different post states. The
state objects are <code>Draft</code>, <code>PendingReview</code>, and <code>Published</code>, and they will all
implement the <code>State</code> trait. For now, the trait doesn’t have any methods, and
we’ll start by defining just the <code>Draft</code> state because that is the state we
want a post to start in.</p>
<p><code>State</code> 特征定义了不同文章状态的共享行为。状态对象为 <code>Draft</code>、<code>PendingReview</code> 和 <code>Published</code>，它们均实现 <code>State</code> 特征。目前该特征无任何方法，我们仅定义 <code>Draft</code> 状态，因为这是文章的初始状态。</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that
holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This
ensures that whenever we create a new instance of <code>Post</code>, it will start out as
a draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to
create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the
<code>content</code> field to a new, empty <code>String</code>.</p>
<p>创建新 <code>Post</code> 时，将其 <code>state</code> 字段设为包含 <code>Box</code> 的 <code>Some</code> 值。该 <code>Box</code> 指向新的 <code>Draft</code> 结构体实例。这确保每当创建新 <code>Post</code> 实例时，均以草稿状态开始。因 <code>Post</code> 的 <code>state</code> 字段私有，无法创建其他状态的 <code>Post</code>！在 <code>Post::new</code> 函数中，将 <code>content</code> 字段设为新的空 <code>String</code>。</p>
<h4 id="storing-the-text-of-the-post-content-存储文章内容文本"><a class="header" href="#storing-the-text-of-the-post-content-存储文章内容文本">Storing the Text of the Post Content 存储文章内容文本</a></h4>
<p>We saw in Listing 18-11 that we want to be able to call a method named
<code>add_text</code> and pass it a <code>&amp;str</code> that is then added as the text content of the
blog post. We implement this as a method, rather than exposing the <code>content</code>
field as <code>pub</code>, so that later we can implement a method that will control how
the <code>content</code> field’s data is read. The <code>add_text</code> method is pretty
straightforward, so let’s add the implementation in Listing 18-13 to the <code>impl  Post</code> block.</p>
<p>如清单 18-11 所示，我们需调用 <code>add_text</code> 方法并传入 <code>&amp;str</code>，将其添加为博客文章的内容文本。我们将此实现为方法而非将 <code>content</code> 字段设为 <code>pub</code>，以便后续实现控制 <code>content</code> 字段数据读取的方法。<code>add_text</code> 方法较简单，如清单 18-13 所示将其添加到 <code>impl Post</code> 块中。</p>
<figure class="listing" id="listing-18-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-13">Listing 18-13</a>: Implementing the <code>add_text</code> method to add text to a post’s <code>content</code> 实现 <code>add_text</code> 方法向文章 <code>content</code> 添加文本</figcaption>
</figure>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code> because we’re
changing the <code>Post</code> instance that we’re calling <code>add_text</code> on. We then call
<code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to
the saved <code>content</code>. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The <code>add_text</code> method doesn’t interact
with the <code>state</code> field at all, but it is part of the behavior we want to
support.</p>
<p><code>add_text</code> 方法获取 <code>self</code> 的可变引用，因为我们正在更改调用 <code>add_text</code> 的 <code>Post</code> 实例。然后在 <code>content</code> 中的 <code>String</code> 上调用 <code>push_str</code>，传入 <code>text</code> 参数以添加到保存的 <code>content</code> 中。此行为不依赖文章状态，故不属状态模式。<code>add_text</code> 方法与 <code>state</code> 字段完全无关，但属于我们期望支持的行为。</p>
<h4 id="ensuring-the-content-of-a-draft-post-is-empty-确保草稿文章内容为空"><a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty-确保草稿文章内容为空">Ensuring the Content of a Draft Post Is Empty 确保草稿文章内容为空</a></h4>
<p>Even after we’ve called <code>add_text</code> and added some content to our post, we still
want the <code>content</code> method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 18-11. For now, let’s
implement the <code>content</code> method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 18-14 shows this placeholder implementation.</p>
<p>即使调用 <code>add_text</code> 添加内容后，我们仍希望 <code>content</code> 方法返回空字符串切片，因为文章仍处草稿状态（如清单 18-11 第 7 行所示）。现在用最简单方式实现 <code>content</code> 方法以满足要求：始终返回空字符串切片。待实现状态变更功能使文章可发布后，再修改此方法。目前文章仅能处于草稿状态，故内容应始终为空。清单 18-14 展示了此占位实现。</p>
<figure class="listing" id="listing-18-14">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-14">Listing 18-14</a>: Adding a placeholder implementation for the <code>content</code> method on <code>Post</code> that always returns an empty string slice 为 <code>Post</code> 的 <code>content</code> 方法添加占位实现（始终返回空字符串切片）</figcaption>
</figure>
<p>With this added <code>content</code> method, everything in Listing 18-11 up to line 7
works as intended.</p>
<p>添加此 <code>content</code> 方法后，清单 18-11 至第 7 行的所有内容均符合预期。</p>
<h4 id="requesting-a-review-changes-the-posts-state-请求审核改变文章状态"><a class="header" href="#requesting-a-review-changes-the-posts-state-请求审核改变文章状态">Requesting a Review Changes the Post’s State 请求审核改变文章状态</a></h4>
<p>Next, we need to add functionality to request a review of a post, which should
change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 18-15 shows this code.</p>
<p>接下来添加请求审核文章的功能，将其状态从 <code>Draft</code> 改为 <code>PendingReview</code>。清单 18-15 展示了此代码。</p>
<figure class="listing" id="listing-18-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-15">Listing 18-15</a>: Implementing <code>request_review</code> methods on <code>Post</code> and the <code>State</code> trait 在 <code>Post</code> 和 <code>State</code> 特征上实现 <code>request_review</code> 方法</figcaption>
</figure>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable
reference to <code>self</code>. Then we call an internal <code>request_review</code> method on the
current state of <code>Post</code>, and this second <code>request_review</code> method consumes the
current state and returns a new state.</p>
<p>为 <code>Post</code> 添加名为 <code>request_review</code> 的公有方法，获取 <code>self</code> 的可变引用。然后在 <code>Post</code> 的当前状态上调用内部 <code>request_review</code> 方法，此内部方法消费当前状态并返回新状态。</p>
<p>We add the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so the state value of the
<code>Post</code> can transform into a new state.</p>
<p>将 <code>request_review</code> 方法加入 <code>State</code> 特征；所有实现该特征的类型现在均需实现 <code>request_review</code> 方法。注意<span class="highlight">[note]方法首参为 <code>self: Box&lt;Self&gt;</code> 而非 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code>。此语法表示方法仅在持有该类型的 <code>Box</code> 上调用有效。</span>该语法获取 <code>Box&lt;Self&gt;</code> 的所有权，使旧状态失效以便 <code>Post</code> 的状态值可转换为新状态。</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership
of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code>
comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code>
field and leave a <code>None</code> in its place because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the <code>state</code> value out of
<code>Post</code> rather than borrowing it. Then we’ll set the post’s <code>state</code> value to the
result of this operation.</p>
<p>为消费旧状态，<code>request_review</code> 方法需获取状态值的所有权。这正是 <code>Post</code> 的 <code>state</code> 字段中的 <code>Option</code> 的作用：调用 <code>take</code> 方法取出 <code>state</code> 字段中的 <code>Some</code> 值，原位留 <code>None</code>（因 Rust 不允许结构体存在未填充字段）。这让我们能移出 <code>state</code> 值而非借用。随后将文章的 <code>state</code> 值设为此次操作结果。</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly
with code like <code>self.state = self.state.request_review();</code> to get ownership of
the <code>state</code> value. This ensures <code>Post</code> can’t use the old <code>state</code> value after
we’ve transformed it into a new state.</p>
<p>需临时将 <code>state</code> 设为 <code>None</code>，而非直接用 <code>self.state = self.state.request_review();</code> 设置，以获取 <code>state</code> 值的所有权。这确保 <code>Post</code> 在状态转换后无法复用旧状态值。</p>
<p>The <code>request_review</code> method on <code>Draft</code> returns a new, boxed instance of a new
<code>PendingReview</code> struct, which represents the state when a post is waiting for a
review. The <code>PendingReview</code> struct also implements the <code>request_review</code> method
but doesn’t do any transformations. Rather, it returns itself because when we
request a review on a post already in the <code>PendingReview</code> state, it should stay
in the <code>PendingReview</code> state.</p>
<p><code>Draft</code> 上的 <code>request_review</code> 方法返回新的 <code>PendingReview</code> 结构体的装箱实例，表示文章等待审核的状态。<code>PendingReview</code> 结构体也实现 <code>request_review</code> 方法但不做转换，而是返回自身（因已处 <code>PendingReview</code> 状态的文章再次请求审核时，应保持该状态）。</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each
state is responsible for its own rules.</p>
<p>现在可见状态模式的优势：无论 <code>state</code> 值为何，<code>Post</code> 的 <code>request_review</code> 方法均相同。各状态负责自身规则。</p>
<p>We’ll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string
slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the
<code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state.
Listing 18-11 now works up to line 10!</p>
<p>暂保持 <code>Post</code> 的 <code>content</code> 方法原样（返回空字符串切片）。现可有处于 <code>PendingReview</code> 状态的 <code>Post</code>（及 <code>Draft</code> 状态），但在 <code>PendingReview</code> 状态需相同行为。清单 18-11 现可运行至第 10 行！</p>
<h4 id="adding-approve-to-change-the-behavior-of-content-添加-approve-改变-content-的行为"><a class="header" href="#adding-approve-to-change-the-behavior-of-content-添加-approve-改变-content-的行为">Adding <code>approve</code> to Change the Behavior of <code>content</code> 添加 <code>approve</code> 改变 <code>content</code> 的行为</a></h4>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will
set <code>state</code> to the value that the current state says it should have when that
state is approved, as shown in Listing 18-16.</p>
<p><code>approve</code> 方法类似 <code>request_review</code>：将 <code>state</code> 设为当前状态在批准时应具有的值，如清单 18-16 所示。</p>
<figure class="listing" id="listing-18-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-16">Listing 18-16</a>: Implementing the <code>approve</code> method on <code>Post</code> and the <code>State</code> trait 在 <code>Post</code> 和 <code>State</code> 特征上实现 <code>approve</code> 方法</figcaption>
</figure>
<p>We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that
implements <code>State</code>, the <code>Published</code> state.</p>
<p>将 <code>approve</code> 方法加入 <code>State</code> 特征，并添加实现 <code>State</code> 的新结构体 <code>Published</code>。</p>
<p>Similar to the way <code>request_review</code> on <code>PendingReview</code> works, if we call the
<code>approve</code> method on a <code>Draft</code>, it will have no effect because <code>approve</code> will
return <code>self</code>. When we call <code>approve</code> on <code>PendingReview</code>, it returns a new,
boxed instance of the <code>Published</code> struct. The <code>Published</code> struct implements the
<code>State</code> trait, and for both the <code>request_review</code> method and the <code>approve</code>
method, it returns itself because the post should stay in the <code>Published</code> state
in those cases.</p>
<p>类似 <code>PendingReview</code> 的 <code>request_review</code>，若在 <code>Draft</code> 上调用 <code>approve</code> 无效（因 <code>approve</code> 返回 <code>self</code>）。在 <code>PendingReview</code> 上调用 <code>approve</code> 时，返回新的 <code>Published</code> 结构体的装箱实例。<code>Published</code> 结构体实现 <code>State</code> 特征，其 <code>request_review</code> 和 <code>approve</code> 方法均返回自身（因文章在这些情况下应保持 <code>Published</code> 状态）。</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>. We want the value
returned from <code>content</code> to depend on the current state of the <code>Post</code>, so we’re
going to have the <code>Post</code> delegate to a <code>content</code> method defined on its <code>state</code>,
as shown in Listing 18-17.</p>
<p>现在需更新 <code>Post</code> 的 <code>content</code> 方法。我们希望 <code>content</code> 的返回值取决于 <code>Post</code> 的当前状态，因此让 <code>Post</code> 委托给其 <code>state</code> 定义的 <code>content</code> 方法，如清单 18-17 所示。</p>
<figure class="listing" id="listing-18-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-17">Listing 18-17</a>: Updating the <code>content</code> method on <code>Post</code> to delegate to a <code>content</code> method on <code>State</code> 更新 <code>Post</code> 的 <code>content</code> 方法以委托给 <code>State</code> 的 <code>content</code> 方法</figcaption>
</figure>
<p>Because the goal is to keep all of these rules inside the structs that
implement <code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass
the post instance (that is, <code>self</code>) as an argument. Then we return the value
that’s returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>目标是将所有规则封装在实现 <code>State</code> 的结构体中，故在 <code>state</code> 值上调用 <code>content</code> 方法并传入文章实例（即 <code>self</code>）作为参数。然后返回使用 <code>state</code> 值的 <code>content</code> 方法的结果。</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the
value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code> is
an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&lt;dyn  State&gt;&gt;</code> is returned. If we didn’t call <code>as_ref</code>, we would get an error because
we can’t move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>在 <code>Option</code> 上调用 <code>as_ref</code> 是因为需要内部值的引用而非所有权。因 <code>state</code> 是 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>，调用 <code>as_ref</code> 后返回 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>。若不调用 <code>as_ref</code> 会报错（因无法从函数参数的借用 <code>&amp;self</code> 中移出 <code>state</code>）。</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic because we
know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code>
value when those methods are done. This is one of the cases we talked about in
“Cases in Which You Have More Information Than the
Compiler” in Chapter 9 when we know that
a <code>None</code> value is never possible, even though the compiler isn’t able to
understand that.</p>
<p>接着调用 <code>unwrap</code> 方法（我们知道这永不触发 panic），因为 <code>Post</code> 的方法确保这些方法完成后 <code>state</code> 始终含 <code>Some</code> 值。这是第 9 章“你比编译器掌握更多信息的情况”中讨论的案例之一：即便编译器无法理解，我们也知 <code>None</code> 值绝不可能出现。</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion
will take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will
ultimately be called on the type that implements the <code>State</code> trait. That means
we need to add <code>content</code> to the <code>State</code> trait definition, and that is where
we’ll put the logic for what content to return depending on which state we
have, as shown in Listing 18-18.</p>
<p>此时，在 <code>&amp;Box&lt;dyn State&gt;</code> 上调用 <code>content</code> 时，解引用强制转换将对 <code>&amp;</code> 和 <code>Box</code> 生效，最终在实现 <code>State</code> 特征的类型上调用 <code>content</code> 方法。这意味着需在 <code>State</code> 特征定义中添加 <code>content</code>，在此处放置根据不同状态返回内容的逻辑，如清单 18-18 所示。</p>
<figure class="listing" id="listing-18-18">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-18">Listing 18-18</a>: Adding the <code>content</code> method to the <code>State</code> trait 向 <code>State</code> 特征添加 <code>content</code> 方法</figcaption>
</figure>
<p>We add a default implementation for the <code>content</code> method that returns an empty
string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code>
and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code>
method and return the value in <code>post.content</code>. While convenient, having the
<code>content</code> method on <code>State</code> determine the <code>content</code> of the <code>Post</code> is blurring
the lines between the responsibility of <code>State</code> and the responsibility of
<code>Post</code>.</p>
<p>为 <code>content</code> 方法添加返回空字符串切片的默认实现。这意味着无需在 <code>Draft</code> 和 <code>PendingReview</code> 结构体上实现 <code>content</code>。<code>Published</code> 结构体将覆盖 <code>content</code> 方法并返回 <code>post.content</code> 中的值。虽然便捷，但让 <code>State</code> 的 <code>content</code> 方法决定 <code>Post</code> 的内容，模糊了 <code>State</code> 与 <code>Post</code> 的职责边界。</p>
<p>Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a <code>post</code> as an argument and returning a
reference to part of that <code>post</code>, so the lifetime of the returned reference is
related to the lifetime of the <code>post</code> argument.</p>
<p>注意此方法需生命周期注解（如第 10 章所述）。我们获取 <code>post</code> 的引用作为参数，并返回该 <code>post</code> 某部分的引用，故返回引用的生命周期与 <code>post</code> 参数相关。</p>
<p>And we’re done—all of Listing 18-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout <code>Post</code>.</p>
<p>至此完成——清单 18-11 的所有功能现均可运行！我们已用状态模式实现博客文章工作流规则。与规则相关的逻辑位于状态对象中，而非分散在 <code>Post</code> 各处。</p>
<section class="note" aria-role="note">
<h3 id="why-not-an-enum-为何不使用枚举"><a class="header" href="#why-not-an-enum-为何不使用枚举">Why Not An Enum? 为何不使用枚举？</a></h3>
<p>You may have been wondering why we didn’t use an <code>enum</code> with the different
possible post states as variants. That’s certainly a possible solution; try it
and compare the end results to see which you prefer! One disadvantage of using
an enum is that every place that checks the value of the enum will need a
<code>match</code> expression or similar to handle every possible variant. This could get
more repetitive than this trait object solution.</p>
<p>你可能好奇为何不用枚举（<code>enum</code>）以不同文章状态作为变体。这当然是可行方案；尝试并比较结果，看哪种更合你意！使用枚举的劣势在于：每次检查枚举值处均需 <code>match</code> 表达式或类似结构处理所有可能变体。这比特征对象方案更重复。</p>
</section>
<h4 id="trade-offs-of-the-state-pattern-状态模式的权衡"><a class="header" href="#trade-offs-of-the-state-pattern-状态模式的权衡">Trade-offs of the State Pattern 状态模式的权衡</a></h4>
<p>We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on <code>Post</code> know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the <code>State</code>
trait on the <code>Published</code> struct.</p>
<p>我们已展示 Rust 能实现面向对象状态模式，以封装文章在各状态下应有的不同行为。<code>Post</code> 的方法对各类行为一无所知。如此组织代码后，仅需查看一处即可知已发布文章的不同行为方式：<code>Published</code> 结构体上 <code>State</code> 特征的实现。</p>
<p>If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or
even in the <code>main</code> code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state.</p>
<p>若不使用状态模式，可能在 <code>Post</code> 的方法中用 <code>match</code> 表达式，甚至在检查文章状态的 <code>main</code> 代码中直接更改行为。这将导致需查看多处才能理解文章处于发布状态的全部影响。</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t
need <code>match</code> expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct in one location.</p>
<p>使用状态模式后，<code>Post</code> 的方法及其使用处均无需 <code>match</code> 表达式。添加新状态时，仅需添加新结构体并在单处为其实现特征方法。</p>
<p>The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:</p>
<p>基于状态模式的实现易于扩展功能。为体验其可维护性，尝试以下建议：</p>
<ul>
<li>
<p>Add a <code>reject</code> method that changes the post’s state from <code>PendingReview</code> back
to <code>Draft</code>.</p>
</li>
<li>
<p>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</p>
</li>
<li>
<p>Allow users to add text content only when a post is in the <code>Draft</code> state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the <code>Post</code>.</p>
</li>
<li>
<p>添加 <code>reject</code> 方法，将文章状态从 <code>PendingReview</code> 改回 <code>Draft</code>。</p>
</li>
<li>
<p>要求两次 <code>approve</code> 调用才将状态改为 <code>Published</code>。</p>
</li>
<li>
<p>仅允许在 <code>Draft</code> 状态下添加文本内容。提示：让状态对象负责内容可能的变化，而非负责修改 <code>Post</code>。</p>
</li>
</ul>
<p>One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>,
we would have to change the code in <code>PendingReview</code> to transition to
<code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>状态模式的一个缺点是：因状态间转换由状态自身实现，部分状态相互耦合。若在 <code>PendingReview</code> 和 <code>Published</code> 间添加新状态（如 <code>Scheduled</code>），需修改 <code>PendingReview</code> 的代码以转为 <code>Scheduled</code>。若 <code>PendingReview</code> 不随新状态改变可减少工作量，但这需改用其他设计模式。</p>
<p>Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
<code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>.
However, this wouldn’t work: when using <code>State</code> as a trait object, the trait
doesn’t know what the concrete <code>self</code> will be exactly, so the return type isn’t
known at compile time. (This is one of the <code>dyn</code> compatibility rules mentioned
earlier.)</p>
<p>另一缺点是有逻辑重复。为消除重复，可尝试为 <code>State</code> 特征的 <code>request_review</code> 和 <code>approve</code> 方法提供返回 <code>self</code> 的默认实现。但这行不通：当 <code>State</code> 作为特征对象使用时，特征不知具体 <code>self</code> 类型，故编译时无法确定返回类型（这是前文提到的 <code>dyn</code> 兼容性规则之一）。</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code>
and <code>approve</code> methods on <code>Post</code>. Both methods use <code>Option::take</code> with the
<code>state</code> field of <code>Post</code>, and if <code>state</code> is <code>Some</code>, they delegate to the wrapped
value’s implementation of the same method and set the new value of the <code>state</code>
field to the result. If we had a lot of methods on <code>Post</code> that followed this
pattern, we might consider defining a macro to eliminate the repetition (see
“Macros” in Chapter 20).</p>
<p>其他重复包括 <code>Post</code> 上 <code>request_review</code> 和 <code>approve</code> 方法的相似实现。两方法均使用 <code>Option::take</code> 处理 <code>Post</code> 的 <code>state</code> 字段，若 <code>state</code> 为 <code>Some</code>，则委托给内部值的同名方法并设置 <code>state</code> 字段的新值。若 <code>Post</code> 上有大量此类方法，可考虑用宏消除重复（见第 20 章“宏”）。</p>
<p>By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the <code>blog</code> crate that can make
invalid states and transitions into compile-time errors.</p>
<p>严格按面向对象语言定义实现状态模式，未能充分利用 Rust 的优势。下面看看如何修改 <code>blog</code> crate，将无效状态和转换转化为编译时错误。</p>
<h3 id="encoding-states-and-behavior-as-types-将状态和行为编码为类型"><a class="header" href="#encoding-states-and-behavior-as-types-将状态和行为编码为类型">Encoding States and Behavior as Types 将状态和行为编码为类型</a></h3>
<p>We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>我们将展示如何重新思考状态模式以获得不同的权衡方案。不同于完全封装状态和转换（使外部代码对其无感知），我们将状态编码为不同类型。因此 Rust 的类型检查系统将通过编译器错误阻止在仅允许发布文章处使用草稿文章。</p>
<p>Let’s consider the first part of <code>main</code> in Listing 18-11:</p>
<p>考虑清单 18-11 中 <code>main</code> 的第一部分：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</figure>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code>
and the ability to add text to the post’s content. But instead of having a
<code>content</code> method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the <code>content</code> method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production because that code won’t even compile.
Listing 18-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct,
as well as methods on each.</p>
<p>我们仍允许用 <code>Post::new</code> 创建草稿状态的新文章，并能向文章添加文本。但不再为草稿文章提供返回空字符串的 <code>content</code> 方法，而是直接让草稿文章无 <code>content</code> 方法。这样，若尝试获取草稿文章内容，编译器将报错“方法不存在”。因此，生产环境不可能意外显示草稿内容（因相关代码甚至无法编译）。清单 18-19 展示了 <code>Post</code> 和 <code>DraftPost</code> 结构体的定义及各自的方法。</p>
<figure class="listing" id="listing-18-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-19">Listing 18-19</a>: A <code>Post</code> with a <code>content</code> method and <code>DraftPost</code> without a <code>content</code> method 带 <code>content</code> 方法的 <code>Post</code> 和不带该方法的 <code>DraftPost</code></figcaption>
</figure>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that
stores the blog post text. The structs no longer have the <code>state</code> field because
we’re moving the encoding of the state to the types of the structs. The <code>Post</code>
struct will represent a published post, and it has a <code>content</code> method that
returns the <code>content</code>.</p>
<p><code>Post</code> 和 <code>DraftPost</code> 结构体均有私有 <code>content</code> 字段存储博客文本。结构体不再含 <code>state</code> 字段，因我们将状态编码移至结构体类型。<code>Post</code> 结构体表示已发布的文章，其 <code>content</code> 方法返回 <code>content</code>。</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private and
there aren’t any functions that return <code>Post</code>, it’s not possible to create an
instance of <code>Post</code> right now.</p>
<p>仍有 <code>Post::new</code> 函数，但它返回 <code>DraftPost</code> 实例而非 <code>Post</code>。因 <code>content</code> 私有且无返回 <code>Post</code> 的函数，目前无法直接创建 <code>Post</code> 实例。</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to
<code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.</p>
<p><code>DraftPost</code> 有 <code>add_text</code> 方法，故可如前往内容添加文本。但注意 <code>DraftPost</code> 未定义 <code>content</code> 方法！程序现确保所有文章均以草稿开始，且草稿文章内容不可显示。任何规避这些约束的尝试将导致编译错误。</p>
<p>So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, <code>PendingReviewPost</code>, defining the
<code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code> and
defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as
shown in Listing 18-20.</p>
<p>那么如何获取已发布的文章？我们需强制规则：草稿文章必须经审核批准才能发布。处于待审核状态的文章仍不应显示内容。通过添加新结构体 <code>PendingReviewPost</code> 实现这些约束：在 <code>DraftPost</code> 上定义 <code>request_review</code> 方法（返回 <code>PendingReviewPost</code>），在 <code>PendingReviewPost</code> 上定义 <code>approve</code> 方法（返回 <code>Post</code>），如清单 18-20 所示。</p>
<figure class="listing" id="listing-18-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-20">Listing 18-20</a>: A <code>PendingReviewPost</code> that gets created by calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a <code>PendingReviewPost</code> into a published <code>Post</code> 通过调用 <code>DraftPost</code> 的 <code>request_review</code> 创建 <code>PendingReviewPost</code>，其 <code>approve</code> 方法将 <code>PendingReviewPost</code> 转为已发布 <code>Post</code></figcaption>
</figure>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won’t have any lingering <code>DraftPost</code> instances after we’ve called
<code>request_review</code> on them, and so forth. The <code>PendingReviewPost</code> struct doesn’t
have a <code>content</code> method defined on it, so attempting to read its content
results in a compiler error, as with <code>DraftPost</code>. Because the only way to get a
published <code>Post</code> instance that does have a <code>content</code> method defined is to call
the <code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we’ve now encoded the blog post workflow into the type system.</p>
<p><code>request_review</code> 和 <code>approve</code> 方法获取 <code>self</code> 的所有权，从而消费 <code>DraftPost</code> 和 <code>PendingReviewPost</code> 实例，分别将其转换为 <code>PendingReviewPost</code> 和已发布的 <code>Post</code>。这样，调用 <code>request_review</code> 后不会遗留 <code>DraftPost</code> 实例，以此类推。<code>PendingReviewPost</code> 结构体未定义 <code>content</code> 方法，故尝试读取其内容会导致编译器错误（同 <code>DraftPost</code>）。因唯一获取带 <code>content</code> 方法的 <code>Post</code> 实例的途径是调用 <code>PendingReviewPost</code> 的 <code>approve</code> 方法，而唯一获取 <code>PendingReviewPost</code> 的途径是调用 <code>DraftPost</code> 的 <code>request_review</code> 方法，我们已将博客文章工作流编码进类型系统。</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and
<code>approve</code> methods return new instances rather than modifying the struct they’re
called on, so we need to add more <code>let post =</code> shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review posts’ contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in <code>main</code> is shown in Listing 18-21.</p>
<p>但也需对 <code>main</code> 做小修改。<code>request_review</code> 和 <code>approve</code> 方法返回新实例而非修改原结构体，故需添加更多 <code>let post =</code> 阴影赋值保存返回实例。此外，不再需要（也不能有）关于草稿和待审核文章内容为空的断言：因编译器已阻止使用这些状态的文章内容。更新后的 <code>main</code> 代码如清单 18-21 所示。</p>
<figure class="listing" id="listing-18-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="ch18-03-oo-design-patterns.html#listing-18-21">Listing 18-21</a>: Modifications to <code>main</code> to use the new implementation of the blog post workflow 修改 <code>main</code> 以使用博客文章工作流的新实现</figcaption>
</figure>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the <code>Post</code> implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.</p>
<p>为重新赋值 <code>post</code> 对 <code>main</code> 的修改意味着：此实现不再严格遵循面向对象状态模式（状态间转换不再完全封装在 <code>Post</code> 实现内）。但我们的收获是：类型系统及编译时类型检查使无效状态成为不可能！这确保某些 bug（如显示未发布文章内容）在进入生产环境前即被发现。</p>
<p>Try the tasks suggested at the start of this section on the <code>blog</code> crate as it
is after Listing 18-21 to see what you think about the design of this version
of the code. Note that some of the tasks might be completed already in this
design.</p>
<p>尝试在本节开头提出的任务，对清单 18-21 后的 <code>blog</code> crate 进行操作，思考此版本代码的设计。注意部分任务可能已在此设计中完成。</p>
<p>We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.</p>
<p>我们已看到：尽管 Rust 能实现面向对象设计模式，但也存在其他模式（如将状态编码进类型系统）。这些模式各有取舍。虽然你可能熟悉面向对象模式，但重新思考问题以利用 Rust 的特性可带来优势（如在编译时阻止某些错误）。因所有权等面向对象语言不具备的特性，在 Rust 中面向对象模式并非总是最佳解决方案。</p>
<h2 id="summary-总结-17"><a class="header" href="#summary-总结-17">Summary 总结</a></h2>
<p>Regardless of whether you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but it is an available
option.</p>
<p>无论阅读本章后你是否认为 Rust 是面向对象语言，现在你已知可用特征对象在 Rust 中获取部分面向对象特性。动态调度能以些许运行时性能为代价换取代码灵活性。此灵活性可用于实现面向对象模式以提升代码可维护性。Rust 也有其他特性（如所有权）是面向对象语言所缺的。面向对象模式并非总能充分利用 Rust 的优势，但它是一种可选项。</p>
<p>Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!</p>
<p>接下来，我们将探讨模式（pattern）——这是 Rust 另一支持高度灵活性的特性。本书中我们已简要接触过，但尚未窥其全貌。让我们继续前进！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching-模式与匹配"><a class="header" href="#patterns-and-matching-模式与匹配">Patterns and Matching 模式与匹配</a></h1>
<p><em>Patterns</em> are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with <code>match</code>
expressions and other constructs gives you more control over a program’s
control flow. A pattern consists of some combination of the following:</p>
<p><strong>模式</strong>是 Rust 中的一种特殊语法，用于匹配简单或复杂类型的结构。结合 <code>match</code> 表达式和其他结构使用模式，能让你更精细地控制程序流程。<span class="highlight">[note]模式可由以下元素的组合构成：</span></p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<!-- -->
<ul>
<li><span class="highlight">[note]字面值</span></li>
<li>解构的数组、枚举、结构体或元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<p>Some example patterns include <code>x</code>, <code>(a, 3)</code>, and <code>Some(Color::Red)</code>. In the
contexts in which patterns are valid, these components describe the shape of
data. Our program then matches values against the patterns to determine whether
it has the correct shape of data to continue running a particular piece of code.</p>
<p>示例模式如 <code>x</code>、<code>(a, 3)</code> 和 <code>Some(Color::Red)</code>。在模式有效的上下文中，这些组件描述了数据的形态。程序通过将值与模式匹配，判断数据是否具有正确的形态以执行特定代码。</p>
<p>To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the <code>match</code> expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn’t, the code associated with the pattern won’t run.</p>
<p>使用模式时需将其与值比较。若匹配成功，可在代码中使用值的对应部分。回顾第 6 章的 <code>match</code> 表达式（如硬币分拣机示例）：若值符合模式形态，则可使用命名的片段；若不符合，与该模式关联的代码不会执行。</p>
<p>This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you’ll know how to use patterns to express many concepts in
a clear way.</p>
<p>本章全面阐述模式的相关知识，涵盖模式的有效使用场景、可辩驳模式与不可辩驳模式的区别，以及各类模式语法。学完本章后，你将掌握如何用模式清晰表达多种概念。
本章全面阐述模式的相关知识，涵盖模式的有效使用场景、可辩驳模式与不可辩驳模式的区别，以及各类模式语法。学完本章后，你将掌握如何用模式清晰表达多种概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="all-the-places-patterns-can-be-used-模式可用位置"><a class="header" href="#all-the-places-patterns-can-be-used-模式可用位置">All the Places Patterns Can Be Used 模式可用位置</a></h2>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.</p>
<p>模式在 Rust 中随处可见，你可能已在不知不觉中频繁使用！本节将讨论所有模式有效的位置。</p>
<h3 id="match-arms-match-分支"><a class="header" href="#match-arms-match-分支"><code>match</code> Arms <code>match</code> 分支</a></h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.
Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:</p>
<p>如第 6 章所述，我们在 <code>match</code> 表达式的分支中使用模式。<span class="highlight">[note]形式化定义中，<code>match</code> 表达式由关键字 <code>match</code>、待匹配的值，以及一个或多个分支组成。每个分支包含一个模式，当值匹配该分支模式时执行对应表达式</span>：</p>
<pre><code>match <em>VALUE</em> {
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
}</code></pre>
<p>For example, here’s the <code>match</code> expression from Listing 6-5 that matches on an
<code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<p>例如，以下代码匹配变量 <code>x</code> 中的 <code>Option&lt;i32&gt;</code> 值（源自代码清单 6-5）：</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> on the
left of each arrow.</p>
<p>此 <code>match</code> 表达式中的模式是箭头左侧的 <code>None</code> 和 <code>Some(i)</code>。</p>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in
the sense that all possibilities for the value in the <code>match</code> expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catch-all pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.</p>
<p><code>match</code> 表达式必须满足<strong>穷尽性</strong>要求：必须覆盖 <code>match</code> 表达式中值的所有可能性。确保全覆盖的方法之一是在最后分支使用通配模式：例如，匹配任意值的变量名永不失败，因此可覆盖所有剩余情况。</p>
<p>The particular pattern <code>_</code> will match anything, but it never binds to a
variable, so it’s often used in the last match arm. The <code>_</code> pattern can be
useful when you want to ignore any value not specified, for example. We’ll cover
the <code>_</code> pattern in more detail in “Ignoring Values in a
Pattern” later in this chapter.</p>
<p>特殊模式 <code>_</code> 可匹配任何值但永不绑定变量，故常用于最后分支。当需忽略未指定的值时，<code>_</code> 模式很有用。本章后续章节“模式中忽略值”将详述 <code>_</code> 模式。</p>
<h3 id="let-statements-let-语句"><a class="header" href="#let-statements-let-语句">let Statements <code>let</code> 语句</a></h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we’ve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<p>在本章之前，我们只明确讨论了在 <code>match</code> 和 <code>if let</code> 中使用模式，但实际上，我们也在其他地方使用了模式，包括 <code>let</code> 语句。例如，考虑这个使用 <code>let</code> 的简单变量赋值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Every time you’ve used a <code>let</code> statement like this you’ve been using patterns,
although you might not have realized it! More formally, a <code>let</code> statement looks
like this:</p>
<p>每次你这样使用 <code>let</code> 语句时，你都在使用模式，尽管你可能没有意识到！更<span class="highlight">[note]正式地说，<code>let</code> 语句如下所示</span>：</p>
<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the PATTERN slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So, in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to
the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>在像 <code>let x = 5;</code> 这样的语句中，模式槽位使用变量名，变量名只是模式的一种特别简单的形式。Rust 将表达式与模式进行比较，并分配它找到的任何名称。因此，在 <code>let x = 5;</code> 示例中，<code>x</code> 是一个表示“将匹配此处的内容绑定到变量 <code>x</code>”的模式。因为名称 <code>x</code> 是整个模式，所以该模式实际上意味着“将所有内容绑定到变量 <code>x</code>，无论值是什么”。</p>
<p>To see the pattern-matching aspect of <code>let</code> more clearly, consider Listing
19-1, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<p>为了更清楚地看到 <code>let</code> 的模式匹配方面，请考虑示例 19-1，它使用带有 <code>let</code> 的模式来解构元组。</p>
<figure class="listing" id="listing-19-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-1">Listing 19-1</a>: Using a pattern to destructure a tuple and create three variables at once 使用模式解构元组并一次性创建三个变量</figcaption>
</figure>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, in that
it sees that the number of elements is the same in both, so Rust binds <code>1</code> to
<code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple pattern as nesting
three individual variable patterns inside it.</p>
<p>在这里，我们将元组与模式进行匹配。Rust 将值 <code>(1, 2, 3)</code> 与模式 <code>(x, y, z)</code> 进行比较，发现值匹配模式，因为它看到两者的元素数量相同，因此 Rust 将 <code>1</code> 绑定到 <code>x</code>，<code>2</code> 绑定到 <code>y</code>，<code>3</code> 绑定到 <code>z</code>。你可以将此元组模式视为嵌套了三个单独的变量模式。</p>
<p>If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 19-2 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.</p>
<p>如果模式中的元素数量与元组中的元素数量不匹配，整体类型将不匹配，我们会收到编译器错误。例如，示例 19-2 展示了尝试将包含三个元素的元组解构为两个变量的情况，这是行不通的。</p>
<figure class="listing" id="listing-19-2">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-2">Listing 19-2</a>: Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple 错误构造变量数与元组元素数不匹配的模式</figcaption>
</figure>
<p>Attempting to compile this code results in this type error:</p>
<p>编译此代码会产生类型错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using
<code>_</code> or <code>..</code>, as you’ll see in the “Ignoring Values in a
Pattern” section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.</p>
<p>要修复错误，我们可以使用 <code>_</code> 或 <code>..</code> 忽略元组中的一个或多个值，正如你将在“忽略模式中的值”一节中看到的那样。如果问题在于模式中的变量过多，解决方案是通过移除变量使类型匹配，使变量数量等于元组中的元素数量。</p>
<h3 id="conditional-if-let-expressions-条件-if-let-表达式"><a class="header" href="#conditional-if-let-expressions-条件-if-let-表达式">Conditional if let Expressions 条件 <code>if let</code> 表达式</a></h3>
<p>In Chapter 6, we discussed how to use <code>if let</code> expressions mainly as a shorter
way to write the equivalent of a <code>match</code> that only matches one case.
Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if
the pattern in the <code>if let</code> doesn’t match.</p>
<p>在第 6 章中，我们讨论了如何使用 <code>if let</code> 表达式，主要是作为仅匹配一种情况的 <code>match</code> 表达式的简写方式。可选地，<code>if let</code> 可以有一个对应的 <code>else</code>，包含在 <code>if let</code> 中的模式不匹配时运行的代码。</p>
<p>Listing 19-3 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a
<code>match</code> expression in which we can express only one value to compare with the
patterns. Also, Rust doesn’t require that the conditions in a series of <code>if let</code>, <code>else if</code>, and <code>else if let</code> arms relate to each other.</p>
<p>示例 19-3 表明，<span class="highlight">[note]混合搭配 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 表达式也是可能的</span>。这样做比 <code>match</code> 表达式提供了更大的灵活性，在 <code>match</code> 中我们只能表达一个与模式比较的值。此外，Rust 不要求一系列 <code>if let</code>、<code>else if</code> 和 <code>else if let</code> 分支中的条件相互关联。</p>
<p>The code in Listing 19-3 determines what color to make your background based on
a series of checks for several conditions. For this example, we’ve created
variables with hardcoded values that a real program might receive from user
input.</p>
<p>示例 19-3 中的代码基于对多个条件的一系列检查来确定背景颜色。在此示例中，我们创建了具有硬编码值的变量，真实程序可能会从用户输入中接收这些值。</p>
<figure class="listing" id="listing-19-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-3">Listing 19-3</a>: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>, and <code>else</code> 混合使用 <code>if let</code>、<code>else if</code>、<code>else if let</code> 和 <code>else</code></figcaption>
</figure>
<p>If the user specifies a favorite color, that color is used as the background.
If no favorite color is specified and today is Tuesday, the background color is
green. Otherwise, if the user specifies their age as a string and we can parse
it as a number successfully, the color is either purple or orange depending on
the value of the number. If none of these conditions apply, the background
color is blue.</p>
<p>如果用户指定了最喜欢的颜色，则该颜色将用作背景色。如果未指定最喜欢的颜色且今天是星期二，则背景颜色为绿色。否则，如果用户将其年龄指定为字符串，并且我们可以成功将其解析为数字，则颜色根据数字的值是紫色或橙色。如果这些条件都不适用，则背景颜色为蓝色。</p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>这种条件结构使我们能够支持复杂的需求。使用我们在此处设置的硬编码值，此示例将打印 <code>Using purple as the background color</code>。</p>
<p>You can see that <code>if let</code> can also introduce new variables that shadow existing
variables in the same way that <code>match</code> arms can: the line <code>if let Ok(age) = age</code>
introduces a new <code>age</code> variable that contains the value inside the <code>Ok</code> variant,
shadowing the existing <code>age</code> variable. This means we need to place the <code>if age &gt; 30</code> condition within that block: we can’t combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The new <code>age</code> we want to compare to 30 isn’t
valid until the new scope starts with the curly bracket.</p>
<p>你可以看到 <code>if let</code> 也可以引入遮蔽现有变量的新变量，其方式与 <code>match</code> 分支相同：行 <code>if let Ok(age) = age</code> 引入了一个新的 <code>age</code> 变量，该变量包含 <code>Ok</code> 变体中的值，遮蔽了现有的 <code>age</code> 变量。这意味着我们需要将 <code>if age &gt; 30</code> 条件放在该代码块内：我们不能将这两个条件组合成 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>。我们想要与 30 比较的新 <code>age</code> 在新作用域（以大括号开始）之前是无效的。</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn’t check
for exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the
last <code>else</code> block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.</p>
<p>使用 <code>if let</code> 表达式的缺点是编译器不检查穷尽性，而 <code>match</code> 表达式会检查。如果我们省略最后一个 <code>else</code> 块，从而遗漏处理某些情况，编译器不会提醒我们可能存在的逻辑错误。</p>
<h3 id="while-let-conditional-loops-while-let-条件循环"><a class="header" href="#while-let-conditional-loops-while-let-条件循环"><code>while let</code> Conditional Loops <code>while let</code> 条件循环</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a
<code>while</code> loop to run for as long as a pattern continues to match. In Listing
19-4 we show a <code>while let</code> loop that waits on messages sent between threads,
but in this case checking a <code>Result</code> instead of an <code>Option</code>.</p>
<p>在结构上类似于 <code>if let</code>，<code>while let</code> 条件循环允许 <code>while</code> 循环在模式持续匹配时运行。在示例 19-4 中，我们展示了一个 <code>while let</code> 循环，它等待线程之间发送的消息，但在此情况下检查的是 <code>Result</code> 而不是 <code>Option</code>。</p>
<figure class="listing" id="listing-19-4">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-4">Listing 19-4</a>: Using a <code>while let</code> loop to print values for as long as <code>rx.recv()</code> returns <code>Ok</code> 使用 <code>while let</code> 循环在 <code>rx.recv()</code> 返回 <code>Ok</code> 时打印值</figcaption>
</figure>
<p>This example prints <code>1</code>, <code>2</code>, and then <code>3</code>. The <code>recv</code> method takes the first
message out of the receiver side of the channel and returns an <code>Ok(value)</code>. When
we first saw <code>recv</code> back in Chapter 16, we unwrapped the error directly, or
interacted with it as an iterator using a <code>for</code> loop. As Listing 19-4 shows,
though, we can also use while let, because the <code>recv</code> method returns an <code>Ok</code>
each time a message arrives, as long as the sender exists, and then produces an
<code>Err </code>once the sender side disconnects.</p>
<p>此示例打印 <code>1</code>、<code>2</code>，然后 <code>3</code>。<code>recv</code> 方法从通道的接收端取出第一条消息并返回 <code>Ok(value)</code>。当我们在第 16 章首次看到 <code>recv</code> 时，我们直接解开了错误，或使用 <code>for</code> 循环将其作为迭代器进行交互。然而，如示例 19-4 所示，我们也可以使用 while let，因为只要发送者存在，<code>recv</code> 方法在每次消息到达时都会返回 <code>Ok</code>，然后在发送端断开连接后产生一个 <code>Err</code>。</p>
<h3 id="for-loops-for-循环"><a class="header" href="#for-loops-for-循环"><code>for</code> Loops <code>for</code> 循环</a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a
pattern. For example, in <code>for x in y</code>, the <code>x</code> is the pattern. Listing 19-5
demonstrates how to use a pattern in a <code>for</code> loop to <em>destructure</em>, or break
apart, a tuple as part of the <code>for</code> loop.</p>
<p>在 <code>for</code> 循环中，紧跟在关键字 <code>for</code> 后面的值是一个模式。例如，在 <code>for x in y</code> 中，<code>x</code> 就是模式。示例 19-5 演示了如何在 <code>for</code> 循环中使用模式来<em>解构</em>或拆分元组，作为 <code>for</code> 循环的一部分。</p>
<figure class="listing" id="listing-19-5">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-5">Listing 19-5</a>: Using a pattern in a <code>for</code> loop to destructure a tuple 在 <code>for</code> 循环中使用模式解构元组</figcaption>
</figure>
<p>The code in Listing 19-5 will print the following:</p>
<p>示例 19-5 中的代码将打印以下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We adapt an iterator using the <code>enumerate</code> method so it produces a value and
the index for that value, placed into a tuple. The first value produced is the
tuple <code>(0, 'a')</code>. When this value is matched to the pattern <code>(index, value)</code>,
<code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>, printing the first line of the
output.</p>
<p>我们使用 <code>enumerate</code> 方法调整迭代器，使其生成一个值及其索引，放入元组中。生成的第一个值是元组 <code>(0, 'a')</code>。当该值与模式 <code>(index, value)</code> 匹配时，<code>index</code> 将为 <code>0</code>，<code>value</code> 将为 <code>'a'</code>，从而打印输出的第一行。</p>
<h3 id="function-parameters-函数参数"><a class="header" href="#function-parameters-函数参数">Function Parameters 函数参数</a></h3>
<p>Function parameters can also be patterns. The code in Listing 19-6, which
declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type
<code>i32</code>, should by now look familiar.</p>
<p><span class="highlight">[note]函数参数也可以是模式</span>。示例 19-6 中的代码声明了一个名为 <code>foo</code> 的函数，该函数接受一个名为 <code>x</code> 的 <code>i32</code> 类型参数，现在看起来应该很熟悉。</p>
<figure class="listing" id="listing-19-6">
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-6">Listing 19-6</a>: A function signature uses patterns in the parameters 函数签名在参数中使用模式</figcaption>
</figure>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a
function’s arguments to the pattern. Listing 19-7 splits the values in a tuple
as we pass it to a function.</p>
<p><code>x</code> 部分就是一个模式！正如我们在 <code>let</code> 中所做的那样，我们可以在函数的参数中将元组与模式匹配。示例 19-7 在将元组传递给函数时拆分元组中的值。</p>
<figure class="listing" id="listing-19-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<figcaption><a href="ch19-01-all-the-places-for-patterns.html#listing-19-7">Listing 19-7</a>: A function with parameters that destructure a tuple 参数解构元组的函数</figcaption>
</figure>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>此代码打印 <code>Current location: (3, 5)</code>。值 <code>&amp;(3, 5)</code> 与模式 <code>&amp;(x, y)</code> 匹配，因此 <code>x</code> 是值 <code>3</code>，<code>y</code> 是值 <code>5</code>。</p>
<p>We can also use patterns in closure parameter lists in the same way as in
function parameter lists because closures are similar to functions, as
discussed in Chapter 13.</p>
<p>我们也可以像在函数参数列表中一样，在闭包参数列表中使用模式，因为闭包类似于函数，正如第 13 章所讨论的那样。</p>
<p>At this point, you’ve seen several ways to use patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We’ll discuss
these two concepts next.</p>
<p>至此，你已经看到了使用模式的几种方式，但模式在我们能使用它们的每个地方的工作方式并不相同。在某些地方，模式必须是不可反驳的；在其他情况下，它们可以是可反驳的。接下来我们将讨论这两个概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutability-whether-a-pattern-might-fail-to-match-可反驳性模式是否可能匹配失败"><a class="header" href="#refutability-whether-a-pattern-might-fail-to-match-可反驳性模式是否可能匹配失败">Refutability: Whether a Pattern Might Fail to Match 可反驳性：模式是否可能匹配失败</a></h2>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are <em>irrefutable</em>. An example would be <code>x</code> in the
statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
<em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than
<code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>模式有两种形式：可反驳的和不可反驳的。将匹配任何可能传递的值的模式是<em>不可反驳的</em>。例如，语句 <code>let x = 5;</code> 中的 <code>x</code> 是不可反驳的，因为 <code>x</code> 匹配任何内容，因此不可能匹配失败。对于某些可能的值可能匹配失败的模式是<em>可反驳的</em>。例如，表达式 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code> 是可反驳的，因为如果 <code>a_value</code> 变量中的值是 <code>None</code> 而不是 <code>Some</code>，则 <code>Some(x)</code> 模式将不匹配。</p>
<p>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept
irrefutable patterns because the program cannot do anything meaningful when
values don’t match. The <code>if let</code> and <code>while let</code> expressions and the
<code>let...else</code> statement accept refutable and irrefutable patterns, but the
compiler warns against irrefutable patterns because, by definition, they’re
intended to handle possible failure: the functionality of a conditional is in
its ability to perform differently depending on success or failure.</p>
<p>函数参数、<code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式，因为当值不匹配时程序无法执行任何有意义的操作。<code>if let</code> 和 <code>while let</code> 表达式以及 <code>let...else</code> 语句接受可反驳和不可反驳的模式，但编译器会警告不可反驳的模式，因为根据定义，它们的目的是处理可能的失败：条件语句的功能在于它能够根据成功或失败执行不同的操作。</p>
<p>In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you’ll need to change either the pattern or the construct you’re
using the pattern with, depending on the intended behavior of the code.</p>
<p>一般来说，你不需要担心可反驳和不可反驳模式之间的区别；但是，你需要熟悉可反驳性的概念，以便在错误消息中看到它时能够做出反应。在这些情况下，你需要根据代码的预期行为更改模式或使用该模式的构造。</p>
<p>Let’s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 19-8 shows a
<code>let</code> statement, but for the pattern, we’ve specified <code>Some(x)</code>, a refutable
pattern. As you might expect, this code will not compile.</p>
<p>让我们看一个示例，说明当我们尝试在 Rust 要求不可反驳模式的地方使用可反驳模式时会发生什么，反之亦然。示例 19-8 展示了一个 <code>let</code> 语句，但对于模式，我们指定了 <code>Some(x)</code>，这是一个可反驳的模式。正如你可能预料的那样，此代码无法编译。</p>
<figure class="listing" id="listing-19-8">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<figcaption><a href="ch19-02-refutability.html#listing-19-8">Listing 19-8</a>: Attempting to use a refutable pattern with <code>let</code> 尝试在 <code>let</code> 中使用可反驳模式</figcaption>
</figure>
<p>If <code>some_option_value</code> were a <code>None</code> value, it would fail to match the pattern
<code>Some(x)</code>, meaning the pattern is refutable. However, the <code>let</code> statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a <code>None</code> value. At compile time, Rust will complain that we’ve tried to
use a refutable pattern where an irrefutable pattern is required:</p>
<p>如果 <code>some_option_value</code> 是 <code>None</code> 值，它将无法匹配模式 <code>Some(x)</code>，这意味着该模式是可反驳的。但是，<code>let</code> 语句只能接受不可反驳的模式，因为代码无法对 <code>None</code> 值执行任何有效操作。在编译时，Rust 会抱怨我们尝试在需要不可反驳模式的地方使用了可反驳模式：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Because we didn’t cover (and couldn’t cover!) every valid value with the
pattern <code>Some(x)</code>, Rust rightfully produces a compiler error.</p>
<p>因为我们没有（也不可能！）用模式 <code>Some(x)</code> 覆盖所有有效值，所以 Rust 理所当然地产生编译器错误。</p>
<p>If we have a refutable pattern where an irrefutable pattern is needed, we can
fix it by changing the code that uses the pattern: instead of using <code>let</code>, we
can use <code>let else</code>. Then, if the pattern doesn’t match, the code will just skip
the code in the curly brackets, giving it a way to continue validly. Listing
19-9 shows how to fix the code in Listing 19-8.</p>
<p>如果我们在需要不可反驳模式的地方使用了可反驳模式，我们可以通过更改使用模式的代码来修复它：不使用 <code>let</code>，而使用 <code>let else</code>。然后，如果模式不匹配，代码将跳过花括号中的代码，从而提供一种有效继续的方式。示例 19-9 展示了如何修复示例 19-8 中的代码。</p>
<figure class="listing" id="listing-19-9">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value else {
        return;
    };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-02-refutability.html#listing-19-9">Listing 19-9</a>: Using <code>let...else</code> and a block with refutable patterns instead of <code>let</code> 使用 <code>let...else</code> 和带有可反驳模式的代码块代替 <code>let</code></figcaption>
</figure>
<p>We’ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving a warning. If we give
<code>let...else</code> a pattern that will always match, such as <code>x</code>, as shown in Listing
19-10, the compiler will give a warning.</p>
<p>我们为代码提供了出路！这段代码完全有效，尽管这意味着如果我们收到警告就无法使用不可反驳模式。如果我们给 <code>let...else</code> 一个总是匹配的模式，例如 <code>x</code>，如示例 19-10 所示，编译器会发出警告。</p>
<figure class="listing" id="listing-19-10">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5 else {
        return;
    };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-02-refutability.html#listing-19-10">Listing 19-10</a>: Attempting to use an irrefutable pattern with <code>let...else</code> 尝试在 <code>let...else</code> 中使用不可反驳模式</figcaption>
</figure>
<p>Rust complains that it doesn’t make sense to use <code>let...else</code> with an
irrefutable pattern:</p>
<p>Rust 抱怨使用 <code>let...else</code> 和不可反驳模式没有意义：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `let...else` pattern
 --&gt; src/main.rs:2:5
  |
2 |     let x = 5 else {
  |     ^^^^^^^^^
  |
  = note: this pattern will always match, so the `else` clause is useless
  = help: consider removing the `else` clause
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but
this syntax isn’t particularly useful and could be replaced with a simpler
<code>let</code> statement.</p>
<p>因此，匹配分支必须使用可反驳模式，除了最后一个分支，它应该使用不可反驳模式匹配所有剩余值。Rust 允许我们在只有一个分支的 <code>match</code> 中使用不可反驳模式，但这种语法并不特别有用，可以用更简单的 <code>let</code> 语句代替。</p>
<p>Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let’s cover all the syntax we can use to create
patterns.</p>
<p>现在你知道了在何处使用模式以及可反驳和不可反驳模式之间的区别，接下来让我们介绍所有可用于创建模式的语法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-syntax-模式语法"><a class="header" href="#pattern-syntax-模式语法">Pattern Syntax 模式语法</a></h2>
<p>In this section, we gather all the syntax that is valid in patterns and discuss
why and when you might want to use each one.</p>
<p>本节汇总了模式中所有有效的语法，并讨论了为何以及何时使用每种语法。</p>
<h3 id="matching-literals-匹配字面值"><a class="header" href="#matching-literals-匹配字面值">Matching Literals 匹配字面值</a></h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:</p>
<p>如第6章所见，可以直接匹配字面值模式。以下代码展示了一些示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is <code>1</code>. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.</p>
<p>此代码打印 <code>one</code>，因为 <code>x</code> 中的值是 <code>1</code>。当希望代码在获取特定具体值时执行操作时，此语法非常有用。</p>
<h3 id="matching-named-variables-匹配命名变量"><a class="header" href="#matching-named-variables-匹配命名变量">Matching Named Variables 匹配命名变量</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we’ve used
them many times in this book. However, there is a complication when you use
named variables in <code>match</code>, <code>if let</code>, or <code>while let</code> expressions. Because each
of these kinds of expressions starts a new scope, variables declared as part of
a pattern inside these expressions will shadow those with the same name outside
the constructs, as is the case with all variables. In Listing 19-11, we declare
a variable named <code>x</code> with the value <code>Some(5)</code> and a variable <code>y</code> with the value
<code>10</code>. We then create a <code>match</code> expression on the value <code>x</code>. Look at the
patterns in the match arms and <code>println!</code> at the end, and try to figure out
what the code will print before running this code or reading further.</p>
<p>命名变量是匹配任何值的无可辩驳模式，本书中已多次使用它们。然而，在 <code>match</code>、<code>if let</code> 或 <code>while let</code> 表达式中使用命名变量时存在复杂性。因为每种表达式都会开启新作用域，这些表达式内部作为模式一部分声明的变量将遮蔽外部同名变量，所有变量皆如此。在示例19-11中，声明了值为 <code>Some(5)</code> 的变量 <code>x</code> 和值为 <code>10</code> 的变量 <code>y</code>。然后在值 <code>x</code> 上创建 <code>match</code> 表达式。查看匹配分支中的模式及结尾的 <code>println!</code>，尝试在运行代码或继续阅读前推断代码将打印的内容。</p>
<figure class="listing" id="listing-19-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-11">Listing 19-11</a>: A <code>match</code> expression with an arm that introduces a new variable which shadows an existing variable <code>y</code> 引入新变量的 <code>match</code> 表达式，该变量遮蔽了现有变量 <code>y</code></figcaption>
</figure>
<p>Let’s walk through what happens when the <code>match</code> expression runs. The pattern
in the first match arm doesn’t match the defined value of <code>x</code>, so the code
continues.</p>
<p>逐步分析 <code>match</code> 表达式运行时的过程。第一个匹配分支的模式与 <code>x</code> 的定义值不匹配，因此代码继续执行。</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that
will match any value inside a <code>Some</code> value. Because we’re in a new scope inside
the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at
the beginning with the value <code>10</code>. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to
the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>第二个匹配分支的模式引入了名为 <code>y</code> 的新变量，它将匹配 <code>Some</code> 值内部的任何值。因为在 <code>match</code> 表达式内部的新作用域中，这是一个新的 <code>y</code> 变量，而非开头声明的值为 <code>10</code> 的 <code>y</code>。此新 <code>y</code> 绑定将匹配 <code>Some</code> 内部的任何值，这正是 <code>x</code> 中的内容。因此，此新 <code>y</code> 绑定到 <code>x</code> 中 <code>Some</code> 的内部值。该值为 <code>5</code>，因此该分支的表达式执行并打印 <code>Matched, y = 5</code>。</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the <code>x</code> variable in the pattern of the
underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn’t
been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>若 <code>x</code> 是 <code>None</code> 值而非 <code>Some(5)</code>，前两个分支的模式不会匹配，因此值会匹配下划线分支。未在下划线分支的模式中引入 <code>x</code> 变量，因此表达式中的 <code>x</code> 仍是未被遮蔽的外部 <code>x</code>。在此假设情况下，<code>match</code> 会打印 <code>Default case, x = None</code>。</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>当 <code>match</code> 表达式结束时，其作用域结束，内部 <code>y</code> 的作用域也随之结束。最后的 <code>println!</code> 输出 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a new variable that shadows the existing <code>y</code>
variable, we would need to use a match guard conditional instead. We’ll talk
about match guards later in “Extra Conditionals with Match
Guards”.</p>
<p>要创建比较外部 <code>x</code> 和 <code>y</code> 值的 <code>match</code> 表达式（而非引入遮蔽现有 <code>y</code> 变量的新变量），需改用匹配守卫条件。稍后将在“匹配守卫的额外条件”中讨论匹配守卫。</p>
<h3 id="multiple-patterns-多重模式"><a class="header" href="#multiple-patterns-多重模式">Multiple Patterns 多重模式</a></h3>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which is the pattern <em>or</em> operator. For example, in the following code we match
the value of <code>x</code> against the match arms, the first of which has an <em>or</em> option,
meaning if the value of <code>x</code> matches either of the values in that arm, that
arm’s code will run:</p>
<p><span class="highlight">[note]在 <code>match</code> 表达式中，可使用 <code>|</code> 语法匹配多个模式，即模式 <em>或</em> 运算符。</span>例如，以下代码将 <code>x</code> 值与匹配分支匹配，第一个分支有 <em>或</em> 选项，意味着若 <code>x</code> 值匹配该分支中的任一值，该分支的代码将运行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<p>此代码打印 <code>one or two</code>。</p>
<h3 id="matching-ranges-of-values-with--用--匹配值范围"><a class="header" href="#matching-ranges-of-values-with--用--匹配值范围">Matching Ranges of Values with <code>..=</code> 用 <code>..=</code> 匹配值范围</a></h3>
<p>The <code>..=</code> syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the given
range, that arm will execute:</p>
<p><span class="highlight">[note]<code>..=</code> 语法允许匹配包含端点值的范围。</span>以下代码中，当模式匹配给定范围内的任意值时，该分支将执行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>If <code>x</code> is <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>, the first arm will match. This syntax is
more convenient for multiple match values than using the <code>|</code> operator to
express the same idea; if we were to use <code>|</code>, we would have to specify <code>1 | 2 | 3 | 4 | 5</code>. Specifying a range is much shorter, especially if we want to match,
say, any number between 1 and 1,000!</p>
<p>若 <code>x</code> 为 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 或 <code>5</code>，第一个分支将匹配。对于多匹配值，此语法比用 <code>|</code> 运算符表达相同概念更便捷；若使用 <code>|</code>，则需指定 <code>1 | 2 | 3 | 4 | 5</code>。指定范围更简短，尤其当需匹配如 1 到 1000 的任意数字时！</p>
<p>The compiler checks that the range isn’t empty at compile time, and because the
only types for which Rust can tell if a range is empty or not are <code>char</code> and
numeric values, ranges are only allowed with numeric or <code>char</code> values.</p>
<p><span class="highlight">[note]编译器在编译时检查范围是否为空。由于 Rust 能判断范围是否为空的唯一类型是 <code>char</code> 和数值，因此范围仅允许用于数值或 <code>char</code> 值。</span></p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<p>以下示例使用 <code>char</code> 值范围：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust can tell that <code>'c'</code> is within the first pattern’s range and prints <code>early ASCII letter</code>.</p>
<p>Rust 可判断 <code>'c'</code> 在第一个模式的范围内，因此打印 <code>early ASCII letter</code>。</p>
<h3 id="destructuring-to-break-apart-values-解构以分解值"><a class="header" href="#destructuring-to-break-apart-values-解构以分解值">Destructuring to Break Apart Values 解构以分解值</a></h3>
<p>We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values. Let’s walk through each value.</p>
<p>也可使用模式解构结构体、枚举和元组，以使用这些值的不同部分。下面逐一分析。</p>
<h4 id="destructuring-structs-解构结构体"><a class="header" href="#destructuring-structs-解构结构体">Destructuring Structs 解构结构体</a></h4>
<p>Listing 19-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement.</p>
<p>示例19-12展示了带 <code>x</code> 和 <code>y</code> 字段的 <code>Point</code> 结构体，可用带 <code>let</code> 语句的模式分解它。</p>
<figure class="listing" id="listing-19-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-12">Listing 19-12</a>: Destructuring a struct’s fields into separate variables 将结构体字段解构为独立变量</figcaption>
</figure>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct.
However, it’s common to match the variable names to the field names to make it
easier to remember which variables came from which fields. Because of this
common usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a
lot of duplication, Rust has a shorthand for patterns that match struct fields:
you only need to list the name of the struct field, and the variables created
from the pattern will have the same names. Listing 19-13 behaves in the same
way as the code in Listing 19-12, but the variables created in the <code>let</code>
pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<p>此代码创建变量 <code>a</code> 和 <code>b</code>，分别匹配 <code>p</code> 结构体的 <code>x</code> 和 <code>y</code> 字段值。此例表明模式中的变量名不必与结构体字段名匹配。但通常将变量名与字段名匹配，以便记忆变量来源。因此常见用法中，写 <code>let Point { x: x, y: y } = p;</code> 包含大量重复，Rust 对匹配结构体字段的模式提供了<span class="highlight">[note]简写：仅需列出结构体字段名，模式创建的变量将同名</span>。示例19-13的行为与示例19-12的代码相同，但 <code>let</code> 模式创建的变量是 <code>x</code> 和 <code>y</code> 而非 <code>a</code> 和 <code>b</code>。</p>
<figure class="listing" id="listing-19-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-13">Listing 19-13</a>: Destructuring struct fields using struct field shorthand 使用结构体字段简写法解构结构体字段</figcaption>
</figure>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields
of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the
values from the <code>p</code> struct.</p>
<p>此代码创建变量 <code>x</code> 和 <code>y</code>，分别匹配 <code>p</code> 变量的 <code>x</code> 和 <code>y</code> 字段。结果是变量 <code>x</code> 和 <code>y</code> 包含来自 <code>p</code> 结构体的值。</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p><span class="highlight">[note]也可将字面值作为结构体模式的一部分进行解构，而非为所有字段创建变量。这样可测试部分字段的特定值，同时创建变量解构其他字段。</span></p>
<p>In Listing 19-14, we have a <code>match</code> expression that separates <code>Point</code> values
into three cases: points that lie directly on the <code>x</code> axis (which is true when
<code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or on neither axis.</p>
<p>示例19-14中，<code>match</code> 表达式将 <code>Point</code> 值分为三种情况：位于 <code>x</code> 轴上的点（当 <code>y = 0</code> 时为真）、位于 <code>y</code> 轴上的点（<code>x = 0</code>）或不在任一轴上的点。</p>
<figure class="listing" id="listing-19-14">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-14">Listing 19-14</a>: Destructuring and matching literal values in one pattern 在单个模式中同时解构和匹配字面</figcaption>
</figure>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>第一个分支通过指定 <code>y</code> 字段匹配字面值 <code>0</code> 来匹配 <code>x</code> 轴上的任意点。模式仍会创建变量 <code>x</code> 供该分支代码使用。</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that
the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the
value of the <code>y</code> field. The third arm doesn’t specify any literals, so it
matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>类似地，第二个分支通过指定 <code>x</code> 字段为 <code>0</code> 来匹配 <code>y</code> 轴上的任意点，并为 <code>y</code> 字段值创建变量 <code>y</code>。第三个分支未指定字面值，因此匹配其他任意 <code>Point</code> 并为 <code>x</code> 和 <code>y</code> 字段创建变量。</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a <code>0</code>, so this code will print <code>On the y axis at 7</code>.</p>
<p>此例中，值 <code>p</code> 因 <code>x</code> 包含 <code>0</code> 而匹配第二个分支，因此代码将打印 <code>On the y axis at 7</code>。</p>
<p>Remember that a <code>match</code> expression stops checking arms once it has found the
first matching pattern, so even though <code>Point { x: 0, y: 0}</code> is on the <code>x</code> axis
and the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>
<p>记住 <code>match</code> 表达式在找到第一个匹配模式后即停止检查分支，因此即使 <code>Point { x: 0, y: 0}</code> 同时在 <code>x</code> 轴和 <code>y</code> 轴上，此代码也仅会打印 <code>On the x axis at 0</code>。</p>
<h4 id="destructuring-enums-解构枚举"><a class="header" href="#destructuring-enums-解构枚举">Destructuring Enums 解构枚举</a></h4>
<p>We’ve destructured enums in this book (for example, Listing 6-5 in Chapter 6),
but haven’t yet explicitly discussed that the pattern to destructure an enum
corresponds to the way the data stored within the enum is defined. As an
example, in Listing 19-15 we use the <code>Message</code> enum from Listing 6-2 and write
a <code>match</code> with patterns that will destructure each inner value.</p>
<p>本书中已解构枚举（如第6章示例6-5），但尚未明确讨论解构枚举的模式与枚举内定义的数据存储方式相对应。例如，示例19-15使用示例6-2的 <code>Message</code> 枚举，编写带模式的 <code>match</code> 以解构每个内部值。</p>
<figure class="listing" id="listing-19-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-15">Listing 19-15</a>: Destructuring enum variants that hold different kinds of values 解构包含不同类型值的枚举变体</figcaption>
</figure>
<p>This code will print <code>Change color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>此代码将打印 <code>Change color to red 0, green 160, and blue 255</code>。尝试更改 <code>msg</code> 值以观察其他分支的代码运行。</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can’t destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and no variables are in that pattern.</p>
<p>对于不含数据的枚举变体（如 <code>Message::Quit</code>），无法进一步解构值。仅能匹配字面值 <code>Message::Quit</code>，该模式不含变量。</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 19-13.</p>
<p>对于类结构体枚举变体（如 <code>Message::Move</code>），可使用类似于匹配结构体的模式。在变体名后放置花括号，然后列出带变量的字段以分解部分值供该分支代码使用。此处使用示例19-13中的简写形式。</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one
element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.</p>
<p>对于类元组枚举变体（如包含单元素元组的 <code>Message::Write</code> 和包含三元素元组的 <code>Message::ChangeColor</code>），模式类似于匹配元组的模式。模式中的变量数必须与匹配变体的元素数一致。</p>
<h4 id="destructuring-nested-structs-and-enums--解构嵌套结构体和枚举"><a class="header" href="#destructuring-nested-structs-and-enums--解构嵌套结构体和枚举">Destructuring Nested Structs and Enums  解构嵌套结构体和枚举</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep,
but matching can work on nested items too! For example, we can refactor the
code in Listing 19-15 to support RGB and HSV colors in the <code>ChangeColor</code>
message, as shown in Listing 19-16.</p>
<p>目前的示例均解构单层结构体或枚举，但<span class="highlight">[note]匹配也可处理嵌套项</span>！例如，可重构示例19-15的代码以支持 <code>ChangeColor</code> 消息中的 RGB 和 HSV 颜色，如示例19-16所示。</p>
<figure class="listing" id="listing-19-16">
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-16">Listing 19-16</a>: Matching on nested enums 匹配嵌套枚举</figcaption>
</figure>
<p>The pattern of the first arm in the <code>match</code> expression matches a
<code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then
the pattern binds to the three inner <code>i32</code> values. The pattern of the second
arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum
matches <code>Color::Hsv</code> instead. We can specify these complex conditions in one
<code>match</code> expression, even though two enums are involved.</p>
<p><code>match</code> 表达式第一个分支的模式匹配包含 <code>Color::Rgb</code> 变体的 <code>Message::ChangeColor</code> 枚举变体，随后模式绑定到三个内部 <code>i32</code> 值。第二个分支的模式也匹配 <code>Message::ChangeColor</code> 枚举变体，但内部枚举匹配 <code>Color::Hsv</code>。即使涉及两个枚举，也可在单个 <code>match</code> 表达式中指定这些复杂条件。</p>
<h4 id="destructuring-structs-and-tuples-解构结构体和元组"><a class="header" href="#destructuring-structs-and-tuples-解构结构体和元组">Destructuring Structs and Tuples 解构结构体和元组</a></h4>
<p>We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:</p>
<p>可以更复杂的方式混合、匹配和嵌套解构模式。下例展示在元组内嵌套结构体和元组的复杂解构，并解构出所有原始值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.</p>
<p>此代码将复杂类型分解为组成部分，以便分别使用关注的值。</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<p>使用模式解构是便捷使用值片段（如结构体各字段的值）的方式。</p>
<h3 id="ignoring-values-in-a-pattern-忽略模式中的值"><a class="header" href="#ignoring-values-in-a-pattern-忽略模式中的值">Ignoring Values in a Pattern 忽略模式中的值</a></h3>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a <code>match</code>, to get a catch-all that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which you’ve seen), using the <code>_</code> pattern within another pattern,
using a name that starts with an underscore, or using <code>..</code> to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.</p>
<p>有时忽略模式中的值很有用，例如 <code>match</code> 的最后一个分支中，用于获取实际不执行操作但涵盖所有剩余可能值的通配项。有几种方法可忽略整个值或部分值：使用 <code>_</code> 模式（已见过）、在其他模式内使用 <code>_</code>、使用下划线开头的名称或使用 <code>..</code> 忽略值的剩余部分。下面探讨每种模式的使用方法及原因。</p>
<h4 id="an-entire-value-with-_-用-_-忽略整个值"><a class="header" href="#an-entire-value-with-_-用-_-忽略整个值">An Entire Value with <code>_</code> 用 <code>_</code> 忽略整个值</a></h4>
<p>We’ve used the underscore as a wildcard pattern that will match any value but
not bind to the value. This is especially useful as the last arm in a <code>match</code>
expression, but we can also use it in any pattern, including function
parameters, as shown in Listing 19-17.</p>
<p>下划线用作通配符模式，可匹配任意值但不绑定值。这在 <code>match</code> 表达式的最后一个分支中尤其有用，但也<span class="highlight">[note]适用于任意模式，包括函数参数</span>，如示例19-17所示。</p>
<figure class="listing" id="listing-19-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-17">Listing 19-17</a>: Using <code>_</code> in a function signature 在函数签名中使用 `_</figcaption>
</figure>
<p>This code will completely ignore the value <code>3</code> passed as the first argument,
and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>此代码将完全忽略作为第一个参数传递的值 <code>3</code>，并打印 <code>This code only uses the y parameter: 4</code>。</p>
<p>In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in cases when, for example,
you’re implementing a trait when you need a certain type signature but the
function body in your implementation doesn’t need one of the parameters. You
then avoid getting a compiler warning about unused function parameters, as you
would if you used a name instead.</p>
<p>多数情况下不再需要特定函数参数时，应更改签名以排除未用参数。忽略函数参数在特定场景下特别有用，例如实现特征时需要特定类型签名，但实现中的函数体不需要某个参数。这样可避免编译器关于未用函数参数的警告（若使用名称则会产生警告）。</p>
<h4 id="parts-of-a-value-with-a-nested-_-用嵌套-_-忽略部分值"><a class="header" href="#parts-of-a-value-with-a-nested-_-用嵌套-_-忽略部分值">Parts of a Value with a Nested <code>_</code> 用嵌套 <code>_</code> 忽略部分值</a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 19-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.</p>
<p><span class="highlight">[note]也可在其他模式内使用 <code>_</code> 以仅忽略值的部分内容</span>。例如当仅需测试值的部分内容，但在对应代码中不使用其他部分时。示例19-18展示了管理设置值的代码。业务要求是用户不应覆盖设置的现有自定义值，但可取消设置并在当前未设置时赋值。</p>
<figure class="listing" id="listing-19-18">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-18">Listing 19-18</a>: Using an underscore within patterns that match <code>Some</code> variants when we don’t need to use the value inside the <code>Some</code> 在匹配 <code>Some</code> 变体的模式中使用下划线，而无需使用 <code>Some</code> 内部的值</figcaption>
</figure>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use
the values inside either <code>Some</code> variant, but we do need to test for the case
when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that
case, we print the reason for not changing <code>setting_value</code>, and it doesn’t get
changed.</p>
<p>此代码将打印 <code>Can't overwrite an existing customized value</code>，然后打印 <code>setting is Some(5)</code>。第一个匹配分支中，无需匹配或使用任一 <code>Some</code> 变体内部的值，但需测试 <code>setting_value</code> 和 <code>new_setting_value</code> 同为 <code>Some</code> 变体的情况。此时打印不更改 <code>setting_value</code> 的原因，且其值不变。</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> is <code>None</code>)
expressed by the <code>_</code> pattern in the second arm, we want to allow
<code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>其他所有情况（即 <code>setting_value</code> 或 <code>new_setting_value</code> 为 <code>None</code>）由第二个分支的 <code>_</code> 模式表示，此时允许 <code>new_setting_value</code> 成为 <code>setting_value</code>。</p>
<p>We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 19-19 shows an example of ignoring the second and
fourth values in a tuple of five items.</p>
<p>也可在单个模式中多处使用下划线以忽略特定值。示例19-19展示了忽略五元素元组中第二和第四个值的例子。</p>
<figure class="listing" id="listing-19-19">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-19">Listing 19-19</a>: Ignoring multiple parts of a tuple 忽略元组的多个部分</figcaption>
</figure>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values <code>4</code> and <code>16</code> will
be ignored.</p>
<p>此代码将打印 <code>Some numbers: 2, 8, 32</code>，且值 <code>4</code> 和 <code>16</code> 将被忽略。</p>
<h4 id="an-unused-variable-by-starting-its-name-with-_-以-_-开头的名称忽略未用变量"><a class="header" href="#an-unused-variable-by-starting-its-name-with-_-以-_-开头的名称忽略未用变量">An Unused Variable by Starting Its Name with <code>_</code> 以 <code>_</code> 开头的名称忽略未用变量</a></h4>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because an unused variable could be a bug. However, sometimes it’s
useful to be able to create a variable you won’t use yet, such as when you’re
prototyping or just starting a project. In this situation, you can tell Rust
not to warn you about the unused variable by starting the name of the variable
with an underscore. In Listing 19-20, we create two unused variables, but when
we compile this code, we should only get a warning about one of them.</p>
<p>若创建变量但未使用，Rust 通常会警告，因为未用变量可能是错误。但有时能创建尚未使用的变量很有用（例如原型设计或项目启动时）。此时可在变量名前加下划线告知 Rust 勿警告未用变量。示例19-20创建了两个未用变量，但编译代码时应仅获关于其中一个的警告。</p>
<figure class="listing" id="listing-19-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-20">Listing 19-20</a>: Starting a variable name with an underscore to avoid getting unused variable warnings 以下划线开头的变量名避免未用变量警告</figcaption>
</figure>
<p>Here, we get a warning about not using the variable <code>y</code>, but we don’t get a
warning about not using <code>_x</code>.</p>
<p>此处收到未用变量 <code>y</code> 的警告，但未收到关于 <code>_x</code> 的警告。</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. The syntax <code>_x</code> still binds the value to the
variable, whereas <code>_</code> doesn’t bind at all. To show a case where this
distinction matters, Listing 19-21 will provide us with an error.</p>
<p>注意仅用 <code>_</code> 与以下划线开头的名称有细微区别。<span class="highlight">[note]语法 <code>_x</code> 仍将值绑定到变量，而 <code>_</code> 完全不绑定</span>。为说明此区别的重要性，示例19-21将给出错误。</p>
<figure class="listing" id="listing-19-21">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-21">Listing 19-21</a>: An unused variable starting with an underscore still binds the value, which might take ownership of the value. 以下划线开头的未用变量仍绑定值，可能获取值的所有权。</figcaption>
</figure>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 19-22 will compile without any errors
because <code>s</code> doesn’t get moved into <code>_</code>.</p>
<p>将收到错误，因为 <code>s</code> 值仍会移入 <code>_s</code>，导致无法再次使用 <code>s</code>。但单独使用下划线不会绑定值。示例19-22无错误编译，因为 <code>s</code> 未移入 <code>_</code>。</p>
<figure class="listing" id="listing-19-22">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-22">Listing 19-22</a>: Using an underscore does not bind the value. 使用下划线不绑定值。</figcaption>
</figure>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn’t moved.</p>
<p>此代码正常运行，因为从未将 <code>s</code> 绑定到任何内容，故其未被移动。</p>
<h4 id="remaining-parts-of-a-value-with--用--忽略值的剩余部分"><a class="header" href="#remaining-parts-of-a-value-with--用--忽略值的剩余部分">Remaining Parts of a Value with <code>..</code> 用 <code>..</code> 忽略值的剩余部分</a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use specific
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 19-23, we have a
<code>Point</code> struct that holds a coordinate in three-dimensional space. In the
<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore
the values in the <code>y</code> and <code>z</code> fields.</p>
<p>对于多部分的值，可用 <code>..</code> 语法使用特定部分并忽略其余部分，避免为每个忽略值单独列出下划线。<code>..</code> 模式忽略值中未在模式其余部分显式匹配的任何部分。示例19-23的 <code>Point</code> 结构体保存三维空间坐标。<code>match</code> 表达式中，希望仅操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段。</p>
<figure class="listing" id="listing-19-23">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-23">Listing 19-23</a>: Ignoring all fields of a <code>Point</code> except for <code>x</code> by using <code>..</code> 使用 <code>..</code> 忽略 <code>Point</code> 中除 <code>x</code> 外的所有字段使用 <code>..</code> 忽略 <code>Point</code> 中除 <code>x</code> 外的所有字段</figcaption>
</figure>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker
than having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.</p>
<p><span class="highlight">[note]<span class="highlight">[note]列出 <code>x</code> 值后仅包含 <code>..</code> 模式。这比单独列出 <code>y: _</code> 和 <code>z: _</code> 更便捷</span>，尤其当处理多字段结构体且仅一两个字段相关时。</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 19-24
shows how to use <code>..</code> with a tuple.</p>
<p><code>..</code> 语法将扩展为所需数量的值。示例19-24展示如何<span class="highlight">[note]在元组中使用 <code>..</code></span>。</p>
<figure class="listing" id="listing-19-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-24">Listing 19-24</a>: Matching only the first and last values in a tuple and ignoring all other values 仅匹配元组的首尾值并忽略所有其他值</figcaption>
</figure>
<p>In this code, the first and last values are matched with <code>first</code> and <code>last</code>.
The <code>..</code> will match and ignore everything in the middle.</p>
<p>此代码中，首尾值分别与 <code>first</code> 和 <code>last</code> 匹配。<code>..</code> 将匹配并忽略中间的所有值。</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 19-25 shows an example of using <code>..</code> ambiguously, so it will not
compile.</p>
<p>但使用 <code>..</code> 必须无歧义。若无法明确哪些值用于匹配、哪些应忽略，Rust 将报错。示例19-25展示了歧义使用 <code>..</code> 的情况，因此无法编译。</p>
<figure class="listing" id="listing-19-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-25">Listing 19-25</a>: An attempt to use <code>..</code> in an ambiguous way 尝试以歧义方式使用 <code>..</code></figcaption>
</figure>
<p>When we compile this example, we get this error:</p>
<p>编译此示例时将报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code> and then how many further values to
ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind
<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore
<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.
The variable name <code>second</code> doesn’t mean anything special to Rust, so we get a
compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<p>Rust 无法确定在匹配 <code>second</code> 值前需忽略元组中的多少值，以及之后需忽略多少值。此代码可能表示：忽略 <code>2</code>，将 <code>second</code> 绑定到 <code>4</code>，然后忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或忽略 <code>2</code> 和 <code>4</code>，将 <code>second</code> 绑定到 <code>8</code>，然后忽略 <code>16</code> 和 <code>32</code>；等等。变量名 <code>second</code> 对 Rust 无特殊含义，因此因 <code>..</code> 在两处歧义使用导致编译器错误。</p>
<h3 id="extra-conditionals-with-match-guards-匹配守卫的额外条件"><a class="header" href="#extra-conditionals-with-match-guards-匹配守卫的额外条件">Extra Conditionals with Match Guards 匹配守卫的额外条件</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in
a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are
useful for expressing more complex ideas than a pattern alone allows. Note,
however, that they are only available in <code>match</code> expressions, not <code>if let</code> or
<code>while let</code> expressions.</p>
<p><span class="highlight">[note]<em>匹配守卫</em> 是 <code>match</code> 分支中模式后的额外 <code>if</code> 条件</span>，也必须匹配才能选择该分支。匹配守卫用于表达比单独模式更复杂的逻辑。但注意其仅在 <code>match</code> 表达式中可用，不适用于 <code>if let</code> 或 <code>while let</code> 表达式。</p>
<p>The condition can use variables created in the pattern. Listing 19-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x % 2 == 0</code> (which will be <code>true</code> if the number is even).</p>
<p>条件可使用模式中创建的变量。示例19-26的 <code>match</code> 中，第一个分支有模式 <code>Some(x)</code> 和匹配守卫 <code>if x % 2 == 0</code>（当数字为偶数时为真）。</p>
<figure class="listing" id="listing-19-26">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-26">Listing 19-26</a>: Adding a match guard to a pattern 为模式添加匹配守卫</figcaption>
</figure>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches because <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to
0, and because it is, the first arm is selected.</p>
<p>此例将打印 <code>The number 4 is even</code>。当 <code>num</code> 与第一个分支的模式比较时，因 <code>Some(4)</code> 匹配 <code>Some(x)</code> 而匹配。随后匹配守卫检查 <code>x</code> 除以2的余数是否为0，结果为真，因此选择第一个分支。</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would
have been <code>false</code> because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>若 <code>num</code> 为 <code>Some(5)</code>，第一个分支的匹配守卫为假（因5除以2余1不为0）。Rust 将跳至第二个分支（无匹配守卫，故匹配任意 <code>Some</code> 变体）。</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn’t try to check for
exhaustiveness when match guard expressions are involved.</p>
<p>无法在模式内表达 <code>if x % 2 == 0</code> 条件，因此匹配守卫提供了表达此逻辑的能力。但额外表达力的代价是：涉及匹配守卫表达式时，编译器不会检查穷尽性。</p>
<p>In Listing 19-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that we created a new variable inside the
pattern in the <code>match</code> expression instead of using the variable outside the
<code>match</code>. That new variable meant we couldn’t test against the value of the
outer variable. Listing 19-27 shows how we can use a match guard to fix this
problem.</p>
<p>示例19-11中提到可用匹配守卫解决模式遮蔽问题。回忆中在 <code>match</code> 表达式的模式内创建了新变量，而非使用外部变量。新变量导致无法测试外部变量的值。示例19-27展示了如何用匹配守卫修复此问题。</p>
<figure class="listing" id="listing-19-27">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-27">Listing 19-27</a>: Using a match guard to test for equality with an outer variable 使用匹配守卫测试与外部变量的相等性</figcaption>
</figure>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>此代码现在将打印 <code>Default case, x = Some(5)</code>。第二个匹配分支的模式未引入遮蔽外部 <code>y</code> 的新变量 <code>y</code>，意味着可在匹配守卫中使用外部 <code>y</code>。未将模式指定为 <code>Some(y)</code>（会遮蔽外部 <code>y</code>），而是指定 <code>Some(n)</code>。这会创建不遮蔽任何内容的新变量 <code>n</code>（因外部无 <code>n</code> 变量）。</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce new
variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new <code>y</code> shadowing it, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>匹配守卫 <code>if n == y</code> 非模式，故不引入新变量。此处的 <code>y</code> 是外部 <code>y</code> 而非新遮蔽的 <code>y</code>，可通过比较 <code>n</code> 和 <code>y</code> 来查找与外部 <code>y</code> 同值的值。</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
19-28 shows the precedence when combining a pattern that uses <code>|</code> with a match
guard. The important part of this example is that the <code>if y</code> match guard
applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only
applies to <code>6</code>.</p>
<p>也可在匹配守卫中用 <em>或</em> 运算符 <code>|</code> 指定多模式；匹配守卫条件将应用于所有模式。示例19-28展示了结合使用带 <code>|</code> 的模式与匹配守卫时的优先级。此例重点是 <code>if y</code> 匹配守卫应用于 <code>4</code>、<code>5</code> 和 <code>6</code>，尽管看似仅应用于 <code>6</code>。</p>
<figure class="listing" id="listing-19-28">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-28">Listing 19-28</a>: Combining multiple patterns with a match guard 结合匹配守卫的多模式</figcaption>
</figure>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is <code>false</code>, so the first arm is not chosen. The code moves on to the second
arm, which does match, and this program prints <code>no</code>. The reason is that the
<code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not just to the last
value <code>6</code>. In other words, the precedence of a match guard in relation to a
pattern behaves like this:</p>
<p>匹配条件要求仅当 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> 且 <code>y</code> 为 <code>true</code> 时匹配分支。运行此代码时，第一个分支的模式因 <code>x</code> 为 <code>4</code> 而匹配，但匹配守卫 <code>if y</code> 为假，故不选第一分支。代码跳至第二分支（匹配），程序打印 <code>no</code>。原因是 <code>if</code> 条件应用于整个模式 <code>4 | 5 | 6</code>，而非仅最后一个值 <code>6</code>。换言之，匹配守卫相对于模式的优先级行为如下：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<p>而非：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<p>运行代码后，优先级行为显而易见：若匹配守卫仅应用于 <code>|</code> 运算符指定的值列表中的末值，则分支会匹配且程序将打印 <code>yes</code>。</p>
<h3 id="-bindings--绑定"><a class="header" href="#-bindings--绑定"><code>@</code> Bindings <code>@</code> 绑定</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same
time we’re testing that value for a pattern match. In Listing 19-29, we want to
test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also
want to bind the value to the variable <code>id</code> so we can use it in the code
associated with the arm.</p>
<p><span class="highlight">[note]<em>at</em> 运算符 <code>@</code> 可在测试值匹配模式的同时创建保存该值的变量。</span>示例19-29中，希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否在范围 <code>3..=7</code> 内。同时也希望将值绑定到变量 <code>id</code> 以在分支关联代码中使用。</p>
<figure class="listing" id="listing-19-29">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id @ 3..=7 } =&gt; {
            println!("Found an id in range: {id}")
        }
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch19-03-pattern-syntax.html#listing-19-29">Listing 19-29</a>: Using <code>@</code> to bind to a value in a pattern while also testing it 使用 <code>@</code> 在测试同时绑定模式中的值</figcaption>
</figure>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id @</code> before
the range <code>3..=7</code>, we’re capturing whatever value matched the range in a
variable named <code>id</code> while also testing that the value matched the range pattern.</p>
<p>此例将打印 <code>Found an id in range: 5</code>。通过在范围 <code>3..=7</code> 前指定 <code>id @</code>，可在测试值匹配范围模式的同时，将匹配该范围的值捕获到名为 <code>id</code> 的变量中。</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the <code>id</code> field, because we haven’t saved the
<code>id</code> value in a variable.</p>
<p><span class="highlight">[note]第二个分支的模式中仅指定了范围，分支关联代码无包含 <code>id</code> 字段实际值的变量。</span><code>id</code> 字段的值可能为10、11或12，但该分支的代码不知道具体值。模式代码无法使用 <code>id</code> 字段的值，因为未将 <code>id</code> 值存入变量。</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code>. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: any value would match this pattern.</p>
<p>最后一个分支中指定了无范围的变量，分支代码可用变量 <code>id</code> 中的值。原因是使用了结构体字段简写语法。但此分支未对 <code>id</code> 字段值应用任何测试（如前两个分支）：任意值均匹配此模式。</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<p>使用 <code>@</code> 可在单个模式中测试值并保存到变量。</p>
<h2 id="summary-总结-18"><a class="header" href="#summary-总结-18">Summary 总结</a></h2>
<p>Rust’s patterns are very useful in distinguishing between different kinds of
data. When used in <code>match</code> expressions, Rust ensures your patterns cover every
possible value, or your program won’t compile. Patterns in <code>let</code> statements and
function parameters make those constructs more useful, enabling the
destructuring of values into smaller parts and assigning those parts to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Rust 的模式在区分不同类型数据时非常有用。在 <code>match</code> 表达式中使用时，Rust 确保模式覆盖所有可能值，否则程序无法编译。<code>let</code> 语句和函数参数中的模式增强了这些结构的功能，支持将值解构为更小部分并分配给变量。可根据需求创建简单或复杂的模式。</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.</p>
<p>接下来，本书倒数第二章将探讨 Rust 各类特性的高级内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features-高级特性"><a class="header" href="#advanced-features-高级特性">Advanced Features 高级特性</a></h1>
<p>By now, you’ve learned the most commonly used parts of the Rust programming
language. Before we do one more project, in Chapter 21, we’ll look at a few
aspects of the language you might run into every once in a while, but may not
use every day. You can use this chapter as a reference for when you encounter
any unknowns. The features covered here are useful in very specific situations.
Although you might not reach for them often, we want to make sure you have a
grasp of all the features Rust has to offer.</p>
<p>至此，你已经学习了 Rust 编程语言最常用的部分。在开始第 21 章的项目之前，我们将探讨一些你可能偶尔会遇到但不一定每天使用的语言特性。当你遇到任何未知内容时，可以将本章作为参考。这里涵盖的特性在特定场景下非常有用。虽然你可能不常使用它们，但我们希望确保你全面掌握 Rust 提供的所有功能。</p>
<p>In this chapter, we’ll cover:</p>
<p>本章将涵盖：</p>
<ul>
<li>Unsafe Rust: how to opt out of some of Rust’s guarantees and take
responsibility for manually upholding those guarantees</li>
<li>Advanced traits: associated types, default type parameters, fully qualified
syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced types: more about the newtype pattern, type aliases, the never type,
and dynamically sized types</li>
<li>Advanced functions and closures: function pointers and returning closures</li>
<li>Macros: ways to define code that defines more code at compile time</li>
</ul>
<!-- -->
<ul>
<li>不安全 Rust：如何退出部分 Rust 的保证，并手动维护这些保证</li>
<li>高级 trait：关联类型、默认类型参数、完全限定语法、超 trait 以及与 trait 相关的新类型模式</li>
<li>高级类型：深入新类型模式、类型别名、Never 类型和动态大小类型</li>
<li>高级函数与闭包：函数指针和返回闭包</li>
<li>宏：在编译时定义生成更多代码的方式</li>
</ul>
<p>It’s a panoply of Rust features with something for everyone! Let’s dive in!</p>
<p>这是 Rust 特性的大全，总有一款适合你！让我们开始探索吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust-不安全-rust"><a class="header" href="#unsafe-rust-不安全-rust">Unsafe Rust 不安全 Rust</a></h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>目前讨论的所有代码都在编译时强制执行 Rust 的内存安全保证。然而，Rust 内部隐藏着另一种不强制执行这些内存安全保证的语言：它被称为<strong>不安全 Rust</strong>，其行为与常规 Rust 相同，但赋予我们额外的超能力。</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs than to accept some invalid
programs. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have
enough information to be confident, it will reject the code. In these cases,
you can use unsafe code to tell the compiler, “Trust me, I know what I’m
doing.” Be warned, however, that you use unsafe Rust at your own risk: if you
use unsafe code incorrectly, problems can occur due to memory unsafety, such as
null pointer dereferencing.</p>
<p>不安全 Rust 的存在是因为静态分析本质上是保守的。当编译器尝试判断代码是否遵守保证时，拒绝某些有效程序比接受无效程序更安全。虽然代码<strong>可能</strong>没问题，但如果 Rust 编译器没有足够信息来确信，它会拒绝代码。此时，你可以使用不安全代码告诉编译器：“请相信我，我知道自己在做什么。“但请注意，使用不安全 Rust 需自行承担风险：如果不正确使用不安全代码，可能导致内存安全问题，例如空指针解引用。</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<p>Rust 存在不安全版本的另一个原因是底层计算机硬件本身就不安全。如果 Rust 不允许不安全操作，某些任务将无法完成。Rust 需要支持底层系统编程，例如直接与操作系统交互甚至编写自己的操作系统。处理底层系统编程是该语言的目标之一。让我们探索不安全 Rust 的功能及其使用方法。</p>
<h3 id="unsafe-superpowers-不安全超能力"><a class="header" href="#unsafe-superpowers-不安全超能力">Unsafe Superpowers 不安全超能力</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust that you
can’t in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers
include the ability to:</p>
<p>要切换到不安全 Rust，需使用 <code>unsafe</code> 关键字并开启包含不安全代码的新代码块。在不安全 Rust 中可执行五项安全 Rust 中不允许的操作，称为<strong>不安全超能力</strong>：</p>
<ol>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ol>
<!-- -->
<ol>
<li>解引用原始指针</li>
<li>调用不安全函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问联合体（union）的字段</li>
</ol>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any of Rust’s other safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside an unsafe block.</p>
<p>需理解 <code>unsafe</code> 不会关闭借用检查器或禁用 Rust 的其他安全检查：在不安全代码中使用引用时仍会检查。<code>unsafe</code> 关键字仅提供访问这五项特性的权限，编译器不会检查它们的内存安全性。在不安全块内部仍会获得一定程度的安全性。</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>此外，<code>unsafe</code> 并不意味着块内代码必然危险或肯定存在内存安全问题：其意图是作为程序员，你应确保 <code>unsafe</code> 块内的代码会以有效方式访问内存。</p>
<p>People are fallible and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with <code>unsafe</code>, you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>人非圣贤孰能无过，但通过要求这五项不安全操作位于 <code>unsafe</code> 标注的块内，可知任何与内存安全相关的错误必定在 <code>unsafe</code> 块中。保持 <code>unsafe</code> 块精简；在调查内存错误时会感激这种做法。</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose such code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>为最大限度隔离不安全代码，最佳实践是将其封装在安全抽象中并提供安全 API，本章稍后探讨不安全函数和方法时将讨论这点。标准库的部分内容就是基于已审计的不安全代码实现的安全抽象。将不安全代码包装在安全抽象中可防止 <code>unsafe</code> 用法泄漏到你或用户可能希望使用该功能的所有地方，因为使用安全抽象本身是安全的。</p>
<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<p>现在依次探讨这五项不安全超能力，同时了解为不安全代码提供安全接口的抽象实现。</p>
<h3 id="dereferencing-a-raw-pointer-解引用原始指针"><a class="header" href="#dereferencing-a-raw-pointer-解引用原始指针">Dereferencing a Raw Pointer 解引用原始指针</a></h3>
<p>In Chapter 4, in “Dangling References”, we
mentioned that the compiler ensures references are always valid. Unsafe Rust has
two new types called <em>raw pointers</em> that are similar to references. As with
references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s
part of the type name. In the context of raw pointers, <em>immutable</em> means that
the pointer can’t be directly assigned to after being dereferenced.</p>
<p>在第 4 章的“悬垂引用“中，我们提到编译器确保引用始终有效。不安全 Rust 有两种称为<strong>原始指针</strong>的新类型，类似于引用。原始指针可以是不可变或可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。星号不是解引用运算符，而是类型名的一部分。在原始指针语境中，“不可变“表示指针解引用后不能被直接赋值。</p>
<p>Different from references and smart pointers, raw pointers:</p>
<p>原始指针与引用和智能指针的区别在于：</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<!-- -->
<ul>
<li>允许忽略借用规则（可同时存在指向同一位置的不可变和可变指针或多个可变指针）</li>
<li>不保证指向有效内存</li>
<li>允许为空</li>
<li>不实现任何自动清理机制</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>通过退出 Rust 的强制保证，可放弃安全性以换取更高性能，或与不适用 Rust 保证的其他语言/硬件交互。</p>
<p>Listing 20-1 shows how to create an immutable and a mutable raw pointer.</p>
<p>示例 20-1 展示如何创建不可变和可变原始指针。</p>
<figure class="listing" id="listing-20-1">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-1">Listing 20-1</a>: Creating raw pointers with the raw borrow operators 使用原始借用运算符创建原始指针</figcaption>
</figure>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>注意此代码未使用 <code>unsafe</code> 关键字。我们可在安全代码中创建原始指针，但稍后会看到，不能在 <code>unsafe</code> 块外解引用原始指针。</p>
<p>We’ve created raw pointers by using the raw borrow operators: <code>&amp;raw const num</code>
creates a <code>*const i32</code> immutable raw pointer, and <code>&amp;raw mut num</code> creates a <code>*mut i32</code> mutable raw pointer. Because we created them directly from a local
variable, we know these particular raw pointers are valid, but we can’t make
that assumption about just any raw pointer.</p>
<p>我们使用原始借用运算符创建原始指针：<code>&amp;raw const num</code> 创建 <code>*const i32</code> 不可变原始指针，<code>&amp;raw mut num</code> 创建 <code>*mut i32</code> 可变原始指针。由于直接从局部变量创建，可知这些特定原始指针有效，但不能假设任意原始指针均有效。</p>
<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be
so certain of, using the keyword <code>as</code> to cast a value instead of using the raw
borrow operator. Listing 20-2 shows how to create a raw pointer to an arbitrary
location in memory. Trying to use arbitrary memory is undefined: there might be
data at that address or there might not, the compiler might optimize the code
so there is no memory access, or the program might terminate with a
segmentation fault. Usually, there is no good reason to write code like this,
especially in cases where you can use a raw borrow operator instead, but it is
possible.</p>
<p>为演示这点，接下来使用 <code>as</code> 关键字转换值（而非原始借用运算符）创建有效性不确定的原始指针。示例 20-2 展示如何创建指向内存任意位置的原始指针。尝试使用任意内存是未定义行为：该地址可能有数据也可能没有，编译器可能优化代码导致无内存访问，或程序可能以段错误终止。通常没有充分理由编写此类代码（尤其当可使用原始借用运算符时），但技术上可行。</p>
<figure class="listing" id="listing-20-2">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-2">Listing 20-2</a>: Creating a raw pointer to an arbitrary memory address 创建指向任意内存地址的原始指针</figcaption>
</figure>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 20-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<p>回忆可知，在安全代码中可创建原始指针，但不能<strong>解引用</strong>原始指针来读取指向的数据。示例 20-3 在需要 <code>unsafe</code> 块的原始指针上使用解引用运算符 <code>*</code>。</p>
<figure class="listing" id="listing-20-3">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-3">Listing 20-3</a>: Dereferencing raw pointers within an <code>unsafe</code> block 在 <code>unsafe</code> 块中解引用原始指针</figcaption>
</figure>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>创建指针无害；仅当尝试访问其指向的值时才可能处理无效值。</p>
<p>Note also that in Listings 20-1 and 20-3, we created <code>*const i32</code> and <code>*mut i32</code> raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>另请注意，在示例 20-1 和 20-3 中，我们创建了指向同一内存位置（存储 <code>num</code> 的位置）的 <code>*const i32</code> 和 <code>*mut i32</code> 原始指针。若尝试创建 <code>num</code> 的不可变和可变引用，代码将无法编译（因 Rust 所有权规则不允许同时存在可变引用和不可变引用）。使用原始指针时，可创建指向同一位置的可变和不可变指针并通过可变指针修改数据，可能导致数据竞争。务必谨慎！</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section.
Another case is when building up safe abstractions that the borrow checker
doesn’t understand. We’ll introduce unsafe functions and then look at an
example of a safe abstraction that uses unsafe code.</p>
<p>既然存在这些危险，为何还要使用原始指针？主要场景是与 C 代码交互（下节将介绍）。另一场景是构建借用检查器无法理解的安全抽象。我们将先介绍不安全函数，再分析使用不安全代码的安全抽象示例。</p>
<h3 id="calling-an-unsafe-function-or-method-调用不安全函数或方法"><a class="header" href="#calling-an-unsafe-function-or-method-调用不安全函数或方法">Calling an Unsafe Function or Method 调用不安全函数或方法</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling
unsafe functions. Unsafe functions and methods look exactly like regular
functions and methods, but they have an extra <code>unsafe</code> before the rest of the
definition. The <code>unsafe</code> keyword in this context indicates the function has
requirements we need to uphold when we call this function, because Rust can’t
guarantee we’ve met these requirements. By calling an unsafe function within an
<code>unsafe</code> block, we’re saying that we’ve read this function’s documentation and
we take responsibility for upholding the function’s contracts.</p>
<p>在 <code>unsafe</code> 块中可执行的第二类操作是调用不安全函数。不安全函数和方法外观与常规函数/方法相同，但在定义其余部分前多一个 <code>unsafe</code>。此处的 <code>unsafe</code> 关键字表示调用该函数时有需要维护的条件（因 Rust 无法保证我们满足这些条件）。通过在 <code>unsafe</code> 块内调用不安全函数，表明我们已阅读其文档并承诺履行函数约定。</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<p>以下是一个名为 <code>dangerous</code> 的不安全函数（其函数体不执行任何操作）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<p>必须在单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。若尝试无 <code>unsafe</code> 块调用，将报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>With the <code>unsafe</code> block, we’re asserting to Rust that we’ve read the function’s
documentation, we understand how to use it properly, and we’ve verified that
we’re fulfilling the contract of the function.</p>
<p>通过 <code>unsafe</code> 块，我们向 Rust 声明：已阅读函数文档，理解正确用法，并已验证满足函数约定。</p>
<p>To perform unsafe operations in the body of an <code>unsafe</code> function, you still
need to use an <code>unsafe</code> block, just as within a regular function, and the
compiler will warn you if you forget. This helps us keep <code>unsafe</code> blocks as
small as possible, as unsafe operations may not be needed across the whole
function body.</p>
<p>在 <code>unsafe</code> 函数体中执行不安全操作时，仍需 <code>unsafe</code> 块（与常规函数相同）。若忘记，编译器将警告。这有助于将 <code>unsafe</code> 块保持最小化（因可能不需要在整个函数体执行不安全操作）。</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code-构建不安全代码的安全抽象"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code-构建不安全代码的安全抽象">Creating a Safe Abstraction over Unsafe Code 构建不安全代码的安全抽象</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study the <code>split_at_mut</code> function
from the standard library, which requires some unsafe code. We’ll explore how
we might implement it. This safe method is defined on mutable slices: it takes
one slice and makes it two by splitting the slice at the index given as an
argument. Listing 20-4 shows how to use <code>split_at_mut</code>.</p>
<p>仅因函数包含不安全代码，并不意味着需将整个函数标记为不安全。实际上，将不安全代码包装在安全函数中是常见抽象。例如，我们研究标准库中的 <code>split_at_mut</code> 函数（需要不安全代码）。我们将探索如何实现它。此安全方法定义在可变切片上：获取一个切片并通过参数给定索引将其拆分为两个切片。示例 20-4 展示如何使用 <code>split_at_mut</code>。</p>
<figure class="listing" id="listing-20-4">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-4">Listing 20-4</a>: Using the safe <code>split_at_mut</code> function 使用安全的 <code>split_at_mut</code> 函数</figcaption>
</figure>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 20-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<p>仅使用安全 Rust 无法实现此函数。尝试实现可能如示例 20-5（无法编译）。为简化，我们将 <code>split_at_mut</code> 实现为函数而非方法，且仅针对 <code>i32</code> 切片而非泛型 <code>T</code>。</p>
<figure class="listing" id="listing-20-5">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-5">Listing 20-5</a>: An attempted implementation of <code>split_at_mut</code> using only safe Rust 尝试仅用安全 Rust 实现 <code>split_at_mut</code></figcaption>
</figure>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>此函数首先获取切片总长度，再断言参数索引在切片内（检查是否小于等于长度）。该断言意味着若传入大于长度的索引来拆分切片，函数将在尝试使用索引前 panic。</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>然后在元组中返回两个可变切片：一个从原始切片起始到 <code>mid</code> 索引，另一个从 <code>mid</code> 到切片末尾。</p>
<p>When we try to compile the code in Listing 20-5, we’ll get an error:</p>
<p>尝试编译示例 20-5 的代码时将报错：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Rust 的借用检查器无法理解我们借用了切片的不同部分；它只知道我们两次借用同一切片。借用切片不同部分本质上是安全的（因两个切片不重叠），但 Rust 不够智能而无法识别这点。当确信代码正确而 Rust 无法识别时，就该使用不安全代码。</p>
<p>Listing 20-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<p>示例 20-6 展示如何使用 <code>unsafe</code> 块、原始指针及不安全函数调用来实现 <code>split_at_mut</code>。</p>
<figure class="listing" id="listing-20-6">
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-6">Listing 20-6</a>: Using unsafe code in the implementation of the <code>split_at_mut</code> function 在 <code>split_at_mut</code> 函数实现中使用不安全代码</figcaption>
</figure>
<p>Recall from “The Slice Type” in Chapter 4 that
a slice is a pointer to some data and the length of the slice. We use the <code>len</code>
method to get the length of a slice and the <code>as_mut_ptr</code> method to access the
raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code>
values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve
stored in the variable <code>ptr</code>.</p>
<p>回忆第 4 章“切片类型“，切片是指向数据及其长度的指针。我们使用 <code>len</code> 方法获取切片长度，使用 <code>as_mut_ptr</code> 方法访问切片的原始指针。本例中，因有 <code>i32</code> 值的可变切片，<code>as_mut_ptr</code> 返回类型为 <code>*mut i32</code> 的原始指针（存储在变量 <code>ptr</code> 中）。</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>保留 <code>mid</code> 索引在切片内的断言。然后进入不安全代码：<code>slice::from_raw_parts_mut</code> 函数接收原始指针和长度来创建切片。我们使用它创建从 <code>ptr</code> 开始且长为 <code>mid</code> 项的切片。接着在 <code>ptr</code> 上调用 <code>add</code> 方法（以 <code>mid</code> 为参数）获取从 <code>mid</code> 开始的原始指针，并使用该指针及 <code>mid</code> 之后剩余项数作为长度创建切片。</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>add</code> method on raw
pointers is also unsafe because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>函数 <code>slice::from_raw_parts_mut</code> 不安全（因接收原始指针且必须信任其有效）。原始指针的 <code>add</code> 方法也不安全（因必须信任偏移位置也是有效指针）。因此，必须将调用 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 的代码放入 <code>unsafe</code> 块。通过查看代码并添加 <code>mid</code> 必须小于等于 <code>len</code> 的断言，可知 <code>unsafe</code> 块内使用的所有原始指针均指向切片内数据的有效指针。这是可接受且恰当的 <code>unsafe</code> 用法。</p>
<p>Note that we don’t need to mark the resultant <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>注意，无需将结果函数 <code>split_at_mut</code> 标记为 <code>unsafe</code>，且可从安全 Rust 调用此函数。我们通过使用 <code>unsafe</code> 代码的安全实现，为不安全代码创建了安全抽象（因仅根据函数可访问的数据创建有效指针）。</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 20-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<p>相反，示例 20-7 使用 <code>slice::from_raw_parts_mut</code> 很可能在使用切片时崩溃。此代码获取任意内存位置并创建长 10,000 项的切片。</p>
<figure class="listing" id="listing-20-7">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-7">Listing 20-7</a>: Creating a slice from an arbitrary memory location 从任意内存位置创建切片</figcaption>
</figure>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>values</code> as though it’s a valid slice results in undefined behavior.</p>
<p>我们不拥有此任意位置的内存，且无法保证此代码创建的切片包含有效的 <code>i32</code> 值。尝试像使用有效切片那样使用 <code>values</code> 将导致未定义行为。</p>
<h4 id="using-extern-functions-to-call-external-code-使用-extern-函数调用外部代码"><a class="header" href="#using-extern-functions-to-call-external-code-使用-extern-函数调用外部代码">Using <code>extern</code> Functions to Call External Code 使用 <code>extern</code> 函数调用外部代码</a></h4>
<p>Sometimes your Rust code might need to interact with code written in another
language. For this, Rust has the keyword <code>extern</code> that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>, which is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>有时 Rust 代码可能需要与其他语言编写的代码交互。为此，Rust 提供 <code>extern</code> 关键字来简化<strong>外部函数接口（FFI）</strong> 的创建和使用——FFI 是编程语言定义函数并允许不同（外部）编程语言调用这些函数的方式。</p>
<p>Listing 20-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
generally unsafe to call from Rust code, so <code>extern</code> blocks must also be marked
<code>unsafe</code>. The reason is that other languages don’t enforce Rust’s rules and
guarantees, and Rust can’t check them, so responsibility falls on the
programmer to ensure safety.</p>
<p>示例 20-8 演示如何与 C 标准库的 <code>abs</code> 函数集成。在 <code>extern</code> 块中声明的函数从 Rust 代码调用通常不安全，因此 <code>extern</code> 块也必须标记为 <code>unsafe</code>。原因在于其他语言不强制执行 Rust 的规则和保证，而 Rust 无法检查它们，因此确保安全的责任落在程序员身上。</p>
<figure class="listing" id="listing-20-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-8">Listing 20-8</a>: Declaring and calling an <code>extern</code> function defined in another language 声明并调用另一语言定义的 <code>extern</code> 函数</figcaption>
</figure>
<p>Within the <code>unsafe extern "C"</code> block, we list the names and signatures of
external functions from another language we want to call. The <code>"C"</code> part
defines which <em>application binary interface (ABI)</em> the external function uses:
the ABI defines how to call the function at the assembly level. The <code>"C"</code> ABI
is the most common and follows the C programming language’s ABI. Information
about all the ABIs Rust supports is available in the Rust Reference.</p>
<p>在 <code>unsafe extern "C"</code> 块中，我们列出要调用的另一语言的外部函数名称和签名。<code>"C"</code> 部分定义外部函数使用的<strong>应用程序二进制接口（ABI）</strong>：ABI 定义了汇编级别的函数调用方式。<code>"C"</code> ABI 最常见且遵循 C 编程语言的 ABI。Rust 支持的所有 ABI 信息见 Rust 参考手册。</p>
<p>Every item declared within an <code>unsafe extern</code> block is implicitly unsafe.
However, some FFI functions <em>are</em> safe to call. For example, the <code>abs</code> function
from C’s standard library does not have any memory safety considerations and we
know it can be called with any <code>i32</code>. In cases like this, we can use the <code>safe</code>
keyword to say that this specific function is safe to call even though it is in
an <code>unsafe extern</code> block. Once we make that change, calling it no longer
requires an <code>unsafe</code> block, as shown in Listing 20-9.</p>
<p>在 <code>unsafe extern</code> 块内声明的每个项都隐式不安全。但某些 FFI 函数<strong>是</strong>安全可调用的。例如，C 标准库的 <code>abs</code> 函数无任何内存安全考量，且我们知道可使用任意 <code>i32</code> 调用它。此类情况下，可用 <code>safe</code> 关键字标记该特定函数安全（即使位于 <code>unsafe extern</code> 块中）。修改后调用它不再需要 <code>unsafe</code> 块，如示例 20-9 所示。</p>
<figure class="listing" id="listing-20-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-9">Listing 20-9</a>: Explicitly marking a function as <code>safe</code> within an <code>unsafe extern</code> block and calling it safely 在 <code>unsafe extern</code> 块中显式标记函数为 <code>safe</code> 并安全调用</figcaption>
</figure>
<p>Marking a function as <code>safe</code> does not inherently make it safe! Instead, it is
like a promise you are making to Rust that it is safe. It is still your
responsibility to make sure that promise is kept!</p>
<p>将函数标记为 <code>safe</code> 并不天然使其安全！相反，这像是你向 Rust 承诺它是安全的。确保信守承诺仍是你的责任！</p>
<h4 id="calling-rust-functions-from-other-languages-从其他语言调用-rust-函数"><a class="header" href="#calling-rust-functions-from-other-languages-从其他语言调用-rust-函数">Calling Rust Functions from Other Languages 从其他语言调用 Rust 函数</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages to
call Rust functions. Instead of creating a whole <code>extern</code> block, we add the
<code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword for
the relevant function. We also need to add an <code>#[unsafe(no_mangle)]</code> annotation
to tell the Rust compiler not to mangle the name of this function. <em>Mangling</em>
is when a compiler changes the name we’ve given a function to a different name
that contains more information for other parts of the compilation process to
consume but is less human readable. Every programming language compiler mangles
names slightly differently, so for a Rust function to be nameable by other
languages, we must disable the Rust compiler’s name mangling. This is unsafe
because there might be name collisions across libraries without the built-in
mangling, so it is our responsibility to make sure the name we choose is safe
to export without mangling.</p>
<p>我们也可用 <code>extern</code> 创建允许其他语言调用 Rust 函数的接口。无需创建整个 <code>extern</code> 块，只需在相关函数的 <code>fn</code> 关键字前添加 <code>extern</code> 关键字并指定 ABI。还需添加 <code>#[unsafe(no_mangle)]</code> 注解告诉 Rust 编译器不要破坏此函数名称。<strong>名称破坏</strong>是编译器将函数名更改为包含更多信息（供编译过程其他部分使用）但可读性更低的名称。每种编程语言编译器破坏名称的方式略有不同，因此要使 Rust 函数可被其他语言调用，必须禁用 Rust 编译器的名称破坏。此操作不安全（因无内置破坏时库间可能存在名称冲突），因此确保所选名称可安全导出（无需破坏）是我们的责任。</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from C
code, after it’s compiled to a shared library and linked from C:</p>
<p>下例使 <code>call_from_c</code> 函数可从 C 代码访问（编译为共享库并从 C 链接后）：</p>
<pre><code>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</code></pre>
<p>This usage of <code>extern</code> requires <code>unsafe</code> only in the attribute, not on the
<code>extern</code> block.</p>
<p>此 <code>extern</code> 用法仅在属性中需要 <code>unsafe</code>，而非在 <code>extern</code> 块上。</p>
<h3 id="accessing-or-modifying-a-mutable-static-variable-访问或修改可变静态变量"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable-访问或修改可变静态变量">Accessing or Modifying a Mutable Static Variable 访问或修改可变静态变量</a></h3>
<p>In this book, we’ve not yet talked about global variables, which Rust does
support but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>本书尚未讨论全局变量（Rust 支持但可能因所有权规则引发问题）。若两个线程访问同一可变全局变量，可能导致数据竞争。</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 20-10 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p>在 Rust 中，全局变量称为<strong>静态</strong>变量。示例 20-10 展示以字符串切片为值的静态变量声明及使用示例。</p>
<figure class="listing" id="listing-20-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}</code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-10">Listing 20-10</a>: Defining and using an immutable static variable 定义并使用不可变静态变量</figcaption>
</figure>
<p>Static variables are similar to constants, which we discussed in
“Constants” in
Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by
convention. Static variables can only store references with the <code>'static</code>
lifetime, which means the Rust compiler can figure out the lifetime and we
aren’t required to annotate it explicitly. Accessing an immutable static
variable is safe.</p>
<p>静态变量类似于常量（第 3 章“常量“中讨论过）。静态变量名按惯例采用 <code>SCREAMING_SNAKE_CASE</code> 格式。静态变量只能存储 <code>'static</code> 生命周期的引用（意味着 Rust 编译器可推断生命周期而无需显式标注）。访问不可变静态变量是安全的。</p>
<p>A subtle difference between constants and immutable static variables is that
values in a static variable have a fixed address in memory. Using the value
will always access the same data. Constants, on the other hand, are allowed to
duplicate their data whenever they’re used. Another difference is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 20-11 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p>常量与不可变静态变量的微妙区别在于：静态变量的值在内存中有固定地址，使用该值总是访问同一数据；而常量允许在每次使用时复制数据。另一区别是静态变量可为可变。访问和修改可变静态变量是<strong>不安全</strong>的。示例 20-11 展示如何声明、访问和修改名为 <code>COUNTER</code> 的可变静态变量。</p>
<figure class="listing" id="listing-20-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-11">Listing 20-11</a>: Reading from or writing to a mutable static variable is unsafe. 读写可变静态变量不安全</figcaption>
</figure>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. The
code in Listing 20-11 compiles and prints <code>COUNTER: 3</code> as we would expect
because it’s single threaded. Having multiple threads access <code>COUNTER</code> would
likely result in data races, so it is undefined behavior. Therefore, we need to
mark the entire function as <code>unsafe</code> and document the safety limitation, so
anyone calling the function knows what they are and are not allowed to do
safely.</p>
<p>与常规变量类似，我们使用 <code>mut</code> 关键字指定可变性。任何读写 <code>COUNTER</code> 的代码必须在 <code>unsafe</code> 块中。示例 20-11 的代码能编译并按预期打印 <code>COUNTER: 3</code>（因是单线程）。多线程访问 <code>COUNTER</code> 可能导致数据竞争（即未定义行为）。因此，需将整个函数标记为 <code>unsafe</code> 并记录安全限制，以便调用者知晓安全操作的边界。</p>
<p>Whenever we write an unsafe function, it is idiomatic to write a comment
starting with <code>SAFETY</code> and explaining what the caller needs to do to call the
function safely. Likewise, whenever we perform an unsafe operation, it is
idiomatic to write a comment starting with <code>SAFETY</code> to explain how the safety
rules are upheld.</p>
<p>编写不安全函数时，惯例是以 <code>SAFETY</code> 开头的注释说明调用者需满足的安全条件。类似地，执行不安全操作时，惯例是用 <code>SAFETY</code> 开头的注释解释如何维护安全规则。</p>
<p>Additionally, the compiler will deny by default any attempt to create
references to a mutable static variable through a compiler lint. You must
either explicitly opt-out of that lint’s protections by adding an
<code>#[allow(static_mut_refs)]</code> annotation or access the mutable static variable
via a raw pointer created with one of the raw borrow operators. That includes
cases where the reference is created invisibly, as when it is used in the
<code>println!</code> in this code listing. Requiring references to static mutable
variables to be created via raw pointers helps make the safety requirements for
using them more obvious.</p>
<p>此外，编译器默认拒绝任何通过编译器 lint 创建对可变静态变量引用的尝试。必须显式选择退出该 lint 的保护（通过添加 <code>#[allow(static_mut_refs)]</code> 注解）或通过原始借用运算符创建的原始指针访问可变静态变量。这包括引用被隐式创建的情况（如本代码清单中在 <code>println!</code> 中使用时）。要求通过原始指针创建对静态可变变量的引用，有助于更明显地体现使用它们的安全要求。</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data access from different threads is done safely.</p>
<p>对于全局可访问的可变数据，确保无数据竞争非常困难，因此 Rust 认为可变静态变量不安全。在可能的情况下，优先使用第 16 章讨论的并发技术和线程安全智能指针，以便编译器检查来自不同线程的数据访问是否安全。</p>
<h3 id="implementing-an-unsafe-trait-实现不安全-trait"><a class="header" href="#implementing-an-unsafe-trait-实现不安全-trait">Implementing an Unsafe Trait 实现不安全 trait</a></h3>
<p>We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at
least one of its methods has some invariant that the compiler can’t verify. We
declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>
and marking the implementation of the trait as <code>unsafe</code> too, as shown in
Listing 20-12.</p>
<p>可使用 <code>unsafe</code> 实现不安全 trait。当 trait 的至少一个方法存在编译器无法验证的不变量时，该 trait 为不安全。通过在 <code>trait</code> 前添加 <code>unsafe</code> 关键字并将 trait 实现标记为 <code>unsafe</code> 来声明 trait 不安全，如示例 20-12 所示。</p>
<figure class="listing" id="listing-20-12">
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch20-01-unsafe-rust.html#listing-20-12">Listing 20-12</a>: Defining and implementing an unsafe trait 定义并实现不安全 trait</figcaption>
</figure>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>通过 <code>unsafe impl</code>，我们承诺将维护编译器无法验证的不变量。</p>
<p>As an example, recall the <code>Send</code> and <code>Sync</code> marker traits we discussed in
“Extensible Concurrency with the <code>Send</code> and <code>Sync</code>
Traits”
in Chapter 16: the compiler implements these traits automatically if our types
are composed entirely of other types that implement <code>Send</code> and <code>Sync</code>. If we
implement a type that contains a type that does not implement <code>Send</code> or <code>Sync</code>,
such as raw pointers, and we want to mark that type as <code>Send</code> or <code>Sync</code>, we
must use <code>unsafe</code>. Rust can’t verify that our type upholds the guarantees that
it can be safely sent across threads or accessed from multiple threads;
therefore, we need to do those checks manually and indicate as such with
<code>unsafe</code>.</p>
<p>例如，回顾第 16 章“使用 <code>Send</code> 和 <code>Sync</code> trait 的可扩展并发“中讨论的 <code>Send</code> 和 <code>Sync</code> 标记 trait：若类型完全由实现 <code>Send</code> 和 <code>Sync</code> 的其他类型组成，编译器会自动实现这些 trait。若实现包含未实现 <code>Send</code> 或 <code>Sync</code> 的类型（如原始指针），且希望标记该类型为 <code>Send</code> 或 <code>Sync</code>，则必须使用 <code>unsafe</code>。Rust 无法验证我们的类型满足可安全跨线程发送或多线程访问的保证，因此需要手动检查并通过 <code>unsafe</code> 表明。</p>
<h3 id="accessing-fields-of-a-union-访问联合体union字段"><a class="header" href="#accessing-fields-of-a-union-访问联合体union字段">Accessing Fields of a Union 访问联合体（union）字段</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a union.
A <em>union</em> is similar to a <code>struct</code>, but only one declared field is used in a
particular instance at one time. Unions are primarily used to interface with
unions in C code. Accessing union fields is unsafe because Rust can’t guarantee
the type of the data currently being stored in the union instance. You can
learn more about unions in the Rust Reference.</p>
<p>仅能通过 <code>unsafe</code> 执行的最后一项操作是访问联合体的字段。<strong>联合体</strong>类似于 <code>struct</code>，但在特定实例中仅使用一个声明的字段。联合体主要用于与 C 代码中的联合体交互。访问联合体字段不安全（因 Rust 无法保证当前存储在联合体实例中的数据类型）。更多关于联合体的信息见 Rust 参考手册。</p>
<h3 id="using-miri-to-check-unsafe-code-使用-miri-检查不安全代码"><a class="header" href="#using-miri-to-check-unsafe-code-使用-miri-检查不安全代码">Using Miri to Check Unsafe Code 使用 Miri 检查不安全代码</a></h3>
<p>When writing unsafe code, you might want to check that what you have written
actually is safe and correct. One of the best ways to do that is to use Miri,
an official Rust tool for detecting undefined behavior. Whereas the borrow
checker is a <em>static</em> tool which works at compile time, Miri is a <em>dynamic</em>
tool which works at runtime. It checks your code by running your program, or
its test suite, and detecting when you violate the rules it understands about
how Rust should work.</p>
<p>编写不安全代码时，可能需要检查所写内容是否安全正确。最佳方法之一是使用 Miri（Rust 官方检测未定义行为的工具）。借用检查器是编译时工作的<strong>静态</strong>工具，而 Miri 是运行时工作的<strong>动态</strong>工具。它通过运行程序或其测试套件来检查代码，并在违反 Rust 规则时检测出来。</p>
<p>Using Miri requires a nightly build of Rust (which we talk about more in
Appendix G: How Rust is Made and “Nightly Rust”). You
can install both a nightly version of Rust and the Miri tool by typing <code>rustup +nightly component add miri</code>. This does not change what version of Rust your
project uses; it only adds the tool to your system so you can use it when you
want to. You can run Miri on a project by typing <code>cargo +nightly miri run</code> or
<code>cargo +nightly miri test</code>.</p>
<p>使用 Miri 需要 nightly 版本的 Rust（附录 G：Rust 开发过程及“Nightly Rust“中详述）。可通过 <code>rustup +nightly component add miri</code> 安装 nightly 版 Rust 和 Miri 工具。这不会改变项目使用的 Rust 版本，仅将该工具添加到系统中以便按需使用。可通过 <code>cargo +nightly miri run</code> 或 <code>cargo +nightly miri test</code> 在项目上运行 Miri。</p>
<p>For an example of how helpful this can be, consider what happens when we run it
against Listing 20-7.</p>
<p>为说明其有效性，考虑在示例 20-7 上运行时的结果：</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
warning: integer-to-pointer cast
 --&gt; src/main.rs:5:13
  |
5 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:5:13: 5:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --&gt; src/main.rs:7:35
  |
7 |     let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:7:35: 7:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted

</code></pre>
<p>Miri correctly warns us that we’re casting an integer to a pointer, which might
be a problem but Miri can’t detect if there is because it doesn’t know how the
pointer originated. Then, Miri returns an error where Listing 20-7 has
undefined behavior because we have a dangling pointer. Thanks to Miri, we now
know there is a risk of undefined behavior, and we can think about how to make
the code safe. In some cases, Miri can even make recommendations about how to
fix errors.</p>
<p>Miri 正确警告我们正将整数转换为指针（可能存在问题），但因不知指针来源而无法检测是否存在问题。接着，Miri 在示例 20-7 处返回错误（因存在悬垂指针）。多亏 Miri，我们现在知道存在未定义行为的风险，并可思考如何使代码安全。某些情况下，Miri 甚至能推荐修复错误的方法。</p>
<p>Miri doesn’t catch everything you might get wrong when writing unsafe code.
Miri is a dynamic analysis tool, so it only catches problems with code that
actually gets run. That means you will need to use it in conjunction with good
testing techniques to increase your confidence about the unsafe code you have
written. Miri also does not cover every possible way your code can be unsound.</p>
<p>Miri 无法捕获编写不安全代码时可能犯的所有错误。Miri 是动态分析工具，因此仅检测实际运行代码中的问题。这意味着需将其与良好测试技术结合使用，以增强对所写不安全代码的信心。Miri 也未涵盖代码可能不健全的所有方式。</p>
<p>Put another way: If Miri <em>does</em> catch a problem, you know there’s a bug, but
just because Miri <em>doesn’t</em> catch a bug doesn’t mean there isn’t a problem. It
can catch a lot, though. Try running it on the other examples of unsafe code in
this chapter and see what it says!</p>
<p>换句话说：若 Miri <strong>确实</strong>发现问题，可知存在 bug；但若 Miri <strong>未</strong>捕获 bug，并不表示没有问题。不过它能捕获很多问题。尝试在本章其他不安全代码示例上运行，看看它怎么说！</p>
<p>You can learn more about Miri at its GitHub repository.</p>
<p>可在其 GitHub 仓库了解更多关于 Miri 的信息。</p>
<h3 id="when-to-use-unsafe-code-何时使用不安全代码"><a class="header" href="#when-to-use-unsafe-code-何时使用不安全代码">When to Use Unsafe Code 何时使用不安全代码</a></h3>
<p>Using <code>unsafe</code> to use one of the five superpowers just discussed isn’t wrong or
even frowned upon, but it is trickier to get <code>unsafe</code> code correct because the
compiler can’t help uphold memory safety. When you have a reason to use
<code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code> annotation makes
it easier to track down the source of problems when they occur. Whenever you
write unsafe code, you can use Miri to help you be more confident that the code
you have written upholds Rust’s rules.</p>
<p>使用 <code>unsafe</code> 来利用上述五项超能力并非错误甚至不被反对，但因编译器无法帮助维护内存安全，正确编写 <code>unsafe</code> 代码更棘手。当有理由使用不安全代码时，可以这样做，且显式的 <code>unsafe</code> 注解使问题溯源更简单。编写不安全代码时，可使用 Miri 帮助确保代码符合 Rust 规则。</p>
<p>For a much deeper exploration of how to work effectively with unsafe Rust, read
Rust’s official guide to the subject, the Rustonomicon.</p>
<p>要更深入掌握如何有效使用不安全 Rust，请阅读 Rust 官方指南《Rustonomicon》。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-traits-高级特性"><a class="header" href="#advanced-traits-高级特性">Advanced Traits 高级特性</a></h2>
<p>We first covered traits in “Traits: Defining Shared
Behavior” in Chapter 10, but we
didn’t discuss the more advanced details. Now that you know more about Rust, we
can get into the nitty-gritty.</p>
<p>我们首次在第10章的“特性：定义共享行为“中介绍了特性，但未讨论更高级的细节。既然你对Rust有了更多了解，现在可以深入细节了。</p>
<h3 id="associated-types-关联类型"><a class="header" href="#associated-types-关联类型">Associated Types 关联类型</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used instead of the
placeholder type for the particular implementation. That way, we can define a
trait that uses some types without needing to know exactly what those types are
until the trait is implemented.</p>
<p><em>关联类型</em> 将类型占位符与特性连接起来，使得特性方法定义能在签名中使用这些占位符类型。特性的实现者会为特定实现指定用于替代占位符类型的具体类型。这样，我们可以定义一个使用某些类型的特性，而无需在实现该特性前确切知道这些类型是什么。</p>
<p>We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>本章描述的大多数高级功能都很少需要使用。关联类型介于中间位置：它们的使用频率低于本书其他部分介绍的功能，但高于本章讨论的许多其他功能。</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. The definition of the <code>Iterator</code> trait is as shown in Listing
20-13.</p>
<p><span class="highlight">[note]带有关联类型的特性示例是标准库提供的<code>Iterator</code>特性。</span>其关联类型名为<code>Item</code>，代表实现<code>Iterator</code>特性的类型所迭代值的类型。<code>Iterator</code>特性的定义如代码清单20-13所示。</p>
<figure class="listing" id="listing-20-13">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-13">Listing 20-13</a>: The definition of the <code>Iterator</code> trait that has an associated type <code>Item</code> 包含关联类型<code>Item</code>的<code>Iterator</code>特性定义</figcaption>
</figure>
<p>The type <code>Item</code> is a placeholder, and the <code>next</code> method’s definition shows that
it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p><code>Item</code>类型是一个占位符，<code>next</code>方法的定义表明它将返回<code>Option&lt;Self::Item&gt;</code>类型的值。<code>Iterator</code>特性的实现者将为<code>Item</code>指定具体类型，<code>next</code>方法将返回包含该具体类型值的<code>Option</code>。</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. To examine the difference between the two concepts, we’ll look at an
implementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies
the <code>Item</code> type is <code>u32</code>:</p>
<p>关联类型看起来与泛型类似，因为后者允许我们在不指定处理类型的情况下定义函数。为研究两者的区别，我们将查看在名为<code>Counter</code>的类型上实现<code>Iterator</code>特性，指定<code>Item</code>类型为<code>u32</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 20-14?</p>
<p>这种语法似乎与泛型相当。那么为什么不直接使用泛型定义<code>Iterator</code>特性，如代码清单20-14所示？</p>
<figure class="listing" id="listing-20-14">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-14">Listing 20-14</a>: A hypothetical definition of the <code>Iterator</code> trait using generics 使用泛型的<code>Iterator</code>特性假设定义</figcaption>
</figure>
<p>The difference is that when using generics, as in Listing 20-14, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>区别在于使用泛型时（如代码清单20-14），我们必须在每个实现中标注类型；因为我们也可以为<code>Counter</code>实现<code>Iterator&lt;String&gt;</code>或任何其他类型，所以对<code>Counter</code>可以有多个<code>Iterator</code>实现。<span class="highlight">[note]换句话说，当特性具有泛型参数时，可以为同一类型多次实现该特性，每次更改泛型类型参数的具体类型。当我们在<code>Counter</code>上使用<code>next</code>方法时，必须提供类型标注以指明要使用哪个<code>Iterator</code>实现。</span></p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 20-13 with the
definition that uses associated types, we can choose what the type of <code>Item</code>
will be only once because there can be only one <code>impl Iterator for Counter</code>. We
don’t have to specify that we want an iterator of <code>u32</code> values everywhere we
call <code>next</code> on <code>Counter</code>.</p>
<p>使用关联类型时，我们不需要标注类型，因为<span class="highlight">[note]无法在同一个类型上多次实现特性</span>。在代码清单20-13使用关联类型的定义中，我们只能选择一次<code>Item</code>的类型，因为只能存在一个<code>impl Iterator for Counter</code>。在<code>Counter</code>上调用<code>next</code>时，无需到处指定需要<code>u32</code>值的迭代器。</p>
<p>Associated types also become part of the trait’s contract: implementors of the
trait must provide a type to stand in for the associated type placeholder.
Associated types often have a name that describes how the type will be used,
and documenting the associated type in the API documentation is a good practice.</p>
<p>关联类型也成为特性契约的一部分：特性的实现者必须提供一个类型来替代关联类型占位符。关联类型通常具有描述其用途的名称，在API文档中记录关联类型是良好实践。</p>
<h3 id="default-generic-type-parameters-and-operator-overloading-默认泛型类型参数与运算符重载"><a class="header" href="#default-generic-type-parameters-and-operator-overloading-默认泛型类型参数与运算符重载">Default Generic Type Parameters and Operator Overloading 默认泛型类型参数与运算符重载</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. You specify a default type
when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>使用泛型类型参数时，可以为泛型类型指定默认的具体类型。如果默认类型适用，这消除了特性实现者指定具体类型的需要。<span class="highlight">[note]声明泛型类型时使用<code>&lt;PlaceholderType=ConcreteType&gt;</code>语法来指定默认类型</span>。</p>
<p>A great example of a situation where this technique is useful is with <em>operator
overloading</em>, in which you customize the behavior of an operator (such as <code>+</code>)
in particular situations.</p>
<p>这种技术的一个典型应用场景是_运算符重载_，即在特定情况下自定义运算符（如<code>+</code>）的行为。</p>
<p>Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 20-15 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct.</p>
<p>Rust不允许创建自定义运算符或重载任意运算符。但可以通过实现与运算符相关的特性来重载<code>std::ops</code>中列出的操作和相应特性。例如，在代码清单20-15中，我们重载<code>+</code>运算符来将两个<code>Point</code>实例相加。这是通过在<code>Point</code>结构体上实现<code>Add</code>特性完成的。</p>
<figure class="listing" id="listing-20-15">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-15">Listing 20-15</a>: Implementing the <code>Add</code> trait to overload the <code>+</code> operator for <code>Point</code> instances 实现<code>Add</code>特性以重载<code>Point</code>实例的<code>+</code>运算符</figcaption>
</figure>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p><code>add</code>方法将两个<code>Point</code>实例的<code>x</code>值和<code>y</code>值相加来创建新<code>Point</code>。<code>Add</code>特性有一个名为<code>Output</code>的关联类型，决定<code>add</code>方法返回的类型。</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<p>此代码中的默认泛型类型在<code>Add</code>特性内部。其定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>Rhs</code> generic type parameter (short for “right-hand
side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t
specify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type
of <code>Rhs</code> will default to <code>Self</code>, which will be the type we’re implementing
<code>Add</code> on.</p>
<p>此代码应大致熟悉：这是一个包含一个方法和一个关联类型的特性。新部分是<code>Rhs=Self</code>：此语法称为 <em>默认类型参数</em>。<code>Rhs</code>泛型类型参数（“right-hand side“的缩写）定义了<code>add</code>方法中<code>rhs</code>参数的类型。如果我们在实现<code>Add</code>特性时未为<code>Rhs</code>指定具体类型，则<code>Rhs</code>的类型将默认为<code>Self</code>，即我们实现<code>Add</code>的类型。</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we
wanted to add two <code>Point</code> instances. Let’s look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the
default.</p>
<p>当为<code>Point</code>实现<code>Add</code>时，我们使用了<code>Rhs</code>的默认值，因为要相加两个<code>Point</code>实例。现在看一个自定义<code>Rhs</code>类型而非使用默认值的<code>Add</code>特性实现示例。</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. This thin wrapping of an existing type in another struct is known as the
<em>newtype pattern</em>, which we describe in more detail in the “Using the Newtype
Pattern to Implement External Traits” section. We want to add values in millimeters to values in meters and have
the implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code>
for <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 20-16.</p>
<p>我们有两个结构体<code>Millimeters</code>和<code>Meters</code>，以不同单位保存值。这种在另一个结构体中对现有类型进行薄包装的模式称为 <em>newtype模式</em>，我们将在“使用Newtype模式实现外部特性“部分详细说明。我们希望将以毫米为单位的值与以米为单位的值相加，并让<code>Add</code>的实现正确处理单位转换。如代码清单20-16所示，我们可以为<code>Millimeters</code>实现<code>Add</code>，并以<code>Meters</code>作为<code>Rhs</code>。</p>
<figure class="listing" id="listing-20-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-16">Listing 20-16</a>: Implementing the <code>Add</code> trait on <code>Millimeters</code> to add <code>Millimeters</code> and <code>Meters</code> 在<code>Millimeters</code>上实现<code>Add</code>特性以将<code>Millimeters</code>和<code>Meters</code>相加</figcaption>
</figure>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>为将<code>Millimeters</code>和<code>Meters</code>相加，我们指定<code>impl Add&lt;Meters&gt;</code>来设置<code>Rhs</code>类型参数的值，而非使用默认的<code>Self</code>。</p>
<p>You’ll use default type parameters in two main ways:</p>
<p>主要在两种情况下使用默认类型参数：</p>
<ol>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ol>
<!-- -->
<ol>
<li>扩展类型而不破坏现有代码</li>
<li>允许在大多数用户不需要的特定情况下进行自定义</li>
</ol>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose:
usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.</p>
<p>标准库的<code>Add</code>特性是第二个目的的示例：通常你会将两个相同类型相加，但<code>Add</code>特性提供了超越此的自定义能力。在<code>Add</code>特性定义中使用默认类型参数意味着大多数时候无需指定额外参数。换句话说，无需编写额外的样板实现代码，使特性更易于使用。</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<p>第一个目的与第二个类似但方向相反：如果想给现有特性添加类型参数，可为其提供默认值以允许扩展特性功能，而不破坏现有实现代码。</p>
<h3 id="disambiguating-between-methods-with-the-same-name-消除同名方法歧义"><a class="header" href="#disambiguating-between-methods-with-the-same-name-消除同名方法歧义">Disambiguating Between Methods with the Same Name 消除同名方法歧义</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>Rust不阻止特性拥有与其他特性方法同名的方法，也不阻止在同一个类型上实现这两个特性。也可以直接在类型上实现与特性方法同名的方法。</p>
<p>When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 20-17 where we’ve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p>调用同名方法时，需要告诉Rust你要使用哪一个。参考代码清单20-17，我们定义了两个特性<code>Pilot</code>和<code>Wizard</code>，它们都有名为<code>fly</code>的方法。然后在已实现<code>fly</code>方法的<code>Human</code>类型上实现这两个特性。每个<code>fly</code>方法执行不同操作。</p>
<figure class="listing" id="listing-20-17">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-17">Listing 20-17</a>: Two traits are defined to have a <code>fly</code> method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is implemented on <code>Human</code> directly. 定义两个包含<code>fly</code>方法的特性并在<code>Human</code>类型上实现，同时直接在<code>Human</code>上实现<code>fly</code>方法</figcaption>
</figure>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 20-18.</p>
<p>当在<code>Human</code>实例上调用<code>fly</code>时，<span class="highlight">[note]编译器默认调用直接实现在类型上的方法</span>，如代码清单20-18所示。</p>
<figure class="listing" id="listing-20-18">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-18">Listing 20-18</a>: Calling <code>fly</code> on an instance of <code>Human</code> 在<code>Human</code>实例上调用<code>fly</code></figcaption>
</figure>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>运行此代码将打印<code>*waving arms furiously*</code>，表明Rust调用了直接在<code>Human</code>上实现的<code>fly</code>方法。</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 20-19 demonstrates this syntax.</p>
<p>要调用<code>Pilot</code>特性或<code>Wizard</code>特性的<code>fly</code>方法，需要使用更明确的语法来指定目标方法。代码清单20-19演示了此语法。</p>
<figure class="listing" id="listing-20-19">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-19">Listing 20-19</a>: Specifying which trait’s <code>fly</code> method we want to call 指定要调用的特性<code>fly</code>方法</figcaption>
</figure>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 20-19, but this is a bit longer to write if we don’t need to
disambiguate.</p>
<p>在方法名前指定特性名可向Rust澄清要调用哪个<code>fly</code>实现。也<span class="highlight">[note]可以写为<code>Human::fly(&amp;person)</code></span>，这等效于代码清单20-19使用的<code>person.fly()</code>，但如果不需要消除歧义则稍长。</p>
<p>Running this code prints the following:</p>
<p>运行此代码打印如下内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>因为<code>fly</code>方法接受<code>self</code>参数，如果有两个类型都实现了同一个特性，Rust能根据<code>self</code>的类型判断使用哪个特性实现。</p>
<p>However, associated functions that are not methods don’t have a <code>self</code>
parameter. When there are multiple types or traits that define non-method
functions with the same function name, Rust doesn’t always know which type you
mean unless you use fully qualified syntax. For example, in Listing 20-20 we
create a trait for an animal shelter that wants to name all baby dogs Spot. We
make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>. The
<code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also provide an
associated non-method function <code>baby_name</code> directly.</p>
<p>但是，非方法的关联函数没有<code>self</code>参数。当多个类型或特性定义了同名的非方法函数时，除非使用完全限定语法，否则Rust无法始终知道你要指的类型。例如在代码清单20-20中，我们为动物收容所创建特性，希望将所有小狗命名为Spot。定义<code>Animal</code>特性包含关联非方法函数<code>baby_name</code>。<code>Animal</code>特性在结构体<code>Dog</code>上实现，同时我们直接在<code>Dog</code>上提供关联非方法函数<code>baby_name</code>。</p>
<figure class="listing" id="listing-20-20">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-20">Listing 20-20</a>: A trait with an associated function and a type with an associated function of the same name that also implements the trait 包含关联函数的特性，以及一个实现了该特性且拥有同名关联函数的类型</figcaption>
</figure>
<p>We implement the code for naming all puppies Spot in the <code>baby_name</code> associated
function that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait
<code>Animal</code>, which describes characteristics that all animals have. Baby dogs are
called puppies, and that is expressed in the implementation of the <code>Animal</code>
trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>我们在直接定义于<code>Dog</code>的<code>baby_name</code>关联函数中实现将所有幼犬命名为Spot的代码。<code>Dog</code>类型也实现了<code>Animal</code>特性，该特性描述了所有动物共有的特征。幼犬称为puppy，这体现在<code>Dog</code>的<code>Animal</code>特性实现中与<code>Animal</code>特性关联的<code>baby_name</code>函数中。</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<p>在<code>main</code>中，调用<code>Dog::baby_name</code>函数直接调用定义于<code>Dog</code>的关联函数。此代码打印如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>This output isn’t what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 20-19 doesn’t help here; if we change <code>main</code> to the code in
Listing 20-21, we’ll get a compilation error.</p>
<p>此输出不符合预期。我们想调用实现在<code>Dog</code>上的<code>Animal</code>特性的<code>baby_name</code>函数，以打印<code>A baby dog is called a puppy</code>。代码清单20-19使用的指定特性名技术在此无效；如果将<code>main</code>改为代码清单20-21的代码，将导致编译错误。</p>
<figure class="listing" id="listing-20-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-21">Listing 20-21</a>: Attempting to call the <code>baby_name</code> function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to use 尝试调用<code>Animal</code>特性的<code>baby_name</code>函数，但Rust不知道要使用哪个实现</figcaption>
</figure>
<p>Because <code>Animal::baby_name</code> doesn’t have a <code>self</code> parameter, and there could be
other types that implement the <code>Animal</code> trait, Rust can’t figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<p>因为<code>Animal::baby_name</code>没有<code>self</code>参数，且可能存在其他实现<code>Animal</code>特性的类型，Rust无法判断我们要哪个<code>Animal::baby_name</code>实现。会得到以下编译错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other
type, we need to use fully qualified syntax. Listing 20-22 demonstrates how to
use fully qualified syntax.</p>
<p>为消除歧义并告诉Rust我们要使用<code>Animal</code>在<code>Dog</code>上的实现而非其他类型的实现，需使用完全限定语法。代码清单20-22演示了如何使用完全限定语法。</p>
<figure class="listing" id="listing-20-22">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-22">Listing 20-22</a>: Using fully qualified syntax to specify that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as implemented on <code>Dog</code> 使用完全限定语法指定要调用实现在<code>Dog</code>上的<code>Animal</code>特性的<code>baby_name</code>函数</figcaption>
</figure>
<p>We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<p>我们在尖括号内为Rust提供类型标注，指明要从实现在<code>Dog</code>上的<code>Animal</code>特性调用<code>baby_name</code>方法，通过指定将<code>Dog</code>类型视为<code>Animal</code>来进行此函数调用。此代码现在打印预期内容：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<p>通常，<span class="highlight">[note]完全限定语法定义如下：</span></p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>For associated functions that aren’t methods, there would not be a <code>receiver</code>:
there would only be the list of other arguments. You could use fully qualified
syntax everywhere that you call functions or methods. However, you’re allowed
to omit any part of this syntax that Rust can figure out from other information
in the program. You only need to use this more verbose syntax in cases where
there are multiple implementations that use the same name and Rust needs help
to identify which implementation you want to call.</p>
<p>对于非方法的关联函数，则没有接收者：只有其他参数列表。你可以在所有调用函数或方法的地方使用完全限定语法。但是，如果Rust能从程序其他信息推断出部分语法，允许省略这些部分。仅当存在多个同名实现且Rust需要帮助识别目标实现时，才需要使用这种更详细的语法。</p>
<h3 id="using-supertraits-使用超级特性"><a class="header" href="#using-supertraits-使用超级特性">Using Supertraits 使用超级特性</a></h3>
<p>Sometimes you might write a trait definition that depends on another trait: for
a type to implement the first trait, you want to require that type to also
implement the second trait. You would do this so that your trait definition can
make use of the associated items of the second trait. The trait your trait
definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>有时可能需要编写依赖另一个特性的特性定义：要使类型实现第一个特性，需要求该类型也实现第二个特性。这样做可使特性定义利用第二个特性的关联项。特性定义所依赖的特性称为你的特性的超特性。</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a given value formatted so that it’s
framed in asterisks. That is, given a <code>Point</code> struct that implements the
standard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call
<code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it
should print the following:</p>
<p>例如，假设我们想创建<code>OutlinePrint</code>特性，其<code>outline_print</code>方法将格式化打印给定值并添加星号边框。即，对于实现标准库特性<code>Display</code>结果为<code>(x, y)</code>的<code>Point</code>结构体，当在<code>x=1</code>、<code>y=3</code>的<code>Point</code>实例上调用<code>outline_print</code>时，应打印如下内容：</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the
<code>Display</code> trait’s functionality. Therefore, we need to specify that the
<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. This technique is
similar to adding a trait bound to the trait. Listing 20-23 shows an
implementation of the <code>OutlinePrint</code> trait.</p>
<p>在<code>outline_print</code>方法的实现中，我们希望利用<code>Display</code>特性的功能。因此需指定<code>OutlinePrint</code>特性仅适用于也实现了<code>Display</code>的类型，并提供<code>OutlinePrint</code>所需的功能。<span class="highlight">[note]我们可以在特性定义中通过指定<code>OutlinePrint: Display</code>来实现。此技术类似于为特性添加特性约束。</span>代码清单20-23展示了<code>OutlinePrint</code>特性的实现。</p>
<figure class="listing" id="listing-20-23">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-23">Listing 20-23</a>: Implementing the <code>OutlinePrint</code> trait that requires the functionality from <code>Display</code> 实现需要<code>Display</code>功能的<code>OutlinePrint</code>特性</figcaption>
</figure>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>因为我们指定了<code>OutlinePrint</code>需要<code>Display</code>特性，所以可以使用为任何实现<code>Display</code>的类型自动实现的<code>to_string</code>函数。如果未在特性名后添加冒号和<code>Display</code>特性就尝试使用<code>to_string</code>，会收到错误提示：在当前作用域中找不到名为<code>to_string</code>的方法。</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p>现在尝试在未实现<code>Display</code>的类型（如<code>Point</code>结构体）上实现<code>OutlinePrint</code>：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<p>会收到要求<code>Display</code>但未实现的错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p>为修复此问题，我们在<code>Point</code>上实现<code>Display</code>以满足<code>OutlinePrint</code>的约束，如下所示：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>Then, implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<p>这样，在<code>Point</code>上实现<code>OutlinePrint</code>特性将能成功编译，我们可以在<code>Point</code>实例上调用<code>outline_print</code>来在星号边框内显示它。</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-使用newtype模式实现外部特性"><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-使用newtype模式实现外部特性">Using the Newtype Pattern to Implement External Traits 使用Newtype模式实现外部特性</a></h3>
<p>In “Implementing a Trait on a Type” in Chapter 10, we mentioned the orphan rule that states we’re only
allowed to implement a trait on a type if either the trait or the type, or
both, are local to our crate. It’s possible to get around this restriction
using the <em>newtype pattern</em>, which involves creating a new type in a tuple
struct. (We covered tuple structs in “Using Tuple Structs Without Named Fields
to Create Different Types” in Chapter 5.) The
tuple struct will have one field and be a thin wrapper around the type for
which we want to implement a trait. Then the wrapper type is local to our
crate, and we can implement the trait on the wrapper. <em>Newtype</em> is a term that
originates from the Haskell programming language. There is no runtime
performance penalty for using this pattern, and the wrapper type is elided at
compile time.</p>
<p>在第10章“在类型上实现特性“中，我们提到孤儿规则：<span class="highlight">[note]仅当特性或类型（或两者）本地属于当前crate时，才允许在类型上实现特性。可通过 newtype 模式绕过此限制</span>，即在元组结构体中创建新类型。（我们在第5章“使用元组结构体创建无名字段的不同类型“中介绍过元组结构体。）元组结构体将包含一个字段，是目标类型的薄包装。这样包装类型对当前crate是本地类型，我们可以在包装器上实现特性。<em>Newtype</em> 是源自Haskell编程语言的术语。使用此模式没有运行时性能损失，且包装类型在编译时会被省略。</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 20-24.</p>
<p>例如，假设要在<code>Vec&lt;T&gt;</code>上实现<code>Display</code>，孤儿规则会直接阻止我们，因为<code>Display</code>特性和<code>Vec&lt;T&gt;</code>类型都定义在外部crate。可以创建包含<code>Vec&lt;T&gt;</code>实例的<code>Wrapper</code>结构体；然后在<code>Wrapper</code>上实现<code>Display</code>并使用<code>Vec&lt;T&gt;</code>值，如代码清单20-24所示。</p>
<figure class="listing" id="listing-20-24">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
<figcaption><a href="ch20-02-advanced-traits.html#listing-20-24">Listing 20-24</a>: Creating a <code>Wrapper</code> type around <code>Vec&lt;String&gt;</code> to implement <code>Display</code> 创建围绕<code>Vec&lt;String&gt;</code>的<code>Wrapper</code>类型以实现<code>Display</code></figcaption>
</figure>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> trait on <code>Wrapper</code>.</p>
<p><code>Display</code>的实现使用<code>self.0</code>访问内部的<code>Vec&lt;T&gt;</code>，因为<code>Wrapper</code>是元组结构体且<code>Vec&lt;T&gt;</code>是元组索引0处的项。这样我们就可以在<code>Wrapper</code>上使用<code>Display</code>特性的功能。</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would
be a solution (we discussed implementing the <code>Deref</code> trait in “Treating Smart
Pointers Like Regular References with <code>Deref</code>” in Chapter 15). If we didn’t want the <code>Wrapper</code> type to have all the
methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s
behavior—we would have to implement just the methods we do want manually.</p>
<p>此技术的缺点是<code>Wrapper</code>是新型类型，因此不包含其持有值的方法。必须在<code>Wrapper</code>上直接实现<code>Vec&lt;T&gt;</code>的所有方法，并将方法委托给<code>self.0</code>，这样才能像对待<code>Vec&lt;T&gt;</code>一样使用<code>Wrapper</code>。如果希望新类型拥有内部类型的所有方法，在<code>Wrapper</code>上实现<code>Deref</code>特性返回内部类型是解决方案（我们在第15章“使用<code>Deref</code>将智能指针视作常规引用“中讨论过实现<code>Deref</code>特性）。如果不希望<code>Wrapper</code>类型拥有内部类型的所有方法（例如为限制<code>Wrapper</code>类型的行为），则必须手动实现所需的方法。</p>
<p>This newtype pattern is also useful even when traits are not involved. Let’s
switch focus and look at some advanced ways to interact with Rust’s type system.</p>
<p>即使不涉及特性，这种newtype模式也很有用。现在让我们转换焦点，看看与Rust类型系统交互的一些高级方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-types-高级类型"><a class="header" href="#advanced-types-高级类型">Advanced Types 高级类型</a></h2>
<p>The Rust type system has some features that we’ve so far mentioned but haven’t
yet discussed. We’ll start by discussing newtypes in general as we examine why
newtypes are useful as types. Then we’ll move on to type aliases, a feature
similar to newtypes but with slightly different semantics. We’ll also discuss
the <code>!</code> type and dynamically sized types.</p>
<p>Rust 的类型系统包含一些我们曾提及但尚未深入讨论的特性。我们将首先探讨 newtype 模式的通用价值，分析其作为类型的优势。接着讨论类型别名这一与 newtype 类似但语义略有不同的功能。我们还将介绍 <code>!</code> 类型和动态大小类型。</p>
<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction-使用-newtype-模式实现类型安全与抽象"><a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction-使用-newtype-模式实现类型安全与抽象">Using the Newtype Pattern for Type Safety and Abstraction 使用 Newtype 模式实现类型安全与抽象</a></h3>
<p>This section assumes you’ve read the earlier section “Using the Newtype Pattern
to Implement External Traits”. The newtype pattern is also useful for tasks beyond those we’ve
discussed so far, including statically enforcing that values are never confused
and indicating the units of a value. You saw an example of using newtypes to
indicate units in Listing 20-16: recall that the <code>Millimeters</code> and <code>Meters</code>
structs wrapped <code>u32</code> values in a newtype. If we wrote a function with a
parameter of type <code>Millimeters</code>, we wouldn’t be able to compile a program that
accidentally tried to call that function with a value of type <code>Meters</code> or a
plain <code>u32</code>.</p>
<p>本节假设您已阅读过前面的章节 “使用 Newtype 模式实现外部特质”。除已讨论的功能外，newtype 模式还可用于静态确保值不被误用及标注值单位等场景。在示例 20-16 中您已见过使用 newtype 标注单位的实例：回忆 <code>Millimeters</code> 和 <code>Meters</code> 结构体将 <code>u32</code> 值封装为 newtype。若函数参数类型为 <code>Millimeters</code>，当错误地尝试用 <code>Meters</code> 类型或裸 <code>u32</code> 值调用该函数时，程序将无法通过编译。</p>
<p>We can also use the newtype pattern to abstract away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type.</p>
<p>我们也可用 newtype 模式抽象类型的实现细节：新类型可提供与内部私有类型不同的公共 API。</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation to
hide implementation details, which we discussed in “Encapsulation that Hides
Implementation Details” in Chapter 18.</p>
<p>Newtype 还能隐藏内部实现。例如，可创建 <code>People</code> 类型封装 <code>HashMap&lt;i32, String&gt;</code> 来存储关联用户 ID 和姓名。使用 <code>People</code> 的代码仅通过我们提供的公共 API 交互（例如添加姓名到集合的方法），无需了解内部用 <code>i32</code> ID 标识姓名的实现。Newtype 模式是实现封装隐藏细节的轻量级方案，我们在第 18 章的 “隐藏实现细节的封装” 中讨论过此概念。</p>
<h3 id="creating-type-synonyms-with-type-aliases-使用类型别名创建类型同义词"><a class="header" href="#creating-type-synonyms-with-type-aliases-使用类型别名创建类型同义词">Creating Type Synonyms with Type Aliases 使用类型别名创建类型同义词</a></h3>
<p>Rust provides the ability to declare a <em>type alias</em> to give an existing type
another name. For this we use the <code>type</code> keyword. For example, we can create
the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<p>Rust 支持通过声明 <em>类型别名</em> 为现有类型赋予新名称，使用 <code>type</code> 关键字实现。例如可为 <code>i32</code> <span class="highlight">[note]创建别名</span> <code>Kilometers</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Now the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code>
and <code>Meters</code> types we created in Listing 20-16, <code>Kilometers</code> is not a separate,
new type. Values that have the type <code>Kilometers</code> will be treated the same as
values of type <code>i32</code>:</p>
<p>此时别名 <code>Kilometers</code> 成为 <code>i32</code> 的 <em>同义词</em>。与示例 20-16 中创建的 <code>Millimeters</code> 和 <code>Meters</code> 不同，<code>Kilometers</code> 并非独立的新类型。<code>Kilometers</code> 类型值将完全等同于 <code>i32</code> 类型值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both
types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. However, using this method, we don’t get the type-checking benefits
that we get from the newtype pattern discussed earlier. In other words, if we
mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us
an error.</p>
<p>由于 <code>Kilometers</code> 和 <code>i32</code> 属同一类型，可对二者进行加法运算，也可将 <code>Kilometers</code> 值传递给接受 <code>i32</code> 参数的函数。但这种方式无法获得前文 newtype 模式中的类型检查优势。换言之，若在代码中混淆 <code>Kilometers</code> 和 <code>i32</code> 值，编译器不会报错。</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:</p>
<p>类型别名的主要用途是减少重复。例如遇到如下冗长类型时：</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 20-25.</p>
<p>在函数签名和类型注解中重复书写此类长类型会降低效率且易出错。设想项目中充满示例 20-25 的代码：</p>
<figure class="listing" id="listing-20-25">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-03-advanced-types.html#listing-20-25">Listing 20-25</a>: Using a long type in many places</figcaption>
</figure>
<p>A type alias makes this code more manageable by reducing the repetition. In
Listing 20-26, we’ve introduced an alias named <code>Thunk</code> for the verbose type and
can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<p>类型别名通过<span class="highlight">[note]减少重复</span>提升代码可管理性。示例 20-26 引入 <code>Thunk</code> 别名替代冗长类型，所有使用处均可替换为简短别名：</p>
<figure class="listing" id="listing-20-26">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-03-advanced-types.html#listing-20-26">Listing 20-26</a>: Introducing a type alias, <code>Thunk</code>, to reduce repetition</figcaption>
</figure>
<p>This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (<em>thunk</em> is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).</p>
<p>此版本代码更易读写！为类型别名选择有意义的名称（如 <em>thunk</em> 表示延迟执行代码）也有助于传达意图。</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<p>类型别名也常用于<span class="highlight">[note]简化</span> <code>Result&lt;T, E&gt;</code> 类型。参考标准库的 <code>std::io</code> 模块：I/O 操作常返回 <code>Result&lt;T, E&gt;</code> 处理失败场景。该库用 <code>std::io::Error</code> 结构体表示所有可能的 I/O 错误。<code>std::io</code> 中许多函数返回 <code>Result&lt;T, E&gt;</code>（其中 <code>E</code> 为 <code>std::io::Error</code>），例如 <code>Write</code> 特质中的函数：</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<p>其中 <code>Result&lt;..., Error&gt;</code> 重复出现。因此 <code>std::io</code> 声明了类型别名：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully
qualified alias <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code>
filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up
looking like this:</p>
<p>因该声明位于 <code>std::io</code> 模块，可使用完全限定别名 <code>std::io::Result&lt;T&gt;</code>（即 <code>E</code> 填充为 <code>std::io::Error</code> 的 <code>Result&lt;T, E&gt;</code>）。<code>Write</code> 特质的函数签名最终变为：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives
us a consistent interface across all of <code>std::io</code>. Because it’s an alias, it’s
just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<p>类型别名的优势体现在两方面：简化代码编写 + 在 <code>std::io</code> 中提供统一接口。因本质是别名，它仍是 <code>Result&lt;T, E&gt;</code>，故可对其使用 <code>Result&lt;T, E&gt;</code> 的所有方法及 <code>?</code> 运算符等特殊语法。</p>
<h3 id="the-never-type-that-never-returns-永不返回的-never-类型"><a class="header" href="#the-never-type-that-never-returns-永不返回的-never-类型">The Never Type That Never Returns 永不返回的 Never 类型</a></h3>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the
<em>empty type</em> because it has no values. We prefer to call it the <em>never type</em>
because it stands in the place of the return type when a function will never
return. Here is an example:</p>
<p>Rust 的 <code>!</code> 类型在类型论中称为 <em>空类型</em>（因其无值），但我们更倾向称其为 <em>never 类型</em>（因函数永不返回时用它占位返回类型）。例如：</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>This code is read as “the function <code>bar</code> returns never.” Functions that return
never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>,
so <code>bar</code> can never possibly return.</p>
<p>此代码解读为 “函数 <code>bar</code> 返回 never”。返回 never 的函数称为 <em>发散函数</em>。我们无法创建 <code>!</code> 类型的值，故 <code>bar</code> 不可能返回。</p>
<p>But what use is a type you can never create values for? Recall the code from
Listing 2-5, part of the number-guessing game; we’ve reproduced a bit of it
here in Listing 20-27.</p>
<p>但无法实例化的类型有何用处？回顾示例 2-5（猜数游戏部分代码），示例 20-27 重现了片段：</p>
<figure class="listing" id="listing-20-27">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch20-03-advanced-types.html#listing-20-27">Listing 20-27</a>: A <code>match</code> with an arm that ends in <code>continue</code></figcaption>
</figure>
<p>At the time, we skipped over some details in this code. In “The <code>match</code>
Control Flow Construct” in
Chapter 6, we discussed that <code>match</code> arms must all return the same type. So,
for example, the following code doesn’t work:</p>
<p>当时我们跳过了某些细节。在第 6 章 “<code>match</code> 控制流结构” 中讨论过：<code>match</code> 分支必须返回相同类型。例如以下代码无效：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string,
and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 20-27?</p>
<p>此代码中 <code>guess</code> 需同时具备整型和字符串类型，但 Rust 要求单一类型。那么 <code>continue</code> 返回什么？为何示例 20-27 中允许一个分支返回 <code>u32</code> 而另一分支以 <code>continue</code> 结尾？</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust
computes the type of <code>guess</code>, it looks at both match arms, the former with a
value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a
value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>您可能已猜到：<code>continue</code> 拥有 <code>!</code> 值。当 Rust 推断 <code>guess</code> 类型时，会同时考察两个分支：前者返回 <code>u32</code>，后者返回 <code>!</code>。因 <code>!</code> 永无值，Rust 判定 <code>guess</code> 类型为 <code>u32</code>。</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We’re allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn’t return a value; instead, it moves control
back to the top of the loop, so in the <code>Err</code> case, we never assign a value to
<code>guess</code>.</p>
<p>该行为的规范表述是：<span class="highlight">[note]<code>!</code> 类型表达式可强制转换为任意其他类型</span>。允许以 <code>continue</code> 结束 <code>match</code> 分支，是因 <code>continue</code> 不返回值而是将控制权交回循环顶部，故在 <code>Err</code> 情况下永远不会给 <code>guess</code> 赋值。</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Recall the <code>unwrap</code>
function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic with
this definition:</p>
<p>Never 类型与 <code>panic!</code> 宏也密切相关。回忆对 <code>Option&lt;T&gt;</code> 调用的 <code>unwrap</code> 函数（返回值或触发 panic）：</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 20-27: Rust
sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result
of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code>
doesn’t produce a value; it ends the program. In the <code>None</code> case, we won’t be
returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>此处逻辑同示例 20-27：Rust 发现 <code>val</code> 属 <code>T</code> 类型而 <span class="highlight">[note]<code>panic!</code> 属 <code>!</code> 类型</span>，故整个 <code>match</code> 表达式结果为 <code>T</code>。因 <code>panic!</code> 不产生值而终止程序，在 <code>None</code> 情况下 <code>unwrap</code> 不会返回值，因此代码有效。</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<p><span class="highlight">[note]最后一种拥有 <code>!</code> 类型的表达式是 <code>loop</code></span>：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this
wouldn’t be true if we included a <code>break</code>, because the loop would terminate
when it got to the <code>break</code>.</p>
<p>此循环永不终止，故表达式值为 <code>!</code>。但若包含 <code>break</code> 则不同，因循环会在 <code>break</code> 处终止。</p>
<h3 id="dynamically-sized-types-and-the-sized-trait-动态大小类型与-sized-特质"><a class="header" href="#dynamically-sized-types-and-the-sized-trait-动态大小类型与-sized-特质">Dynamically Sized Types and the <code>Sized</code> Trait 动态大小类型与 <code>Sized</code> 特质</a></h3>
<p>Rust needs to know certain details about its types, such as how much space to
allocate for a value of a particular type. This leaves one corner of its type
system a little confusing at first: the concept of <em>dynamically sized types</em>.
Sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write
code using values whose size we can know only at runtime.</p>
<p>Rust 需掌握类型的某些细节（如特定类型值分配的空间大小）。这使得类型系统的某个角落初看易混淆：<em>动态大小类型</em> 的概念。这些类型（有时称 <em>DST</em> 或 <em>不定长类型</em>）允许我们编写使用运行时才能确定大小的值的代码。</p>
<p>Let’s dig into the details of a dynamically sized type called <code>str</code>, which
we’ve been using throughout the book. That’s right, not <code>&amp;str</code>, but <code>str</code> on
its own, is a DST. In many cases, such as when storing text entered by a user,
we can’t know how long the string is until runtime. That means we can’t create
a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>. Consider
the following code, which does not work:</p>
<p>让我们深入名为 <code>str</code> 的动态大小类型（本书通篇使用）。是的，单独的 <code>str</code> 而非 <code>&amp;str</code> 才是 DST。许多场景（如存储用户输入的文本）需到运行时才能确定字符串长度。这意味着无法创建 <code>str</code> 类型变量，也不能接收 <code>str</code> 类型参数。考虑以下无效代码：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two <code>str</code> values would need to take up the
same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of
storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.</p>
<p>Rust 需知特定类型值的内存分配量，且同类型所有值必须使用等量内存。若允许此代码，两个 <code>str</code> 值需占用相同空间。但实际长度不同：<code>s1</code> 需 12 字节而 <code>s2</code> 需 15 字节。因此不可能创建持有动态大小类型的变量。</p>
<p>So what do we do? In this case, you already know the answer: we make the types
of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall from “String
Slices” in Chapter 4 that the slice data
structure just stores the starting position and the length of the slice. So,
although a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it’s
twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no
matter how long the string it refers to is. In general, this is the way in which
dynamically sized types are used in Rust: they have an extra bit of metadata
that stores the size of the dynamic information. The golden rule of dynamically
sized types is that we must always put values of dynamically sized types behind
a pointer of some kind.</p>
<p>解决方案是什么？您应已知晓：将 <code>s1</code> 和 <code>s2</code> 类型改为 <code>&amp;str</code> 而非 <code>str</code>。回顾第 4 章 “字符串切片”：切片数据结构仅存储起始位置和长度。因此虽然 <code>&amp;T</code> 是存储 <code>T</code> 内存地址的单个值，但 <code>&amp;str</code> 是 <em>两个</em> 值：<code>str</code> 的地址 + 其长度。故在编译时可获知 <code>&amp;str</code> 值的大小：两倍 <code>usize</code> 长度。无论引用字符串多长，我们总能知道 <code>&amp;str</code> 的大小。通常这就是 Rust 使用动态大小类型的方式：它们携带额外元数据存储动态信息的大小。动态大小类型的黄金法则是：必须通过某种指针使用动态大小类型的值。</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In “Using Trait Objects to Abstract over Shared
Behavior”
in Chapter 18, we mentioned that to use traits as trait objects, we must put
them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn  Trait&gt;</code> would work too).</p>
<p>可将 <code>str</code> 与各类指针组合：如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。其实您曾接触过另一种动态大小类型：特质。每个特质都是动态大小类型，可通过特质名称引用。在第 18 章 “使用特质对象抽象共享行为” 中提过：将特质用作特质对象时，必须置于指针后（如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code>，<code>Rc&lt;dyn Trait&gt;</code> 也可行）。</p>
<p>To work with DSTs, Rust provides the <code>Sized</code> trait to determine whether or not
a type’s size is known at compile time. This trait is automatically implemented
for everything whose size is known at compile time. In addition, Rust
implicitly adds a bound on <code>Sized</code> to every generic function. That is, a
generic function definition like this:</p>
<p>为处理 DST，Rust 提供 <code>Sized</code> 特质判断类型大小是否在编译时可知。<span class="highlight">[note]该特质会自动为所有编译期可确定大小的类型实现。此外，Rust 隐式为每个泛型函数添加 <code>Sized</code> 约束。</span>即如下泛型函数定义：</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>is actually treated as though we had written this:</p>
<p>实际被视为：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:</p>
<p>默认情况下，泛型函数仅适用于编译期已知大小的类型。但可用特殊语法放宽限制：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>A trait bound on <code>?Sized</code> means “<code>T</code> may or may not be <code>Sized</code>” and this
notation overrides the default that generic types must have a known size at
compile time. The <code>?Trait</code> syntax with this meaning is only available for
<code>Sized</code>, not any other traits.</p>
<p><code>?Sized</code> 特质约束表示 “<code>T</code> 可能是也可能不是 <code>Sized</code>”，此注解覆盖了泛型类型必须在编译期有已知大小的默认行为。<code>?Trait</code> 语法目前仅适用于 <code>Sized</code>，不适用于其他特质。</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>.
Because the type might not be <code>Sized</code>, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.</p>
<p>另请注意：将参数 <code>t</code> 类型从 <code>T</code> 改为 <code>&amp;T</code>。因类型可能非 <code>Sized</code>，需通过某种指针使用。本例中我们选择了引用。</p>
<p>Next, we’ll talk about functions and closures!</p>
<p>接下来我们将探讨函数与闭包！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-functions-and-closures-高级函数与闭包"><a class="header" href="#advanced-functions-and-closures-高级函数与闭包">Advanced Functions and Closures 高级函数与闭包</a></h2>
<p>This section explores some advanced features related to functions and closures,
including function pointers and returning closures.</p>
<p>本节探讨一些与函数和闭包相关的高级特性，包括函数指针和返回闭包。</p>
<h3 id="function-pointers--函数指针"><a class="header" href="#function-pointers--函数指针">Function Pointers  函数指针</a></h3>
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Functions
coerce to the type <code>fn</code> (with a lowercase <em>f</em>), not to be confused with the
<code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. Passing
functions with function pointers will allow you to use functions as arguments
to other functions.</p>
<p>我们已经讨论过如何将闭包传递给函数；你也可以将常规函数传递给函数！当你想要传递一个已定义的函数而不是定义一个新的闭包时，这项技术很有用。<span class="highlight">[note]函数会被强制转换为 <code>fn</code> 类型</span>（小写的 <em>f</em>），不要与<code>Fn</code> 闭包特质（trait）混淆。<code>fn</code> 类型被称为 <em>函数指针</em>。使用函数指针传递函数将允许你将函数用作其他函数的参数。</p>
<p>The syntax for specifying that a parameter is a function pointer is similar to
that of closures, as shown in Listing 20-28, where we’ve defined a function
<code>add_one</code> that adds 1 to its parameter. The function <code>do_twice</code> takes two
parameters: a function pointer to any function that takes an <code>i32</code> parameter
and returns an <code>i32</code>, and one <code>i32</code> value. The <code>do_twice</code> function calls the
function <code>f</code> twice, passing it the <code>arg</code> value, then adds the two function call
results together. The <code>main</code> function calls <code>do_twice</code> with the arguments
<code>add_one</code> and <code>5</code>.</p>
<p>指定参数为函数指针的语法与闭包的类似，如代码清单 20-28 所示，其中我们定义了一个函数<code>add_one</code>，它将其参数加 1。函数 <code>do_twice</code> 接受两个参数：一个指向任何接受 <code>i32</code> 参数并返回 <code>i32</code> 的函数的函数指针，以及一个 <code>i32</code> 值。<code>do_twice</code> 函数调用函数 <code>f</code> 两次，将 <code>arg</code> 值传递给它，然后将两次函数调用的结果相加。<code>main</code> 函数以参数<code>add_one</code> 和 <code>5</code> 调用 <code>do_twice</code>。</p>
<figure class="listing" id="listing-20-28">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-28">Listing 20-28</a>: Using the <code>fn</code> type to accept a function pointer as an argument 使用 <code>fn</code> 类型接受函数指针作为参数</figcaption>
</figure>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>此代码打印 <code>The answer is: 12</code>。我们指定 <code>do_twice</code> 中的参数 <code>f</code> 是一个 <code>fn</code>，它接受一个类型为 <code>i32</code> 的参数并返回一个<code>i32</code>。然后我们可以在 <code>do_twice</code> 的函数体中调用 <code>f</code>。在 <code>main</code> 中，我们可以传递函数名 <code>add_one</code> 作为第一个参数给 <code>do_twice</code>。</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>与闭包不同，<code>fn</code> 是一个类型而不是一个特质（trait），因此我们直接指定 <code>fn</code> 作为参数类型，而不是声明一个使用某个 <code>Fn</code> 特质作为特质约束的泛型类型参数。</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), meaning you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.</p>
<p>函数指针实现了所有三个闭包特质（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），这意味着你总是可以将函数指针作为参数传递给期望闭包的函数。最好使用泛型类型和某个闭包特质来编写函数，这样你的函数就可以接受函数或闭包。</p>
<p>That said, one example of where you would want to only accept <code>fn</code> and not
closures is when interfacing with external code that doesn’t have closures: C
functions can accept functions as arguments, but C doesn’t have closures.</p>
<p>话虽如此，一个你可能只想接受 <code>fn</code> 而不接受闭包的例子是与没有闭包的外部代码交互时：C 函数可以接受函数作为参数，但 C 没有闭包。</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of the <code>map</code> method provided by the <code>Iterator</code>
trait in the standard library. To use the <code>map</code> method to turn a vector of
numbers into a vector of strings, we could use a closure, as in Listing 20-29.</p>
<p>作为既可以使用内联定义的闭包也可以使用命名函数的一个例子，我们来看一下标准库中 <code>Iterator</code> 特质提供的 <code>map</code> 方法的使用。要使用 <code>map</code> 方法将数字向量转换为字符串向量，我们可以使用闭包，如代码清单 20-29 所示。</p>
<figure class="listing" id="listing-20-29">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-29">Listing 20-29</a>: Using a closure with the <code>map</code> method to convert numbers to strings 将闭包与 <code>map</code> 方法结合使用以将数字转换为字符串</figcaption>
</figure>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure.
Listing 20-30 shows what this would look like.</p>
<p>或者，我们可以将一个命名函数作为参数传递给 <code>map</code> 来代替闭包。代码清单 20-30 展示了这种情况的样子。</p>
<figure class="listing" id="listing-20-30">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-30">Listing 20-30</a>: Using the <code>String::to_string</code> function with the <code>map</code> method method to convert numbers to strings 将 <code>String::to_string</code> 函数与 <code>map</code> 方法结合使用以将数字转换为字符串</figcaption>
</figure>
<p>Note that we must use the fully qualified syntax that we talked about in
“Advanced Traits” because there are multiple
functions available named <code>to_string</code>.</p>
<p>注意我们必须使用我们在“高级特质”一节中讨论过的完全限定语法（fully qualified syntax），因为有多个可用的名为 <code>to_string</code> 的函数。</p>
<p>Here, we’re using the <code>to_string</code> function defined in the <code>ToString</code> trait,
which the standard library has implemented for any type that implements
<code>Display</code>.</p>
<p>这里，我们使用的是 <code>ToString</code> 特质中定义的 <code>to_string</code> 函数，标准库为任何实现了 <code>Display</code> 的类型实现了该特质。</p>
<p>Recall from “Enum Values” in Chapter 6 that the
name of each enum variant that we define also becomes an initializer function.
We can use these initializer functions as function pointers that implement the
closure traits, which means we can specify the initializer functions as
arguments for methods that take closures, as seen in Listing 20-31.</p>
<p>回忆第 6 章“枚举值”一节，我们定义的每个枚举变体的名称也会成为一个初始化函数。我们可以将这些初始化函数用作实现了闭包特质的函数指针，这意味着我们可以将初始化函数指定为接受闭包的方法的参数，如代码清单 20-31 所示。</p>
<figure class="listing" id="listing-20-31">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-31">Listing 20-31</a>: Using an enum initializer with the <code>map</code> method to create a <code>Status</code> instance from numbers将枚举初始化函数与 <code>map</code> 方法结合使用以从数字创建 <code>Status</code> 实例</figcaption>
</figure>
<p>Here, we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
<p>这里，我们通过使用 <code>Status::Value</code> 的初始化函数，利用 <code>map</code> 调用范围内的每个 <code>u32</code> 值创建 <code>Status::Value</code> 实例。有些人更喜欢这种风格，有些人则更喜欢使用闭包。它们编译后的代码是相同的，因此使用你觉得更清晰的风格即可。</p>
<h3 id="returning-closures-返回闭包"><a class="header" href="#returning-closures-返回闭包">Returning Closures 返回闭包</a></h3>
<p>Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. However, you can’t usually do that with closures because they don’t
have a concrete type that is returnable; you’re not allowed to use the function
pointer <code>fn</code> as a return type if the closure captures any values from its
scope, for example.</p>
<p>闭包由特质表示，这意味着你不能直接返回闭包。在大多数你可能想要返回一个特质的情况下，你可以改为使用实现了该特质的具体类型作为函数的返回值。然而，对于闭包，你通常不能这样做，因为它们没有可返回的具体类型；例如，如果闭包从其作用域捕获了任何值，就不允许使用函数指针 <code>fn</code> 作为返回类型。</p>
<p>Instead, you will normally use the <code>impl Trait</code> syntax we learned about in
Chapter 10. You can return any function type, using <code>Fn</code>, <code>FnOnce</code> and <code>FnMut</code>.
For example, the code in Listing 20-32 will compile just fine.</p>
<p>相反，你通常会使用我们在第 10 章中学到的 <code>impl Trait</code> 语法。你可以返回任何函数类型，使用 <code>Fn</code>、<code>FnOnce</code> 和 <code>FnMut</code>。例如，代码清单 20-32 中的代码可以顺利编译。</p>
<figure class="listing" id="listing-20-32">
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-32">Listing 20-32</a>: Returning a closure from a function using the <code>impl Trait</code> syntax 使用 <code>impl Trait</code> 语法从函数返回闭包</figcaption>
</figure>
<p>However, as we noted in “Closure Type Inference and
Annotation” in Chapter 13, each closure is also
its own distinct type. If you need to work with multiple functions that have the
same signature but different implementations, you will need to use a trait
object for them. Consider what happens if you write code like that shown in
Listing 20-33.</p>
<p>然而，正如我们在第 13 章“闭包类型推断和注解”一节中指出的，每个闭包也是其自身独特（distinct）的类型。如果你需要处理多个具有相同签名但不同实现的函数，你将需要对它们使用特质对象（trait object）。考虑如果你编写如代码清单 20-33 所示的代码会发生什么。</p>
<figure class="listing" id="listing-20-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-33">Listing 20-33</a>: Creating a <code>Vec&lt;T&gt;</code> of closures defined by functions that return <code>impl Fn</code> types 创建一个 <code>Vec&lt;T&gt;</code>，其元素是由返回 <code>impl Fn</code> 类型的函数定义的闭包</figcaption>
</figure>
<p>Here we have two functions, <code>returns_closure</code> and <code>returns_initialized_closure</code>,
which both return <code>impl Fn(i32) -&gt; i32</code>. Notice that the closures that they
return are different, even though they implement the same type. If we try to
compile this, Rust lets us know that it won’t work:</p>
<p>这里我们有两个函数，<code>returns_closure</code> 和 <code>returns_initialized_closure</code>，它们都返回 <code>impl Fn(i32) -&gt; i32</code>。注意它们返回的闭包是不同的，尽管它们实现了相同的类型。如果我们尝试编译此代码，Rust 会告诉我们这行不通：</p>
<pre><code class="language-text">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --&gt; src/main.rs:2:44
   |
2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
9  | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:9:25&gt;)
              found opaque type `impl Fn(i32) -&gt; i32` (opaque type at &lt;src/main.rs:13:46&gt;)
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>The error message tells us that whenever we return an <code>impl Trait</code>, Rust
creates a unique <em>opaque type</em>, a type where we cannot see into the details of
what Rust constructs for us, nor can we guess the type Rust will generate to
write ourselves. So even though these functions return closures that implement
the same trait, <code>Fn(i32) -&gt; i32</code>, the opaque types Rust generates for each are
distinct. (This is similar to how Rust produces different concrete types for
distinct async blocks even when they have the same output type, as we saw in
“Working with Any Number of Futures” in
Chapter 17.) We have seen a solution to this problem a few times now: we can
use a trait object, as in Listing 20-34.</p>
<p>错误信息告诉我们，每当我们<span class="highlight">[note]返回一个 <code>impl Trait</code> 时，Rust 会创建一个唯一的不透明类型（opaque type）</span>，一种我们无法看到 Rust 为我们构造的细节的类型，我们也无法猜测 Rust 将生成什么类型以便我们自己编写。因此，即使这些函数返回实现了相同特质 <code>Fn(i32) -&gt; i32</code> 的闭包，Rust 为每个生成的不透明类型也是不同的。（这类似于 Rust 如何为不同的异步块生成不同的具体类型，即使它们具有相同的输出类型，正如我们在第 17 章“处理任意数量的 Future”一节中所见。）我们现在已经多次看到这个问题的解决方案：我们可以使用特质对象，如代码清单 20-34 所示。</p>
<figure class="listing" id="listing-20-34">
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre></pre>
<figcaption><a href="ch20-04-advanced-functions-and-closures.html#listing-20-34">Listing 20-34</a>: Creating a <code>Vec&lt;T&gt;</code> of closures defined by functions that return <code>Box&lt;dyn Fn&gt;</code> so they have the same type 创建一个 <code>Vec&lt;T&gt;</code>，其元素是由返回 <code>Box&lt;dyn Fn&gt;</code> 的函数定义的闭包，以便它们具有相同的类型</figcaption>
</figure>
<p>This code will compile just fine. For more about trait objects, refer to the
section “Using Trait Objects That Allow for Values of Different
Types” in Chapter 18.</p>
<p>这段代码将顺利编译。有关特质对象的更多信息，请参阅第 18 章“使用允许不同类型值的特质对象”一节。</p>
<p>Next, let’s look at macros!</p>
<p>接下来，让我们看看宏（macros）！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros-宏"><a class="header" href="#macros-宏">Macros 宏</a></h2>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds
of <em>procedural</em> macros:</p>
<p>我们在本书中一直使用像 <code>println!</code> 这样的宏，但还没有深入探讨宏是什么以及它是如何工作的。术语 <em>宏</em> 指的是 Rust 中的一系列功能：使用 <code>macro_rules!</code> 的 <em>声明式</em> 宏，以及三种 <em>过程式</em> 宏：</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<!-- -->
<ul>
<li>自定义 <code>#[derive]</code> 宏：用于在结构体和枚举上通过 <code>derive</code> 属性指定添加的代码</li>
<li>类属性宏：可定义适用于任意项目的自定义属性</li>
<li>类函数宏：外观类似函数调用，但作用于作为参数指定的令牌</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<p>我们将依次讨论这些宏，但首先，让我们看看既然已有函数，为什么还需要宏。</p>
<h3 id="the-difference-between-macros-and-functions-宏与函数的区别"><a class="header" href="#the-difference-between-macros-and-functions-宏与函数的区别">The Difference Between Macros and Functions 宏与函数的区别</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We’ve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you’ve written manually.</p>
<p>从根本上说，宏是一种编写代码来生成其他代码的方式，这被称为 <em>元编程</em>。在附录 C 中，我们讨论了 <code>derive</code> 属性，它会为你生成各种 trait 的实现。我们在书中也使用了 <code>println!</code> 和 <code>vec!</code> 宏。所有这些宏都会通过 <em>展开</em> 生成比你手动编写的代码更多的代码。</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t have.</p>
<p>元编程有助于减少需要编写和维护的代码量，这也是函数的作用之一。然而，宏具备一些函数所没有的额外能力。</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!("hello")</code> with one argument or
<code>println!("hello {}", name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>函数的签名必须声明其参数的个数和类型。而宏可以接受可变数量的参数：我们可以用一个参数调用 <code>println!("hello")</code>，也可以用两个参数调用 <code>println!("hello {}", name)</code>。此外，宏在编译器解释代码含义之前就已展开，因此宏可以在给定类型上实现 trait。函数则无法做到这一点，因为它是在运行时被调用的，而 trait 需要在编译时实现。</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>与函数相比，实现宏的缺点在于宏定义比函数定义更复杂，因为你需要编写生成 Rust 代码的 Rust 代码。由于这种间接性，宏定义通常比函数定义更难阅读、理解和维护。</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<p>宏与函数的另一个重要区别是：在文件中调用宏之前，必须先定义宏或将其引入作用域；而函数则可以在任意位置定义并在任意位置调用。</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming-使用-macro_rules-的声明式宏进行通用元编程"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming-使用-macro_rules-的声明式宏进行通用元编程">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming 使用 <code>macro_rules!</code> 的声明式宏进行通用元编程</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These
are also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,”
or just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resultant value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.</p>
<p>Rust 中最广泛使用的宏形式是 <em>声明式宏</em>。它们有时也被称为“示例宏”、“<code>macro_rules!</code> 宏”或简称为“宏”。声明式宏的核心是允许你编写类似于 Rust <code>match</code> 表达式的结构。如第 6 章所述，<code>match</code> 表达式是控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式关联的代码。宏也会将值与特定代码的模式进行比较：在这种情况下，值是将传递给宏的原始 Rust 源代码；模式与该源代码的结构进行比较；当匹配时，与每个模式关联的代码将替换传递给宏的代码。这一切都发生在编译期间。</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:</p>
<p>要定义宏，需要使用 <code>macro_rules!</code> 结构。让我们通过了解 <code>vec!</code> 宏的定义方式来探索如何使用 <code>macro_rules!</code>。第 8 章介绍了如何使用 <code>vec!</code> 宏创建包含特定值的新向量。例如，以下宏创建了一个包含三个整数的新向量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.</p>
<p>我们也可以用 <code>vec!</code> 宏创建包含两个整数的向量或包含五个字符串切片的向量。我们无法使用函数实现相同的功能，因为无法提前知道值的数量或类型。</p>
<p>Listing 20-35 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<p>代码清单 20-35 展示了 <code>vec!</code> 宏的一个略微简化的定义。</p>
<figure class="listing" id="listing-20-35">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-35">Listing 20-35</a>: A simplified version of the <code>vec!</code> macro definition <code>vec!</code> 宏定义的简化版本</figcaption>
</figure>
<section class="note" aria-role="note">
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to pre-allocate the correct amount of memory up front. That code
is an optimization that we don’t include here, to make the example simpler.</p>
<p>注意：标准库中 <code>vec!</code> 宏的实际定义包含预先分配正确内存量的代码。这段代码是优化措施，为使示例简单，此处未包含。</p>
</section>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.</p>
<p><code>#[macro_export]</code> 注解表示每当定义宏的 crate 被引入作用域时，此宏都应可用。没有此注解，宏将无法被引入作用域。</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we’re defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>接着我们以 <code>macro_rules!</code> 和要定义的宏名称（<em>不带</em> 感叹号）开始宏定义。这里的名称是 <code>vec</code>，后面跟着表示宏定义主体的花括号。</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.</p>
<p><code>vec!</code> 主体中的结构类似于 <code>match</code> 表达式的结构。这里我们有一个模式为 <code>( $( $x:expr ),* )</code> 的分支，后跟 <code>=&gt;</code> 和与此模式关联的代码块。如果模式匹配，将生成关联的代码块。鉴于这是此宏中唯一的模式，只有一种有效的匹配方式；任何其他模式都将导致错误。更复杂的宏会有多个分支。</p>
<p>Valid pattern syntax in macro definitions is different from the pattern syntax
covered in Chapter 19 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 20-29 mean; for the full macro pattern syntax, see the Rust
Reference.</p>
<p>宏定义中的有效模式语法与第 19 章介绍的模式语法不同，因为宏模式是针对 Rust 代码结构进行匹配，而不是针对值。让我们逐步分析代码清单 20-29 中模式各部分的意义；完整的宏模式语法请参阅 Rust 参考手册。</p>
<p>First we use a set of parentheses to encompass the whole pattern. We use a
dollar sign (<code>$</code>) to declare a variable in the macro system that will contain
the Rust code matching the pattern. The dollar sign makes it clear this is a
macro variable as opposed to a regular Rust variable. Next comes a set of
parentheses that captures values that match the pattern within the parentheses
for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any
Rust expression and gives the expression the name <code>$x</code>.</p>
<p>首先，我们使用一对括号包裹整个模式。我们在宏系统中使用美元符号 (<code>$</code>) 声明一个变量，该变量将包含与模式匹配的 Rust 代码。美元符号明确表示这是一个宏变量，而非普通的 Rust 变量。接下来是一对括号，用于捕获括号内与模式匹配的值，以便在替换代码中使用。在 <code>$()</code> 内部是 <code>$x:expr</code>，它匹配任何 Rust 表达式并将该表达式命名为 <code>$x</code>。</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
must appear between each instance of the code that matches the code in <code>$()</code>.
The <code>*</code> specifies that the pattern matches zero or more of whatever precedes
the <code>*</code>.</p>
<p><code>$()</code> 后面的逗号表示在匹配 <code>$()</code> 中代码的每个实例之间必须出现一个字面逗号分隔符。<code>*</code> 指定该模式匹配零次或多次 <code>*</code> 前面的内容。</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>当我们用 <code>vec![1, 2, 3];</code> 调用此宏时，<code>$x</code> 模式会匹配三次，分别对应表达式 <code>1</code>、<code>2</code> 和 <code>3</code>。</p>
<p>Now let’s look at the pattern in the body of the code associated with this arm:
<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>
in the pattern zero or more times depending on how many times the pattern
matches. The <code>$x</code> is replaced with each expression matched. When we call this
macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call
will be the following:</p>
<p>现在让我们看与此分支主体中模式关联的代码：<code>$()*</code> 内的 <code>temp_vec.push()</code> 会根据模式匹配 <code>$()</code> 的次数生成零次或多次。<code>$x</code> 被替换为每个匹配的表达式。当我们用 <code>vec![1, 2, 3];</code> 调用此宏时，替换此宏调用的生成代码将如下：</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>我们定义了一个可以接受任意数量、任意类型参数，并能生成代码来创建包含指定元素的向量的宏。</p>
<p>To learn more about how to write macros, consult the online documentation or
other resources, such as “The Little Book of Rust Macros” started by
Daniel Keep and continued by Lukas Wirth.</p>
<p>要了解更多关于编写宏的信息，请查阅在线文档或其他资源，例如由 Daniel Keep 发起、Lukas Wirth 继续维护的“The Little Book of Rust Macros”。</p>
<h3 id="procedural-macros-for-generating-code-from-attributes-用于从属性生成代码的过程式宏"><a class="header" href="#procedural-macros-for-generating-code-from-attributes-用于从属性生成代码的过程式宏">Procedural Macros for Generating Code from Attributes 用于从属性生成代码的过程式宏</a></h3>
<p>The second form of macros is the procedural macro, which acts more like a
function (and is a type of procedure). <em>Procedural macros</em> accept some code as
an input, operate on that code, and produce some code as an output rather than
matching against patterns and replacing the code with other code as declarative
macros do. The three kinds of procedural macros are custom <code>derive</code>,
attribute-like, and function-like, and all work in a similar fashion.</p>
<p>第二种宏形式是过程式宏，它的行为更像函数（并且是一种过程）。<em>过程式宏</em> 接受一些代码作为输入，对这些代码进行操作，然后生成一些代码作为输出，而不是像声明式宏那样匹配模式并用其他代码替换代码。过程式宏的三种类型是自定义 <code>derive</code>、类属性和类函数宏，它们的工作方式相似。</p>
<p>When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. In Listing 20-36, we show how to define a
procedural macro, where <code>some_attribute</code> is a placeholder for using a specific
macro variety.</p>
<p>创建过程式宏时，其定义必须位于具有特殊 crate 类型的独立 crate 中。这是出于复杂的技术原因，我们希望将来能消除此限制。在代码清单 20-36 中，我们展示了如何定义过程式宏，其中 <code>some_attribute</code> 是使用特定宏变体的占位符。</p>
<figure class="listing" id="listing-20-36">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-36">Listing 20-36</a>: An example of defining a procedural macro 定义过程式宏的示例</figcaption>
</figure>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input
and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by
the <code>proc_macro</code> crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input <code>TokenStream</code>, and the code the macro produces
is the output <code>TokenStream</code>. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.</p>
<p>定义过程式宏的函数接受一个 <code>TokenStream</code> 作为输入，并生成一个 <code>TokenStream</code> 作为输出。<code>TokenStream</code> 类型由 Rust 附带的 <code>proc_macro</code> crate 定义，表示一系列令牌。这是宏的核心：宏操作所针对的源代码构成输入 <code>TokenStream</code>，而宏生成的代码则是输出 <code>TokenStream</code>。该函数还附加了一个属性，用于指定我们正在创建的过程式宏的类型。我们可以在同一个 crate 中包含多种过程式宏。</p>
<p>Let’s look at the different kinds of procedural macros. We’ll start with a
custom <code>derive</code> macro and then explain the small dissimilarities that make the
other forms different.</p>
<p>让我们看看不同类型的过程式宏。我们将从自定义 <code>derive</code> 宏开始，然后解释其他形式的不同之处。</p>
<h3 id="how-to-write-a-custom-derive-macro-如何编写自定义-derive-宏"><a class="header" href="#how-to-write-a-custom-derive-macro-如何编写自定义-derive-宏">How to Write a Custom <code>derive</code> Macro 如何编写自定义 <code>derive</code> 宏</a></h3>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our users implement the <code>HelloMacro</code> trait for each of their types,
we’ll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 20-37 using our crate.</p>
<p>让我们创建一个名为 <code>hello_macro</code> 的 crate，其中定义了一个名为 <code>HelloMacro</code> 的 trait，该 trait 有一个名为 <code>hello_macro</code> 的关联函数。我们不是让用户为每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程式宏，以便用户可以通过 <code>#[derive(HelloMacro)]</code> 注解其类型，从而获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如代码清单 20-37 所示的代码。</p>
<figure class="listing" id="listing-20-37">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-37">Listing 20-37</a>: The code a user of our crate will be able to write when using our procedural macro 用户在使用我们的过程式宏时可编写的代码</figcaption>
</figure>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The
first step is to make a new library crate, like this:</p>
<p>完成后，此代码将打印 <code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库 crate，如下所示：</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, in Listing 20-38, we’ll define the <code>HelloMacro</code> trait and its associated
function.</p>
<p>接下来，在代码清单 20-38 中，我们将定义 <code>HelloMacro</code> trait 及其关联函数。</p>
<figure class="listing" id="listing-20-38">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-38">Listing 20-38</a>: A simple trait that we will use with the <code>derive</code> macro 我们将与 <code>derive</code> 宏一起使用的简单 trait</figcaption>
</figure>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, as in Listing 20-39.</p>
<p>我们定义了一个 trait 及其函数。此时，我们的 crate 用户可以通过实现该 trait 来实现所需功能，如代码清单 20-39 所示。</p>
<figure class="listing" id="listing-20-39">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-39">Listing 20-39</a>: How it would look if users wrote a manual implementation of the <code>HelloMacro</code> trait 如果用户手动实现 <code>HelloMacro</code> trait 时的代码</figcaption>
</figure>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>但是，他们需要为他们希望与 <code>hello_macro</code> 一起使用的每个类型编写实现块；我们想让他们省去这项工作。</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.</p>
<p>此外，我们还无法为 <code>hello_macro</code> 函数提供默认实现来打印实现该 trait 的类型的名称：Rust 不具备反射能力，因此无法在运行时查找类型的名称。我们需要一个在编译时生成代码的宏。</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom <code>derive</code> procedural macro crate is
called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<p>下一步是定义过程式宏。在撰写本文时，过程式宏需要位于它们自己的 crate 中。最终，此限制可能会被取消。组织 crate 和宏 crate 的约定如下：对于名为 <code>foo</code> 的 crate，自定义 <code>derive</code> 过程式宏 crate 称为 <code>foo_derive</code>。让我们在 <code>hello_macro</code> 项目中启动一个名为 <code>hello_macro_derive</code> 的新 crate：</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we’ll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don’t want the
<code>derive</code> functionality.</p>
<p>我们的两个 crate 紧密相关，因此我们在 <code>hello_macro</code> crate 的目录中创建过程式宏 crate。如果我们更改 <code>hello_macro</code> 中的 trait 定义，也必须更改 <code>hello_macro_derive</code> 中过程式宏的实现。这两个 crate 需要单独发布，使用这些 crate 的程序员需要将两者都添加为依赖项并引入作用域。或者，我们可以让 <code>hello_macro</code> crate 使用 <code>hello_macro_derive</code> 作为依赖项并重新导出过程式宏代码。然而，我们构建项目的方式使得程序员即使不需要 <code>derive</code> 功能也可以使用 <code>hello_macro</code>。</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p>我们需要将 <code>hello_macro_derive</code> crate 声明为过程式宏 crate。我们还需要 <code>syn</code> 和 <code>quote</code> crate 的功能，稍后你会看到，因此需要将它们添加为依赖项。将以下内容添加到 <code>hello_macro_derive</code> 的 <em>Cargo.toml</em> 文件中：</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/Cargo.toml</span>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</figure>
<p>To start defining the procedural macro, place the code in Listing 20-40 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p>要开始定义过程式宏，请将代码清单 20-40 中的代码放入 <code>hello_macro_derive</code> crate 的 <em>src/lib.rs</em> 文件中。请注意，在添加 <code>impl_hello_macro</code> 函数的定义之前，此代码不会编译。</p>
<figure class="listing" id="listing-20-40">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&amp;ast)
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-40">Listing 20-40</a>: Code that most procedural macro crates will require in order to process Rust code 大多数过程式宏 crate 处理 Rust 代码所需的代码</figcaption>
</figure>
<p>Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which
is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(<code>hello_macro_derive</code> in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (<code>impl_hello_macro</code> in this case) will be different
depending on your procedural macro’s purpose.</p>
<p>请注意，我们将代码拆分为 <code>hello_macro_derive</code> 函数（负责解析 <code>TokenStream</code>）和 <code>impl_hello_macro</code> 函数（负责转换语法树）：这使得编写过程式宏更加方便。外部函数（此处为 <code>hello_macro_derive</code>）的代码几乎与你看到或创建的每个过程式宏 crate 相同。内部函数（此处为 <code>impl_hello_macro</code>）主体中指定的代码将根据过程式宏的目的而有所不同。</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <code>syn</code>,
and <code>quote</code>. The <code>proc_macro</code> crate comes with Rust,
so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. The
<code>proc_macro</code> crate is the compiler’s API that allows us to read and manipulate
Rust code from our code.</p>
<p>我们引入了三个新的 crate：<code>proc_macro</code>、<code>syn</code> 和 <code>quote</code>。<code>proc_macro</code> crate 随 Rust 一起提供，因此无需将其添加到 <em>Cargo.toml</em> 的依赖项中。<code>proc_macro</code> crate 是编译器的 API，允许我们从代码中读取和操作 Rust 代码。</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we
can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.</p>
<p><code>syn</code> crate 将 Rust 代码从字符串解析为我们可以执行操作的数据结构。<code>quote</code> crate 将 <code>syn</code> 数据结构转换回 Rust 代码。这些 crate 极大地简化了解析我们可能希望处理的任何类型的 Rust 代码：为 Rust 代码编写完整的解析器并非易事。</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve
annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and
specified the name <code>HelloMacro</code>, which matches our trait name; this is the
convention most procedural macros follow.</p>
<p>当库用户在类型上指定 <code>#[derive(HelloMacro)]</code> 时，将调用 <code>hello_macro_derive</code> 函数。这是可行的，因为我们在此处用 <code>proc_macro_derive</code> 注解了 <code>hello_macro_derive</code> 函数，并指定了名称 <code>HelloMacro</code>，这与我们的 trait 名称相匹配；这是大多数过程式宏遵循的约定。</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a
<code>TokenStream</code> to a data structure that we can then interpret and perform
operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in
<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the
parsed Rust code. Listing 20-41 shows the relevant parts of the <code>DeriveInput</code>
struct we get from parsing the <code>struct Pancakes;</code> string.</p>
<p><code>hello_macro_derive</code> 函数首先将 <code>input</code> 从 <code>TokenStream</code> 转换为我们可以解释和执行操作的数据结构。这就是 <code>syn</code> 发挥作用的地方。<code>syn</code> 中的 <code>parse</code> 函数接受 <code>TokenStream</code> 并返回一个表示已解析 Rust 代码的 <code>DeriveInput</code> 结构体。代码清单 20-41 展示了通过解析 <code>struct Pancakes;</code> 字符串得到的 <code>DeriveInput</code> 结构体的相关部分。</p>
<figure class="listing" id="listing-20-41">
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-41">Listing 20-41</a>: The <code>DeriveInput</code> instance we get when parsing the code that has the macro’s attribute in Listing 20-37 解析包含代码清单 20-37 中宏属性的代码时得到的 <code>DeriveInput</code> 实例</figcaption>
</figure>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (<em>identifier</em>, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <code>syn</code>
documentation for <code>DeriveInput</code> for more information.</p>
<p>此结构体的字段表明我们解析的 Rust 代码是一个单元结构体，其 <code>ident</code>（标识符，即名称）为 <code>Pancakes</code>。此结构体上还有更多字段用于描述各种 Rust 代码；有关更多信息，请参阅 <code>syn</code> 文档中关于 <code>DeriveInput</code> 的部分。</p>
<p>Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our <code>derive</code> macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
<code>TokenStream</code>.</p>
<p>稍后我们将定义 <code>impl_hello_macro</code> 函数，用于构建我们希望包含的新 Rust 代码。但在此之前，请注意我们的 <code>derive</code> 宏的输出也是一个 <code>TokenStream</code>。返回的 <code>TokenStream</code> 会添加到 crate 用户编写的代码中，因此当他们编译其 crate 时，将获得我们在修改后的 <code>TokenStream</code> 中提供的额外功能。</p>
<p>You might have noticed that we’re calling <code>unwrap</code> to cause the
<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function
fails here. It’s necessary for our procedural macro to panic on errors because
<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to
conform to the procedural macro API. We’ve simplified this example by using
<code>unwrap</code>; in production code, you should provide more specific error messages
about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>你可能注意到我们调用了 <code>unwrap</code>，如果对 <code>syn::parse</code> 函数的调用在此处失败，会导致 <code>hello_macro_derive</code> 函数 panic。过程式宏在出错时 panic 是必要的，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> 以符合过程式宏 API。我们通过使用 <code>unwrap</code> 简化了此示例；在生产代码中，应使用 <code>panic!</code> 或 <code>expect</code> 提供关于出错原因的更具体错误消息。</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let’s generate the code that implements the
<code>HelloMacro</code> trait on the annotated type, as shown in Listing 20-42.</p>
<p>现在我们有了将带注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们在带注解的类型上生成实现 <code>HelloMacro</code> trait 的代码，如代码清单 20-42 所示。</p>
<figure class="listing" id="listing-20-42">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}</code></pre>
<figcaption><a href="ch20-05-macros.html#listing-20-42">Listing 20-42</a>: Implementing the <code>HelloMacro</code> trait using the parsed Rust code 使用解析后的 Rust 代码实现 <code>HelloMacro</code> trait</figcaption>
</figure>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 20-41 shows that when
we run the <code>impl_hello_macro</code> function on the code in Listing 20-37, the
<code>ident</code> we get will have the <code>ident</code> field with a value of <code>"Pancakes"</code>. Thus
the <code>name</code> variable in Listing 20-42 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>"Pancakes"</code>, the name of the struct in
Listing 20-37.</p>
<p>我们使用 <code>ast.ident</code> 获取包含带注解类型名称（标识符）的 <code>Ident</code> 结构体实例。代码清单 20-41 中的结构体表明，当我们在代码清单 20-37 中的代码上运行 <code>impl_hello_macro</code> 函数时，得到的 <code>ident</code> 的 <code>ident</code> 字段值为 <code>"Pancakes"</code>。因此，代码清单 20-42 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时将是字符串 <code>"Pancakes"</code>，即代码清单 20-37 中结构体的名称。</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the <code>quote!</code>
macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by
calling the <code>into</code> method, which consumes this intermediate representation and
returns a value of the required <code>TokenStream</code> type.</p>
<p><code>quote!</code> 宏让我们能够定义希望返回的 Rust 代码。编译器期望的内容与 <code>quote!</code> 宏执行的直接结果不同，因此我们需要将其转换为 <code>TokenStream</code>。我们通过调用 <code>into</code> 方法来实现，该方法会使用此中间表示并返回所需类型 <code>TokenStream</code> 的值。</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can
enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
<code>name</code>. You can even do some repetition similar to the way regular macros work.
Check out the <code>quote</code> crate’s docs for a thorough introduction.</p>
<p><code>quote!</code> 宏还提供了一些非常酷的模板机制：我们可以输入 <code>#name</code>，<code>quote!</code> 将用变量 <code>name</code> 中的值替换它。你甚至可以执行类似于常规宏工作的重复操作。有关完整介绍，请查看 <code>quote</code> crate 的文档。</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has the one function <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>我们希望过程式宏为用户注解的类型生成 <code>HelloMacro</code> trait 的实现，我们可以通过 <code>#name</code> 获取该类型。trait 实现有一个函数 <code>hello_macro</code>，其主体包含我们希望提供的功能：打印 <code>Hello, Macro! My name is</code>，然后是带注解类型的名称。</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>"1 + 2"</code>. This is different from <code>format!</code> or
<code>println!</code>, macros which evaluate the expression and then turn the result into
a <code>String</code>. There is a possibility that the <code>#name</code> input might be an
expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also
saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>这里使用的 <code>stringify!</code> 宏是 Rust 内置的。它接受一个 Rust 表达式（例如 <code>1 + 2</code>），并在编译时将该表达式转换为字符串字面量（例如 <code>"1 + 2"</code>）。这与 <code>format!</code> 或 <code>println!</code> 宏不同，后者会计算表达式然后将结果转换为 <code>String</code>。<code>#name</code> 输入可能是一个要逐字打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省一次内存分配。</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing
20-37 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they
would be regular dependencies; if not, you can specify them as <code>path</code>
dependencies as follows:</p>
<p>此时，在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 中，<code>cargo build</code> 应该都能成功完成。让我们将这些 crate 与代码清单 20-37 中的代码连接起来，看看过程式宏的实际效果！使用 <code>cargo new pancakes</code> 在你的 <em>projects</em> 目录中创建一个新的二进制项目。我们需要在 <code>pancakes</code> crate 的 <em>Cargo.toml</em> 中将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 添加为依赖项。如果你要将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/">crates.io</a>，它们将是常规依赖项；否则，可以将它们指定为 <code>path</code> 依赖项，如下所示：</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Put the code in Listing 20-37 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>将代码清单 20-37 中的代码放入 <em>src/main.rs</em>，然后运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code>。来自过程式宏的 <code>HelloMacro</code> trait 实现已被包含，而 <code>pancakes</code> crate 无需实现它；<code>#[derive(HelloMacro)]</code> 添加了 trait 实现。</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom
<code>derive</code> macros.</p>
<p>接下来，让我们探讨其他类型的过程式宏与自定义 <code>derive</code> 宏的区别。</p>
<h3 id="attribute-like-macros-类属性宏"><a class="header" href="#attribute-like-macros-类属性宏">Attribute-Like Macros 类属性宏</a></h3>
<p>Attribute-like macros are similar to custom <code>derive</code> macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They’re also more flexible: <code>derive</code> only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro. Say you have an attribute
named <code>route</code> that annotates functions when using a web application framework:</p>
<p>类属性宏类似于自定义 <code>derive</code> 宏，但它们不是为 <code>derive</code> 属性生成代码，而是允许你创建新属性。它们也更灵活：<code>derive</code> 仅适用于结构体和枚举；属性也可应用于其他项目，例如函数。以下是使用类属性宏的示例。假设在使用 Web 应用程序框架时，你有一个名为 <code>route</code> 的属性用于注解函数：</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:</p>
<p>此 <code>#[route]</code> 属性将由框架定义为过程式宏。宏定义函数的签名如下所示：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the
contents of the attribute: the <code>GET, "/"</code> part. The second is the body of the
item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest
of the function’s body.</p>
<p>这里，我们有两个 <code>TokenStream</code> 类型的参数。第一个用于属性的内容：<code>GET, "/"</code> 部分。第二个是属性所附加项目的主体：在本例中是 <code>fn index() {}</code> 和函数的其余主体。</p>
<p>Other than that, attribute-like macros work the same way as custom <code>derive</code>
macros: you create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<p>除此之外，类属性宏的工作方式与自定义 <code>derive</code> 宏相同：创建一个具有 <code>proc-macro</code> crate 类型的 crate，并实现一个生成所需代码的函数！</p>
<h3 id="function-like-macros-类函数宏"><a class="header" href="#function-like-macros-类函数宏">Function-Like Macros 类函数宏</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can only
be defined using the match-like syntax we discussed in “Declarative Macros with
<code>macro_rules!</code> for General Metaprogramming” earlier.
Function-like macros take a <code>TokenStream</code> parameter, and their definition
manipulates that <code>TokenStream</code> using Rust code as the other two types of
procedural macros do. An example of a function-like macro is an <code>sql!</code> macro
that might be called like so:</p>
<p>类函数宏定义了外观类似函数调用的宏。与 <code>macro_rules!</code> 宏类似，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code> 宏只能使用前面“使用 <code>macro_rules!</code> 的声明式宏进行通用元编程”中讨论的类匹配语法来定义。类函数宏接受一个 <code>TokenStream</code> 参数，其定义使用 Rust 代码操作该 <code>TokenStream</code>，就像其他两种过程式宏一样。类函数宏的一个例子是 <code>sql!</code> 宏，它可能被这样调用：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<p>此宏会解析其内部的 SQL 语句并检查其语法是否正确，这比 <code>macro_rules!</code> 宏能做的处理复杂得多。<code>sql!</code> 宏的定义如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>This definition is similar to the custom <code>derive</code> macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<p>此定义类似于自定义 <code>derive</code> 宏的签名：我们接收括号内的令牌，并返回希望生成的代码。</p>
<h2 id="summary-总结-19"><a class="header" href="#summary-总结-19">Summary 总结</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use
often, but you’ll know they’re available in very particular circumstances.
We’ve introduced several complex topics so that when you encounter them in
error message suggestions or in other people’s code, you’ll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>呼！现在你的工具箱中有一些 Rust 功能，可能不会经常使用，但你会知道它们在特定情况下是可用的。我们介绍了几个复杂的主题，以便当你在错误消息建议或他人代码中遇到它们时，能够识别这些概念和语法。使用本章作为参考来指导你找到解决方案。</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
<p>接下来，我们将把全书讨论的所有内容付诸实践，并再做一个项目！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-building-a-multithreaded-web-server-最终项目构建多线程web服务器"><a class="header" href="#final-project-building-a-multithreaded-web-server-最终项目构建多线程web服务器">Final Project: Building a Multithreaded Web Server 最终项目：构建多线程Web服务器</a></h1>
<p>It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.</p>
<p>这段旅程很长，但我们终于抵达了本书的终点。在本章中，我们将共同构建最后一个项目，用于演示在最后几章中涵盖的概念，并回顾一些早期的课程。</p>
<p>For our final project, we’ll make a web server that says “hello” and looks like
Figure 21-1 in a web browser.</p>
<p>对于我们的最终项目，我们将创建一个在Web浏览器中显示“你好“的Web服务器，效果类似图21-1。</p>
<p><img src="img/trpl21-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 21-1: Our final shared project 我们的最终共享项目</span></p>
<p>Here is our plan for building the web server:</p>
<p>这是我们构建Web服务器的计划：</p>
<ol>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ol>
<!-- -->
<ol>
<li>学习一些关于TCP和HTTP的知识</li>
<li>在套接字上监听TCP连接</li>
<li>解析少量HTTP请求</li>
<li>创建正确的HTTP响应</li>
<li>使用线程池提高服务器的吞吐量</li>
</ol>
<p>Before we get started, we should mention two details. First, the method we’ll
use won’t be the best way to build a web server with Rust. Community members
have published a number of production-ready crates available on
<a href="https://crates.io/">crates.io</a> that provide more complete web server and thread
pool implementations than we’ll build. However, our intention in this chapter is
to help you learn, not to take the easy route. Because Rust is a systems
programming language, we can choose the level of abstraction we want to work
with and can go to a lower level than is possible or practical in other
languages.</p>
<p>在开始之前，我们应该说明两个细节。首先，我们将使用的方法不是用Rust构建Web服务器的最佳方式。社区成员已在<a href="https://crates.io/">crates.io</a>上发布了许多可用于生产环境的crate，它们提供了比我们将构建的更完整的Web服务器和线程池实现。然而，我们在本章的意图是帮助你学习，而不是走捷径。因为Rust是一种系统编程语言，我们可以选择想要工作的抽象级别，并且可以深入到其他语言无法达到或实际不可行的较低级别。</p>
<p>Second, we will not be using async and await here. Building a thread pool is a
big enough challenge on its own, without adding in building an async runtime!
However, we will note how async and await might be applicable to some of the
same problems we will see in this chapter. Ultimately, as we noted back in
Chapter 17, many async runtimes use thread pools for managing their work.</p>
<p>其次，我们这里不会使用async和await。构建线程池本身就是一个足够大的挑战，无需再添加构建异步运行时的任务！不过，我们会注意到async和await可能如何适用于本章中我们将看到的相同问题。最终，正如我们在第17章提到的，许多异步运行时使用线程池来管理工作。</p>
<p>We’ll therefore write the basic HTTP server and thread pool manually so you can
learn the general ideas and techniques behind the crates you might use in the
future.</p>
<p>因此，我们将手动编写基本的HTTP服务器和线程池，以便你了解未来可能使用的crate背后的通用思想和技术。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-a-single-threaded-web-server-构建单线程web服务器"><a class="header" href="#building-a-single-threaded-web-server-构建单线程web服务器">Building a Single-Threaded Web Server 构建单线程Web服务器</a></h2>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>我们将从使单线程Web服务器工作开始。在开始之前，让我们快速概述构建Web服务器所涉及的协议。这些协议的细节超出了本书的范围，但简要概述将为你提供所需的信息。</p>
<p>The two main protocols involved in web servers are <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both protocols
are <em>request-response</em> protocols, meaning a <em>client</em> initiates requests and a
<em>server</em> listens to the requests and provides a response to the client. The
contents of those requests and responses are defined by the protocols.</p>
<p>Web服务器涉及的两个主要协议是超文本传输协议(HTTP)和传输控制协议(TCP)。这两种协议都是请求-响应协议，意味着客户端发起请求，服务器监听请求并向客户端提供响应。这些请求和响应的内容由协议定义。</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<p>TCP是较低级别的协议，描述了信息如何从一台服务器传递到另一台服务器的细节，但没有指定该信息是什么。HTTP建立在TCP之上，定义了请求和响应的内容。从技术上讲，可以将HTTP与其他协议一起使用，但在绝大多数情况下，HTTP通过TCP发送其数据。我们将处理TCP和HTTP请求及响应的原始字节。</p>
<h3 id="listening-to-the-tcp-connection-监听tcp连接"><a class="header" href="#listening-to-the-tcp-connection-监听tcp连接">Listening to the TCP Connection 监听TCP连接</a></h3>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<p>我们的Web服务器需要监听TCP连接，因此这是我们要处理的第一部分。标准库提供了一个<code>std::net</code>模块，让我们可以做到这一点。让我们以通常的方式创建一个新项目：</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 21-1 in <em>src/main.rs</em> to start. This code will
listen at the local address <code>127.0.0.1:7878</code> for incoming TCP streams. When it
gets an incoming stream, it will print <code>Connection established!</code>.</p>
<p>现在在_src/main.rs_中输入代码清单21-1中的代码。此代码将在本地地址<code>127.0.0.1:7878</code>监听传入的TCP流。当它接收到传入流时，会打印<code>Connection established!</code>。</p>
<figure class="listing" id="listing-21-1">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-1">Listing 21-1</a>: Listening for incoming streams and printing a message when we receive a stream 监听传入流并在接收到流时打印消息</figcaption>
</figure>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP isn’t normally accepted on this port so
our server is unlikely to conflict with any other web server you might have
running on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>
<p>使用<code>TcpListener</code>，我们可以在地址<code>127.0.0.1:7878</code>监听TCP连接。在地址中，冒号前的部分代表你的计算机的IP地址（这在每台计算机上都是相同的，并不特指作者的计算机），而<code>7878</code>是端口。我们选择这个端口有两个原因：HTTP通常不接受此端口，因此我们的服务器不太可能与你计算机上可能运行的其他Web服务器冲突；并且7878在电话键盘上是rust的拼写。</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The function is called <code>bind</code>
because, in networking, connecting to a port to listen to is known as “binding
to a port.”</p>
<p>此场景中的<code>bind</code>函数类似于<code>new</code>函数，它会返回一个新的<code>TcpListener</code>实例。该函数被称为<code>bind</code>，因为在网络中，连接到端口进行监听被称为“绑定到端口“。</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that it’s
possible for binding to fail. For example, connecting to port 80 requires
administrator privileges (non-administrators can listen only on ports higher
than 1023), so if we tried to connect to port 80 without being an
administrator, binding wouldn’t work. Binding also wouldn’t work, for example,
if we ran two instances of our program and so had two programs listening to the
same port. Because we’re writing a basic server just for learning purposes, we
won’t worry about handling these kinds of errors; instead, we use <code>unwrap</code> to
stop the program if errors happen.</p>
<p><code>bind</code>函数返回一个<code>Result&lt;T, E&gt;</code>，表示绑定可能失败。例如，连接到端口80需要管理员权限（非管理员只能监听1023以上的端口），因此如果我们尝试以非管理员身份连接端口80，绑定将不起作用。绑定也可能失败，例如，如果我们运行两个程序实例，就有两个程序监听同一个端口。因为我们正在编写仅用于学习目的的简单服务器，所以不用担心处理此类错误；相反，如果发生错误，我们使用<code>unwrap</code>停止程序。</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, we will read from the <code>TcpStream</code> to see what
the client sent and then write our response to the stream to send data back to
the client. Overall, this <code>for</code> loop will process each connection in turn and
produce a series of streams for us to handle.</p>
<p><code>TcpListener</code>上的<code>incoming</code>方法返回一个迭代器，该迭代器为我们提供一系列流（更具体地说，是<code>TcpStream</code>类型的流）。单个流表示客户端和服务器之间的开放连接。连接是指客户端连接到服务器、服务器生成响应以及服务器关闭连接的完整请求和响应过程的名称。因此，我们将从<code>TcpStream</code>读取以查看客户端发送的内容，然后将响应写入流以将数据发送回客户端。总的来说，这个<code>for</code>循环将依次处理每个连接，并生成一系列供我们处理的流。</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>目前，我们对流的处理包括在流有任何错误时调用<code>unwrap</code>终止程序；如果没有错误，程序会打印一条消息。我们将在下一个代码清单中为成功情况添加更多功能。当客户端连接到服务器时，我们可能从<code>incoming</code>方法收到错误的原因是我们实际上不是在遍历连接，而是在遍历连接尝试。由于多种原因（其中许多与操作系统相关），连接可能不成功。例如，许多操作系统对其可以支持的并发打开连接数量有限制；超过该数量的新连接尝试将产生错误，直到一些打开的连接关闭。</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<p>让我们尝试运行此代码！在终端中调用<code>cargo run</code>，然后在Web浏览器中加载_127.0.0.1:7878_。浏览器应显示类似“Connection reset“的错误消息，因为服务器当前没有返回任何数据。但是当你查看终端时，应该看到浏览器连接到服务器时打印的几条消息！</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>有时你会看到针对一个浏览器请求打印多条消息；原因可能是浏览器正在请求页面以及其他资源，例如浏览器标签中出现的_favicon.ico_图标。</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary.</p>
<p>也可能是因为服务器没有响应任何数据，浏览器尝试多次连接到服务器。当<code>stream</code>在循环结束时超出作用域并被丢弃时，连接作为<code>drop</code>实现的一部分被关闭。浏览器有时会通过重试来处理已关闭的连接，因为问题可能是暂时的。</p>
<p>Browsers also sometimes open multiple connections to the server without sending
any requests, so that if they <em>do</em> later send requests, they can happen faster.
When this happens, our server will see each connection, regardless of whether
there are any requests over that connection. Many versions of Chrome-based
browsers do this, for example; you can disable that optimization by using =
private browsing mode or use a different browser.</p>
<p>浏览器有时也会在不发送任何请求的情况下打开多个到服务器的连接，以便以后发送请求时可以更快。发生这种情况时，我们的服务器将看到每个连接，无论该连接上是否有任何请求。例如，许多基于Chrome的浏览器版本都会这样做；你可以通过使用隐私浏览模式或使用不同的浏览器来禁用该优化。</p>
<p>The important factor is that we’ve successfully gotten a handle to a TCP
connection!</p>
<p>重要的因素是我们已成功获取到TCP连接句柄！</p>
<p>Remember to stop the program by pressing <kbd>ctrl</kbd>-<kbd>c</kbd> when
you’re done running a particular version of the code. Then restart the program
by invoking the <code>cargo run</code> command after you’ve made each set of code changes
to make sure you’re running the newest code.</p>
<p>请记住在运行特定版本的代码后按<kbd>ctrl</kbd>-<kbd>c</kbd>停止程序。然后在每次代码更改后通过调用<code>cargo run</code>命令重新启动程序，以确保运行的是最新代码。</p>
<h3 id="reading-the-request-读取请求"><a class="header" href="#reading-the-request-读取请求">Reading the Request 读取请求</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 21-2.</p>
<p>让我们实现从浏览器读取请求的功能！为了分离首先获取连接然后对连接执行某些操作的关注点，我们将为处理连接启动一个新函数。在这个新的<code>handle_connection</code>函数中，我们将从TCP流读取数据并打印出来，以便查看浏览器发送的数据。将代码更改为代码清单21-2所示。</p>
<figure class="listing" id="listing-21-2">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-2">Listing 21-2</a>: Reading from the <code>TcpStream</code> and printing the data 从<code>TcpStream</code>读取并打印数据</figcaption>
</figure>
<p>We bring <code>std::io::prelude</code> and <code>std::io::BufReader</code> into scope to get access
to traits and types that let us read from and write to the stream. In the <code>for</code>
loop in the <code>main</code> function, instead of printing a message that says we made a
connection, we now call the new <code>handle_connection</code> function and pass the
<code>stream</code> to it.</p>
<p>我们将<code>std::io::prelude</code>和<code>std::io::BufReader</code>引入作用域，以获取允许我们从流读取和写入的特征和类型。在<code>main</code>函数的<code>for</code>循环中，我们现在不再打印已建立连接的消息，而是调用新的<code>handle_connection</code>函数并将<code>stream</code>传递给它。</p>
<p>In the <code>handle_connection</code> function, we create a new <code>BufReader</code> instance that
wraps a reference to the <code>stream</code>. The <code>BufReader</code> adds buffering by managing calls
to the <code>std::io::Read</code> trait methods for us.</p>
<p>在<code>handle_connection</code>函数中，我们创建一个新的<code>BufReader</code>实例，该实例包装了对<code>stream</code>的引用。<code>BufReader</code>通过管理对<code>std::io::Read</code>特征方法的调用来为我们添加缓冲。</p>
<p>We create a variable named <code>http_request</code> to collect the lines of the request
the browser sends to our server. We indicate that we want to collect these
lines in a vector by adding the <code>Vec&lt;_&gt;</code> type annotation.</p>
<p>我们创建一个名为<code>http_request</code>的变量来收集浏览器发送给我们服务器的请求行。我们通过添加<code>Vec&lt;_&gt;</code>类型注释来表明我们希望在向量中收集这些行。</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code>
method. The <code>lines</code> method returns an iterator of <code>Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline
byte. To get each <code>String</code>, we map and <code>unwrap</code> each <code>Result</code>. The <code>Result</code>
might be an error if the data isn’t valid UTF-8 or if there was a problem
reading from the stream. Again, a production program should handle these errors
more gracefully, but we’re choosing to stop the program in the error case for
simplicity.</p>
<p><code>BufReader</code>实现了<code>std::io::BufRead</code>特征，该特征提供了<code>lines</code>方法。<code>lines</code>方法返回一个<code>Result&lt;String, std::io::Error&gt;</code>的迭代器，通过在每次看到换行字节时分割数据流来生成。为了获取每个<code>String</code>，我们对每个<code>Result</code>进行映射和<code>unwrap</code>。如果数据不是有效的UTF-8或者从流中读取时出现问题，则<code>Result</code>可能是一个错误。再次强调，生产程序应该更优雅地处理这些错误，但为了简单起见，我们选择在错误情况下停止程序。</p>
<p>The browser signals the end of an HTTP request by sending two newline
characters in a row, so to get one request from the stream, we take lines until
we get a line that is the empty string. Once we’ve collected the lines into the
vector, we’re printing them out using pretty debug formatting so we can take a
look at the instructions the web browser is sending to our server.</p>
<p>浏览器通过连续发送两个换行符来表示HTTP请求的结束，因此为了从流中获取一个请求，我们获取行直到得到一个空字符串。一旦将行收集到向量中，我们就使用漂亮的调试格式打印它们，以便查看Web浏览器发送给我们服务器的指令。</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<p>让我们尝试这段代码！启动程序并在Web浏览器中再次发出请求。请注意，浏览器中仍会显示错误页面，但我们终端中的程序输出现在应类似于：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>GET</code> in the first line
of the request. If the repeated connections are all requesting <em>/</em>, we know the
browser is trying to fetch <em>/</em> repeatedly because it’s not getting a response
from our program.</p>
<p>根据浏览器的不同，你可能会得到略有不同的输出。现在我们正在打印请求数据，通过查看请求第一行中<code>GET</code>之后的路径，我们可以看到为什么从一个浏览器请求获得多个连接。如果重复的连接都请求_/<em>，我们知道浏览器正在尝试重复获取</em>/_，因为它没有从我们的程序获得响应。</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<p>让我们分解这些请求数据以了解浏览器对我们的程序提出了什么要求。</p>
<h3 id="a-closer-look-at-an-http-request-深入了解http请求"><a class="header" href="#a-closer-look-at-an-http-request-深入了解http请求">A Closer Look at an HTTP Request 深入了解HTTP请求</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<p>HTTP是基于文本的协议，请求采用以下格式：</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request, which means it is asking for
information.</p>
<p>第一行是请求行，包含有关客户端请求内容的信息。请求行的第一部分指示使用的方法，例如<code>GET</code>或<code>POST</code>，描述了客户端如何发出此请求。我们的客户端使用了<code>GET</code>请求，这意味着它正在请求信息。</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>uniform resource
identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>uniform resource locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute <em>URL</em> for <em>URI</em> here.</p>
<p>请求行的下一部分是_/<em>，表示客户端请求的统一资源标识符(URI)：URI几乎与统一资源定位符(URL)相同，但不完全相同。URI和URL之间的区别在本章中并不重要，但HTTP规范使用术语URI，因此我们可以在这里在心理上用_URL_替代_URI</em>。</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a CRLF sequence. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
<em>CRLF sequence</em> separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>最后一部分是客户端使用的HTTP版本，然后请求行以CRLF序列结束。（CRLF代表回车和换行，这是来自打字机时代的术语！）CRLF序列也可以写成<code>\r\n</code>，其中<code>\r</code>是回车，<code>\n</code>是换行。CRLF序列将请求行与请求数据的其余部分分开。请注意，当打印CRLF时，我们看到的是新行开始而不是<code>\r\n</code>。</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>查看我们到目前为止运行程序收到的请求行数据，我们看到<code>GET</code>是方法，_/_是请求URI，<code>HTTP/1.1</code>是版本。</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>在请求行之后，从<code>Host:</code>开始的行是头部。<code>GET</code>请求没有正文。</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>尝试从不同的浏览器发出请求或请求不同的地址，例如_127.0.0.1:7878/test_，以查看请求数据如何变化。</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<p>现在我们知道了浏览器请求的内容，让我们发回一些数据！</p>
<h3 id="writing-a-response-编写响应"><a class="header" href="#writing-a-response-编写响应">Writing a Response 编写响应</a></h3>
<p>We’re going to implement sending data in response to a client request.
Responses have the following format:</p>
<p>我们将实现发送数据以响应客户端请求。响应具有以下格式：</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>第一行是状态行，包含响应中使用的HTTP版本、总结请求结果的数字状态码以及提供状态码文本描述的原因短语。在CRLF序列之后是任何头部、另一个CRLF序列和响应的正文。</p>
<p>Here is an example response that uses HTTP version 1.1, and has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<p>这是一个使用HTTP版本1.1、状态码200（OK原因短语）、无头部和无正文的响应示例：</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 21-3.</p>
<p>状态码200是标准的成功响应。这段文本是一个微小的成功HTTP响应。让我们将其写入流作为对成功请求的响应！从<code>handle_connection</code>函数中，删除打印请求数据的<code>println!</code>，并将其替换为代码清单21-3中的代码。</p>
<figure class="listing" id="listing-21-3">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-3">Listing 21-3</a>: Writing a tiny successful HTTP response to the stream 将微小的成功HTTP响应写入流</figcaption>
</figure>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection. Because the <code>write_all</code> operation
could fail, we use <code>unwrap</code> on any error result as before. Again, in a real
application you would add error handling here.</p>
<p>第一行定义了<code>response</code>变量，该变量保存成功消息的数据。然后我们在<code>response</code>上调用<code>as_bytes</code>将字符串数据转换为字节。<code>stream</code>上的<code>write_all</code>方法接受一个<code>&amp;[u8]</code>并将这些字节直接发送到连接。因为<code>write_all</code>操作可能失败，所以我们像以前一样对任何错误结果使用<code>unwrap</code>。再次强调，在实际应用中，你应该在此处添加错误处理。</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just handcoded receiving an HTTP
request and sending a response!</p>
<p>通过这些更改，让我们运行代码并发出请求。我们不再向终端打印任何数据，因此除了Cargo的输出外，不会看到任何输出。当你在Web浏览器中加载_127.0.0.1:7878_时，应该得到一个空白页面而不是错误。你刚刚手动编写了接收HTTP请求和发送响应的代码！</p>
<h3 id="returning-real-html-返回真实的html"><a class="header" href="#returning-real-html-返回真实的html">Returning Real HTML 返回真实的HTML</a></h3>
<p>Let’s implement the functionality for returning more than a blank page. Create
the new file <em>hello.html</em> in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 21-4 shows one
possibility.</p>
<p>让我们实现返回超过空白页面的功能。在你的项目目录的根目录（而不是_src_目录）中创建新文件_hello.html_。你可以输入任何你想要的HTML；代码清单21-4展示了一种可能性。</p>
<figure class="listing" id="listing-21-4">
<span class="file-name">Filename: hello.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-4">Listing 21-4</a>: A sample HTML file to return in a response 要在响应中返回的示例HTML文件</figcaption>
</figure>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 21-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p>这是一个最小的HTML5文档，包含一个标题和一些文本。为了在收到请求时从服务器返回此内容，我们将修改<code>handle_connection</code>，如代码清单21-5所示，读取HTML文件，将其作为正文添加到响应中并发送。</p>
<figure class="listing" id="listing-21-5">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-5">Listing 21-5</a>: Sending the contents of <em>hello.html</em> as the body of the response 发送<em>hello.html</em>的内容作为响应的正文</figcaption>
</figure>
<p>We’ve added <code>fs</code> to the <code>use</code> statement to bring the standard library’s
filesystem module into scope. The code for reading the contents of a file to a
string should look familiar; we used it when we read the contents of a file for
our I/O project in Listing 12-4.</p>
<p>我们已将<code>fs</code>添加到<code>use</code>语句中，以将标准库的文件系统模块引入作用域。将文件内容读取到字符串的代码应该很熟悉；我们在列表12-4中的I/O项目中读取文件内容时使用过它。</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header
which is set to the size of our response body, in this case the size of
<code>hello.html</code>.</p>
<p>接下来，我们使用<code>format!</code>将文件的内容添加为成功响应的正文。为确保有效的HTTP响应，我们添加了<code>Content-Length</code>头部，该头部设置为响应正文的大小，即<code>hello.html</code>的大小。</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>使用<code>cargo run</code>运行此代码，并在浏览器中加载_127.0.0.1:7878_；你应该看到HTML被渲染！</p>
<p>Currently, we’re ignoring the request data in <code>http_request</code> and just sending
back the contents of the HTML file unconditionally. That means if you try
requesting <em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get
back this same HTML response. At the moment, our server is very limited and
does not do what most web servers do. We want to customize our responses
depending on the request and only send back the HTML file for a well-formed
request to <em>/</em>.</p>
<p>目前，我们忽略了<code>http_request</code>中的请求数据，只是无条件地发送回HTML文件的内容。这意味着如果你在浏览器中尝试请求_127.0.0.1:7878/something-else_，你仍将获得相同的HTML响应。目前，我们的服务器非常有限，没有执行大多数Web服务器的操作。我们希望根据请求自定义响应，并且仅对格式正确的_/_请求发送回HTML文件。</p>
<h3 id="validating-the-request-and-selectively-responding-验证请求并有选择地响应"><a class="header" href="#validating-the-request-and-selectively-responding-验证请求并有选择地响应">Validating the Request and Selectively Responding 验证请求并有选择地响应</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 21-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p>目前，无论客户端请求什么，我们的Web服务器都将返回文件中的HTML。让我们添加功能来检查浏览器是否请求_/<em>，然后再返回HTML文件，如果浏览器请求其他任何内容，则返回错误。为此，我们需要修改<code>handle_connection</code>，如代码清单21-6所示。这段新代码将接收到的请求内容与我们已知的</em>/_请求进行比较，并添加<code>if</code>和<code>else</code>块以区别处理请求。</p>
<figure class="listing" id="listing-21-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-6">Listing 21-6</a>: Handling requests to <em>/</em> differently from other requests 以不同于其他请求的方式处理对*/*的请求</figcaption>
</figure>
<p>We’re only going to be looking at the first line of the HTTP request, so rather
than reading the entire request into a vector, we’re calling <code>next</code> to get the
first item from the iterator. The first <code>unwrap</code> takes care of the <code>Option</code> and
stops the program if the iterator has no items. The second <code>unwrap</code> handles the
<code>Result</code> and has the same effect as the <code>unwrap</code> that was in the <code>map</code> added in
Listing 21-2.</p>
<p>我们只关注HTTP请求的第一行，因此不是将整个请求读入向量，而是调用<code>next</code>从迭代器获取第一项。第一个<code>unwrap</code>处理<code>Option</code>，如果迭代器没有项则停止程序。第二个<code>unwrap</code>处理<code>Result</code>，其效果与代码清单21-2中添加的<code>map</code>中的<code>unwrap</code>相同。</p>
<p>Next, we check the <code>request_line</code> to see if it equals the request line of a GET
request to the <em>/</em> path. If it does, the <code>if</code> block returns the contents of our
HTML file.</p>
<p>接下来，我们检查<code>request_line</code>是否等于对_/_路径的GET请求行。如果是，<code>if</code>块返回HTML文件的内容。</p>
<p>If the <code>request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it
means we’ve received some other request. We’ll add code to the <code>else</code> block in
a moment to respond to all other requests.</p>
<p>如果<code>request_line</code>不等于对_/_路径的GET请求，则意味着我们收到了其他请求。我们将很快在<code>else</code>块中添加代码以响应所有其他请求。</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 21-1 and Listing 21-2.</p>
<p>现在运行此代码并请求_127.0.0.1:7878_；你应该获得_hello.html_中的HTML。如果你发出任何其他请求，例如_127.0.0.1:7878/something-else_，你将得到连接错误，类似于运行代码清单21-1和21-2中的代码时看到的错误。</p>
<p>Now let’s add the code in Listing 21-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p>现在让我们将代码清单21-7中的代码添加到<code>else</code>块，以返回状态码404的响应，该状态码表示未找到请求的内容。我们还将返回一些HTML，以便在浏览器中呈现页面向最终用户指示响应。</p>
<figure class="listing" id="listing-21-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-7">Listing 21-7</a>: Responding with status code 404 and an error page if anything other than <em>/</em> was requested 如果请求了*/*以外的任何内容，则响应状态码404和错误页面</figcaption>
</figure>
<p>Here, our response has a status line with status code 404 and the reason phrase
<code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>.
You’ll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error
page; again feel free to use any HTML you want or use the example HTML in
Listing 21-8.</p>
<p>这里，我们的响应有一个状态行，状态码为404，原因短语为<code>NOT FOUND</code>。响应的正文将是文件_404.html_中的HTML。你需要在_hello.html_旁边创建一个_404.html_文件作为错误页面；同样，你可以使用任何你想要的HTML，或使用代码清单21-8中的示例HTML。</p>
<figure class="listing" id="listing-21-8">
<span class="file-name">Filename: 404.html</span>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-8">Listing 21-8</a>: Sample content for the page to send back with any 404 response 随任何404响应发送回的页面内容示例</figcaption>
</figure>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should
return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<p>通过这些更改，再次运行你的服务器。请求_127.0.0.1:7878_应返回_hello.html_的内容，而任何其他请求（如_127.0.0.1:7878/foo_）应返回_404.html_中的错误HTML。</p>
<h3 id="a-touch-of-refactoring-重构一下"><a class="header" href="#a-touch-of-refactoring-重构一下">A Touch of Refactoring 重构一下</a></h3>
<p>At the moment, the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables; we
can then use those variables unconditionally in the code to read the file and
write the response. Listing 21-9 shows the resultant code after replacing the
large <code>if</code> and <code>else</code> blocks.</p>
<p>目前，<code>if</code>和<code>else</code>块有很多重复：它们都读取文件并将文件内容写入流。唯一的区别是状态行和文件名。让我们通过将这些差异提取到单独的<code>if</code>和<code>else</code>行来使代码更简洁，这些行将状态行和文件名的值分配给变量；然后我们可以在代码中无条件地使用这些变量来读取文件和写入响应。在用较小的<code>if</code>和<code>else</code>块替换大型块后，代码清单21-9显示了结果代码。</p>
<figure class="listing" id="listing-21-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<figcaption><a href="ch21-01-single-threaded.html#listing-21-9">Listing 21-9</a>: Refactoring the <code>if</code> and <code>else</code> blocks to contain only the code that differs between the two cases 重构<code>if</code>和<code>else</code>块以仅包含两种情况之间不同的代码</figcaption>
</figure>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 19.</p>
<p>现在<code>if</code>和<code>else</code>块仅返回元组中状态行和文件名的适当值；然后我们使用解构将这些值分配给<code>status_line</code>和<code>filename</code>，使用<code>let</code>语句中的模式，如第19章所述。</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 21-9 will be the same as that in
Listing 21-7.</p>
<p>以前重复的代码现在位于<code>if</code>和<code>else</code>块之外，并使用<code>status_line</code>和<code>filename</code>变量。这样可以更清楚地看到两种情况之间的差异，并且意味着如果我们想更改文件读取和响应写入的工作方式，我们只有一个地方可以更新代码。代码清单21-9中的代码行为将与代码清单21-7中的行为相同。</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>太棒了！我们现在有了一个大约40行Rust代码的简单Web服务器，它用一个内容页面响应一个请求，并用404响应所有其他请求。</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<p>目前，我们的服务器在单个线程中运行，这意味着它一次只能处理一个请求。让我们通过模拟一些慢速请求来检查这可能有什么问题。然后我们将修复它，使我们的服务器能够同时处理多个请求。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="turning-our-single-threaded-server-into-a-multithreaded-server-将单线程服务器转换为多线程服务器"><a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server-将单线程服务器转换为多线程服务器">Turning Our Single-Threaded Server into a Multithreaded Server 将单线程服务器转换为多线程服务器</a></h2>
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first we’ll look at the problem in action.</p>
<p>当前服务器会依次处理每个请求，这意味着在处理完第一个连接之前不会处理第二个连接。如果服务器收到越来越多的请求，这种串行执行将变得越来越低效。如果服务器收到一个需要长时间处理的请求，后续请求将不得不等待该长请求完成，即使新请求可以快速处理。我们需要解决这个问题，但首先我们要观察实际存在的问题。</p>
<h3 id="simulating-a-slow-request-in-the-current-server-implementation-在当前服务器实现中模拟慢请求"><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation-在当前服务器实现中模拟慢请求">Simulating a Slow Request in the Current Server Implementation 在当前服务器实现中模拟慢请求</a></h3>
<p>We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 21-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for five seconds before responding.</p>
<p>我们将观察处理慢请求如何影响当前服务器实现处理的其他请求。代码清单21-10实现了对 <em>/sleep</em> 请求的处理，它通过模拟慢响应使服务器在响应前休眠五秒。</p>
<figure class="listing" id="listing-21-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-10">Listing 21-10</a>: Simulating a slow request by sleeping for 5 seconds 通过休眠5秒模拟慢请求</figcaption>
</figure>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to
explicitly match on a slice of <code>request_line</code> to pattern match against the
string literal values; <code>match</code> doesn’t do automatic referencing and
dereferencing, like the equality method does.</p>
<p>由于现在有三种情况，我们将 <code>if</code> 改为 <code>match</code>。我们需要显式匹配 <code>request_line</code> 的切片，以便与字符串字面值进行模式匹配；<code>match</code> 不会像等值方法那样自动进行引用和解引用。</p>
<p>The first arm is the same as the <code>if</code> block from Listing 21-9. The second arm
matches a request to <em>/sleep</em>. When that request is received, the server will
sleep for five seconds before rendering the successful HTML page. The third arm
is the same as the <code>else</code> block from Listing 21-9.</p>
<p>第一个分支与代码清单21-9的 <code>if</code> 块相同。第二个分支匹配 <em>/sleep</em> 请求。收到该请求时，服务器将在渲染成功HTML页面前休眠五秒。第三个分支与代码清单21-9的 <code>else</code> 块相同。</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>你可以看到我们的服务器多么原始：真正的库会以更简洁的方式处理多请求识别！</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until
<code>sleep</code> has slept for its full five seconds before loading.</p>
<p>使用 <code>cargo run</code> 启动服务器。然后打开两个浏览器窗口：一个访问 <em>http://127.0.0.1:7878/</em> ，另一个访问 <em>http://127.0.0.1:7878/sleep</em> 。如果像之前一样多次输入 <em>/ URI</em>，你会看到它快速响应。但如果输入 <em>/sleep</em> 后再加载 <em>/，</em> 你会看到 <em>/ 要等待</em>sleep* 完整休眠五秒后才加载。</p>
<p>There are multiple techniques we could use to avoid requests backing up behind
a slow request, including using async as we did Chapter 17; the one we’ll
implement is a thread pool.</p>
<p>我们可以使用多种技术避免请求在慢请求后堆积，包括像第17章那样使用异步；我们将实现的是线程池。</p>
<h3 id="improving-throughput-with-a-thread-pool-使用线程池提高吞吐量"><a class="header" href="#improving-throughput-with-a-thread-pool-使用线程池提高吞吐量">Improving Throughput with a Thread Pool 使用线程池提高吞吐量</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p><strong>线程池</strong> 是一组已生成且待命处理任务的线程。当程序收到新任务时，它会将池中的线程分配给该任务，该线程将处理此任务。池中剩余线程可处理第一个线程处理期间到达的其他任务。当第一个线程完成任务后，它将返回空闲线程池，准备处理新任务。线程池允许并发处理连接，从而提高服务器吞吐量。</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from DoS attacks; if we had our program create a new thread for each request as
it came in, someone making 10 million requests to our server could create havoc
by using up all our server’s resources and grinding the processing of requests
to a halt.</p>
<p>我们将池中线程数限制在较小数量以防止DoS攻击；如果为每个到达的请求创建新线程，有人向服务器发起1000万次请求就可能耗尽所有服务器资源，导致请求处理停滞。</p>
<p>Rather than spawning unlimited threads, then, we’ll have a fixed number of
threads waiting in the pool. Requests that come in are sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process up
to <em><code>N</code></em> requests concurrently, where <em><code>N</code></em> is the number of threads. If each
thread is responding to a long-running request, subsequent requests can still
back up in the queue, but we’ve increased the number of long-running requests
we can handle before reaching that point.</p>
<p>因此，我们将让固定数量的线程在池中等待。到达的请求被发送到池中处理。池将维护传入请求的队列。池中每个线程将从队列中取出请求，处理该请求，然后向队列请求另一个请求。通过这种设计，我们可以并发处理最多 <strong><code>N</code></strong> 个请求，其中 <strong><code>N</code></strong> 是线程数。如果每个线程都响应长时间运行的请求，后续请求仍可能在队列中积压，但我们增加了在达到此点前可处理的长时间运行请求数量。</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model, the
single-threaded async I/O model, and the multithreaded async I/O model. If
you’re interested in this topic, you can read more about other solutions and
try to implement them; with a low-level language like Rust, all of these
options are possible.</p>
<p>这只是提高Web服务器吞吐量的众多方法之一。其他可探索的方案包括fork/join模型、单线程异步I/O模型和多线程异步I/O模型。若对此感兴趣，可阅读其他解决方案并尝试实现；对于像Rust这样的底层语言，所有这些方案都是可行的。</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>在开始实现线程池前，我们先讨论使用池的预期形式。设计代码时，先编写客户端接口有助于指导设计。编写代码的API使其符合调用方式，然后在该结构中实现功能，而不是先实现功能再设计公共API。</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work. Before we do that, however,
we’ll explore the technique we’re not going to use as a starting point.</p>
<p>类似于第12章项目中使用的测试驱动开发，这里我们将使用编译器驱动开发。先编写调用所需函数的代码，然后根据编译器错误决定下一步更改以使代码工作。但在之前，我们先探讨不作为起点的技术。</p>
<h4 id="spawning-a-thread-for-each-request-为每个请求生成线程"><a class="header" href="#spawning-a-thread-for-each-request-为每个请求生成线程">Spawning a Thread for Each Request 为每个请求生成线程</a></h4>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point to get a working multithreaded server first. Then we’ll add the
thread pool as an improvement, and contrasting the two solutions will be
easier. Listing 21-11 shows the changes to make to <code>main</code> to spawn a new thread
to handle each stream within the <code>for</code> loop.</p>
<p>首先，假设我们为每个连接创建新线程，代码会是什么样。如前所述，由于可能生成无限数量线程的问题，这不是最终方案，但作为起点可先获得可用的多线程服务器。然后我们将添加线程池作为改进，对比两种方案会更轻松。代码清单21-11展示了修改 <code>main</code> 以在 <code>for</code> 循环中生成新线程处理每个流。</p>
<figure class="listing" id="listing-21-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-11">Listing 21-11</a>: Spawning a new thread for each stream 为每个流生成新线程</figcaption>
</figure>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see
that the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. However, as
we mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.</p>
<p>如第16章所学，<code>thread::spawn</code> 将创建新线程，然后在新线程中运行闭包代码。运行此代码并在浏览器中加载 <em>/sleep</em>，然后在另外两个浏览器标签页加载 <em>/，</em> 你会看到对 <em>/ 的请求确实不必等待/sleep</em> 完成。但如前所述，这最终会压垮系统，因为你会无限制地创建新线程。</p>
<p>You may also recall from Chapter 17 that this is exactly the kind of situation
where async and await really shine! Keep that in mind as we build the thread
pool and think about how things would look different or the same with async.</p>
<p>你可能还记得第17章，这正是异步(async)和等待(await)真正闪耀的场景！在我们构建线程池时请记住这一点，并思考在异步方式下会有何异同。</p>
<h4 id="creating-a-finite-number-of-threads-创建有限数量的线程"><a class="header" href="#creating-a-finite-number-of-threads-创建有限数量的线程">Creating a Finite Number of Threads 创建有限数量的线程</a></h4>
<p>We want our thread pool to work in a similar, familiar way so that switching
from threads to a thread pool doesn’t require large changes to the code that
uses our API. Listing 21-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p>我们希望线程池以类似且熟悉的方式工作，这样从线程切换到线程池就不需要对使用API的代码进行大改。代码清单21-12展示了我们希望用来替代 <code>thread::spawn</code> 的 <code>ThreadPool</code> 结构体的假设接口。</p>
<figure class="listing" id="listing-21-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-12">Listing 21-12</a>: Our ideal <code>ThreadPool</code> interface 理想的 <code>ThreadPool</code> 接口</figcaption>
</figure>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<p>我们使用 <code>ThreadPool::new</code> 创建具有可配置线程数的新线程池，此处为4。然后在 <code>for</code> 循环中，<code>pool.execute</code> 的接口类似于 <code>thread::spawn</code>，它接受池应为每个流运行的闭包。我们需要实现 <code>pool.execute</code> 使其接受闭包并交给池中线程运行。此代码尚不能编译，但我们将尝试，以便编译器指导如何修复。</p>
<h4 id="building-threadpool-using-compiler-driven-development-使用编译器驱动开发构建-threadpool"><a class="header" href="#building-threadpool-using-compiler-driven-development-使用编译器驱动开发构建-threadpool">Building <code>ThreadPool</code> Using Compiler Driven Development 使用编译器驱动开发构建 <code>ThreadPool</code></a></h4>
<p>Make the changes in Listing 21-12 to <em>src/main.rs</em>, and then let’s use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<p>按代码清单21-12修改 <em>src/main.rs</em>，然后使用 <code>cargo check</code> 的编译器错误驱动开发。以下是第一个错误：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So let’s switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>很好！此错误表明我们需要 <code>ThreadPool</code> 类型或模块，因此现在开始构建。我们的 <code>ThreadPool</code> 实现将独立于Web服务器的工作类型。因此我们将 <code>hello</code> crate从二进制crate切换为库crate来存放 <code>ThreadPool</code> 实现。改为库crate后，我们还可以为任何需要使用线程池的工作（而不仅是服务Web请求）使用独立的线程池库。</p>
<p>Create a <em>src/lib.rs</em> file that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p>创建包含以下内容的 <em>src/lib.rs</em> 文件，这是目前最简单的 <code>ThreadPool</code> 结构体定义：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</figure>
<p>Then edit <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library
crate by adding the following code to the top of <em>src/main.rs</em>:</p>
<p>然后编辑 <em>main.rs</em> 文件，通过添加以下代码到 <em>src/main.rs</em> 顶部，将 <code>ThreadPool</code> 从库crate引入作用域：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</figure>
<p>This code still won’t work, but let’s check it again to get the next error that
we need to address:</p>
<p>此代码仍无法工作，但我们再次检查以获取下一个需要解决的错误：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p>此错误表明接下来需要为 <code>ThreadPool</code> 创建名为 <code>new</code> 的关联函数。我们还知道 <code>new</code> 需要有一个接受 <code>4</code> 作为参数的参数，并应返回 <code>ThreadPool</code> 实例。让我们实现具有这些特征的最简单 <code>new</code> 函数：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</figure>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
<code>4</code> as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in “Integer Types” in Chapter 3.</p>
<p>选择 <code>usize</code> 作为 <code>size</code> 参数的类型，因为我们知道负数的线程没有意义。我们还知道将使用 <code>4</code> 作为线程集合的元素数，这正是 <code>usize</code> 类型的用途，如第3章“整数类型“所述。</p>
<p>Let’s check the code again:</p>
<p>再次检查代码：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Now the error occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>.
Recall from “Creating a Finite Number of
Threads” that we decided
our thread pool should have an interface similar to <code>thread::spawn</code>. In
addition, we’ll implement the <code>execute</code> function so it takes the closure it’s
given and gives it to an idle thread in the pool to run.</p>
<p>现在的错误是因为 <code>ThreadPool</code> 上没有 <code>execute</code> 方法。回顾“创建有限数量的线程” ，我们决定线程池应有类似 <code>thread::spawn</code> 的接口。此外，我们将实现 <code>execute</code> 函数，使其接受给定的闭包并交给池中的空闲线程运行。</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from “Moving Captured Values Out of the Closure and the <code>Fn</code>
Traits” in Chapter 13 that we can take closures as
parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to
decide which kind of closure to use here. We know we’ll end up doing something
similar to the standard library <code>thread::spawn</code> implementation, so we can look
at what bounds the signature of <code>thread::spawn</code> has on its parameter. The
documentation shows us the following:</p>
<p>我们将定义 <code>ThreadPool</code> 上的 <code>execute</code> 方法以闭包作为参数。回顾第13章的“将捕获值移出闭包和 <code>Fn</code> 特征“，我们可以用三种不同的特征接受闭包作为参数：<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>。需要决定此处使用哪种闭包。我们知道最终会实现类似于标准库 <code>thread::spawn</code> 的功能，因此可以查看 <code>thread::spawn</code> 对其参数签名的限制。文档显示：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type
parameter is related to the return value, and we’re not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we’ll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>我们关注的是 <code>F</code> 类型参数；<code>T</code> 类型参数与返回值相关，我们不关注。可见 <code>spawn</code> 对 <code>F</code> 使用 <code>FnOnce</code> 作为特征约束。这可能也是我们需要的，因为我们最终会将 <code>execute</code> 中收到的参数传递给 <code>spawn</code>。可以进一步确认 <code>FnOnce</code> 是所需的特征，因为运行请求的线程只会执行该请求的闭包一次，这与 <code>FnOnce</code> 中的“Once“相符。</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don’t know how long
the thread will take to execute. Let’s create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><code>F</code> 类型参数还具有 <code>Send</code> 特征约束和生命周期约束 <code>'static</code>，这在我们的场景中很有用：需要 <code>Send</code> 将闭包从一个线程转移到另一个，需要 <code>'static</code> 因为我们不知道线程执行需要多长时间。让我们在 <code>ThreadPool</code> 上创建 <code>execute</code> 方法，该方法接受具有这些约束的 <code>F</code> 类型的泛型参数：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</figure>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and returns the unit type <code>()</code>. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>在 <code>FnOnce</code> 后仍使用 <code>()</code>，因为此 <code>FnOnce</code> 表示不接受参数且返回单元类型 <code>()</code> 的闭包。就像函数定义一样，返回类型可以从签名中省略，但即使没有参数，我们仍需要括号。</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we’re only trying to make our code compile. Let’s check it again:</p>
<p>同样，这是 <code>execute</code> 方法最简单的实现：它什么都不做，但我们只是尝试使代码编译。再次检查：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>It compiles! But note that if you try <code>cargo run</code> and make a request in the
browser, you’ll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn’t actually calling the closure passed to <code>execute</code>
yet!</p>
<p>编译通过了！但注意如果尝试 <code>cargo run</code> 并在浏览器发出请求，你会看到本章开头在浏览器中看到的错误。我们的库实际上还没有调用传递给 <code>execute</code> 的闭包！</p>
<section class="note" aria-role="note">
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is “if the code compiles, it works.” But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
<p>注意：对于具有严格编译器的语言（如Haskell和Rust），你可能会听到“如果代码能编译，它就能工作“的说法。但这并非普遍正确。我们的项目能编译，但完全什么都不做！如果构建的是真实完整的项目，这是开始编写单元测试的好时机，以检查代码既能编译又具有所需行为。</p>
</section>
<p>Consider: what would be different here if we were going to execute a <em>future</em>
instead of a closure?</p>
<p>思考：如果要执行的是 <strong>future</strong> 而不是闭包，这里会有何不同？</p>
<h4 id="validating-the-number-of-threads-in-new-在-new-中验证线程数"><a class="header" href="#validating-the-number-of-threads-in-new-在-new-中验证线程数">Validating the Number of Threads in <code>new</code> 在 <code>new</code> 中验证线程数</a></h4>
<p>We aren’t doing anything with the parameters to <code>new</code> and <code>execute</code>. Let’s
implement the bodies of these functions with the behavior we want. To start,
let’s think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code>
parameter because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid <code>usize</code>. We’ll add code to check that <code>size</code> is greater than zero before
we return a <code>ThreadPool</code> instance and have the program panic if it receives a
zero by using the <code>assert!</code> macro, as shown in Listing 21-13.</p>
<p>我们没有对 <code>new</code> 和 <code>execute</code> 的参数做任何处理。让我们用期望的行为实现这些函数体。首先考虑 <code>new</code>。之前为 <code>size</code> 参数选择无符号类型，因为负数的线程池没有意义。但零个线程的池同样没有意义，而零是有效的 <code>usize</code>。我们将添加代码在返回 <code>ThreadPool</code> 实例前检查 <code>size</code> 大于零，如果收到零则使用 <code>assert!</code> 宏使程序panic，如代码清单21-13所示。</p>
<figure class="listing" id="listing-21-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-13">Listing 21-13</a>: Implementing <code>ThreadPool::new</code> to panic if <code>size</code> is zero 实现 <code>ThreadPool::new</code> 在 <code>size</code> 为零时panic</figcaption>
</figure>
<p>We’ve also added some documentation for our <code>ThreadPool</code> with doc comments.
Note that we followed good documentation practices by adding a section that
calls out the situations in which our function can panic, as discussed in
Chapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct
to see what the generated docs for <code>new</code> look like!</p>
<p>我们还为 <code>ThreadPool</code> 添加了文档注释。注意遵循了良好的文档实践，添加了说明函数可能panic的场景部分，如第14章所述。尝试运行 <code>cargo doc --open</code> 并点击 <code>ThreadPool</code> 结构体查看为 <code>new</code> 生成的文档！</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could change <code>new</code>
into <code>build</code> and return a <code>Result</code> like we did with <code>Config::build</code> in the I/O
project in Listing 12-9. But we’ve decided in this case that trying to create a
thread pool without any threads should be an unrecoverable error. If you’re
feeling ambitious, try to write a function named <code>build</code> with the following
signature to compare with the <code>new</code> function:</p>
<p>除了像此处添加 <code>assert!</code> 宏，我们还可以将 <code>new</code> 改为 <code>build</code> 并返回 <code>Result</code>，就像在I/O项目的代码清单12-9中对 <code>Config::build</code> 所做的那样。但在这种情况下，我们决定创建没有任何线程的线程池应是不可恢复的错误。如果你有雄心，尝试编写具有以下签名的 <code>build</code> 函数，与 <code>new</code> 函数比较：</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="creating-space-to-store-the-threads-创建存储线程的空间"><a class="header" href="#creating-space-to-store-the-threads-创建存储线程的空间">Creating Space to Store the Threads 创建存储线程的空间</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning the struct. But how do we “store” a thread? Let’s take another
look at the <code>thread::spawn</code> signature:</p>
<p>既然有办法确保存储到池中的线程数有效，我们可以在返回结构体前创建这些线程并将其存储在 <code>ThreadPool</code> 结构体中。但如何“存储“线程？再看一下 <code>thread::spawn</code> 签名：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p><code>spawn</code> 函数返回 <code>JoinHandle&lt;T&gt;</code>，其中 <code>T</code> 是闭包的返回类型。我们也尝试使用 <code>JoinHandle</code>，看看会发生什么。在我们的场景中，传递给线程池的闭包将处理连接且不返回任何内容，因此 <code>T</code> 将是单元类型 <code>()</code>。</p>
<p>The code in Listing 21-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p>代码清单21-14中的代码可以编译但尚未创建任何线程。我们修改了 <code>ThreadPool</code> 的定义以保存 <code>thread::JoinHandle&lt;()&gt;</code> 实例的向量，用 <code>size</code> 容量初始化向量，设置循环创建线程，并返回包含它们的 <code>ThreadPool</code> 实例。</p>
<figure class="listing" id="listing-21-14">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-14">Listing 21-14</a>: Creating a vector for <code>ThreadPool</code> to hold the threads 为 <code>ThreadPool</code> 创建向量以保存线程</figcaption>
</figure>
<p>We’ve brought <code>std::thread</code> into scope in the library crate because we’re
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>因为在线程池的向量中使用 <code>thread::JoinHandle</code> 作为项的类型，我们在库crate中将 <code>std::thread</code> 引入作用域。</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. The <code>with_capacity</code> function performs the same task as
<code>Vec::new</code> but with an important difference: it pre-allocates space in the
vector. Because we know we need to store <code>size</code> elements in the vector, doing
this allocation up front is slightly more efficient than using <code>Vec::new</code>,
which resizes itself as elements are inserted.</p>
<p>一旦收到有效的 size，我们的 <code>ThreadPool</code> 就创建一个可容纳 <code>size</code> 个项的新向量。<code>with_capacity</code> 函数执行与 <code>Vec::new</code> 相同的任务，但有一个重要区别：它预分配向量空间。因为我们知道需要在向量中存储 <code>size</code> 个元素，预先分配比使用 <code>Vec::new</code> 更高效，后者在插入元素时会自行调整大小。</p>
<p>When you run <code>cargo check</code> again, it should succeed.</p>
<p>再次运行 <code>cargo check</code>，它应该成功。</p>
<h4 id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread-负责将代码从-threadpool-发送到线程的-worker-结构体"><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread-负责将代码从-threadpool-发送到线程的-worker-结构体">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread 负责将代码从 <code>ThreadPool</code> 发送到线程的 <code>Worker</code> 结构体</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 21-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.</p>
<p>我们在代码清单21-14的 <code>for</code> 循环中留下了关于创建线程的注释。这里我们将探讨如何实际创建线程。标准库提供 <code>thread::spawn</code> 作为创建线程的方式，<code>thread::spawn</code> 期望在创建线程后立即获取线程应运行的代码。但在我们的场景中，我们希望创建线程并让它们等待稍后发送的代码。标准库的线程实现未包含任何实现方式；我们必须手动实现。</p>
<p>We’ll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call
this data structure <em>Worker</em>, which is a common term in pooling
implementations. The <code>Worker</code> picks up code that needs to be run and runs the
code in the Worker’s thread.</p>
<p>我们将通过在线程池和线程之间引入新的数据结构来实现此行为。我们称此数据结构为 <strong>Worker</strong>，这是池实现中的常见术语。<code>Worker</code> 获取需要运行的代码并在Worker的线程中运行它。</p>
<p>Think of people working in the kitchen at a restaurant: the workers wait until
orders come in from customers, and then they’re responsible for taking those
orders and fulfilling them.</p>
<p>想象餐厅厨房的工作人员：工人等待顾客订单，然后负责处理这些订单。</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each <code>Worker</code> an <code>id</code> so we can distinguish between
the different instances of <code>Worker</code> in the pool when logging or debugging.</p>
<p>我们将在线程池中存储 <code>Worker</code> 结构体实例，而不是 <code>JoinHandle&lt;()&gt;</code> 实例。每个 <code>Worker</code> 存储一个 <code>JoinHandle&lt;()&gt;</code> 实例。然后我们将实现 <code>Worker</code> 上的方法，该方法接受要运行的代码闭包并将其发送给已运行的线程执行。我们还将为每个 <code>Worker</code> 分配 <code>id</code>，以便在日志记录或调试时区分池中的不同 <code>Worker</code> 实例。</p>
<p>Here is the new process that will happen when we create a <code>ThreadPool</code>. We’ll
implement the code that sends the closure to the thread after we have <code>Worker</code>
set up in this way:</p>
<p>创建 <code>ThreadPool</code> 时的新流程如下。设置好 <code>Worker</code> 后，我们将实现将闭包发送给线程的代码：</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<!-- -->
<ol>
<li>定义包含 <code>id</code> 和 <code>JoinHandle&lt;()&gt;</code> 的 <code>Worker</code> 结构体</li>
<li>修改 <code>ThreadPool</code> 以保存 <code>Worker</code> 实例的向量</li>
<li>定义 <code>Worker::new</code> 函数，它接受 <code>id</code> 数字并返回包含 <code>id</code> 和用空闭包生成的线程的 <code>Worker</code> 实例</li>
<li>在 <code>ThreadPool::new</code> 中，使用 <code>for</code> 循环计数器生成 <code>id</code>，用该 <code>id</code> 创建新的 <code>Worker</code>，并将worker存储在向量中</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 21-15.</p>
<p>如果你准备好挑战，在查看代码清单21-15之前尝试自己实现这些更改。</p>
<p>Ready? Here is Listing 21-15 with one way to make the preceding modifications.</p>
<p>准备好了吗？以下是实现前述修改的一种方式（代码清单21-15）。</p>
<figure class="listing" id="listing-21-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-15">Listing 21-15</a>: Modifying <code>ThreadPool</code> to hold <code>Worker</code> instances instead of holding threads directly 修改 <code>ThreadPool</code> 以保存 <code>Worker</code> 实例而非直接保存线程</figcaption>
</figure>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>我们将 <code>ThreadPool</code> 上的字段从 <code>threads</code> 重命名为 <code>workers</code>，因为它现在保存的是 <code>Worker</code> 实例而非 <code>JoinHandle&lt;()&gt;</code> 实例。我们使用 <code>for</code> 循环中的计数器作为 <code>Worker::new</code> 的参数，并将每个新的 <code>Worker</code> 存储在名为 <code>workers</code> 的向量中。</p>
<p>External code (like our server in <em>src/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<p>外部代码（如 <em>src/main.rs</em> 中的服务器）不需要知道在线程池内使用 <code>Worker</code> 结构体的实现细节，因此我们将 <code>Worker</code> 结构体及其 <code>new</code> 函数设为私有。<code>Worker::new</code> 函数使用给定的 <code>id</code>，并存储通过空闭包生成新线程创建的 <code>JoinHandle&lt;()&gt;</code> 实例。</p>
<section class="note" aria-role="note">
<p>Note: If the operating system can’t create a thread because there aren’t
enough system resources, <code>thread::spawn</code> will panic. That will cause our
whole server to panic, even though the creation of some threads might
succeed. For simplicity’s sake, this behavior is fine, but in a production
thread pool implementation, you’d likely want to use
<code>std::thread::Builder</code> and its
<code>spawn</code> method that returns <code>Result</code> instead.</p>
<p>注意：如果操作系统因系统资源不足无法创建线程，<code>thread::spawn</code> 会panic。这将导致整个服务器panic，即使创建某些线程可能成功。为简单起见，此行为可以接受，但在生产级线程池实现中，可能需要使用 <code>std::thread::Builder</code> 及其返回 <code>Result</code> 的 <code>spawn</code> 方法。</p>
</section>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>
<p>此代码将编译并存储我们指定为 <code>ThreadPool::new</code> 参数的 <code>Worker</code> 实例数量。但我们仍未处理在 <code>execute</code> 中收到的闭包。接下来看看如何实现。</p>
<h4 id="sending-requests-to-threads-via-channels-通过通道向线程发送请求"><a class="header" href="#sending-requests-to-threads-via-channels-通过通道向线程发送请求">Sending Requests to Threads via Channels 通过通道向线程发送请求</a></h4>
<p>The next problem we’ll tackle is that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>下一个问题是传递给 <code>thread::spawn</code> 的闭包完全不执行任何操作。当前我们在 <code>execute</code> 方法中获取要执行的闭包。但在创建线程池期间创建每个 <code>Worker</code> 时，需要给 <code>thread::spawn</code> 一个要运行的闭包。</p>
<p>We want the <code>Worker</code> structs that we just created to fetch the code to run from
a queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>我们希望刚创建的 <code>Worker</code> 结构体从线程池持有的队列中获取要运行的代码，并将该代码发送给其线程运行。</p>
<p>The channels we learned about in Chapter 16—a simple way to communicate between
two threads—would be perfect for this use case. We’ll use a channel to function
as the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to
the <code>Worker</code> instances, which will send the job to its thread. Here is the plan:</p>
<p>第16章学习的通道（线程间通信的简单方式）非常适合此场景。我们将使用通道作为任务队列，<code>execute</code> 将任务从线程池发送给 <code>Worker</code> 实例，后者将任务发送给其线程。方案如下：</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sender.</li>
<li>Each <code>Worker</code> will hold on to the receiver.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute through the
sender.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiver and execute the
closures of any jobs it receives.</li>
</ol>
<!-- -->
<ol>
<li>线程池将创建通道并保留发送端</li>
<li>每个 <code>Worker</code> 将保留接收端</li>
<li>创建新的 <code>Job</code> 结构体来保存要通过通道发送的闭包</li>
<li><code>execute</code> 方法将通过发送端发送要执行的任务</li>
<li>在线程中，<code>Worker</code> 将循环遍历其接收端并执行收到的任何任务的闭包</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sender
in the <code>ThreadPool</code> instance, as shown in Listing 21-16. The <code>Job</code> struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.</p>
<p>让我们先在 <code>ThreadPool::new</code> 中创建通道，并将发送端保留在线程池实例中，如代码清单21-16所示。<code>Job</code> 结构体现在不包含任何内容，但将作为通过通道发送的项类型。</p>
<figure class="listing" id="listing-21-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-16">Listing 21-16</a>: Modifying <code>ThreadPool</code> to store the sender of a channel that transmits <code>Job</code> instances 修改 <code>ThreadPool</code> 存储传输 <code>Job</code> 实例的通道发送端</figcaption>
</figure>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sender. This will successfully compile.</p>
<p>在 <code>ThreadPool::new</code> 中，我们创建新通道并让池保留发送端。这将成功编译。</p>
<p>Let’s try passing a receiver of the channel into each <code>Worker</code> as the thread
pool creates the channel. We know we want to use the receiver in the thread that
the <code>Worker</code> instances spawn, so we’ll reference the <code>receiver</code> parameter in the
closure. The code in Listing 21-17 won’t quite compile yet.</p>
<p>尝试在创建通道时将通道的接收端传递给每个 <code>Worker</code>。我们知道希望在工作线程生成的线程中使用接收端，因此将在闭包中引用 <code>receiver</code> 参数。代码清单21-17中的代码尚不能完全编译。</p>
<figure class="listing" id="listing-21-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-17">Listing 21-17</a>: Passing the receiver to each <code>Worker</code> 将接收端传递给每个 <code>Worker</code></figcaption>
</figure>
<p>We’ve made some small and straightforward changes: we pass the receiver into
<code>Worker::new</code>, and then we use it inside the closure.</p>
<p>我们做了一些小而直接的更改：将接收端传递给 <code>Worker::new</code>，然后在闭包内部使用它。</p>
<p>When we try to check this code, we get this error:</p>
<p>尝试检查此代码时，出现以下错误：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t
just clone the consuming end of the channel to fix this code. We also don’t
want to send a message multiple times to multiple consumers; we want one list
of messages with multiple <code>Worker</code> instances such that each message gets
processed once.</p>
<p>代码尝试将 <code>receiver</code> 传递给多个 <code>Worker</code> 实例。这行不通，正如第16章回忆：Rust提供的通道实现是<strong>多生产者</strong>、<strong>单消费者</strong>。这意味着不能仅克隆通道的消费端来修复此代码。我们也不希望多次向多个消费者发送消息；而是需要一个包含多个 <code>Worker</code> 实例的消息列表，使每条消息被处理一次。</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>此外，从通道队列获取任务涉及修改 <code>receiver</code>，因此线程需要安全共享和修改 <code>receiver</code> 的方式；否则可能出现竞争条件（如第16章所述）。</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple <code>Worker</code> instances
own the receiver, and <code>Mutex</code> will ensure that only one <code>Worker</code> gets a job from
the receiver at a time. Listing 21-18 shows the changes we need to make.</p>
<p>回顾第16章讨论的线程安全智能指针：要在多个线程间共享所有权并允许线程修改值，需要使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。<code>Arc</code> 类型允许多个 <code>Worker</code> 实例拥有接收端，而 <code>Mutex</code> 确保一次只有一个 <code>Worker</code> 从接收端获取任务。代码清单21-18展示了所需的更改。</p>
<figure class="listing" id="listing-21-18">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{
    sync::{Arc, Mutex, mpsc},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-18">Listing 21-18</a>: Sharing the receiver among the <code>Worker</code> instances using <code>Arc</code> and <code>Mutex</code> 使用 <code>Arc</code> 和 <code>Mutex</code> 在 <code>Worker</code> 实例间共享接收端</figcaption>
</figure>
<p>In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each
new <code>Worker</code>, we clone the <code>Arc</code> to bump the reference count so the <code>Worker</code>
instances can share ownership of the receiver.</p>
<p>在 <code>ThreadPool::new</code> 中，我们将接收端放入 <code>Arc</code> 和 <code>Mutex</code>。对于每个新的 <code>Worker</code>，我们克隆 <code>Arc</code> 以增加引用计数，使 <code>Worker</code> 实例能共享接收端所有权。</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<p>通过这些更改，代码编译通过！我们快完成了！</p>
<h4 id="implementing-the-execute-method-实现-execute-方法"><a class="header" href="#implementing-the-execute-method-实现-execute-方法">Implementing the <code>execute</code> Method 实现 <code>execute</code> 方法</a></h4>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in “Creating Type Synonyms with
Type Aliases” in
Chapter 20, type aliases allow us to make long types shorter for ease of use.
Look at Listing 21-19.</p>
<p>最后实现 <code>ThreadPool</code> 上的 <code>execute</code> 方法。同时将 <code>Job</code> 从结构体改为类型别名，指向保存 <code>execute</code> 所接收闭包类型的特征对象。如第20章“使用类型别名创建类型同义词“所述，类型别名允许缩短长类型以便使用。见代码清单21-19。</p>
<figure class="listing" id="listing-21-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-19">Listing 21-19</a>: Creating a <code>Job</code> type alias for a <code>Box</code> that holds each closure and then sending the job down the channel 为保存每个闭包的 <code>Box</code> 创建 <code>Job</code> 类型别名，然后将任务发送到通道</figcaption>
</figure>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the
compiler doesn’t know that.</p>
<p>使用 <code>execute</code> 中收到的闭包创建新的 <code>Job</code> 实例后，我们将该任务通过通道的发送端发送。在 <code>send</code> 上调用 <code>unwrap</code> 以应对发送失败的情况。例如，如果我们停止所有线程执行（意味着接收端停止接收新消息）就可能发生。目前无法停止线程执行：只要池存在线程就继续执行。使用 <code>unwrap</code> 是因为我们知道失败情况不会发生，但编译器不知道。</p>
<p>But we’re not quite done yet! In the <code>Worker</code>, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 21-20 to <code>Worker::new</code>.</p>
<p>但我们尚未完成！在 <code>Worker</code> 中，传递给 <code>thread::spawn</code> 的闭包仍仅引用通道的接收端。我们需要闭包无限循环，向通道接收端请求任务并在获取时运行它。让我们按代码清单21-20修改 <code>Worker::new</code>。</p>
<figure class="listing" id="listing-21-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-20">Listing 21-20</a>: Receiving and executing the jobs in the <code>Worker</code> instance’s thread 在 <code>Worker</code> 实例的线程中接收和执行任务</figcaption>
</figure>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>这里首先在 <code>receiver</code> 上调用 <code>lock</code> 获取互斥锁，然后调用 <code>unwrap</code> 在出错时panic。获取锁可能失败（如果互斥锁处于 <strong>中毒(poisoned)</strong> 状态，当某线程持有锁时panic而未释放锁就可能发生）。此时调用 <code>unwrap</code> 使此线程panic是正确的操作。可随意将此 <code>unwrap</code> 改为包含对你有意义的错误信息的 <code>expect</code>。</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sender has shut down, similar to how the <code>send</code>
method returns <code>Err</code> if the receiver shuts down.</p>
<p>如果获取互斥锁成功，则调用 <code>recv</code> 从通道接收 <code>Job</code>。最后的 <code>unwrap</code> 同样用于处理错误（如果发送端持有者线程关闭就可能发生，类似于当接收端关闭时 <code>send</code> 方法返回 <code>Err</code>）。</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p><code>recv</code> 调用会阻塞，因此如果尚无任务，当前线程将等待直到任务可用。<code>Mutex&lt;T&gt;</code> 确保一次只有一个 <code>Worker</code> 线程尝试请求任务。</p>
<p>Our thread pool is now in a working state! Give it a <code>cargo run</code> and make some
requests:</p>
<p>线程池现在处于工作状态！运行 <code>cargo run</code> 并发出一些请求：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<p>成功！我们现在拥有一个异步执行连接的线程池。创建的线程数永远不会超过四个，因此即使服务器收到大量请求，系统也不会过载。如果向 <em>/sleep</em> 发出请求，服务器将通过让其他线程运行请求来服务其他请求。</p>
<section class="note" aria-role="note">
<p>Note: If you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load one at a time in five-second intervals. Some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
<p>注意：如果在多个浏览器窗口同时打开 <em>/sleep</em>，它们可能会以五秒间隔逐个加载。某些Web浏览器会顺序执行相同请求的多个实例以实现缓存。此限制并非由Web服务器引起。</p>
</section>
<p>This is a good time to pause and consider how the code in Listings 21-18, 21-19,
and 21-20 would be different if we were using futures instead of a closure for
the work to be done. What types would change? How would the method signatures be
different, if at all? What parts of the code would stay the same?</p>
<p>这是暂停并思考的好时机：如果使用future而不是闭包执行工作，代码清单21-18、21-19和21-20中的代码会有何不同？哪些类型会改变？方法签名会有何不同（如果有）？哪些代码部分保持不变？</p>
<p>After learning about the <code>while let</code> loop in Chapters 17 and 18, you might be
wondering why we didn’t write the worker thread code as shown in Listing 21-21.</p>
<p>在第17章和第18章学习 <code>while let</code> 循环后，你可能想知道为何不将工作线程代码写成代码清单21-21所示。</p>
<figure class="listing" id="listing-21-21">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption><a href="ch21-02-multithreaded.html#listing-21-21">Listing 21-21</a>: An alternative implementation of <code>Worker::new</code> using <code>while let</code> 使用 <code>while let</code> 的 <code>Worker::new</code> 替代实现</figcaption>
</figure>
<p>This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. However, this implementation can also result in the lock being held
longer than intended if we aren’t mindful of the lifetime of the
<code>MutexGuard&lt;T&gt;</code>.</p>
<p>此代码能编译运行，但不会产生预期的线程行为：慢请求仍会导致其他请求等待处理。原因有些微妙：<code>Mutex</code> 结构体没有公共 <code>unlock</code> 方法，因为锁的所有权基于 <code>lock</code> 方法返回的 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 中的 <code>MutexGuard&lt;T&gt;</code> 的生命周期。在编译时，借用检查器可以强制执行规则：除非持有锁，否则无法访问由 <code>Mutex</code> 保护的资源。但如果未注意 <code>MutexGuard&lt;T&gt;</code> 的生命周期，此实现也可能导致锁持有时间超过预期。</p>
<p>The code in Listing 21-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any
temporary values used in the expression on the right hand side of the equal
sign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of
the associated block. In Listing 21-21, the lock remains held for the duration
of the call to <code>job()</code>, meaning other <code>Worker</code> instances cannot receive jobs.</p>
<p>代码清单21-20使用 <code>let job = receiver.lock().unwrap().recv().unwrap();</code> 是可行的，因为对于 <code>let</code>，等号右侧表达式中的任何临时值在 <code>let</code> 语句结束时立即被丢弃。但 <code>while let</code>（以及 <code>if let</code> 和 <code>match</code>）直到关联块结束才丢弃临时值。在代码清单21-21中，锁在调用 <code>job()</code> 期间保持持有，意味着其他 <code>Worker</code> 实例无法接收任务。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="graceful-shutdown-and-cleanup"><a class="header" href="#graceful-shutdown-and-cleanup">Graceful Shutdown and Cleanup</a></h2>
<p>The code in Listing 21-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant
<kbd>ctrl</kbd>-<kbd>c</kbd> method to halt the main thread, all other threads
are stopped immediately as well, even if they’re in the middle of serving a
request.</p>
<p>如我们所愿，示例 21-20 中的代码通过线程池异步响应请求。关于 <code>workers</code>、<code>id</code> 和 <code>thread</code> 字段未被直接使用的警告提醒我们未进行任何清理。当使用较粗糙的 <kbd>ctrl</kbd>-<kbd>c</kbd> 方法终止主线程时，其他所有线程也会立即停止，即使它们正在处理请求。</p>
<p>Next, then, we’ll implement the <code>Drop</code> trait to call <code>join</code> on each of the
threads in the pool so they can finish the requests they’re working on before
closing. Then we’ll implement a way to tell the threads they should stop
accepting new requests and shut down. To see this code in action, we’ll modify
our server to accept only two requests before gracefully shutting down its
thread pool.</p>
<p>接下来，我们将实现 <code>Drop</code> trait 来对线程池中的每个线程调用 <code>join</code>，使它们能在关闭前完成正在处理的请求。然后实现一种通知线程停止接收新请求并关闭的方式。为观察代码运行，我们将修改服务器使其仅接受两个请求后优雅关闭线程池。</p>
<p>One thing to notice as we go: none of this affects the parts of the code that
handle executing the closures, so everything here would be just the same if we
were using a thread pool for an async runtime.</p>
<p>需注意：这些修改不影响执行闭包的代码部分，因此即使将线程池用于异步运行时，此处内容也完全适用。</p>
<h3 id="implementing-the-drop-trait-on-threadpool-为-threadpool-实现-drop-trait"><a class="header" href="#implementing-the-drop-trait-on-threadpool-为-threadpool-实现-drop-trait">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code> 为 <code>ThreadPool</code> 实现 <code>Drop</code> Trait</a></h3>
<p>Let’s start with implementing <code>Drop</code> on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 21-22 shows a first attempt at a <code>Drop</code> implementation; this code won’t
quite work yet.</p>
<p>首先为线程池实现 <code>Drop</code>。当线程池被丢弃时，所有线程应通过 <code>join</code> 确保完成工作。示例 21-22 展示了首次尝试的 <code>Drop</code> 实现；此代码尚未完全生效。</p>
<figure class="listing" id="listing-21-22">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-03-graceful-shutdown-and-cleanup.html#listing-21-22">Listing 21-22</a>: Joining each thread when the thread pool goes out of scope 当线程池离开作用域时连接每个线程</figcaption>
</figure>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for this
because <code>self</code> is a mutable reference, and we also need to be able to mutate
<code>worker</code>. For each worker, we print a message saying that this particular
<code>Worker</code> instance is shutting down, and then we call <code>join</code> on that <code>Worker</code>
instance’s thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust
panic and go into an ungraceful shutdown.</p>
<p>首先遍历线程池的每个 <code>workers</code>。此处使用 <code>&amp;mut</code> 因为 <code>self</code> 是可变引用，且需修改 <code>worker</code>。对每个 worker，打印其关闭信息，然后对其线程调用 <code>join</code>。若 <code>join</code> 调用失败，则用 <code>unwrap</code> 触发 Rust panic 进行非优雅关闭。</p>
<p>Here is the error we get when we compile this code:</p>
<p>编译错误如下：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:1876:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>The error tells us we can’t call <code>join</code> because we only have a mutable borrow of
each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this issue,
we need to move the thread out of the <code>Worker</code> instance that owns <code>thread</code> so
<code>join</code> can consume the thread. One way to do this is by taking the same approach
we did in Listing 18-15. If <code>Worker</code> held an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>,
we could call the <code>take</code> method on the <code>Option</code> to move the value out of the
<code>Some</code> variant and leave a <code>None</code> variant in its place. In other words, a
<code>Worker</code> that is running would have a <code>Some</code> variant in <code>thread</code>, and when we
wanted to clean up a <code>Worker</code>, we’d replace <code>Some</code> with <code>None</code> so the <code>Worker</code>
wouldn’t have a thread to run.</p>
<p>错误表明因仅拥有 <code>worker</code> 的可变借用，而 <code>join</code> 需获取参数所有权，故无法调用。解决方案是：将线程移出拥有它的 <code>Worker</code> 实例，使 <code>join</code> 能消费线程。可参考示例 18-15 的做法。若 <code>Worker</code> 持有 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>，则可对 <code>Option</code> 调用 <code>take</code> 方法移出 <code>Some</code> 的值并替换为 <code>None</code>。即运行中的 <code>Worker</code> 在 <code>thread</code> 字段存有 <code>Some</code>，清理时用 <code>None</code> 替换使 <code>Worker</code> 无线程可运行。</p>
<p>However, the <em>only</em> time this would come up would be when dropping the <code>Worker</code>.
In exchange, we’d have to deal with an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> anywhere
we accessed <code>worker.thread</code>. Idiomatic Rust uses <code>Option</code> quite a bit, but when
you find yourself wrapping something you know will always be present in <code>Option</code>
as a workaround like this, it’s a good idea to look for alternative approaches.
They can make your code cleaner and less error-prone.</p>
<p>但这种情况仅在丢弃 <code>Worker</code> 时出现。代价是每次访问 <code>worker.thread</code> 都需处理 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>。虽然 Rust 惯常用法常用 <code>Option</code>，但当仅为解决已知必然存在的情况而包裹 <code>Option</code> 时，应考虑替代方案，它们能使代码更清晰且不易出错。</p>
<p>In this case, a better alternative exists: the <code>Vec::drain</code> method. It accepts
a range parameter to specify which items to remove from the <code>Vec</code>, and returns
an iterator of those items. Passing the <code>..</code> range syntax will remove <em>every</em>
value from the <code>Vec</code>.</p>
<p>此处存在更佳方案：<code>Vec::drain</code> 方法。它接受范围参数指定要移除的项，并返回这些项的迭代器。使用 <code>..</code> 范围语法将移除 <code>Vec</code> 中的全部值。</p>
<p>So we need to update the <code>ThreadPool</code> <code>drop</code> implementation like this:</p>
<p>因此需如下更新 <code>ThreadPool</code> 的 <code>drop</code> 实现：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</figure>
<p>This resolves the compiler error and does not require any other changes to our
code.</p>
<p>这解决了编译错误且无需其他代码修改。</p>
<h3 id="signaling-to-the-threads-to-stop-listening-for-jobs-通知线程停止监听任务"><a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs-通知线程停止监听任务">Signaling to the Threads to Stop Listening for Jobs 通知线程停止监听任务</a></h3>
<p>With all the changes we’ve made, our code compiles without any warnings.
However, the bad news is that this code doesn’t function the way we want it to
yet. The key is the logic in the closures run by the threads of the <code>Worker</code>
instances: at the moment, we call <code>join</code>, but that won’t shut down the threads
because they <code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code>
with our current implementation of <code>drop</code>, the main thread will block forever,
waiting for the first thread to finish.</p>
<p>完成所有修改后，代码编译无警告。但问题在于代码未按预期运行：关键在于 <code>Worker</code> 实例线程运行的闭包逻辑——当前调用 <code>join</code> 不会关闭线程，因为它们无限循环查找任务。若用当前 <code>drop</code> 实现丢弃 <code>ThreadPool</code>，主线程将永远阻塞等待首个线程结束。</p>
<p>To fix this problem, we’ll need a change in the <code>ThreadPool</code> <code>drop</code>
implementation and then a change in the <code>Worker</code> loop.</p>
<p>修复此问题需先修改 <code>ThreadPool</code> 的 <code>drop</code> 实现，再调整 <code>Worker</code> 循环。</p>
<p>First we’ll change the <code>ThreadPool</code> <code>drop</code> implementation to explicitly drop
the <code>sender</code> before waiting for the threads to finish. Listing 21-23 shows the
changes to <code>ThreadPool</code> to explicitly drop <code>sender</code>. Unlike with the thread,
here we <em>do</em> need to use an <code>Option</code> to be able to move <code>sender</code> out of
<code>ThreadPool</code> with <code>Option::take</code>.</p>
<p>首先在等待线程结束前显式丢弃 <code>sender</code>。示例 21-23 展示了对 <code>ThreadPool</code> 的修改。与线程不同，此处需用 <code>Option</code> 配合 <code>Option::take</code> 移出 <code>sender</code>。</p>
<figure class="listing" id="listing-21-23">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-03-graceful-shutdown-and-cleanup.html#listing-21-23">Listing 21-23</a>: Explicitly drop <code>sender</code> before joining the <code>Worker</code> threads 在连接 <code>Worker</code> 线程前显式丢弃 <code>sender</code></figcaption>
</figure>
<p>Dropping <code>sender</code> closes the channel, which indicates no more messages will be
sent. When that happens, all the calls to <code>recv</code> that the <code>Worker</code> instances do
in the infinite loop will return an error. In Listing 21-24, we change the
<code>Worker</code> loop to gracefully exit the loop in that case, which means the threads
will finish when the <code>ThreadPool</code> <code>drop</code> implementation calls <code>join</code> on them.</p>
<p>丢弃 <code>sender</code> 会关闭通道，表明不再发送消息。此时，<code>Worker</code> 实例在无限循环中的所有 <code>recv</code> 调用将返回错误。在示例 21-24 中，我们修改 <code>Worker</code> 循环以优雅退出，这意味着当 <code>ThreadPool</code> 的 <code>drop</code> 实现调用 <code>join</code> 时线程将结束。</p>
<figure class="listing" id="listing-21-24">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let message = receiver.lock().unwrap().recv();

                match message {
                    Ok(job) =&gt; {
                        println!("Worker {id} got a job; executing.");

                        job();
                    }
                    Err(_) =&gt; {
                        println!("Worker {id} disconnected; shutting down.");
                        break;
                    }
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<figcaption><a href="ch21-03-graceful-shutdown-and-cleanup.html#listing-21-24">Listing 21-24</a>: Explicitly breaking out of the loop when <code>recv</code> returns an error 当 <code>recv</code> 返回错误时显式跳出循环</figcaption>
</figure>
<p>To see this code in action, let’s modify <code>main</code> to accept only two requests
before gracefully shutting down the server, as shown in Listing 21-25.</p>
<p>为观察运行，如示例 21-25 所示修改 <code>main</code> 使其仅接受两个请求后优雅关闭服务器。</p>
<figure class="listing" id="listing-21-25">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="ch21-03-graceful-shutdown-and-cleanup.html#listing-21-25">Listing 21-25</a>: Shutting down the server after serving two requests by exiting the loop 服务两个请求后退出循环以关闭服务器</figcaption>
</figure>
<p>You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.</p>
<p>真实场景的 Web 服务器不会仅服务两个请求就关闭。此代码仅演示优雅关闭和清理功能正常工作。</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration
to the first two items at most. The <code>ThreadPool</code> will go out of scope at the
end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p><code>take</code> 方法定义于 <code>Iterator</code> trait，将迭代限制为最多前两项。<code>ThreadPool</code> 在 <code>main</code> 结束时离开作用域，其 <code>drop</code> 实现将运行。</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output similar to this:</p>
<p>用 <code>cargo run</code> 启动服务器并发三个请求。第三个请求应出错，终端输出类似：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of <code>Worker</code> IDs and messages printed. We can
see how this code works from the messages: <code>Worker</code> instances 0 and 3 got the
first two requests. The server stopped accepting connections after the second
connection, and the <code>Drop</code> implementation on <code>ThreadPool</code> starts executing
before <code>Worker</code> 3 even starts its job. Dropping the <code>sender</code> disconnects all the
<code>Worker</code> instances and tells them to shut down. The <code>Worker</code> instances each
print a message when they disconnect, and then the thread pool calls <code>join</code> to
wait for each <code>Worker</code> thread to finish.</p>
<p>输出中的 <code>Worker</code> ID 和消息顺序可能不同。从消息可知：<code>Worker</code> 0 和 3 处理了前两个请求。服务器在第二个连接后停止接受连接，且 <code>ThreadPool</code> 的 <code>Drop</code> 实现甚至在 <code>Worker</code> 3 开始工作前就执行。丢弃 <code>sender</code> 断开所有 <code>Worker</code> 实例的连接并通知关闭。各 <code>Worker</code> 在断开时打印消息，随后线程池调用 <code>join</code> 等待每个线程结束。</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code>
dropped the <code>sender</code>, and before any <code>Worker</code> received an error, we tried to
join <code>Worker</code> 0. <code>Worker</code> 0 had not yet gotten an error from <code>recv</code>, so the main
thread blocked waiting for <code>Worker</code> 0 to finish. In the meantime, <code>Worker</code> 3
received a job and then all threads received an error. When <code>Worker</code> 0 finished,
the main thread waited for the rest of the <code>Worker</code> instances to finish. At that
point, they had all exited their loops and stopped.</p>
<p>注意此执行过程的细节：<code>ThreadPool</code> 丢弃 <code>sender</code> 后，在任何 <code>Worker</code> 收到错误前，我们尝试连接 <code>Worker</code> 0。此时 <code>Worker</code> 0 尚未从 <code>recv</code> 收到错误，故主线程阻塞等待其结束。其间 <code>Worker</code> 3 收到任务，随后所有线程均收到错误。当 <code>Worker</code> 0 结束后，主线程等待其余 <code>Worker</code> 结束。此时它们均已退出循环并停止。</p>
<p>Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.</p>
<p>恭喜！我们已完成项目：拥有一个使用线程池异步响应的基础 Web 服务器，并能优雅关闭服务器以清理线程池中所有线程。</p>
<p>Here’s the full code for reference:</p>
<p>完整代码参考：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</figure>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::{
    sync::{Arc, Mutex, mpsc},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let message = receiver.lock().unwrap().recv();

                match message {
                    Ok(job) =&gt; {
                        println!("Worker {id} got a job; executing.");

                        job();
                    }
                    Err(_) =&gt; {
                        println!("Worker {id} disconnected; shutting down.");
                        break;
                    }
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</figure>
<p>We could do more here! If you want to continue enhancing this project, here are
some ideas:</p>
<p>还可进一步优化！增强项目的建议：</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library’s functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/">crates.io</a> and implement a
similar web server using the crate instead. Then compare its API and
robustness to the thread pool we implemented.</li>
</ul>
<!-- -->
<ul>
<li>为 <code>ThreadPool</code> 及其公共方法添加文档</li>
<li>为库功能添加测试</li>
<li>将 <code>unwrap</code> 调用改为健壮的错误处理</li>
<li>使用 <code>ThreadPool</code> 执行除 Web 请求外的任务</li>
<li>在 <a href="https://crates.io/">crates.io</a> 查找线程池 crate，并用其实现类似 Web 服务器，对比其 API 和健壮性</li>
</ul>
<h2 id="summary-总结-20"><a class="header" href="#summary-总结-20">Summary 总结</a></h2>
<p>Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other people’s projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.</p>
<p>太棒了！您已完成本书学习！感谢您参与这次 Rust 之旅。现在您已能实现自己的 Rust 项目并协助他人项目。请记住，Rust 社区充满热情，当您在 Rust 之旅中遇到挑战时，随时可向乐于助人的 Rustacean 们寻求帮助。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-附录"><a class="header" href="#appendix-附录">Appendix 附录</a></h1>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<p>以下部分包含在Rust学习旅程中可能有用的参考资料。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-a-keywords-关键字"><a class="header" href="#appendix-a-keywords-关键字">Appendix A: Keywords 关键字</a></h2>
<p>The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we’ll discuss in the “Raw
Identifiers” section). Identifiers are names
of functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.</p>
<p>以下列表包含Rust语言保留供当前或未来使用的关键字。因此，它们不能用作标识符（除非作为原始标识符，我们将在“原始标识符“部分讨论）。标识符是指函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、特质或生命周期的名称。</p>
<h3 id="keywords-currently-in-use-当前使用的关键字"><a class="header" href="#keywords-currently-in-use-当前使用的关键字">Keywords Currently in Use 当前使用的关键字</a></h3>
<p>The following is a list of keywords currently in use, with their functionality
described.</p>
<p>以下是当前使用的关键字列表及其功能描述：</p>
<ul>
<li><code>as</code> - perform primitive casting, disambiguate the specific trait containing
an item, or rename items in <code>use</code> statements</li>
<li><code>async</code> - return a <code>Future</code> instead of blocking the current thread</li>
<li><code>await</code> - suspend execution until the result of a <code>Future</code> is ready</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - define constant items or constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - in a module path, refers to the crate root</li>
<li><code>dyn</code> - dynamic dispatch to a trait object</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>extern</code> - link an external function or variable</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define a function or the function pointer type</li>
<li><code>for</code> - loop over items from an iterator, implement a trait, or specify a
higher-ranked lifetime</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - bind a variable</li>
<li><code>loop</code> - loop unconditionally</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - denote mutability in references, raw pointers, or pattern bindings</li>
<li><code>pub</code> - denote public visibility in struct fields, <code>impl</code> blocks, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - a type alias for the type we are defining or implementing</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - define a structure</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - define a type alias or associated type</li>
<li><code>union</code> - define a union; is only a keyword when used
in a union declaration</li>
<li><code>unsafe</code> - denote unsafe code, functions, traits, or implementations</li>
<li><code>use</code> - bring symbols into scope; specify precise captures for generic and
lifetime bounds</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<!-- -->
<ul>
<li><code>as</code> - 执行基本类型转换，消除包含项的特定特质的歧义，或在<code>use</code>语句中重命名项</li>
<li><code>async</code> - 返回<code>Future</code>而不是阻塞当前线程</li>
<li><code>await</code> - 暂停执行直到<code>Future</code>结果就绪</li>
<li><code>break</code> - 立即退出循环</li>
<li><code>const</code> - 定义常量项或常量裸指针</li>
<li><code>continue</code> - 继续下一次循环迭代</li>
<li><code>crate</code> - 在模块路径中指向crate根目录</li>
<li><code>dyn</code> - 对特质对象进行动态分发</li>
<li><code>else</code> - <code>if</code>和<code>if let</code>控制流结构的备用分支</li>
<li><code>enum</code> - 定义枚举</li>
<li><code>extern</code> - 链接外部函数或变量</li>
<li><code>false</code> - 布尔值假字面量</li>
<li><code>fn</code> - 定义函数或函数指针类型</li>
<li><code>for</code> - 遍历迭代器中的项，实现特质，或指定高阶生命周期</li>
<li><code>if</code> - 基于条件表达式结果进行分支</li>
<li><code>impl</code> - 实现固有功能或特质功能</li>
<li><code>in</code> - <code>for</code>循环语法的一部分</li>
<li><code>let</code> - 绑定变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 将值与模式匹配</li>
<li><code>mod</code> - 定义模块</li>
<li><code>move</code> - 使闭包获取其所有捕获的所有权</li>
<li><code>mut</code> - 表示引用、裸指针或模式绑定中的可变性</li>
<li><code>pub</code> - 表示结构体字段、<code>impl</code>块或模块中的公开可见性</li>
<li><code>ref</code> - 通过引用绑定</li>
<li><code>return</code> - 从函数返回</li>
<li><code>Self</code> - 当前定义或实现类型的类型别名</li>
<li><code>self</code> - 方法主体或当前模块</li>
<li><code>static</code> - 全局变量或持续整个程序执行期间的生命周期</li>
<li><code>struct</code> - 定义结构体</li>
<li><code>super</code> - 当前模块的父模块</li>
<li><code>trait</code> - 定义特质</li>
<li><code>true</code> - 布尔值真字面量</li>
<li><code>type</code> - 定义类型别名或关联类型</li>
<li><code>union</code> - 定义联合体；仅在联合体声明中作为关键字</li>
<li><code>unsafe</code> - 表示不安全代码、函数、特质或实现</li>
<li><code>use</code> - 将符号引入作用域；为泛型和生命周期约束指定精确捕获</li>
<li><code>where</code> - 表示约束类型的子句</li>
<li><code>while</code> - 基于表达式结果有条件地循环</li>
</ul>
<h3 id="keywords-reserved-for-future-use-保留供未来使用的关键字"><a class="header" href="#keywords-reserved-for-future-use-保留供未来使用的关键字">Keywords Reserved for Future Use 保留供未来使用的关键字</a></h3>
<p>The following keywords do not yet have any functionality but are reserved by
Rust for potential future use.</p>
<p>以下关键字尚无任何功能，但被Rust保留供未来潜在使用：</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="raw-identifiers-原始标识符"><a class="header" href="#raw-identifiers-原始标识符">Raw Identifiers 原始标识符</a></h3>
<p><em>Raw identifiers</em> are the syntax that lets you use keywords where they wouldn’t
normally be allowed. You use a raw identifier by prefixing a keyword with <code>r#</code>.</p>
<p>原始标识符是一种语法，允许在通常不允许的地方使用关键字。通过在关键字前添加<code>r#</code>前缀来使用原始标识符。</p>
<p>For example, <code>match</code> is a keyword. If you try to compile the following function
that uses <code>match</code> as its name:</p>
<p>例如，<code>match</code>是一个关键字。如果尝试编译以下使用<code>match</code>作为函数名的函数：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>you’ll get this error:</p>
<p>会出现以下错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>The error shows that you can’t use the keyword <code>match</code> as the function
identifier. To use <code>match</code> as a function name, you need to use the raw
identifier syntax, like this:</p>
<p>错误表明不能使用关键字<code>match</code>作为函数标识符。要将<code>match</code>用作函数名，需要使用原始标识符语法：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>This code will compile without any errors. Note the <code>r#</code> prefix on the function
name in its definition as well as where the function is called in <code>main</code>.</p>
<p>此代码将无错误编译。注意函数定义处的<code>r#</code>前缀以及<code>main()</code>中调用函数的位置。</p>
<p>Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. This gives us more freedom to choose
identifier names, as well as lets us integrate with programs written in a
language where these words aren’t keywords. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, <code>try</code> isn’t a keyword in the 2015 edition but is in the 2018, 2021,
and 2024 editions. If you depend on a library that is written using the 2015
edition and has a <code>try</code> function, you’ll need to use the raw identifier syntax,
<code>r#try</code> in this case, to call that function from your code on later editions.
See Appendix E for more information on editions.</p>
<p>原始标识符允许使用任意单词作为标识符，即使该单词是保留关键字。这为我们选择标识符名称提供了更多自由，也让我们能够与使用非关键字语言编写的程序集成。此外，原始标识符允许使用与当前crate不同Rust版本编写的库。例如，<code>try</code>在2015版中不是关键字，但在2018、2021和2024版中是。如果依赖使用2015版编写并包含<code>try</code>函数的库，则需要使用原始标识符语法（此处为<code>r#try</code>）从后续版本的代码中调用该函数。有关版本的更多信息，请参阅附录E。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-b-operators-and-symbols-运算符和符号"><a class="header" href="#appendix-b-operators-and-symbols-运算符和符号">Appendix B: Operators and Symbols 运算符和符号</a></h2>
<p>This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.</p>
<p>本附录包含Rust语法的词汇表，包括运算符和其他独立出现或在路径、泛型、特质约束、宏、属性、注释、元组和括号上下文中出现的符号。</p>
<h3 id="operators-运算符"><a class="header" href="#operators-运算符">Operators 运算符</a></h3>
<p>Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<p>表B-1包含Rust中的运算符、运算符在上下文中出现的示例、简要说明以及该运算符是否可重载。如果运算符可重载，则列出用于重载该运算符的相关特质。</p>
<p><span class="caption">Table B-1: Operators 运算符</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro expansion</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Borrow</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Borrowed pointer type</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Short-circuiting logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereference</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Raw pointer</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Compound type constraint</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|…| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Field access</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident(expr, ...)</code></td><td>Method call</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Tuple indexing</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Right-exclusive range literal</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Right-inclusive range literal</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Struct literal update syntax</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“And the rest” pattern binding</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Deprecated, use <code>..=</code> instead) In a pattern: inclusive range pattern</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Loop label</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Part of fixed-size array syntax</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignment/equivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Pattern alternatives</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Short-circuiting logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Error propagation</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>运算符</th><th>示例</th><th>说明</th><th>可重载？</th><th>相关特质</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>宏展开</td><td>不可重载</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>按位或逻辑取反</td><td>可重载</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>不等比较</td><td>可重载</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>算术取余</td><td>可重载</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>算术取余并赋值</td><td>可重载</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>借用</td><td>不可重载</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>借用指针类型</td><td>不可重载</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>按位与</td><td>可重载</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>按位与并赋值</td><td>可重载</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>短路逻辑与</td><td>不可重载</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>算术乘法</td><td>可重载</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>算术乘法并赋值</td><td>可重载</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>解引用</td><td>可重载</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>裸指针</td><td>不可重载</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>复合类型约束</td><td>不可重载</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>算术加法</td><td>可重载</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>算术加法并赋值</td><td>可重载</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>参数和元素分隔符</td><td>不可重载</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>算术取负</td><td>可重载</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>算术减法</td><td>可重载</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>算术减法并赋值</td><td>可重载</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|…| -&gt; type</code></td><td>函数和闭包返回类型</td><td>不可重载</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>字段访问</td><td>不可重载</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident(expr, ...)</code></td><td>方法调用</td><td>不可重载</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.0</code>, <code>expr.1</code>等</td><td>元组索引</td><td>不可重载</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>右开区间字面量</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>右闭区间字面量</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>结构体字面量更新语法</td><td>不可重载</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“其余部分“模式绑定</td><td>不可重载</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(已弃用，改用<code>..=</code>) 在模式中：包含区间模式</td><td>不可重载</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>算术除法</td><td>可重载</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>算术除法并赋值</td><td>可重载</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>约束</td><td>不可重载</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>结构体字段初始化器</td><td>不可重载</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>循环标签</td><td>不可重载</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>语句和项终止符</td><td>不可重载</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>固定大小数组语法的一部分</td><td>不可重载</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>左移</td><td>可重载</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>左移并赋值</td><td>可重载</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>小于比较</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>小于等于比较</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>赋值/等价</td><td>不可重载</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>相等比较</td><td>可重载</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>match分支语法的一部分</td><td>不可重载</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>大于比较</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>大于等于比较</td><td>可重载</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>右移</td><td>可重载</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>右移并赋值</td><td>可重载</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>模式绑定</td><td>不可重载</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>按位异或</td><td>可重载</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>按位异或并赋值</td><td>可重载</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>模式备选项</td><td>不可重载</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>按位或</td><td>可重载</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>按位或并赋值</td><td>可重载</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>短路逻辑或</td><td>不可重载</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>错误传播</td><td>不可重载</td><td></td></tr>
</tbody></table>
</div>
<h3 id="non-operator-symbols-非运算符符号"><a class="header" href="#non-operator-symbols-非运算符符号">Non-operator Symbols 非运算符符号</a></h3>
<p>The following list contains all symbols that don’t function as operators; that
is, they don’t behave like a function or method call.</p>
<p>以下列表包含所有不作为运算符功能的符号；即它们的行为不像函数或方法调用。</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.</p>
<p>表B-2显示了独立出现且在多种位置有效的符号。</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax 独立语法</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Named lifetime or loop label</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>"..."</code></td><td>String literal</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>, etc.</td><td>Raw string literal, escape characters not processed</td></tr>
<tr><td><code>b"..."</code></td><td>Byte string literal; constructs an array of bytes instead of a string</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>Raw byte string literal, combination of raw and byte string literal</td></tr>
<tr><td><code>'...'</code></td><td>Character literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII byte literal</td></tr>
<tr><td><code>|…| expr</code></td><td>Closure</td></tr>
<tr><td><code>!</code></td><td>Always empty bottom type for diverging functions</td></tr>
<tr><td><code>_</code></td><td>“Ignored” pattern binding; also used to make integer literals readable</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>命名生命周期或循环标签</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>等</td><td>指定类型的数字字面量</td></tr>
<tr><td><code>"..."</code></td><td>字符串字面量</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>等</td><td>原始字符串字面量（不处理转义字符）</td></tr>
<tr><td><code>b"..."</code></td><td>字节字符串字面量（构造字节数组而非字符串）</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>等</td><td>原始字节字符串字面量（原始和字节字符串字面量的组合）</td></tr>
<tr><td><code>'...'</code></td><td>字符字面量</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII字节字面量</td></tr>
<tr><td><code>|…| expr</code></td><td>闭包</td></tr>
<tr><td><code>!</code></td><td>发散函数的始终空底部类型</td></tr>
<tr><td><code>_</code></td><td>“忽略“模式绑定；也用于提高整数字面量可读性</td></tr>
</tbody></table>
</div>
<p>Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.</p>
<p>表B-3显示了在通过模块层次结构访问项的路径上下文中出现的符号。</p>
<p><span class="caption">Table B-3: Path-Related Syntax 路径相关语法</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the extern prelude, where all other crates are rooted (i.e., an explicitly absolute path including crate name)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it’s defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>命名空间路径</td></tr>
<tr><td><code>::path</code></td><td>相对于外部预导入的路径（即包含crate名称的显式绝对路径）</td></tr>
<tr><td><code>self::path</code></td><td>相对于当前模块的路径（即显式相对路径）</td></tr>
<tr><td><code>super::path</code></td><td>相对于当前模块父模块的路径</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>关联常量、函数和类型</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>无法直接命名的类型的关联项（例如<code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>等）</td></tr>
<tr><td><code>trait::method(...)</code></td><td>通过命名定义方法的特质来消除方法调用歧义</td></tr>
<tr><td><code>type::method(...)</code></td><td>通过命名方法定义的类型来消除方法调用歧义</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>通过命名特质和类型来消除方法调用歧义</td></tr>
</tbody></table>
</div>
<p>Table B-4 shows symbols that appear in the context of using generic type
parameters.</p>
<p>表B-4显示了在使用泛型类型参数的上下文中出现的符号。</p>
<p><span class="caption">Table B-4: Generics 泛型</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Higher-ranked lifetime bounds</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>指定类型中泛型的参数（例如<code>Vec&lt;u8&gt;</code>）</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>在表达式中指定泛型类型、函数或方法的参数（通常称为turbofish，例如<code>"42".parse::&lt;i32&gt;()</code>）</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>定义泛型函数</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>定义泛型结构体</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>定义泛型枚举</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>定义泛型实现</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>高阶生命周期约束</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>一个或多个关联类型具有特定赋值的泛型类型（例如<code>Iterator&lt;Item=T&gt;</code>）</td></tr>
</tbody></table>
</div>
<p>Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.</p>
<p>表B-5显示了在用特质约束限制泛型类型参数的上下文中出现的符号。</p>
<p><span class="caption">Table B-5: Trait Bound Constraints 特质约束</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Generic parameter <code>T</code> constrained to types that implement <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones</td></tr>
<tr><td><code>'b: 'a</code></td><td>Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Allow generic type parameter to be a dynamically sized type</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Compound type constraint</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>泛型参数<code>T</code>被约束为实现<code>U</code>的类型</td></tr>
<tr><td><code>T: 'a</code></td><td>泛型类型<code>T</code>必须比生命周期<code>'a</code>存活更久（即该类型不能传递性包含任何生命周期短于<code>'a</code>的引用）</td></tr>
<tr><td><code>T: 'static</code></td><td>泛型类型<code>T</code>不包含除<code>'static</code>之外的借用引用</td></tr>
<tr><td><code>'b: 'a</code></td><td>泛型生命周期<code>'b</code>必须比生命周期<code>'a</code>存活更久</td></tr>
<tr><td><code>T: ?Sized</code></td><td>允许泛型类型参数为动态大小类型</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>复合类型约束</td></tr>
</tbody></table>
</div>
<p>Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.</p>
<p>表B-6显示了在调用或定义宏以及在项上指定属性的上下文中出现的符号。</p>
<p><span class="caption">Table B-6: Macros and Attributes 宏与属性</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Outer attribute</td></tr>
<tr><td><code>#![meta]</code></td><td>Inner attribute</td></tr>
<tr><td><code>$ident</code></td><td>Macro substitution</td></tr>
<tr><td><code>$ident:kind</code></td><td>Macro capture</td></tr>
<tr><td><code>$(…)…</code></td><td>Macro repetition</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro invocation</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>外部属性</td></tr>
<tr><td><code>#![meta]</code></td><td>内部属性</td></tr>
<tr><td><code>$ident</code></td><td>宏替换</td></tr>
<tr><td><code>$ident:kind</code></td><td>宏捕获</td></tr>
<tr><td><code>$(…)…</code></td><td>宏重复</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>宏调用</td></tr>
</tbody></table>
</div>
<p>Table B-7 shows symbols that create comments.</p>
<p>表B-7显示了创建注释的符号。</p>
<p><span class="caption">Table B-7: Comments 注释</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
<tr><td><code>//!</code></td><td>Inner line doc comment</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>行注释</td></tr>
<tr><td><code>//!</code></td><td>内部行文档注释</td></tr>
<tr><td><code>///</code></td><td>外部行文档注释</td></tr>
<tr><td><code>/*...*/</code></td><td>块注释</td></tr>
<tr><td><code>/*!...*/</code></td><td>内部块文档注释</td></tr>
<tr><td><code>/**...*/</code></td><td>外部块文档注释</td></tr>
</tbody></table>
</div>
<p>Table B-8 shows the contexts in which parentheses are used.</p>
<p>表B-8显示了使用圆括号的上下文。</p>
<p><span class="caption">Table B-8: Parentheses 圆括号</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>空元组（即单元类型），字面量和类型</td></tr>
<tr><td><code>(expr)</code></td><td>括号表达式</td></tr>
<tr><td><code>(expr,)</code></td><td>单元素元组表达式</td></tr>
<tr><td><code>(type,)</code></td><td>单元素元组类型</td></tr>
<tr><td><code>(expr, ...)</code></td><td>元组表达式</td></tr>
<tr><td><code>(type, ...)</code></td><td>元组类型</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>函数调用表达式；也用于初始化元组结构体和元组枚举变体</td></tr>
</tbody></table>
</div>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<p>表B-9显示了使用花括号的上下文。</p>
<p><span class="caption">Table B-9: Curly Brackets 花括号</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>上下文</th><th>说明</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>块表达式</td></tr>
<tr><td><code>Type {...}</code></td><td>结构体字面量</td></tr>
</tbody></table>
</div>
<p>Table B-10 shows the contexts in which square brackets are used.</p>
<p>表B-10显示了使用方括号的上下文。</p>
<p><span class="caption">Table B-10: Square Brackets 方括号</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array literal</td></tr>
<tr><td><code>[expr; len]</code></td><td>Array literal containing <code>len</code> copies of <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Array type containing <code>len</code> instances of <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the “index”</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>上下文</th><th>说明</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>数组字面量</td></tr>
<tr><td><code>[expr; len]</code></td><td>包含<code>len</code>个<code>expr</code>副本的数组字面量</td></tr>
<tr><td><code>[type; len]</code></td><td>包含<code>len</code>个<code>type</code>实例的数组类型</td></tr>
<tr><td><code>expr[expr]</code></td><td>集合索引（可重载，<code>Index</code>, <code>IndexMut</code>）</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>使用<code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>或<code>RangeFull</code>作为“索引“的伪切片集合索引</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-c-derivable-traits-可派生特质"><a class="header" href="#appendix-c-derivable-traits-可派生特质">Appendix C: Derivable Traits 可派生特质</a></h2>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the <code>derive</code> syntax.</p>
<p>在本书的不同地方，我们讨论了<code>derive</code>属性，您可以将其应用于结构体或枚举定义。<code>derive</code>属性生成代码，将在使用<code>derive</code>语法标注的类型上使用其默认实现来实现特质。</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<p>在本附录中，我们提供了标准库中所有可通过<code>derive</code>使用的特质的参考。每个部分涵盖：</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<!-- -->
<ul>
<li>派生该特质将启用的运算符和方法</li>
<li><code>derive</code>提供的特质实现的功能</li>
<li>实现该特质对类型的意义</li>
<li>允许或不允许实现该特质的条件</li>
<li>需要该特质的操作示例</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute,
consult the <a href="../std/index.html">standard library documentation</a>
for each trait for details on how to manually implement them.</p>
<p>如果您需要不同于<code>derive</code>属性提供的功能，请查阅<a href="https://doc.rust-lang.org/std/index.html">标准库文档</a>获取手动实现这些特质的详细信息。</p>
<p>The traits listed here are the only ones defined by the standard library that
can be implemented on your types using <code>derive</code>. Other traits defined in the
standard library don’t have sensible default behavior, so it’s up to you to
implement them in the way that makes sense for what you’re trying to accomplish.</p>
<p>此处列出的特质是标准库中唯一可以通过<code>derive</code>在您的类型上实现的特质。标准库中定义的其他特质没有合理的默认行为，因此需要您根据要实现的目标以合理的方式实现它们。</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.</p>
<p>无法被派生的特质的一个例子是<code>Display</code>，它处理面向最终用户的格式化。您应始终考虑向最终用户展示类型的适当方式。最终用户应被允许看到类型的哪些部分？哪些部分对他们来说是相关的？数据的什么格式对他们最相关？Rust编译器没有这种洞察力，因此无法为您提供适当的默认行为。</p>
<p>The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the
“Macros” section of Chapter 20.</p>
<p>本附录提供的可派生特质列表并非详尽无遗：库可以为它们自己的特质实现<code>derive</code>，使您可以使用<code>derive</code>的特质列表真正无限扩展。实现<code>derive</code>涉及使用过程宏，这将在第20章的“宏“部分介绍。</p>
<h3 id="debug-for-programmer-output-面向程序输出的debug"><a class="header" href="#debug-for-programmer-output-面向程序输出的debug"><code>Debug</code> for Programmer Output 面向程序输出的<code>Debug</code></a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p><code>Debug</code>特质在格式化字符串中启用调试格式化，通过在<code>{}</code>占位符内添加<code>:?</code>来指示。</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.</p>
<p><code>Debug</code>特质允许您打印类型的实例以进行调试，这样您和其他使用您的类型的程序员可以在程序执行的特定点检查实例。</p>
<p>The <code>Debug</code> trait is required, for example, in the use of the <code>assert_eq!</code>
macro. This macro prints the values of instances given as arguments if the
equality assertion fails so programmers can see why the two instances weren’t
equal.</p>
<p>例如，在使用<code>assert_eq!</code>宏时就需要<code>Debug</code>特质。如果相等断言失败，此宏会打印作为参数给出的实例值，以便程序员可以看到两个实例不相等的原因。</p>
<h3 id="partialeq-and-eq-for-equality-comparisons-用于相等比较的partialeq和eq"><a class="header" href="#partialeq-and-eq-for-equality-comparisons-用于相等比较的partialeq和eq"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons 用于相等比较的<code>PartialEq</code>和<code>Eq</code></a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p><code>PartialEq</code>特质允许您比较类型的实例以检查相等性，并启用<code>==</code>和<code>!=</code>运算符的使用。</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p><span class="highlight">[note]派生<code>PartialEq</code>会实现<code>eq</code>方法</span>。当在结构体上派生时，仅当所有字段相等时两个实例才相等，如果有任何字段不相等则实例不相等。当在枚举上派生时，每个变体等于其自身而不等于其他变体。</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>例如，在使用<code>assert_eq!</code>宏时就需要<code>PartialEq</code>特质，该宏需要能够比较两个类型的实例是否相等。</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p><span class="highlight">[note]<code>Eq</code>特质没有方法。其目的是表明对于带注释类型的每个值，该值都等于其自身。<code>Eq</code>特质只能应用于也实现了<code>PartialEq</code>的类型，尽管并非所有实现<code>PartialEq</code>的类型都能实现<code>Eq</code>。</span>这方面的一个例子是浮点数类型：浮点数的实现规定两个非数字（<code>NaN</code>）值彼此不相等。</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<p>当<code>Eq</code>被要求的一个例子是<code>HashMap&lt;K, V&gt;</code>中的键，这样<code>HashMap&lt;K, V&gt;</code>可以判断两个键是否相同。</p>
<h3 id="partialord-and-ord-for-ordering-comparisons-用于排序比较的partialord和ord"><a class="header" href="#partialord-and-ord-for-ordering-comparisons-用于排序比较的partialord和ord"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons 用于排序比较的<code>PartialOrd</code>和<code>Ord</code></a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p><code>PartialOrd</code>特质允许您比较类型的实例以进行排序。实现<code>PartialOrd</code>的类型可以与<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>和<code>&gt;=</code>运算符一起使用。<code>PartialOrd</code>特质只能应用于也实现了<code>PartialEq</code>的类型。</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating-point number and the <code>NaN</code>
floating-point value will return <code>None</code>.</p>
<p>派生<code>PartialOrd</code>会实现<code>partial_cmp</code>方法，该方法返回一个<code>Option&lt;Ordering&gt;</code>，当给定值无法产生排序时将返回<code>None</code>。一个即使该类型的大多数值可以比较也无法产生排序的值的例子是非数字（<code>NaN</code>）浮点值。使用任何浮点数和<code>NaN</code>浮点值调用<code>partial_cmp</code>都将返回<code>None</code>。</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>在结构体上派生时，<code>PartialOrd</code>通过比较结构体定义中字段出现的顺序来比较两个实例。在枚举上派生时，枚举定义中较早声明的变体被认为小于后面列出的变体。</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
range expression.</p>
<p>例如，<code>rand</code> crate中的<code>gen_range</code>方法就需要<code>PartialOrd</code>特质，该方法生成范围表达式中指定范围内的随机值。</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p><span class="highlight">[note]<code>Ord</code>特质允许您知道对于带注释类型的任意两个值，都存在有效的排序。</span><code>Ord</code>特质实现了<code>cmp</code>方法，该方法返回<code>Ordering</code>而不是<code>Option&lt;Ordering&gt;</code>，因为始终可能存在有效的排序。<code>Ord</code>特质只能应用于也实现了<code>PartialOrd</code>和<code>Eq</code>的类型（而<code>Eq</code>需要<code>PartialEq</code>）。在结构体和枚举上派生时，<code>cmp</code>的行为方式与<code>PartialOrd</code>的派生实现中的<code>partial_cmp</code>相同。</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<p>当将值存储在<code>BTreeSet&lt;T&gt;</code>（一种根据值排序存储数据的数据结构）中时，就需要<code>Ord</code>特质。</p>
<h3 id="clone-and-copy-for-duplicating-values-用于复制值的clone和copy"><a class="header" href="#clone-and-copy-for-duplicating-values-用于复制值的clone和copy"><code>Clone</code> and <code>Copy</code> for Duplicating Values 用于复制值的<code>Clone</code>和<code>Copy</code></a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See Variables and Data Interacting with
Clone” in Chapter 4
for more information on <code>Clone</code>.</p>
<p><code>Clone</code>特质允许您显式创建值的深拷贝，复制过程可能涉及运行任意代码和复制堆数据。有关<code>Clone</code>的更多信息，请参见第4章“变量与数据交互：克隆“。</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>派生<code>Clone</code>会实现<code>clone</code>方法，当为整个类型实现时，会调用类型各部分的<code>clone</code>方法。这意味着类型的所有字段或值也必须实现<code>Clone</code>才能派生<code>Clone</code>。</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus the type stored in the slice must implement <code>Clone</code>.</p>
<p>当在切片上调用<code>to_vec</code>方法时就需要<code>Clone</code>。切片不拥有其包含的类型实例，但从<code>to_vec</code>返回的向量需要拥有其实例，因此<code>to_vec</code>会对每个项调用<code>clone</code>。因此存储在切片中的类型必须实现<code>Clone</code>。</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See “Stack-Only Data:
Copy” in Chapter 4 for more information on
<code>Copy</code>.</p>
<p><code>Copy</code>特质允许您仅通过复制存储在栈上的位来复制值；无需运行任意代码。有关<code>Copy</code>的更多信息，请参见第4章“仅栈数据：复制“。</p>
<p>The <code>Copy</code> trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p><code>Copy</code>特质没有定义任何方法来防止程序员重载这些方法并违反不运行任意代码的假设。这样，所有程序员都可以假设复制值会非常快。</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. A type that
implements <code>Copy</code> must also implement <code>Clone</code>, because a type that implements
<code>Copy</code> has a trivial implementation of <code>Clone</code> that performs the same task as
<code>Copy</code>.</p>
<p>您可以在所有部分都实现<code>Copy</code>的任何类型上派生<code>Copy</code>。实现<code>Copy</code>的类型也必须实现<code>Clone</code>，因为实现<code>Copy</code>的类型具有执行与<code>Copy</code>相同任务的<code>Clone</code>的简单实现。</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don’t have to call <code>clone</code>, which makes
the code more concise.</p>
<p><code>Copy</code>特质很少被要求；实现<code>Copy</code>的类型具有可用的优化，这意味着您不必调用<code>clone</code>，从而使代码更简洁。</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<p><code>Copy</code>能完成的一切也可以通过<code>Clone</code>完成，但代码可能更慢或必须在某些地方使用<code>clone</code>。</p>
<h3 id="hash-for-mapping-a-value-to-a-value-of-fixed-size-用于将值映射到固定大小值的hash"><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size-用于将值映射到固定大小值的hash"><code>Hash</code> for Mapping a Value to a Value of Fixed Size 用于将值映射到固定大小值的<code>Hash</code></a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p><code>Hash</code>特质允许您使用哈希函数获取任意大小的类型实例并将该实例映射到固定大小的值。派生<code>Hash</code>会实现<code>hash</code>方法。<code>hash</code>方法的派生实现会组合对类型各部分调用<code>hash</code>的结果，这意味着所有字段或值也必须实现<code>Hash</code>才能派生<code>Hash</code>。</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<p>当在<code>HashMap&lt;K, V&gt;</code>中存储键以高效存储数据时就需要<code>Hash</code>。</p>
<h3 id="default-for-default-values-用于默认值的default"><a class="header" href="#default-for-default-values-用于默认值的default"><code>Default</code> for Default Values 用于默认值的<code>Default</code></a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p><code>Default</code>特质允许您为类型创建默认值。派生<code>Default</code>会实现<code>default</code>函数。<code>default</code>函数的派生实现会调用类型各部分的<code>default</code>函数，这意味着所有字段或值也必须实现<code>Default</code>才能派生<code>Default</code>。</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in “Creating Instances from Other Instances with Struct
Update
Syntax” in Chapter 5. You can customize a few fields of a struct and then set
and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p><span class="highlight">[note]<code>Default::default</code>函数通常与第5章“使用结构体更新语法从其他实例创建实例“中讨论的结构体更新语法结合使用。您可以自定义结构体的几个字段，然后使用<code>..Default::default()</code>为其余字段设置并使用默认值。</span></p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<p>当您对<code>Option&lt;T&gt;</code>实例使用方法<code>unwrap_or_default</code>时就需要<code>Default</code>特质。如果<code>Option&lt;T&gt;</code>是<code>None</code>，则方法<code>unwrap_or_default</code>将返回类型<code>T</code>的<code>Default::default</code>的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-d---useful-development-tools-实用的开发工具"><a class="header" href="#appendix-d---useful-development-tools-实用的开发工具">Appendix D - Useful Development Tools 实用的开发工具</a></h2>
<p>In this appendix, we talk about some useful development tools that the Rust
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.</p>
<p>在本附录中，我们将介绍 Rust 项目提供的一些实用开发工具。我们将探讨自动格式化、快速修复警告的方法、linter 工具以及与 IDE 的集成。</p>
<h3 id="automatic-formatting-with-rustfmt-使用-rustfmt-自动格式化"><a class="header" href="#automatic-formatting-with-rustfmt-使用-rustfmt-自动格式化">Automatic Formatting with <code>rustfmt</code> 使用 <code>rustfmt</code> 自动格式化</a></h3>
<p>The <code>rustfmt</code> tool reformats your code according to the community code style.
Many collaborative projects use <code>rustfmt</code> to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.</p>
<p><code>rustfmt</code> 工具会根据社区代码风格重新格式化你的代码。许多协作项目使用 <code>rustfmt</code> 来避免关于 Rust 编码风格的争论：所有人都通过该工具格式化代码。</p>
<p>Rust installations include rustfmt by default, so you should already have the
programs <code>rustfmt</code> and <code>cargo-fmt</code> on your system. These two commands are
analogous to <code>rustc</code> and <code>cargo</code> in that <code>rustfmt</code> allows finer-grained control
and <code>cargo-fmt</code> understands conventions of a project that uses Cargo. To format
any Cargo project, enter the following:</p>
<p>Rust 安装包默认包含 rustfmt，因此你的系统中应已存在 <code>rustfmt</code> 和 <code>cargo-fmt</code> 程序。这两个命令类似于 <code>rustc</code> 和 <code>cargo</code>：<code>rustfmt</code> 提供更细粒度的控制，而 <code>cargo-fmt</code> 理解使用 Cargo 的项目的约定。要格式化任何 Cargo 项目，请输入：</p>
<pre><code class="language-sh">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics.</p>
<p>运行此命令会重新格式化当前 crate 中的所有 Rust 代码。此操作仅改变代码风格，不影响代码语义。</p>
<p>This command gives you <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives you
both <code>rustc</code> and <code>cargo</code>. To format any Cargo project, enter the following:</p>
<p>该命令提供 <code>rustfmt</code> 和 <code>cargo-fmt</code>，类似于 Rust 同时提供 <code>rustc</code> 和 <code>cargo</code>。要格式化任何 Cargo 项目，请输入：</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on <code>rustfmt</code>, see its documentation.</p>
<p>运行此命令会重新格式化当前 crate 中的所有 Rust 代码。此操作仅改变代码风格，不影响代码语义。有关 <code>rustfmt</code> 的更多信息，请参阅其文档。</p>
<h3 id="fix-your-code-with-rustfix-使用-rustfix-修复代码"><a class="header" href="#fix-your-code-with-rustfix-使用-rustfix-修复代码">Fix Your Code with <code>rustfix</code> 使用 <code>rustfix</code> 修复代码</a></h3>
<p>The <code>rustfix</code> tool is included with Rust installations and can automatically fix
compiler warnings that have a clear way to correct the problem that’s likely
what you want. It’s likely you’ve seen compiler warnings before. For example,
consider this code:</p>
<p><code>rustfix</code> 工具包含在 Rust 安装包中，可自动修复那些存在明确修正方案的编译器警告（通常符合你的预期）。你可能之前见过编译器警告。例如：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 42;
    println!("{x}");
}</code></pre></pre>
<p>Here, we’re defining the variable <code>x</code> as mutable, but we never actually mutate
it. Rust warns us about that:</p>
<p>此处我们将变量 <code>x</code> 定义为可变(mutable)，但从未实际修改它。Rust 对此发出警告：</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: variable does not need to be mutable
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 0;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default
</code></pre>
<p>The warning suggests that we remove the <code>mut</code> keyword. We can automatically
apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<p>该建议提示我们移除 <code>mut</code> 关键字。通过运行 <code>cargo fix</code> 命令，我们可以使用 <code>rustfix</code> 工具自动应用此建议：</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>When we look at <em>src/main.rs</em> again, we’ll see that <code>cargo fix</code> has changed the
code:</p>
<p>再次查看 <em>src/main.rs</em> 时，我们会发现 <code>cargo fix</code> 已修改代码：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 42;
    println!("{x}");
}</code></pre></pre>
<p>The <code>x</code> variable is now immutable, and the warning no longer appears.</p>
<p>现在 <code>x</code> 变量是不可变的，警告不再出现。</p>
<p>You can also use the <code>cargo fix</code> command to transition your code between
different Rust editions. Editions are covered in Appendix E.</p>
<p>你还可以使用 <code>cargo fix</code> 命令在不同 Rust 版本间迁移代码。版本相关内容将在附录 E 中介绍。</p>
<h3 id="more-lints-with-clippy-使用-clippy-进行更多代码检查"><a class="header" href="#more-lints-with-clippy-使用-clippy-进行更多代码检查">More Lints with Clippy 使用 Clippy 进行更多代码检查</a></h3>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code. Clippy is included with standard
Rust installations.</p>
<p>Clippy 工具是一组用于分析代码的 lint 规则集合，可帮助你发现常见错误并改进 Rust 代码。Clippy 包含在标准 Rust 安装中。</p>
<p>To run Clippy’s lints on any Cargo project, enter the following:</p>
<p>要在任何 Cargo 项目上运行 Clippy 的 lint 检查，请输入：</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:</p>
<p>例如，假设你编写了一个使用数学常数近似值（如圆周率 pi）的程序：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
</figure>
<p>Running <code>cargo clippy</code> on this project results in this error:</p>
<p>在此项目上运行 <code>cargo clippy</code> 会产生错误：</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>This error lets you know that Rust already has a more precise <code>PI</code> constant
defined, and that your program would be more correct if you used the constant
instead. You would then change your code to use the <code>PI</code> constant. The
following code doesn’t result in any errors or warnings from Clippy:</p>
<p>此错误提示 Rust 已定义了更精确的 <code>PI</code> 常量，使用该常量会使程序更正确。随后你会将代码改为使用 <code>PI</code> 常量。以下代码不会引发 Clippy 的任何错误或警告：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
</figure>
<p>For more information on Clippy, see its documentation.</p>
<p>有关 Clippy 的更多信息，请参阅其文档。</p>
<h3 id="ide-integration-using-rust-analyzer-使用-rust-analyzer-实现-ide-集成"><a class="header" href="#ide-integration-using-rust-analyzer-使用-rust-analyzer-实现-ide-集成">IDE Integration Using <code>rust-analyzer</code> 使用 <code>rust-analyzer</code> 实现 IDE 集成</a></h3>
<p>To help IDE integration, the Rust community recommends using
<code>rust-analyzer</code>. This tool is a set of
compiler-centric utilities that speaks the Language Server Protocol, which is a specification for IDEs and programming languages to
communicate with each other. Different clients can use <code>rust-analyzer</code>, such as
the Rust analyzer plug-in for Visual Studio Code.</p>
<p>为支持 IDE 集成，Rust 社区推荐使用 <code>rust-analyzer</code>。该工具是一套以编译器为核心的工具集，遵循语言服务器协议（Language Server Protocol）——这是 IDE 与编程语言相互通信的规范。不同客户端（如 Visual Studio Code 的 Rust 分析器插件）均可使用 <code>rust-analyzer</code>。</p>
<p>Visit the <code>rust-analyzer</code> project’s home page
for installation instructions, then install the language server support in your
particular IDE. Your IDE will gain abilities such as autocompletion, jump to
definition, and inline errors.</p>
<p>访问 <code>rust-analyzer</code> 项目主页获取安装说明，然后在你的 IDE 中安装语言服务器支持。安装后你的 IDE 将获得自动补全、跳转到定义和内联错误显示等功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-e---editions-版本"><a class="header" href="#appendix-e---editions-版本">Appendix E - Editions 版本</a></h2>
<p>In Chapter 1, you saw that <code>cargo new</code> adds a bit of metadata to your
<em>Cargo.toml</em> file about an edition. This appendix talks about what that means!</p>
<p>在第 1 章中，你看到 <code>cargo new</code> 会在 <em>Cargo.toml</em> 中添加关于版本的元数据。本附录将解释其含义！</p>
<p>The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!”</p>
<p>Rust 语言和编译器采用六周发布周期，意味着用户能持续获得新功能。其他编程语言发布大更新的频率较低；而 Rust 更频繁地发布小更新。久而久之，这些微小变化会累积成显著改进。但逐版本回顾时，可能难以察觉变化幅度（例如“Rust 1.10 到 1.31 的变化真大！”）。</p>
<p>Every three years or so, the Rust team produces a new Rust <em>edition</em>. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.</p>
<p>大约每三年，Rust 团队会推出新的 Rust 版本(edition)。每个版本汇集已实现的功能，整合成包含完整更新文档和工具链的清晰套件。新版本会按常规六周发布流程推出。</p>
<p>Editions serve different purposes for different people:</p>
<p>版本对不同人群有不同意义：</p>
<ul>
<li>For active Rust users, a new edition brings together incremental changes into
an easy-to-understand package.</li>
<li>For non-users, a new edition signals that some major advancements have
landed, which might make Rust worth another look.</li>
<li>For those developing Rust, a new edition provides a rallying point for the
project as a whole.</li>
</ul>
<!-- -->
<ul>
<li>对活跃的 Rust 用户：新版本将增量变更整合为易于理解的套件</li>
<li>对非用户：新版本标志着重大进展，可能值得重新关注 Rust</li>
<li>对 Rust 开发者：新版本为整个项目提供统一的发力点</li>
</ul>
<p>At the time of this writing, four Rust editions are available: Rust 2015, Rust
2018, Rust 2021, and Rust 2024. This book is written using Rust 2024 edition
idioms.</p>
<p>截至本文撰写时，已有四个 Rust 版本：Rust 2015、Rust 2018、Rust 2021 和 Rust 2024。本书采用 Rust 2024 版本的惯用写法。</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition the compiler should
use for your code. If the key doesn’t exist, Rust uses <code>2015</code> as the edition
value for backward compatibility reasons.</p>
<p><em>Cargo.toml</em> 中的 <code>edition</code> 键指明编译器应使用的版本。若未指定，出于向后兼容考虑，Rust 默认使用 <code>2015</code> 版本。</p>
<p>Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.</p>
<p>每个项目可选择非默认的 2015 版本。版本可能包含不兼容变更（例如引入与现有标识符冲突的新关键字）。但除非你主动选择这些变更，否则即使升级 Rust 编译器版本，代码仍可编译。</p>
<p>All Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.</p>
<p>所有 Rust 编译器版本均支持早于该编译器发布的任何版本，并能链接不同版本的 crate。版本变更仅影响编译器初始解析代码的方式。因此，若你使用 Rust 2015 而某个依赖使用 Rust 2018，你的项目仍能编译并使用该依赖。反之亦然（项目用 2018，依赖用 2015）。</p>
<p>To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.</p>
<p>需明确：大多数功能在所有版本中都可用。使用任何 Rust 版本的开发者在新稳定版发布时都将持续获得改进。但在某些情况下（主要是新增关键字时），部分新功能可能仅限后期版本使用。要利用这些功能，你需要切换版本。</p>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via <code>cargo fix</code>.</p>
<p>更多细节请参阅《版本指南》——这是专门介绍版本的完整书籍，列举了版本间的差异，并说明如何通过 <code>cargo fix</code> 自动将代码升级到新版本。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-f-translations-of-the-book-本书的翻译"><a class="header" href="#appendix-f-translations-of-the-book-本书的翻译">Appendix F: Translations of the Book 本书的翻译</a></h2>
<p>For resources in languages other than English. Most are still in progress; see
the Translations label to help or let us know about a new translation!</p>
<p>此处列出非英语资源。多数翻译仍在进行中；可查看翻译标签参与或告知我们新的翻译计划！</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li>简体中文: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>, <a href="https://github.com/RustLangES/rust-book-es">Español por RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-g---how-rust-is-made-and-nightly-rust-rust-的发布机制与-nightly-rust"><a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust-rust-的发布机制与-nightly-rust">Appendix G - How Rust is Made and “Nightly Rust” Rust 的发布机制与 “Nightly Rust”</a></h2>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer.</p>
<p>本附录介绍 Rust 的构建方式及其对 Rust 开发者的影响。</p>
<h3 id="stability-without-stagnation-稳定而不停滞"><a class="header" href="#stability-without-stagnation-稳定而不停滞">Stability Without Stagnation 稳定而不停滞</a></h3>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>作为一门语言，Rust 极其重视代码的稳定性。我们希望 Rust 成为可依赖的坚实基础，而频繁变更会使这变得不可能。同时，若无法试验新功能，我们可能在发布后才发现重大缺陷，届时将无法修改。</p>
<p>Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<p>我们的解决方案称为“稳定而不停滞”，其指导原则是：你永远不必担心升级到新的 Rust 稳定版。每次升级都应是无痛的，同时带来新功能、更少错误和更快的编译速度。</p>
<h3 id="choo-choo-release-channels-and-riding-the-trains-列车时刻表发布通道与搭乘列车"><a class="header" href="#choo-choo-release-channels-and-riding-the-trains-列车时刻表发布通道与搭乘列车">Choo, Choo! Release Channels and Riding the Trains 列车时刻表：发布通道与搭乘列车</a></h3>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<p>Rust 开发遵循列车时刻表模型。所有开发都在 Rust 仓库的 <code>master</code> 分支进行。发布采用软件发布列车模型（Cisco IOS 等项目也采用此模型）。Rust 有三个发布通道：</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>大多数 Rust 开发者主要使用稳定版，但想尝试实验性功能的人可使用每夜版或测试版。</p>
<p>Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<p>以下是开发和发布流程的示例：假设 Rust 团队正在开发 Rust 1.5（实际发布于 2015 年 12 月，此处用其版本号说明）。新功能加入 Rust：新的提交落地到 <code>master</code> 分支。每晚都会生成新的每夜版 Rust。每天都是发布日，发布由基础设施自动完成。随时间推移，发布轨迹如下（每晚一次）：</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it’s time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<p>每六周，是时候准备新发布了！Rust 仓库的 <code>beta</code> 分支从每夜版使用的 <code>master</code> 分支分出。此时有两个发布：</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:</p>
<p>大多数 Rust 用户不主动使用测试版，但会在 CI 系统中针对测试版测试，以帮助 Rust 发现可能的回归问题。同时，每夜版仍每晚发布：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<p>假设发现回归问题。幸好我们在回归问题潜入稳定版前有时间测试测试版！修复方案会应用到 <code>master</code>（确保每夜版修复），然后反向移植到 <code>beta</code> 分支，并生成新的测试版发布：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it’s time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<p>第一个测试版创建六周后，稳定版发布！<code>stable</code> 分支从 <code>beta</code> 分支分出：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<p>欢呼！Rust 1.5 完成！但我们遗漏了一点：由于六周已过，我们还需要下一个 Rust 版本 1.6 的新测试版。因此在 <code>stable</code> 从 <code>beta</code> 分出后，下一版本的 <code>beta</code> 再次从 <code>每夜版</code> 分出：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>这称为“列车模型”，因为每六周就有一版“离开车站”，但在成为稳定版前需经历测试通道的旅程。</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Rust 每六周准时发布。若知道某个版本的发布日期，就能推知下一个版本的日期：六周后。六周发布周期的优势在于下一班列车很快到来。若功能错过某次发布，无需担心：短期内会有下一次发布！这减少了在截止日期前仓促加入未完善功能的压力。</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<p>得益于该流程，你总能检出 Rust 的下个构建版本并亲自验证升级是否顺畅：如果测试版出现问题，可向团队报告并在下个稳定版发布前修复！测试版的问题相对少见，但 <code>rustc</code> 仍是软件，难免存在缺陷。</p>
<h3 id="maintenance-time-维护周期"><a class="header" href="#maintenance-time-维护周期">Maintenance time 维护周期</a></h3>
<p>The Rust project supports the most recent stable version. When a new stable
version is released, the old version reaches its end of life (EOL). This means
each version is supported for six weeks.</p>
<p>Rust 项目支持最新的稳定版本。当新稳定版发布时，旧版本即到达生命周期终点(EOL)。这意味着每个版本的支持期为六周。</p>
<h3 id="unstable-features-不稳定功能"><a class="header" href="#unstable-features-不稳定功能">Unstable Features 不稳定功能</a></h3>
<p>There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>此发布模型还有个注意事项：不稳定功能。Rust 使用“功能标志”技术决定特定版本启用的功能。若新功能处于开发阶段，它会落地到 <code>master</code>（因此在每夜版中可用），但位于功能标志后。作为用户，若想尝试开发中的功能，必须使用每夜版 Rust 并在源码中添加相应标志来启用。</p>
<p>If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.</p>
<p>若使用测试版或稳定版 Rust，则无法使用任何功能标志。这是我们在宣布功能永久稳定前获得实践验证的关键。追求前沿的用户可选择每夜版，而需要坚如磐石体验的用户可坚守稳定版并确保代码不被破坏。这就是稳定而不停滞。</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<p>本书仅涵盖稳定功能的信息，因为开发中的功能仍在变化，且从本书撰写到功能在稳定版启用的过程中必然存在差异。你可以在线查阅每夜版专属功能的文档。</p>
<h3 id="rustup-and-the-role-of-rust-nightly-rustup-与每夜版-rust-的作用"><a class="header" href="#rustup-and-the-role-of-rust-nightly-rustup-与每夜版-rust-的作用">Rustup and the Role of Rust Nightly Rustup 与每夜版 Rust 的作用</a></h3>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:</p>
<p>Rustup 便于全局或按项目切换不同 Rust 发布通道。默认安装稳定版 Rust。例如安装每夜版：</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here’s an example on one
of your authors’ Windows computer:</p>
<p>可通过 <code>rustup</code> 查看所有已安装的工具链（Rust 版本及相关组件）。以下是作者 Windows 电脑的示例：</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project’s directory to set the
nightly toolchain as the one <code>rustup</code> should use when you’re in that directory:</p>
<p>如你所见，稳定工具链是默认项。大多数 Rust 用户主要使用稳定版。你可能大部分时间用稳定版，但在特定项目使用每夜版（因需要前沿功能）。为此，可在项目目录使用 <code>rustup override</code> 设置 <code>rustup</code> 在该目录下使用每夜版工具链：</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<p>现在，每当在 <em>~/projects/needs-nightly</em> 目录中调用 <code>rustc</code> 或 <code>cargo</code> 时，<code>rustup</code> 会确保你使用每夜版 Rust 而非默认的稳定版。这在管理多个 Rust 项目时非常实用！</p>
<h3 id="the-rfc-process-and-teams-rfc-流程与团队协作"><a class="header" href="#the-rfc-process-and-teams-rfc-流程与团队协作">The RFC Process and Teams RFC 流程与团队协作</a></h3>
<p>So how do you learn about these new features? Rust’s development model follows
a <em>Request For Comments (RFC) process</em>. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>那么如何了解这些新功能呢？Rust 的开发遵循请求意见稿(Request For Comments, RFC)流程。若希望改进 Rust，可编写提案（即 RFC）。</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams <a href="https://www.rust-lang.org/governance">on Rust’s website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.</p>
<p>任何人都能提交改进 Rust 的 RFC，提案将由包含多个专业子团队的 Rust 团队评审讨论。完整团队列表见<a href="https://www.rust-lang.org/governance">Rust官网</a>，涵盖项目的各个领域：语言设计、编译器实现、基础设施、文档等。相关团队阅读提案及评论，提出意见，最终达成接受或拒绝功能的共识。</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the <a href="appendix-07-nightly-rust.html#unstable-features">“Unstable Features”</a> section.</p>
<p>若功能被接受，将在 Rust 仓库创建 issue，由贡献者实现（不一定是提案者本人）。实现完成后，功能会通过特性门控(feature gate)落地到 <code>master</code> 分支（如<a href="appendix-07-nightly-rust.html#unstable-features">“不稳定功能”</a>所述）。</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>
<p>经过一段时间，当使用每夜版的 Rust 开发者测试新功能后，团队成员会讨论该功能在每夜版的表现，并决定是否将其纳入稳定版。若决定推进，则移除特性门控，该功能即被视为稳定！它将搭乘发布列车进入新的 Rust 稳定版。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
